<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6 实现自己的 Promise</title>
    <url>/2019/11/22/2017-04-01-Programing-JavaScript-drive-promise-in-ES6/</url>
    <content><![CDATA[<h2 id="一、JavaScript-异步编程背景"><a href="#一、JavaScript-异步编程背景" class="headerlink" title="一、JavaScript 异步编程背景"></a>一、JavaScript 异步编程背景</h2><p>​ 从去年 ES2015 发布至今，已经过去了一年多，ES2015 发布的新的语言特性中最为流行的也就莫过于 Promise 了，Promise 使得如今 JavaScript 异步编程如此轻松惬意，甚至慢慢遗忘了曾经那不堪回首的痛楚。</p>
<p>其实从 JavaScript 诞生，JavaScript 中的异步编程就已经出现，例如点击鼠标、敲击键盘这些事件的处理函数都是异步的，时间到了 2009 年，Node.js 横空出世，在整个 Node.js 的实现中，将回调模式的异步编程机制发挥的淋漓尽致，Node 的流行也是的越来越多的 JavaScripter 开始了异步编程，但是回调模式的副作用也慢慢展现在人们眼前，错误处理不够优雅以及嵌套回调带来的“回调地狱”。</p>
<p>这些副作用使得人们从回调模式的温柔乡中慢慢清醒过来，开始寻找更为优雅的异步编程模式，路漫漫其修远兮、吾将上下而求索。时间到了 2015 年，Promise 拯救那些苦苦探索的先驱。行使它历史使命的时代似乎已经到来。</p>
<p>​每个事物的诞生有他的历史使命，更有其历史成因，促进其被那些探索的先驱们所发现。<br>了解 nodejs 或者熟悉浏览器的人都知道，JavaScript 引擎是基于事件循环或单线程这两个特性的。更为甚者在浏览器中，更新 UI(也就是浏览器重绘、重拍页面布局)和执行 JavaScript 代码也在一个单线程中，可想而知，一个线程就相当于只有一条马路，如果一辆马车抛锚在路上了阻塞了马路，那么别的马车也就拥堵在了那儿，这个单线程容易被阻塞是一个道理，单线程也只能允许某一时间点只能够执行一段代码。<br>同时，JavaScript 没有想它的哥哥姐姐们那么财大气粗，像 Java 或者 C++，一个线程不够，那么再加一个线程，这样就能够同时执行多段代码了，但是这样就会带来的隐患就是状态不容易维护，JavaScript 选择了单线程非阻塞式的方式，也就是异步编程的方式，就像上面的马车抛锚在了路上，那么把马车推到路边的维修站，让其他马车先过去，等马车修好了再回到马路上继续行驶，这就是单线程非阻塞方式。正如 Promise 的工作方式一样，通过 Promise 去向服务器发起一个请求，毕竟请求有网络开销，不可能马上就返回请求结果的，这个时候 Promise 就处于 pending 状态，但是其并不会阻塞其他代码的执行，当请求返回时，修改 Promise 状态为 fulfilled 或者 rejected（失败请求）。同时执行绑定到这两个状态上面的“处理函数”。这就是异步编程的模式，也就是 Promise 兢兢业业的工作方式，在下面一个部分将详细讨论 Promise。</p>
<h2 id="二、Promise-基础"><a href="#二、Promise-基础" class="headerlink" title="二、Promise 基础"></a>二、Promise 基础</h2><p>​ 怎么一句话解释 Promise 呢？Promise 可以代指那些尚未完成的一些操作，但是其在未来的某个时间会返回某一特定的结果。</p>
<p>​ 当创建一个 Promise 实例后，其代表一个未知的值，在将来的某个时间会返回一个成功的返回值，或者失败的返回值，我们可以为这些返回值添加处理函数，当值返回时，处理函数被调用。Promise 总是处于下面三种状态之一：</p>
<ul>
<li>pending： Promise 的初始状态，也就是未被 fulfilled 或者 rejected 的状态。</li>
<li>fulfilled： 意味着 promise 代指的操作已经成功完成。</li>
<li>rejected：意味着 promise 代指的操作由于某些原因失败。</li>
</ul>
<p>一个处于 pending 状态的 promise 可能由于某个成功返回值而发展为 fulfilled 状态，也有可能因为某些错误而进入 rejected 状态，无论是进入 fulfilled 状态或者 rejected 状态，绑定到这两种状态上面的处理函数就会被执行。并且进入 fulfilled 或者 rejected 状态也就不能再返回 pending 状态了。</p>
<a id="more"></a>
<h2 id="三、边学边写"><a href="#三、边学边写" class="headerlink" title="三、边学边写"></a>三、边学边写</h2><p>上面说了那么多，其实都是铺垫。接下来我们就开始实现自己的 Promise 对象。go go go！！！</p>
<h3 id="第一步：Promise-构造函数"><a href="#第一步：Promise-构造函数" class="headerlink" title="第一步：Promise 构造函数"></a>第一步：Promise 构造函数</h3><p>Promise 有三种状态，pending、fulfilled、rejected。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span> <span class="comment">// Promise 的 初始状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span> <span class="comment">// Promise 成功返回后的状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span> <span class="comment">// Promise 失败后的状态</span></span><br></pre></td></tr></table></figure>
<p>有了三种状态后，那么我们怎么创建一个 Promise 实例呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(executor) <span class="comment">// 创建 Promise 的语法</span></span><br></pre></td></tr></table></figure>
<p>通过上面生成 promise 语法我们知道，Promise 实例是调用 Promise 构造函数通过 new 操作符生成的。这个构造函数我们可以先这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING <span class="comment">// 创建一个 promise 时，首先进行状态初始化。pending</span></span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span> <span class="comment">// result 属性用来缓存 promise 的返回结果，可以是成功的返回结果，或失败的返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到上面构造函数接受的参数 executor。它是一个函数，并且接受其他两个函数（resolve 和 reject）作为参数，当 resolve 函数调用后，promise 的状态转化为 fulfilled，并且执行成功返回的处理函数（不用着急后面会说到怎么添加处理函数）。当 reject 函数调用后，promise 状态转化为 rejected，并且执行失败返回的处理函数。</p>
<p>现在我们的代码大概是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING</span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    executor(<span class="function"><span class="params">data</span> =&gt;</span> resolveProvider(<span class="keyword">this</span>, data), err =&gt; rejectProvider(<span class="keyword">this</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveProvider</span>(<span class="params">promise, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = FULFILLED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejectProvider</span>(<span class="params">promise, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = FULFILLED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dont Repeat Yourselt！！！我们可以看到上面代码后面两个函数基本相同，其实我们可以把它整合成一个函数，在结合高阶函数的使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = status</span><br><span class="line">    promise.result = data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">        executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们的代码就看上去简洁多了。</p>
<h3 id="第二步：为-Promise-添加处理函数"><a href="#第二步：为-Promise-添加处理函数" class="headerlink" title="第二步：为 Promise 添加处理函数"></a>第二步：为 Promise 添加处理函数</h3><p>其实通过 new Promise(executor)已经可以生成一个 Promise 实例了，甚至我们可以通过传递到 executor 中的 resolve 和 reject 方法来改变 promise 状态，但是！现在的 promise 依然没啥卵用！！！因为我们并没有给它添加成功和失败返回的处理函数。</p>
<p>首先我们需要给我们的 promise 增加两个属性，successListener 和 failureListener 用来分别缓存成功处理函数和失败处理函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING</span><br><span class="line">        <span class="keyword">this</span>.successListener = []</span><br><span class="line">        <span class="keyword">this</span>.failureListener = []</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">        executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么添加处理函数呢？ECMASCRIPT 标准中说到，我们可以通过 promise 原型上面的 then 方法为 promise 添加成功处理函数和失败处理函数，可以通过 catch 方法为 promise 添加失败处理函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = status</span><br><span class="line">    promise.result = data</span><br><span class="line">    <span class="keyword">switch</span>(status) &#123;</span><br><span class="line">        <span class="keyword">case</span> FULFILLED: <span class="keyword">return</span> promise.successListener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line">        <span class="keyword">case</span> REJECTED: <span class="keyword">return</span> promise.failurelistener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING</span><br><span class="line">        <span class="keyword">this</span>.successListener = []</span><br><span class="line">        <span class="keyword">this</span>.failurelistener = []</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">        executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Promise 原型上面的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    then(...args) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">            <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">                <span class="keyword">this</span>.successListener.push(args[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">this</span>.failurelistener.push(args[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">                args[<span class="number">0</span>](<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">                args[<span class="number">1</span>](<span class="keyword">this</span>.result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在的 Promise 基本初具雏形了。甚至可以运用到一些简单的场景中了。举个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个延时 resolve 的 pormise*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">5</span>), <span class="number">2000</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">/* 创建一个及时 resolve 的 promise*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="number">5</span>)).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">/* 链式调用 then 方法还不能够使用！*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span> resolve(<span class="number">5</span>)).then(<span class="function"><span class="params">data</span> =&gt;</span> data).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read property 'then' of undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="第三步：Promise-的链式调用"><a href="#第三步：Promise-的链式调用" class="headerlink" title="第三步：Promise 的链式调用"></a>第三步：Promise 的链式调用</h3><p>Promise 需要实现链式调用，我们需要再次回顾下 then 方法的定义：</p>
<p>then 方法为 pormise 添加成功和失败的处理函数，同时 then 方法返回一个新的 promise 对象，这个新的 promise 对象 resolve 处理函数的返回值，或者当没有提供处理函数时直接 resolve 原始的值。</p>
<p>可以看出，promise 能够链式调用归功于 then 方法返回一个全新的 promise，并且 resolve 处理函数的返回值，当然，如果 then 方法的处理函数本身就返回一个 promise，那么久不用我们自己手动生成一个 promise 了。了解了这些，就开始动手写代码了。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isPromise = <span class="function"><span class="params">object</span> =&gt;</span> object &amp;&amp; object.then &amp;&amp; <span class="keyword">typeof</span> object.then === <span class="string">'function'</span></span><br><span class="line"><span class="keyword">const</span> noop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 同上面代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line"><span class="comment">// 同上面代码</span></span><br><span class="line">&#125;</span><br><span class="line">then(...args) &#123;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(noop)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> handler = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = fn(data)</span><br><span class="line">                <span class="keyword">if</span> (isPromise(result)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> successHandler = child.successListener[<span class="number">0</span>]</span><br><span class="line">    	    <span class="keyword">const</span> errorHandler = child.failureListener[<span class="number">0</span>]</span><br><span class="line">    	    result</span><br><span class="line">    	    .then(successHandler, errorHandler)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    statusProvider(child, FULFILLED)(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!fn) &#123;</span><br><span class="line">                statusProvider(child, <span class="keyword">this</span>.status)(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">            <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">                <span class="keyword">this</span>.successListener.push(handler(args[<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">this</span>.failureListener.push(handler(args[<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">                handler(args[<span class="number">0</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">                handler(args[<span class="number">1</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, arg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们写了一个 isPromise 方法，用于判断一个对象是否是 promise。就是判断对象是否有一个 then 方法，免责声明为了实现上的简单，我们不区分 thenable 和 promise 的区别，但是我们应该是知道。所有的 promise 都是 thenable 的，而并不是所有的 thenable 对象都是 promise。（thenable 对象是指带有一个 then 方法的对象，该 then 方法其实就是一个 executor。）isPromise 的作用就是用于判断 then 方法返回值是否是一个 promise，如果是 promise，就直接返回该 promise，如果不是，就新生成一个 promise 并返回该 promise。</p>
<p>​由于需要链式调用，我们对 successListener 和 failureListener 中处理函数进行了重写，并不是直接 push 进去 then 方法接受的参数函数了，因为 then 方法需要返回一个 promise，所以当 then 方法里面的处理函数被执行的同时，我们也需要对 then 方法返回的这个 promise 进行处理，要么 resolve，要么 reject 掉。当然，大部分情况都是需要 resolve 掉的，只有当 then 方法没有添加第二个参数函数，同时调用 then 方法的 promise 就是 rejected 的时候，才需要把 then 方法返回的 pormise 进行 reject 处理，也就是调用 statusProvider(child, REJECTED)(data).</p>
<p>Promise 实现的完整代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span> <span class="comment">// Promise 的 初始状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span> <span class="comment">// Promise 成功返回后的状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span> <span class="comment">// Promise 失败后的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isPromise = <span class="function"><span class="params">object</span> =&gt;</span> object &amp;&amp; object.then &amp;&amp; <span class="keyword">typeof</span> object.then === <span class="string">'function'</span></span><br><span class="line"><span class="keyword">const</span> noop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">promise.status = status</span><br><span class="line">promise.result = data</span><br><span class="line"><span class="keyword">switch</span>(status) &#123;</span><br><span class="line"><span class="keyword">case</span> FULFILLED: <span class="keyword">return</span> promise.successListener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line"><span class="keyword">case</span> REJECTED: <span class="keyword">return</span> promise.failureListener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING</span><br><span class="line">    <span class="keyword">this</span>.successListener = []</span><br><span class="line">    <span class="keyword">this</span>.failureListener = []</span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Promise 原型上面的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    then(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(noop)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> handler = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = fn(data)</span><br><span class="line">                <span class="keyword">if</span> (isPromise(result)) &#123;</span><br><span class="line">                    	<span class="keyword">const</span> successHandler = child.successListener[<span class="number">0</span>]</span><br><span class="line">    		<span class="keyword">const</span> errorHandler = child.failureListener[<span class="number">0</span>]</span><br><span class="line">    		result</span><br><span class="line">    		.then(successHandler, errorHandler)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    statusProvider(child, FULFILLED)(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!fn) &#123;</span><br><span class="line">                statusProvider(child, <span class="keyword">this</span>.status)(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">            <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">                <span class="keyword">this</span>.successListener.push(handler(args[<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">this</span>.failurelistener.push(handler(args[<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">                handler(args[<span class="number">0</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">                handler(args[<span class="number">1</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="四、怎么让我们的-toy-Promise-变强健"><a href="#四、怎么让我们的-toy-Promise-变强健" class="headerlink" title="四、怎么让我们的 toy Promise 变强健"></a>四、怎么让我们的 toy Promise 变强健</h3><p>在 ECMAScript 标准中，Promise 构造函数上面还提供了一些静态方法，比如 Promise.resolve、Promise.reject、Promsie.all、Promise.race。当我们有了上面的基础实现后，为我们的 toy Promise 添加上面这些新的功能一定能让其更加实用。</p>
<p>在我们的基本实现中，我们并没有区分 thenable 对象，其实 Promise.resolve 和 then 方法都可以接受一个 thenable 对象，并把该 thenable 对象转化为一个 promise 对象，如果想让我们的 toy Promise 用于生产的话，这也是要考虑的。</p>
<p>为了让我们的 toy Promise 变得更强壮，我们需要拥有强健的错误处理机制，比如验证 executor 必须是一个函数、then 方法的参数只能是函数或者 undefined 或 null，又比如 executor 和 then 方法中抛出的错误并不能够被 window.onerror 监测到，而只能够通过错误处理函数来处理，这也是需要考虑的因素。</p>
<p>如果我们的 <code>Promise polyfill</code> 是考虑支持多平台，那么首要考虑的就是浏览器环境或 Node.js 环境，其实在这两个平台，原生 Promise 都是支持两个事件的。就拿浏览器端举例：</p>
<p>unhandledrejection: 在一个事件循环中，如果我们没有对 promise 返回的错误进行处理，那么就会在 window 对象上面触发该事件。<br>rejectionhandled:如果在一个事件循环后，我们才去对 promise 返回的错误进行处理，那么就会在 window 对象上面监听到此事件。<br>关于这两个事件以及 node.js 平台上面类似的事件请参考 Nicholas C. Zakas 新书</p>
<p>Promise 能够很棒的处理异步编程，要想学好它我认为最好的方法就是亲自动手去实现一个自己的 Promise。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>今日一文：妈妈的手套</title>
    <url>/2019/11/20/2019-11-20_Life-Wenxin-wen/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>昨天晚上给妈妈打电话的时候，妈妈说预报里面说：明天家里要下雪了，你那边冷吗？你要多穿点衣服，不要冻着啦！</p>
<h2 id="妈妈的手套"><a href="#妈妈的手套" class="headerlink" title="妈妈的手套"></a>妈妈的手套</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-fed24a8c6ace4bf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手套"></p>
<blockquote>
<p>图文无关</p>
</blockquote>
<p>记得那年冬天，我上初二，学校周末放假了，我和弟弟两个人闹矛盾，然后我的手不小心被刀划伤了。小时候的我们，都不是让母亲省心的孩子。弟弟那时还小，把我划伤后就和其它的小伙伴出去玩了。妈妈听到了我的哭声，从地里回来，带着我去村上的医疗室包扎伤口。医生仔细检查完伤口，进行了消毒包扎，然后对妈妈说：现在天冷，注意手不要冻着了，不然会很麻烦的。</p>
<p>回家后，妈妈让我坐在椅子上烤火看电视，然后自己又到田里去忙了。我在家里看着电视，听着外面呼呼的风声，心想天可真冷啊。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-afdea73a422163cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="北风吹"></p>
<a id="more"></a>
<p>第二天是周一，我们要一大早就去学校上课，并且我要在学习住校，周末才能回家。一大早，妈妈帮我收拾好东西，临出门的时候妈妈从房间拿出来一个很 <code>丑</code> 的 <code>手套</code>，递给我然后说道：这几点带着这个，天冷了主要别冻着了。我看着手里的手套，那是一个很大的<code>手套</code>，完全不符合我现在手的尺寸;  <code>手套</code> 腕部的地方很长，手指的部分除了大拇指有一个手指外，其它的几个手指都 是一个整体、并且没有封口; 看着就像是现在我们常用的护腕，只是多了大拇指那一点；<code>手套</code> 是使用的灰色的毛线织成的。妈妈看我不太情愿，拿起 <code>手套</code> 准备套在我受伤的手上。我把手往后缩了缩，妈妈顿了顿，一把抓过我的手，边小心地往受伤的手上套边说道：不想带就别受伤啊。我突然就哭了起来，但还是任由妈妈套上了手套，期间有几次妈妈碰到了伤口，我哭的更厉害了。妈妈没有安慰我，套完手套就进屋去了，我看着外面在等我的同学，我抹了抹眼泪和他们一起到学校去了。</p>
<p>一离开妈妈的视线，我就尝试 <code>扯</code> 下手套，但是试了几次，单手不太方便、伤口被碰了几次，最后还是放弃了。</p>
<p>到学校后，受伤的手给我的生活带来了很多的不便，原来能够很快完成的事情，现在很慢才能完成，例如扣衣服、上厕所完了提裤子。</p>
<p>比起生活上的不便，我更在意的是同学对我 <code>手套</code> 的评论。有些同学，会问怎么回事？有些同学会直接说：手套真丑，剩下的大部分同学都选择了忽视。我还是尝试要拿掉手套，但是终究还是没成功，本来最后一次都要成功了，忽然想到了医生那句：冻坏了就麻烦了，只得作罢。之后，我把受伤的手，放在桌子下面、衣服兜里、用手护着，反正就是减少被同学看到的机会。</p>
<p>终于又到了回家的日子。回到家后，我没看看妈妈，在上小学的弟弟说妈妈到田里去忙了，弟弟对我说道：哥哥，对不起，我不是故意弄伤你的。你也不要怪妈妈，那个手套是妈妈那天晚上花了一晚上织成的，毛线是妈妈从爸爸的毛衣上面拆下来的。那天你走了后，妈妈在家里哭了好久。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-1964f27924a42e33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="妈妈不哭"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>天冷了，你那边冷吗？你要多穿点衣服，不要冻着啦！</p>
<hr>
<p>图片来源于网络，侵删。</p>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>公众号</category>
        <category>天冷了</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>公众号</tag>
        <tag>天冷了</tag>
      </tags>
  </entry>
  <entry>
    <title>今日一文：国足又输球了</title>
    <url>/2019/11/18/2019-11-18_Life-Wenxin-wen/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>11 月 14 日晚，中国男足又输球了。</p>
<h2 id="比赛相关"><a href="#比赛相关" class="headerlink" title="比赛相关"></a>比赛相关</h2><p>11 月 14 日晚，2022 年世界杯亚洲区预选赛预赛阶段（四十强赛）A组的一场关键战役在此间打响，中国男足和叙利亚队伍的比赛正式上演。此前，中国队已踢过三场小组赛，分别以 <strong>5:0</strong> 和 <strong>7:0</strong> 战胜了马尔代夫和关岛，以 <strong>0:0</strong> 踢平菲律宾队。</p>
<p>比赛中中国男足在上半场扳平比分后，下半场因为一粒乌龙球以 <strong>1:2</strong> 遗憾负于小组最强对手叙利亚队，目前在小组中仅以净胜球优势排在第二位。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-11f7aa4a650f9008?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足比分"></p>
<p>在 <strong>1:2</strong> 不敌叙利亚队，再一次，将出线主动权拱手让出。本场战罢，中国队 2 胜 1 平 1 负积 7 分，以净胜球优势领先菲律宾队排在四十强赛 A 组的第二位，叙利亚队则以四战全胜积 12 分排名第一。依照“四十强赛”的规则，总共 40 支球队分成 8 个小组参加世界杯亚洲区的预选赛，8 个小组的第一名以及 4 个表现最佳的第二名球队也得以参加预选赛下一轮的比赛。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-9eb2079921b316e7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分组"></p>
<p>中国队唯一一次入围世界杯是在 2002 年的日韩世界杯，当时中国队输掉了所有三场比赛，并且未进一球。</p>
<a id="more"></a>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-5509e9a7619401a0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足比赛经过"></p>
<p>根据亚足联安排，国足在四十强赛A组的下一轮比赛定于 2020 年 3 月 26 日举行，届时国足将在主场迎战马尔代夫队。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-76d171ffee9dcfe1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足新赛程"></p>
<p>在赛后新闻发布会上中国男足主教练里皮宣布辞职并承担输球责任。“我们今晚输球了，我的年薪收入非常高，这场输球我承担全部责任，所以我向大家宣布现在辞职，不再担任中国队主教练。”，没等翻译讲完，里皮便离开了新闻发布会，留下一脸茫然的记者和工作人员。对于这位拿着2300万欧元年薪、全球收入最高国家队主教练来说，他和国足的缘分，真的到头了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-f3470af85020cae7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="里皮辞职"></p>
<p>11 月 15 日早上，足协官方微博上发表声明对国家队失利”深表歉意”。声明称：“接受里皮的辞职请求。并表示接下来“将会深刻反思，重组男足国家队，打好接下来的四十强赛”。”</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-ef20fb7f3ed632ee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足协道歉"></p>
<h2 id="中国女足的世界杯之旅"><a href="#中国女足的世界杯之旅" class="headerlink" title="中国女足的世界杯之旅"></a>中国女足的世界杯之旅</h2><p>上面是中国男足的情况，那作为另一个极端的中国女足的情况呢？</p>
<p>2019年法国女足世界杯上，中国女足先是 1:0 不敌德国队，后以 1:0 战胜南非队，在最后一轮则与西班牙队战平，最终以小组第三的成绩出线。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-211119c43021cb6d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="女足比赛日程"></p>
<p>但是在1/8决赛中 0-2 不敌意大利女足，无缘 8 强。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-a966191a7aff8ce8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="女足比赛日程"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>世界杯的比赛暂时告一段落，男足主教练“银狐”也离开了，中足协也道歉了，广大球迷也吐槽了，事件的热点也慢慢地退去了。但是，作为中国的足球事业却是刚刚起步，很多的问题需要解决。有人说是球员问题，有人说是教练问题，有人说是体制问题。其实对于广大的 “吃瓜群众” 来说，是谁的问题并不重要，重要的是什么时候才能真正的赢一场呢？</p>
<p>中国足球加油，中国加油…</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-71ce94dc3aff39e9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中国加油"></p>
<hr>
<p>图片来源于网络，侵删。</p>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>公众号</category>
        <category>世界杯</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>公众号</tag>
        <tag>世界杯</tag>
      </tags>
  </entry>
  <entry>
    <title>今日一文：三罢对香港经济的影响</title>
    <url>/2019/11/15/2019-11-15_Life-Wenxin-wen/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我们都知道，最近香港的局势不太稳定，暴徒们恶意破坏的行径，已经严重影响到香港居民的方方面面。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-41ab7b2376308e2c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一条满是砖块垃圾的马路"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-c28106337cf53a62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在沙田，一列火车因抗议者的扰乱而暂停服务，乘客被迫下车"></p>
<p>我们都知道，动荡的社会环境中，社会生产活动肯定会受到影响，这些影响最后将以经济数据的形式呈现出来。8 月份开始的 “三罢（罢工、罢课、罢市）” 活动，更是将对经济的影响放大了。这篇文章里，我们将尝试从香港政府已经公布的经济数据中，去发现暴力活动对香港经济造成的影响。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-20fdf6abb39bee30?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<blockquote>
<p>因为经济数据，具有一定的延后性，我们这里只从现有的数据出发，去分析问题。至于当下实际的情况，只能通过后续更新的数据再去分析啦。</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="三罢对香港经济的影响"><a href="#三罢对香港经济的影响" class="headerlink" title="三罢对香港经济的影响"></a>三罢对香港经济的影响</h2><p>三罢（罢工、罢课、罢市）对经济的影响对经济的影响是巨大的。</p>
<p>香港私人消费总额的年度变化在今年第三季罕有地出现负增长。虽然背后的最大成因仍需科学验证，但初步认为与全球经济衰退、美中贸易战和香港的社会动荡和罢市行动有关。而私人消费 (Private Consumption) 是香港的经济产值(GDP)中占最大份额组成，2018年的占比比高达68.3% (图1)，因此每当私人消费下跌，经常伴随经济衰退。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-fa7bd48162dceffa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1 香港各项经济环节佔经济产值的百分比，2018年。资料来源：贸易发展局 (2019) [1]"></p>
<p>但到底是经济衰退带动私人消费下跌，还是其他外在因素引发私人消费下跌，从而令GDP下跌？这里有两种不同的说法<br>说法一：由于通胀和人口增长等因素，私人消费一般长期持续正增长，但当经济衰退，预期和实际失业人数增加，打击私人消费信心，导致私人消费下跌；<br>说法二：当外在因素如罢市行动或支持节约消费行动生效，私人消费下跌，因而造成经济衰退。</p>
<p>在过去大半年的香港却同时出现以上两种情况，消费下跌的真正原因仍有待进一步研究。</p>
<p>数据方面，私人消费的年度增长率由今年第二季的 +1.3% 转为第三季的 -3.5%，虽然跌幅比其他组别为细，但由于占比巨大，对GDP增长的影响举足轻重 (图2)：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-d20d0dfb20690132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2 香港生产总值各项分项的年度增长率，2019年第二及第三季比较，资料来源：香港统计处[2]"></p>
<p>私人消费的组成以「零售总值」和「食肆收益」两项最具代表，图3是过去一年零售总值的每月年度变化率，自今年2月起至最新的9月份数字均是负数，而且有持续扩大迹象，最新8、9月份的跌幅更急跌两成多，打破了过去十几年的记录。但由于早自2月份已经出现双位数跌幅，远早于罢市行动，反映部份原因与罢市和社会动动荡等近期本地因素无关。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-b364e626da46cc57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3 香港零售总值年度变化2018年9月-2019年9月。资料来源：Trading Economics"></p>
<p>但零售数据较难分析成因，因为随着网络科技和智能手机的普及，愈来愈多的购物是透过网购完成，而零售总值的统计仍然只限于实体零售，网购未有定期统计数据 (事实上亦较难准确统计，尤其是二手货网购平台和非本地网购等)，因此部份零售总值的下跌可能源于愈来愈多消费者由实体店购物改为网购而已，同时，当社会动荡，经常变相戒严，亦会鼓励更多消费者改为网购，因此零售总值数据对反映私人消费变化有重大缺点。</p>
<p>食肆收益数据亦出现类似情况，不外出用餐可改为在家用餐，但如此一来已直接造成GDP减少 (因为GDP是不计算家庭成员的家务工作产出价值)，二来也影响商用物业租用，间接影响GDP数据。</p>
<p>图4显示食肆收益价值指数及其年度变化，过去十年持续正增长，平均年增长4%，但自今年4月起已经出现负值 (若以收益数量指数计算，更早在2月起已经变负)，最新9月份的跌幅高达13.1%，比2009年国际金融风暴时的跌幅还要大得多。</p>
<p>图4 香港食肆收益价值指数及其年度变化 2009 - 2019年9月。资料来源：香港统计处 [3]</p>
<p>其中各类餐饮均出现大幅下跌，只有快餐继续上升，这通常反映消费信心疲弱，减少在高级食肆消费，转食较经济的快餐。</p>
<p>图5显示中式餐饮自2月起已经出现下跌，但6月起跌幅扩大至双位数，最新9月份跌幅更达-20.3%；非中式餐馆的收益下跌相比没有中式的严重，9月份的跌幅为-14.5%，而且负增长由4月起才出现；酒吧的收益下跌最突然，由6月起突然由正转负，且一跌就跌双位数，9月份跌幅为-18.8%，可能与旅游警示、游客减少有关。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-447a5ecf51a117ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5 香港四类食肆的收益价值指数年度变化 2009 - 2019年9月。资料来源：香港统计处 [3]"></p>
<p>各类私人消费自6月起均有较明显的下跌，反映6月起市场出现突变，但由于同期美中贸易谈判曾经破裂，直到10月中美之间才再次开启了新一轮的和谈，但因为10月份的数据还没有对外公布，需待下个月数据出台再作分析。</p>
<p>参考：</p>
<p>[1]  香港贸易发展局 (2019) 香港经济概况，10月25日。<br><a href="http://hong-kong-economy-research.hktdc.com/business-news/article/%E5%B8%82%E5%A0%B4%E7%92%B0%E5%A2%83/%E9%A6%99%E6%B8%AF%E7%B6%93%E8%B2%BF%E6%A6%82%E6%B3%81/etihk/tc/1/1X000000/1X09OVUL.htm" target="_blank" rel="noopener">http://hong-kong-economy-research.hktdc.com/business-news/article/%E5%B8%82%E5%A0%B4%E7%92%B0%E5%A2%83/%E9%A6%99%E6%B8%AF%E7%B6%93%E8%B2%BF%E6%A6%82%E6%B3%81/etihk/tc/1/1X000000/1X09OVUL.htm</a></p>
<p>[2] 香港统计处 (2019) 二零一九年第三季本地生产总值预先估计数字，香港政府 10月31日。<br><a href="https://www.censtatd.gov.hk/press_release/pressReleaseDetail.jsp?charsetID=2&amp;pressRID=4506" target="_blank" rel="noopener">https://www.censtatd.gov.hk/press_release/pressReleaseDetail.jsp?charsetID=2&amp;pressRID=4506</a></p>
<p>[3] 香港统计处 (2019) 表E088：按食肆类别划分的食肆收益，香港政府 11月5日。<br><a href="https://www.censtatd.gov.hk/hkstat/sub/sp320_tc.jsp?productCode=D5600088" target="_blank" rel="noopener">https://www.censtatd.gov.hk/hkstat/sub/sp320_tc.jsp?productCode=D5600088</a></p>
<hr>
<p>PS: 图片来源于互联网，侵删。</p>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>公众号</category>
        <category>香港</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>公众号</tag>
        <tag>香港</tag>
      </tags>
  </entry>
  <entry>
    <title>今日一文-矛盾的日本人</title>
    <url>/2019/11/14/2019-11-14_Life-Wenxin-wen/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>早上的时候，因为工作需要和日本的客户开了个会，就是我们作为方案提供方，想客户推广公司的产品，我基本全程 <code>打酱油</code>，主讲的另外的两个同事。主要通过英语进行讲解，日本那边有一个英语翻译，复杂将双方的意思进行传达。会议讲述的内容是已经在很多场合下讲过很多次了，客户也没有问特别深奥的问题，整个过程下来感觉也没有给客户留下特别的印象。</p>
<p>会上的一件小事，却让我感到有点吃惊。</p>
<p>既然是推广，那肯定会有答疑环节，日方的翻译和同事就一个问题讨论了几分钟了，突然有个声音出现，说着日语，然后那个翻译很快地就用几句话结束了交谈。</p>
<p>我还在郁闷，这是怎么回事呢？怎么突然就结束啦。正当我还在疑惑的时候，旁边的同事说道：“1个小时过的真快，这就结束了”。</p>
<p>然后同事有顺口提到：日本人也真是的，说一小时就一小时，多一分钟都不行。我们约的一个小时的会议，我们 10 点 55 开始的会议，现在刚11：54 就结束了会议。</p>
<p>会后，我对这个话题比较的感兴趣，就去搜索了相关的内容。这一搜，发现了一个重要的事实：日本人对待时间这件事情上就是一个 <code>矛盾</code> 的混合体。一方面，日本人有很重的时间观念，对于 <code>守时</code> 这件事情上的表现近乎刻板。另一方面，日本人也是“加班狂人”。为什么会出现这种看似 <code>矛盾</code> 的现象呢，这背后的原因是什么呢？</p>
<p>顺着这个思路，来展开我们今天的话题。</p>
<a id="more"></a>
<h2 id="日本人-守时-到什么程度呢？"><a href="#日本人-守时-到什么程度呢？" class="headerlink" title="日本人 守时 到什么程度呢？"></a>日本人 <code>守时</code> 到什么程度呢？</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-52e923987fe896e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>和日本人有过接触经验的人，都对日本人的 <code>守时</code> 的时间观念印象深刻。</p>
<p>日本人开会从来不迟到，也不会无故延长会议时间。就想我们今天遇到的这样，说是 1 个小时的会员，一定不会开到 1 小时零 1 分。日本人守时的习惯，尤其是“不迟到”这点更是多数日本人天生养成的习惯。比如在企业、公共机构或与他人会面的方方面面，必定“正确守时”即便是准时到达也会视为“迟到”，这已成为常识。关系亲密的人之间也有迟到的，不过也会事先邮件通知。</p>
<p>日本人不光在私人小事上，做到守时，在很复杂的系统上也能做到守时。</p>
<p>日本的新干线列车的晚点时间是以分钟计算延迟的，就是说延迟 1 分钟以上就算是延迟了。作为对比，在其他国家，如意大利定为 15 分钟、英国为 10 分钟、连号称规矩严谨与日本不相上下的德国也只定为 5 分钟。几年前的一个道歉事件，曾经被广泛报道。经营日本筑波快线（Tsukuba Express）的日本首都圈新都市铁道公司原定于 11 月 14 日上午 9 点 44 分 40 秒发出，但由于操作员的失误，结果列车没有按照原定计划，在 9 点 44 分 20 秒提前 20 秒发了车。令人意想不到的是，铁路公司竟然郑重其事的在网页上发布了如下的道歉声明。日本铁路公司的电车只要晚1分钟，车内必定播放道歉的广播。而新干线的到达和出发时刻是以15秒为单位设定的。</p>
<p>日本的机场在守时上也不输铁路，OAG 发布的最新准点率统计表明，<code>大阪国际机场</code> 在全球小型机场中准点率排名第一，<code>东京羽田机场</code> 在名列大型机场准点排行第一。准点率是衡量一个机场成熟度的重要指标。</p>
<p>铁路和机场，这样复杂的系统都没有阻止日本人守时的脚步，这些复杂系统做到这么 <code>精确</code> 的守时背后，是许许多多的小个体守时的缩影，可以说，<code>守时</code> 观念已经深入了日本人的骨髓。</p>
<h2 id="日本人独特的-“加班文化”"><a href="#日本人独特的-“加班文化”" class="headerlink" title="日本人独特的 “加班文化”"></a>日本人独特的 “加班文化”</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-075be3d4d4be32f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>如果说日本人 <code>不迟到</code> 是一个特色，那与之相关的一定是另一个特色—- <code>加班文化</code>。</p>
<p>在日本，加班对于每一个职场人士来说是“家常便饭”，乃至于“过劳死”成为日本加班文化的一个显著特征。日本是出名的“加班大国”，在日文中有“超勤文化”的表述，有时被说成“过劳文化”。日本人以加班为荣，对他们来说加班才是常态，晚上写字楼里的灯光也有个专有名词——“劳工之光”。对不少日本男性来说，“朝6晚11”的工作模式相当普遍，这比之前国内的“996”，似乎还要厉害一点。清早从家乘地铁到公司，上班然后“例行”加班后，再和同事酌酒交际到深夜，便是正常一天的工作行程。日本妻子也大多习惯了丈夫早出晚归，甚至在很多日本女人的观念里，丈夫如果每天正常下班回家是一种在职场上无能的表现。</p>
<p>那是什么原因让日本的加班文化如此盛行呢？</p>
<p>首先，由于连年的经济不景气，日本公司不断地缩减人工规模，员工随时可能被裁员，剩下的员工不得不处理大量的工作任务来减少自己被裁的可能性，从而导致加班不可避免。</p>
<p>第二，日本的终身雇佣制度使得就业市场缺乏活力，员工很难跳槽寻找更好的工作，被迫工作更长时间。</p>
<p>第三，日本企业大多实行终身雇佣制和工龄薪酬制度，工作时间更长意味着更易获得成功，每周多工作几个小时的员工被提升到管理岗位的机会更大，同时也可以获得更多的薪酬。</p>
<p>第四，日本独特的职场文化：强调不带条件的服从和忠诚，以集体主义为最高目标，个人在集体中只有义务，个人的需求会被自动忽视。</p>
<p>第五点，日本人内向拘谨，不愿给别人添麻烦，因此，他们工作勤奋、守规则、敬业心强、对企业忠诚。</p>
<p>与加班文化同时伴生的一个问题是：工作效率低下。2013年日本每小时劳动生产价值为41.3美元，不到挪威的一半，在34个经合组织国家中排名20位，“日本人以工作努力闻名，但效率低下和官僚作风同样有名”，一家英国的每天曾经这样评价日本的加班文化。</p>
<h2 id="其实这就是真实的日本人"><a href="#其实这就是真实的日本人" class="headerlink" title="其实这就是真实的日本人"></a>其实这就是真实的日本人</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-6001b03e5fd58a72?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>近乎苛责的 <code>守时</code>  和独特的 <code>加班文化</code> 夹杂在一起的日本人，就是一对矛盾的集合体，同时，这也是最真实的日本人。</p>
<p>好消息是，情况正在向好的方向发展。最近几届的日本政府都在积极推动“禁止加班”，通过立法的手段来禁止 日益加剧的 <code>加班文化</code> 。同时企业也通过内部改革来减少加班文化的土壤，例如减少时薪。最近看到的消息说：微软日本公司，已经实现每周休假 3  天的制度。</p>
<p>没有谁的生活是容易的，简单生活，才能更好的享受生活。</p>
<hr>
<p>PS: 图片来源于互联网，侵删。</p>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>公众号</category>
        <category>矛盾</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>公众号</tag>
        <tag>矛盾</tag>
      </tags>
  </entry>
  <entry>
    <title>副业赚钱？ 我用自己的教训来给你指路</title>
    <url>/2019/11/13/2019-11-13_Life-Wenxin-wen/</url>
    <content><![CDATA[<p><code>副业赚钱</code>, 是每个人读梦寐以求的，毕竟 <code>躺着就能把钱挣了</code> 还是很舒服的。</p>
<p>最近在不断的总结和反思着一个多月以来的 <code>折腾之旅</code> , 得到了下面的几点教训。这里分享出来给大家参考。</p>
<h2 id="涉及的东西太多"><a href="#涉及的东西太多" class="headerlink" title="涉及的东西太多"></a>涉及的东西太多</h2><p>自从 9 月份开始说要开始自己的折腾之旅开始，先后试过下面平台及方向。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>平台</th>
<th>内容、方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>简书</td>
<td>书写、技术付费文章</td>
<td></td>
</tr>
<tr>
<td>公众号</td>
<td>书写、图片转载</td>
</tr>
<tr>
<td>头条号</td>
<td>图片转载</td>
</tr>
<tr>
<td>悟空问答</td>
<td>影视领域认证</td>
</tr>
<tr>
<td>抖音</td>
<td>视频搬运</td>
</tr>
<tr>
<td>TiTok</td>
<td>视频搬运</td>
</tr>
<tr>
<td>微视</td>
<td>视频搬运</td>
</tr>
<tr>
<td>好看视频</td>
<td>视频搬运</td>
</tr>
<tr>
<td>Youtobe</td>
<td>视频搬运</td>
</tr>
<tr>
<td>Gitbook</td>
<td>技术付费文章</td>
</tr>
<tr>
<td>小专栏</td>
<td>技术付费专栏</td>
</tr>
</tbody>
</table>
</div>
<p>还有很多就试过一两次的，然后觉得不靠谱的就不再列出来了，如果列出来这份清单会很长很长。</p>
<p>上面的这些内容，大部分都在上班时间抽空来完成的。质量可定也好不到哪里去，基本上可以说大部分的内容都是拼凑完成的，另外一些内容，虽然加入了自己的一些东西，但是大部分都不是太深入。</p>
<a id="more"></a>
<h2 id="没有明确的方向"><a href="#没有明确的方向" class="headerlink" title="没有明确的方向"></a>没有明确的方向</h2><p>上面的那份清单里面，已经列出来了，目前试过的方向包括</p>
<ul>
<li>技术付费文章</li>
<li>视频搬运</li>
<li>图片转载</li>
</ul>
<p>上面的每个领域，都是很大的领域，在其中的领域如果做的好，都可以做的很成功。但是毫无疑问，每个领域的成功都需要投入很多的精力，包括但不限于：时间，金钱。</p>
<blockquote>
<p>为什么是为了赚钱的，怎么还需要投入金钱呢？这里解释下原因：很多领域开始赚钱前是需要一个“门槛”的，有些门槛对新人来说感觉很高，此时适当的金钱投入，是可以帮我们快速跨过这个门槛的。</p>
</blockquote>
<h2 id="无法持续的输出"><a href="#无法持续的输出" class="headerlink" title="无法持续的输出"></a>无法持续的输出</h2><p>上面的那份清单里面的每一个，都需要持续不断的 <code>原创</code> 输出，才有可能成功。如果只是 <code>转载</code>、<code>搬运</code>、<code>洗稿</code>，成功的可能性基本没有。</p>
<blockquote>
<p>这里为什么不把话说满呢？因为现实中的的确确出现一些，<code>山寨货</code> 最后逆袭 <code>正版货</code> 的故事。福建莆田的鞋类生产就是一个很好的例子。</p>
</blockquote>
<p>为什么我们一定要坚持原创呢？因为原创是制约你走的更远的决定性条件。在刚开始的时候，你 <code>搬运</code> 了，没人会关注到你，因为你太小了。如果有一天你长大了，很多人都可以看到你的时候，你的所有问题都会暴露在众人面前，一旦发生了问题，众人的 <code>口水</code> 真的就把你淹没了,然后就真的没有然后了。</p>
<blockquote>
<p>大家可以参看下 <code>李现ins点赞</code> 的 <code>故事</code>。</p>
</blockquote>
<p>可能走的越远，越能体会到 <code>人言可畏</code> 这句话的真正威力吧。</p>
<hr>
<p>上面的内容是对自己这一段时间的复盘，下面来简短的写下自己接下来的计划。</p>
<h2 id="精简自己的内容"><a href="#精简自己的内容" class="headerlink" title="精简自己的内容"></a>精简自己的内容</h2><div class="table-container">
<table>
<thead>
<tr>
<th>平台</th>
<th>内容、方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>简书</td>
<td>书写、技术付费文章</td>
</tr>
<tr>
<td>公众号</td>
<td>书写、技术付费文章</td>
</tr>
<tr>
<td>Gitbook</td>
<td>技术付费文章</td>
</tr>
</tbody>
</table>
</div>
<p>之所以这么选择，理由如下：</p>
<ul>
<li><code>技术文章</code> 基本就是自己平时工作、学习的再记录。把学到的东西分享出去，不仅可以促进自己不断的学习，还能把自己的知识分享给更多的人，这是多方共赢的。</li>
<li><code>书写</code> 主要的目的是记录平时生活、工作，同时系统化的构建自己的知识体系。</li>
</ul>
<p>下面对着3个平台的功能进行下区分，</p>
<ul>
<li><code>简书</code> 上面是所有的内容的整合地，类似于目录的作用。</li>
<li><code>公众号</code> 上面主要是日常生活的中的见闻分享。通过日常的一个点，去发散开来，理论上不设任何的领域限制。</li>
<li><code>Gitbook</code> 上面主要是</li>
</ul>
<h2 id="持续原创输出"><a href="#持续原创输出" class="headerlink" title="持续原创输出"></a>持续原创输出</h2><p>上面提到的两个方向都是需要持续不断的更新内容，才能看到后来的光明。<br>其实对于各个行业都需要持续不断的的产出，才有可能成功。坚持下来，才有可能看到阳光；如果不坚持，一定就看不到阳光。</p>
<p>即使 <code>强</code> 如李佳琦也会有翻船的时候。</p>
<blockquote>
<p>具体事件可以参见这篇文章 <a href="https://new.qq.com/rain/a/20191105A0PNQX00" target="_blank" rel="noopener">https://new.qq.com/rain/a/20191105A0PNQX00</a></p>
</blockquote>
<p>虽然李佳琦带货会翻车，但是不可否认李佳琦的带货能力，毕竟他是曾经打败过 <code>马爸爸</code> 的男人。</p>
<p>上面写就是我这一段时间来的总结，是一个悲伤的故事，说出来让大家笑一笑。</p>
<p>最后附上我的微信公众号，欢迎大家关注。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-9b2b8d44ef7010f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" &quot;you的日常&quot; 公众号 "></p>
<blockquote>
<p>有需要的朋友，请到评论区留言吧，我们来互相关注啊。</p>
</blockquote>
<p>希望大家都能够早日通过 “副业” 赚到钱。</p>
<p>加油…</p>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>公众号</category>
        <category>副业</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>公众号</tag>
        <tag>副业</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-高级-使用MongoDB</title>
    <url>/2018/11/03/2018-11-03_Programing-Python-Advanced-use-mongoDB/</url>
    <content><![CDATA[<hr>
<h2 id="Python使用MongoDB"><a href="#Python使用MongoDB" class="headerlink" title="Python使用MongoDB"></a>Python使用MongoDB</h2><p>MongoDB相对于传统的关系型数据库，可以存储JSON数据，非常适合存储数据抓取返回的JSON数据。<br>今天主要学习的是使用Python连接MongoDB，并进行增删改查的操作。</p>
<blockquote>
<p>MongoDB 的安装及使用，请参照官方文档。<br><a href="https://api.mongodb.com/python/current/installation.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/installation.html</a></p>
</blockquote>
<p>在连接MongoDB前 首先要安装的是Python包：PyMongo，包的安装非常的简单。<br>只需执行 <code>pip install pymongo</code> 即可使用。</p>
<h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>在安装完PyMongo以后，使用Python连接MongoDB变得异常简单。具体方式为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"> </span><br><span class="line">client = MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br></pre></td></tr></table></figure><br>或使用如下方式：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"> </span><br><span class="line">client = MongoClient(<span class="string">'mongodb://localhost:27017'</span>)</span><br></pre></td></tr></table></figure><br>如果连接含有账号密码等，请参考：<br><a href="https://api.mongodb.com/python/current/api/pymongo/mongo_client.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/api/pymongo/mongo_client.html</a></p>
<a id="more"></a>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>连接数据库的操作也非常的简单，最为重要的是，在你连接数据库之前无需先创建数据库，如果数据库存在则直接连接，如果数据库不存在则会创建新的库。具体方式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">db = client.pymongo_test</span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">db = client[<span class="string">'pymongo_test'</span>]</span><br></pre></td></tr></table></figure>
<p>以上两种方式任选一种即可。</p>
<h3 id="Collection概念"><a href="#Collection概念" class="headerlink" title="Collection概念"></a>Collection概念</h3><p>在MongoDB中存在一个Collection的概念，我将其理解为命名空间，类似其他数据库中Scheme的概念，Collection可以理解为一些表的集合。Collection可以使用也可以不使用，具体看你是否要给库下的表分类。相关的操作：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法一：</span></span><br><span class="line">collection = db.test_collection</span><br><span class="line"><span class="comment">#方法二</span></span><br><span class="line">collection = db[<span class="string">'test-collection'</span>]</span><br></pre></td></tr></table></figure><br>需要知晓的是，collection的创建是在第一张表创建时才会创建。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入数据的方式的凡是非常的简单，最长使用的方法是，<code>insert_one()</code>和<code>inert_many()</code>方法，从字面上就可以看出来一个是插入一条数据，另外一个是插入多条数据，示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"> </span><br><span class="line">client = MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br><span class="line">db = client.testdb</span><br><span class="line">posts = db.posts</span><br><span class="line"> </span><br><span class="line">post_1 = &#123;</span><br><span class="line">    <span class="string">'title'</span>: <span class="string">'Python and MongoDB'</span>,</span><br><span class="line">    <span class="string">'content'</span>: <span class="string">'PyMongo is fun'</span>,</span><br><span class="line">    <span class="string">'author'</span>: <span class="string">'saul'</span></span><br><span class="line">&#125;</span><br><span class="line">post_2 = &#123;</span><br><span class="line">    <span class="string">'title'</span>: <span class="string">'Virtual Environments'</span>,</span><br><span class="line">    <span class="string">'content'</span>: <span class="string">'Use virtual environments'</span>,</span><br><span class="line">    <span class="string">'author'</span>: <span class="string">'Scott'</span></span><br><span class="line">&#125;</span><br><span class="line">post_3 = &#123;</span><br><span class="line">    <span class="string">'title'</span>: <span class="string">'Learning Python'</span>,</span><br><span class="line">    <span class="string">'content'</span>: <span class="string">'Learn Python, it is easy'</span>,</span><br><span class="line">    <span class="string">'author'</span>: <span class="string">'Bill'</span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">#每次插入一条数据</span></span><br><span class="line">posts.insert_one(post_1)</span><br><span class="line">posts.insert_one(post_2)</span><br><span class="line">posts.insert_one(post_3)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#一次插入多条数据</span></span><br><span class="line">posts.insert_many([post_1, post_2, post_3])</span><br></pre></td></tr></table></figure></p>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>和插入数据一样，查询数据的时候，提供查询一条或多条数据的方法，方法分别为<code>find_one()</code>和<code>find()</code>。示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询一条数据</span></span><br><span class="line">bills_post = posts.find_one(&#123;<span class="string">'author'</span>: <span class="string">'Bill'</span>&#125;)</span><br><span class="line">print(bills_post)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查询多条数据</span></span><br><span class="line">scotts_posts = posts.find(&#123;<span class="string">'author'</span>: <span class="string">'Scott'</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> post <span class="keyword">in</span> scotts_posts:</span><br><span class="line">    print(post)</span><br></pre></td></tr></table></figure><br>另外，查询多条时，可以设定返回的数量或其他限定条件：<br><a href="https://api.mongodb.com/python/current/api/pymongo/collection.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/api/pymongo/collection.html</a></p>
<p>另外条件中如需支持类似的关系数据库中的WHERE条件，需要使用特定的关键词。示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = datetime.datetime(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">for</span> post <span class="keyword">in</span> posts.find(&#123;<span class="string">"date"</span>: &#123;<span class="string">"$lt"</span>: d&#125;&#125;).sort(<span class="string">"author"</span>):</span><br><span class="line">    pprint.pprint(post)</span><br></pre></td></tr></table></figure></p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除数据同样非常的简单，主要用到的方法为：<code>delete_one()</code>和<code>delete_many()</code>。</p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>更新数据的主要方法是，<code>update_one()</code>和<code>update_many()</code>，除此之外，还有一个<code>replace_one()</code>方法用来替换，由于用的不多，具体看文档。</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>pyMongo还支持创建索引，可以进一步提升查询的性能，示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = db.profiles.create_index([(<span class="string">'user_id'</span>, pymongo.ASCENDING)],unique=<span class="literal">True</span>)</span><br><span class="line">sorted(list(db.profiles.index_information()))</span><br></pre></td></tr></table></figure>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://api.mongodb.com/python/current/tutorial.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/tutorial.html</a><br><a href="https://docs.mongodb.com/manual/indexes/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/indexes/</a></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>Python</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-高级-聊一聊 Flask 的 jsonify</title>
    <url>/2018/07/07/2018-07-07_Programing-Python-Advanced-jsonify-in-Flask/</url>
    <content><![CDATA[<p>首先我们来看一段 Python 代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 python_mastery 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/python_mastery'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 pythonml 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/pythonml'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: tasks&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>在这段代码里面，我们看到了今天的主角 <code>jsonify</code>。</p>
<p>Flask 框架里，可以用 <code>jsonify</code> 返回 json 数据，但是为什么不用 <code>Python</code> 自带的 <code>json</code> 模块返回 JSON 数据呢？</p>
<a id="more"></a>
<hr>
<h2 id="其实是一样"><a href="#其实是一样" class="headerlink" title="其实是一样"></a>其实是一样</h2><p>其实，<code>jsonify</code> 在处理数据过程中，对数据做 JSON 序列化处理时，用的是 <code>itsdangerous</code> 模块里的 JSON ，让我们看一下，这个模块里的 JSON 是如何引入的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> simplejson <span class="keyword">as</span> json</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> json</span><br></pre></td></tr></table></figure>
<p>它会先尝试引入<code>simplejson</code>，如果没有安装这个模块，则引入 Python 原生模。</p>
<p>在Flask框架中，引入过程如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> json <span class="keyword">as</span> _json</span><br></pre></td></tr></table></figure>
<p>对于数据的序列化处理，用的正是 <code>_json</code>.</p>
<hr>
<h2 id="Content-Type-的差别"><a href="#Content-Type-的差别" class="headerlink" title="Content-Type 的差别"></a>Content-Type 的差别</h2><p>前面讲到，<code>jsonify</code> 和 <code>json</code> 是殊途同归，那么为什么要费周折绕这么一圈呢?</p>
<p>肯定存在一个合理的原因让 <code>jsonify</code>存在的有意义。</p>
<p>这个原因就是 <code>Content-Type</code></p>
<p>看下面两段代码</p>
<p><strong>第一段代码</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##  jsonify</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/json')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json</span><span class="params">()</span>:</span></span><br><span class="line">    data = &#123;<span class="string">'name'</span>: <span class="string">'lilei'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(data)</span><br><span class="line"></span><br><span class="line">app.run(host=<span class="string">"0.0.0.0"</span>, port=<span class="number">9877</span>)</span><br></pre></td></tr></table></figure></p>
<p>在浏览器里输入<a href="http://127.0.0.1:9877/json," target="_blank" rel="noopener">http://127.0.0.1:9877/json</a>， 得到的结果是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"age"</span>:<span class="number">30</span>,<span class="string">"name"</span>:<span class="string">"lilei"</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二段代码：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## json</span><br><span class="line">import json</span><br><span class="line">from flask import Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/json&apos;)</span><br><span class="line">def test_json():</span><br><span class="line">    data = &#123;&apos;name&apos;: &apos;lilei&apos;, &apos;age&apos;: 30&#125;</span><br><span class="line">    return json.dumps(data)</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;, port=9877)</span><br></pre></td></tr></table></figure></p>
<p>在浏览器里输入<a href="http://127.0.0.1:9877/json," target="_blank" rel="noopener">http://127.0.0.1:9877/json</a>， 得到的结果是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>: <span class="string">"lilei"</span>, <span class="string">"age"</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>
<p>从内容上看，两种方法没有区别。<br>但是使用  <code>jsonify</code> 时，返回的 <code>http response</code>  的 <code>Content-Type</code> 是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>
<p>而使用json.dumps时，Content-Type则是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure>
<p>既然返回的是 json 数据，那么自然要指明 <code>Content-Type</code> 是 <code>application/json</code> ， 这样做是符合 HTTP 协议的规定的，这就是使用 <code>jsonify</code> 的原因之一。</p>
<hr>
<h2 id="减小数据量"><a href="#减小数据量" class="headerlink" title="减小数据量"></a>减小数据量</h2><p>使用 <code>jsonify</code> 除了让返回的 `http response符合 HTTP 协议，同时也对数据做了压缩处理，让数据体积更小。</p>
<p>仔细比较上面两种方法返回的数据，虽然内容相同，但 <code>jsonify</code> 返回的数据，每个 <code>key-value</code> 对之间的逗号，和每个 <code>key</code> 与 <code>value</code> 之间的冒号后面都是没有空格的，而 <code>json.dumps</code> 返回的数据里，却在逗号和冒号后面存在空格，因此即便内容相同，<code>jsonify</code> 返回的数据体积更小，更节省流量。</p>
<p>其实，<code>json.dumps</code> 也可以将这些不必要的空格去掉，看下面的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">'name'</span>: <span class="string">'lilei'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">print(json.dumps(data, separators=(<span class="string">','</span>, <span class="string">':'</span>)))</span><br><span class="line">print(json.dumps(data))</span><br></pre></td></tr></table></figure>
<p>输出结果为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;lilei&quot;,&quot;age&quot;:30&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;lilei&quot;, &quot;age&quot;: 30&#125;</span><br></pre></td></tr></table></figure></p>
<p>只需要在 <code>dumps</code> 参数里指定   <code>separators</code> 即可，其实在 <code>jsonify</code> 里就是这么干的。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>Python</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot Web 应用加速</title>
    <url>/2018/04/29/2018-04-29-Programing-Java-Spring-Boot-App-speeded-up/</url>
    <content><![CDATA[<h1 id="Spring-Boot-Web-应用加速"><a href="#Spring-Boot-Web-应用加速" class="headerlink" title="Spring Boot Web 应用加速"></a>Spring Boot Web 应用加速</h1><p>默认情况下，Spring Boot Web 应用会装配一些功能组件 Bean。</p>
<p>在大多数 Web 应用场景下，可以选择性地关闭一下自动装配的Spring 组件 Bean，以达到提升性能的目的。</p>
<h2 id="配置项优化"><a href="#配置项优化" class="headerlink" title="配置项优化"></a>配置项优化</h2><h3 id="Spring-Boot-Web-应用加速-完整配置项"><a href="#Spring-Boot-Web-应用加速-完整配置项" class="headerlink" title="Spring Boot Web 应用加速 完整配置项"></a>Spring Boot Web 应用加速 完整配置项</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.add-application-context-header</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">spring.mvc.formcontent.putfilter.enabled</span> = <span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<h3 id="配置项汇总"><a href="#配置项汇总" class="headerlink" title="配置项汇总"></a>配置项汇总</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration,\</span></span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="关闭-Web-请求跟踪-自动装配"><a href="#关闭-Web-请求跟踪-自动装配" class="headerlink" title="关闭 Web 请求跟踪 自动装配"></a>关闭 Web 请求跟踪 自动装配</h3><h4 id="org-springframework-boot-actuate-autoconfigure-TraceWebFilterAutoConfiguration"><a href="#org-springframework-boot-actuate-autoconfigure-TraceWebFilterAutoConfiguration" class="headerlink" title="org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration"></a><code>org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration</code></h4><p>顾名思义，该自动装配用跟踪 Web 请求，通过Servlet Filter <code>org.springframework.boot.actuate.trace.WebRequestTraceFilter</code> 记录请求的信息（如：请求方法、请求头以及请求路径等），其计算的过程存在一定的开销，使用场景罕见，故可选择关闭。</p>
<ul>
<li>配置项</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<h4 id="org-springframework-boot-actuate-autoconfigure-TraceRepositoryAutoConfiguration"><a href="#org-springframework-boot-actuate-autoconfigure-TraceRepositoryAutoConfiguration" class="headerlink" title="org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration"></a><code>org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration</code></h4><p>当<code>org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration</code>关闭后，其请求信息存储介质<code>org.springframework.boot.actuate.trace.TraceRepository</code>没有存在的必要，故可选择关闭。</p>
<ul>
<li>配置项</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭-Web-请求结果指标-自动装配"><a href="#关闭-Web-请求结果指标-自动装配" class="headerlink" title="关闭 Web 请求结果指标 自动装配"></a>关闭 Web 请求结果指标 自动装配</h3><h4 id="org-springframework-boot-actuate-autoconfigure-MetricFilterAutoConfiguration"><a href="#org-springframework-boot-actuate-autoconfigure-MetricFilterAutoConfiguration" class="headerlink" title="org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration"></a><code>org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</code></h4><p>该组件将自动装配<code>org.springframework.boot.actuate.autoconfigure.MetricsFilter</code>，该 Filter</p>
<p>主要记录Web 请求结果指标（如：相应状态码、请求方法执行时间等），该信息一定程度上与反向代理服务器（nginx）功能重叠，故可选择关闭。</p>
<ul>
<li>配置项</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<h3 id="可关闭-Servlet-Web-组件"><a href="#可关闭-Servlet-Web-组件" class="headerlink" title="可关闭 Servlet Web 组件"></a>可关闭 Servlet Web 组件</h3><h4 id="org-springframework-web-filter-HttpPutFormContentFilter"><a href="#org-springframework-web-filter-HttpPutFormContentFilter" class="headerlink" title="org.springframework.web.filter.HttpPutFormContentFilter"></a><code>org.springframework.web.filter.HttpPutFormContentFilter</code></h4><ul>
<li>引入版本</li>
</ul>
<p><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 由 Spring<br>Framework 3.1 版本引入，分发在 <code>org.springframework:spring-web</code> 中。</p>
<ul>
<li>使用场景</li>
</ul>
<p>通常 Web 场景中，浏览器通过 HTTP <code>GET</code> 或者 <code>POST</code> 请求 提交 Form 数据，而非浏览<br>器客户端（如应用程序）可能通过 HTTP <code>PUT</code> 请求来实现。</p>
<p>当 HTTP 请求头<code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 时<br>，Form 数据被 encoded。而 Servlet 规范中， <code>ServletRequest.getParameter*()</code><br>方法仅对 HTTP <code>POST</code> 方法支持请求参数的获取，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> intetfacce ServletRequest &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name);</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故 以上方法无法支持 HTTP <code>PUT</code> 或 HTTP <code>PATCH</code> 请求方法（请求头<code>Content-Type</code><br>为<code>application/x-www-form-urlencoded</code>）。</p>
<p><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 正是这种场景的解<br>决方案。</p>
<p>Spring Boot 默认场景下，将<br><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 被<br><code>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration</code> 自动<br>装配，以下为 Spring Boot 1.4.1.RELEASE 以及更好版本定义（可能存在一定的差异）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span>, <span class="title">WebMvcConfigurerAdapter</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">WebMvcConfigurationSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureOrder</span>(<span class="title">Ordered</span>.<span class="title">HIGHEST_PRECEDENCE</span> + 10)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HttpPutFormContentFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.mvc.formcontent.putfilter"</span>, name = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderedHttpPutFormContentFilter <span class="title">httpPutFormContentFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderedHttpPutFormContentFilter();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，<code>org.springframework.web.filter.HttpPutFormContentFilter</code> 在绝大<br>多数 Web 使用场景下为非必须组件。</p>
<ul>
<li>配置项</li>
</ul>
<p>如果应用依赖 Spring Boot 版本 为 1.4.1.RELEASE 以及更高的版本，可通过如下配置，<br>进行将 <code>org.springframework.web.filter.HttpPutFormContentFilter</code> 关闭：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.formcontent.putfilter.enabled</span> = <span class="string">false</span></span><br></pre></td></tr></table></figure>
<h4 id="org-springframework-web-filter-HiddenHttpMethodFilter"><a href="#org-springframework-web-filter-HiddenHttpMethodFilter" class="headerlink" title="org.springframework.web.filter.HiddenHttpMethodFilter"></a><code>org.springframework.web.filter.HiddenHttpMethodFilter</code></h4><ul>
<li>引入版本</li>
</ul>
<p><code>org.springframework.web.filter.HiddenHttpMethodFilter</code> 由 Spring<br>Framework 3.0 版本引入，分发在 <code>org.springframework:spring-web</code> 中。</p>
<ul>
<li>使用场景</li>
</ul>
<p>当 Web 服务端同一资源（URL）提供了多请求方法的实现，例如 URI ：/update 提供了<br>HTTP <code>POST</code> 以及 HTTP <code>PUT</code> 实现），通常 Web 场景中，浏览器仅支持 HTTP <code>GET</code><br>或者 <code>POST</code> 请求方法，这样的话，浏览器无法发起 HTTP <code>PUT</code> 请求。</p>
<p>为了浏览器可以消费 HTTP <code>PUT</code> 资源， 需要在服务端将 HTTP <code>POST</code> 转化成<br>HTTP <code>PUT</code> 请求，为了解决这类问题，Spring 引入<br><code>org.springframework.web.filter.HiddenHttpMethodFilter</code> Web 组件。</p>
<p>当浏览器 发起 HTTP <code>POST</code> 请求时，可通过增加请求参数（默认参数名称：”_method”）<br>的方式，进行HTTP 请求方法切换，<br><code>org.springframework.web.filter.HiddenHttpMethodFilter</code> 获取参数”_method”<br>值后，将参数值作为 <code>HttpServletRequest#getMethod()</code>的返回值，给后续 <code>Servlet</code><br>实现使用。</p>
<p>出于通用性的考虑，<code>org.springframework.web.filter.HiddenHttpMethodFilter</code><br>通过调用 <code>#setMethodParam(String)</code> 方法，来修改转换请求方法的参数名称。</p>
<p>Spring Boot 默认场景下，将<br><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 被<br><code>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration</code> 自动<br>装配，以下为 Spring Boot 1.4.1.RELEASE 以及更好版本定义（可能存在一定的差异）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span>, <span class="title">WebMvcConfigurerAdapter</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">WebMvcConfigurationSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureOrder</span>(<span class="title">Ordered</span>.<span class="title">HIGHEST_PRECEDENCE</span> + 10)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>,	<span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HiddenHttpMethodFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">OrderedHiddenHttpMethodFilter</span> <span class="title">hiddenHttpMethodFilter</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，<code>org.springframework.web.filter.HiddenHttpMethodFilter</code> 也是特殊<br>场景下所需，故可以关闭之。</p>
<ul>
<li>配置项</li>
</ul>
<p>按目前最新的 Spring Boot 1.5.2.RELEASE 版本中实现，也没有提供类似<br><code>spring.mvc.formcontent.putfilter.enabled</code> 这样的配置项关闭，无法关闭。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Java</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo 注解驱动</title>
    <url>/2017/11/28/2017-12-28-Programing-Java-Dubbo-Annotation-Driven/</url>
    <content><![CDATA[<h1 id="Dubbo-注解驱动（Annotation-Driven）"><a href="#Dubbo-注解驱动（Annotation-Driven）" class="headerlink" title="Dubbo 注解驱动（Annotation-Driven）"></a>Dubbo 注解驱动（Annotation-Driven）</h1><h2 id="注解驱动（Annotation-Driven）"><a href="#注解驱动（Annotation-Driven）" class="headerlink" title="注解驱动（Annotation-Driven）"></a>注解驱动（Annotation-Driven）</h2><h3 id="DubboComponentScan"><a href="#DubboComponentScan" class="headerlink" title="@DubboComponentScan"></a><code>@DubboComponentScan</code></h3><h4 id="起始版本：-2-5-7"><a href="#起始版本：-2-5-7" class="headerlink" title="起始版本： 2.5.7"></a>起始版本： <code>2.5.7</code></h4><h4 id="lt-dubbo-annotation-gt-历史遗留问题"><a href="#lt-dubbo-annotation-gt-历史遗留问题" class="headerlink" title="&lt;dubbo:annotation&gt;历史遗留问题"></a><code>&lt;dubbo:annotation&gt;</code>历史遗留问题</h4><h5 id="1-注解支持不充分"><a href="#1-注解支持不充分" class="headerlink" title="1. 注解支持不充分"></a>1. 注解支持不充分</h5><p>在 Dubbo <code>2.5.7</code>之前的版本 ，Dubbo 提供了两个核心注解 <code>@Service</code> 以及 <code>@Reference</code>，分别用于 Dubbo 服务提供和 Dubbo 服务引用。</p>
<p>其中，<code>@Service</code> 作为 XML 元素 <code>&lt;dubbo:service&gt;</code>的替代注解，与 Spring Framework <code>@org.springframework.stereotype.Service</code> 类似，用于服务提供方 Dubbo 服务暴露。与之相对应的<code>@Reference</code>，则是替代<code>&lt;dubbo:reference</code> 元素，类似于 Spring 中的 <code>@Autowired</code>。</p>
<p><code>2.5.7</code> 之前的 Dubbo，与早期的 Spring Framework 2.5 存在类似的不足，即注解支持不够充分。注解需要和 XML 配置文件配合使用，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"annotation-provider"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"127.0.0.1:4548"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.alibaba.dubbo.config.spring.annotation.provider"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="2-Service-Bean-不支持-Spring-AOP"><a href="#2-Service-Bean-不支持-Spring-AOP" class="headerlink" title="2. @Service Bean 不支持 Spring AOP"></a>2. <code>@Service</code> Bean 不支持 Spring AOP</h5><p>同时，使用 <code>&lt;dubbo:annotation&gt;</code> 方式扫描后的 Dubbo <code>@Service</code> ，在 Spring 代理方面存在问题，如 GitHub 上的 issue <a href="https://github.com/alibaba/dubbo/issues/794：" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/794：</a></p>
<blockquote>
<p>关于 dubbo @Service 注解生成 ServiceBean 时, interface 获取成 spring 的代理对象的 bug</p>
<blockquote>
<p>在项目里， 我使用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@com</span>.alibaba.dubbo.config.annotation.Service</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SUserJpushServiceImp</span></span></span><br></pre></td></tr></table></figure>
<p>的形式， 来暴露服务。但是在发布服务的时候， interface class 是通过<br><code>serviceConfig.setInterface(bean.getClass().getInterfaces()[0]);</code><br>的形式获取， 刚好， 我的 service 都使用了@Transactional 注解， 对象被代理了。所以获取到的 interface 是 Spring 的代理接口…</p>
</blockquote>
</blockquote>
<p>不少热心的小伙伴不仅发现这个历史遗留问题，而且提出了一些修复方案。同时，为了更好地适配 Spring 生命周期以及将 Dubbo 完全向注解驱动编程模型过渡，因此，引入了全新 Dubbo 组件扫描注解 - <code>@DubboComponentScan</code>。</p>
<blockquote>
<p>注： <code>&lt;dubbo:annotation&gt;</code> Spring AOP 问题将在 <code>2.5.9</code> 中修复：<a href="https://github.com/alibaba/dubbo/issues/1125" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/1125</a></p>
</blockquote>
<h5 id="3-Reference-不支持字段继承性"><a href="#3-Reference-不支持字段继承性" class="headerlink" title="3. @Reference 不支持字段继承性"></a>3. @Reference 不支持字段继承性</h5><p>假设有一个 Spring Bean <code>AnnotationAction</code> 直接通过字段<code>annotationService</code> 标记 <code>@Reference</code> 引用 <code>AnnotationService</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.examples.annotation.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.examples.annotation.api.AnnotationService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"annotationAction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>AnnotationAction</code> 被 XML 元素 <code>&lt;dubbo:annotation&gt;</code> 扫描后：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.alibaba.dubbo.examples.annotation.action"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>字段 <code>annotationService</code> 能够引用到 <code>AnnotationService</code>，执行 <code>doSayHello</code> 方法能够正常返回。</p>
<p>如果将字段<code>annotationService</code> 抽取到<code>AnnotationAction</code> 的父类<code>BaseAction</code> 后，<code>AnnotationService</code> 无法再被引用，改造如下所示：</p>
<p><code>AnnotationAction.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"annotationAction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAction</span> <span class="keyword">extends</span> <span class="title">BaseAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAnnotationService().sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BaseAction.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AnnotationService <span class="title">getAnnotationService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造后，再次执行 <code>doSayHello</code> 方法，<code>NullPointerException</code> 将会被抛出。说明<code>&lt;dubbo:annotation&gt;</code> 并不支持<code>@Reference</code> 字段继承性。</p>
<p>了解了历史问题，集合整体愿景，下面介绍<code>@DubboComponentScan</code> 的设计原则。</p>
<h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>Spring Framework 3.1 引入了新 Annotation - <code>@ComponentScan</code> ， 完全替代了 XML 元素 <code>&lt;context:component-scan&gt;</code> 。同样， <code>@DubboComponentScan</code> 作为 Dubbo <code>2.5.7</code> 新增的 Annotation，也是 XML 元素 <code>&lt;dubbo:annotation&gt;</code> 的替代方案。</p>
<p>在命名上（类名以及属性方法），为了简化使用和关联记忆，Dubbo 组件扫描 Annotation <code>@DubboComponentScan</code>，借鉴了 Spring Boot 1.3 引入的 <code>@ServletComponentScan</code>。定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DubboComponentScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise annotation</span></span><br><span class="line"><span class="comment">     * declarations e.g.: &#123;<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>("org.my.pkg")&#125; instead of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>(basePackages="org.my.pkg")&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base packages to scan for annotated <span class="doctag">@Service</span> classes. &#123;<span class="doctag">@link</span> #value()&#125; is an</span></span><br><span class="line"><span class="comment">     * alias for (and mutually exclusive with) this attribute.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Use &#123;<span class="doctag">@link</span> #basePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment">     * package names.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment">     * scan for annotated <span class="doctag">@Service</span> classes. The package of each class specified will be</span></span><br><span class="line"><span class="comment">     * scanned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> classes from the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>basePackages()</code> 和 <code>value()</code> 均能支持占位符（placeholder）指定的包名</p>
</blockquote>
<p>在职责上，<code>@DubboComponentScan</code> 相对于 Spring Boot <code>@ServletComponentScan</code> 更为繁重，原因在于处理 Dubbo <code>@Service</code> 类暴露 Dubbo 服务外，还有帮助 Spring Bean <code>@Reference</code>字段或者方法注入 Dubbo 服务代理。</p>
<p>在场景上，Spring Framework <code>@ComponentScan</code> 组件扫描逻辑更为复杂。而在 <code>@DubboComponentScan</code> 只需关注 <code>@Service</code> 和 <code>@Reference</code> 处理。</p>
<p>在功能上， <code>@DubboComponentScan</code> 不但需要提供完整 Spring AOP 支持的能力，而且还得具备<code>@Reference</code> 字段可继承性的能力。</p>
<p>了解基本设计原则后，下面通过完整的示例，简介<code>@DubboComponentScan</code> 使用方法以及注意事项。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>后续通过服务提供方（<code>@Serivce</code>）以及服务消费方（<code>@Reference</code>）两部分来介绍<code>@DubboComponentScan</code> 使用方法。</p>
<p>假设，服务提供方和服务消费分均依赖服务接口<code>DemoService</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="服务提供方（-Serivce）"><a href="#服务提供方（-Serivce）" class="headerlink" title="服务提供方（@Serivce）"></a>服务提供方（<code>@Serivce</code>）</h5><h6 id="实现-DemoService"><a href="#实现-DemoService" class="headerlink" title="实现 DemoService"></a>实现 <code>DemoService</code></h6><p>服务提供方实现<code>DemoService</code> - <code>AnnotationDemoService</code> ，同时标注 Dubbo <code>@Service</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation &#123;<span class="doctag">@link</span> DemoService&#125; 实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello , "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="服务提供方-Annotation-配置"><a href="#服务提供方-Annotation-配置" class="headerlink" title="服务提供方 Annotation 配置"></a>服务提供方 Annotation 配置</h6><p>将 <code>AnnotationDemoService</code> 暴露成 Dubbo 服务，需要依赖 Spring Bean：<code>AplicationConfig</code>、<code>ProtocolConfig</code> 以及 <code>RegistryConfig</code> 。这三个 Spring Bean 过去可通过 XML 文件方式组装 Spring Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当前应用信息配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-annotation-provider"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 连接注册中心配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"my-registry"</span> <span class="attr">address</span>=<span class="string">"N/A"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"12345"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上装配方式不予推荐，推荐使用 Annotation 配置，因此可以换成 Spring <code>@Configuration</code> Bean 的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProtocolConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供方配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span>(<span class="string">"com.alibaba.dubbo.demo.provider"</span>) <span class="comment">// 扫描 Dubbo 组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前应用配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dubbo-annotation-provider"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-annotation-provider"</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"my-registry"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setAddress(<span class="string">"N/A"</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dubbo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">        protocolConfig.setName(<span class="string">"dubbo"</span>);</span><br><span class="line">        protocolConfig.setPort(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">return</span> protocolConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="服务提供方引导类"><a href="#服务提供方引导类" class="headerlink" title="服务提供方引导类"></a>服务提供方引导类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.bootstrap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ProviderConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供方引导类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册配置 Bean</span></span><br><span class="line">        context.register(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 启动上下文</span></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 获取 DemoService Bean</span></span><br><span class="line">        DemoService demoService = context.getBean(DemoService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行 sayHello 方法</span></span><br><span class="line">        String message = demoService.sayHello(<span class="string">"World"</span>);</span><br><span class="line">        <span class="comment">// 控制台输出信息</span></span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ProviderBootstrap</code> 启动并执行后，控制输出与预期一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello , World</span><br></pre></td></tr></table></figure>
<p>以上直接结果说明 <code>@DubboComponentScan(&quot;com.alibaba.dubbo.demo.provider&quot;)</code> 扫描后，标注 Dubbo <code>@Service</code> 的 <code>AnnotationDemoService</code> 被注册成 Spring Bean，可从 Spring ApplicationContext 自由获取。</p>
<h5 id="服务消费方（-Reference）"><a href="#服务消费方（-Reference）" class="headerlink" title="服务消费方（@Reference）"></a>服务消费方（<code>@Reference</code>）</h5><h6 id="服务-DemoService"><a href="#服务-DemoService" class="headerlink" title="服务 DemoService"></a>服务 <code>DemoService</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation 驱动 &#123;<span class="doctag">@link</span> DemoService&#125; 消费方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoServiceConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span>(url = <span class="string">"dubbo://127.0.0.1:12345"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHell</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="服务消费方-Annotation-配置"><a href="#服务消费方-Annotation-配置" class="headerlink" title="服务消费方 Annotation 配置"></a>服务消费方 Annotation 配置</h6><p>与服务提供方配置类似，服务消费方也许 Dubbo 相关配置 Bean - <code>ConsumerConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.consumer.AnnotationDemoServiceConsumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务消费方配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前应用配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-annotation-consumer"</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setAddress(<span class="string">"N/A"</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 AnnotationDemoServiceConsumer，<span class="doctag">@DubboComponentScan</span> 将处理其中 <span class="doctag">@Reference</span> 字段。</span></span><br><span class="line"><span class="comment">     * 如果 AnnotationDemoServiceConsumer 非 Spring Bean 的话，</span></span><br><span class="line"><span class="comment">     * 即使 <span class="doctag">@DubboComponentScan</span> 指定 package 也不会进行处理，与 Spring <span class="doctag">@Autowired</span> 同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnotationDemoServiceConsumer <span class="title">annotationDemoServiceConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationDemoServiceConsumer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="服务消费方引导类"><a href="#服务消费方引导类" class="headerlink" title="服务消费方引导类"></a>服务消费方引导类</h6><p>服务消费方需要先引导服务提供方，下面的实例将会启动两个 Spring 应用上下文，首先引导服务提供方 Spring 应用上下文，同时，需要复用前面 Annotation 配置 <code>ProviderConfiguration</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动服务提供方上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startProviderContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Annotation 配置上下文</span></span><br><span class="line">    AnnotationConfigApplicationContext providerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    <span class="comment">// 注册配置 Bean</span></span><br><span class="line">    providerContext.register(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 启动服务提供方上下文</span></span><br><span class="line">    providerContext.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后引导服务消费方 Spring 应用上下文：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动并且返回服务消费方上下文</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> AnnotationConfigApplicationContext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext <span class="title">startConsumerContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务消费方 Annotation 配置上下文</span></span><br><span class="line">    AnnotationConfigApplicationContext consumerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    <span class="comment">// 注册服务消费方配置 Bean</span></span><br><span class="line">    consumerContext.register(ConsumerConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 启动服务消费方上下文</span></span><br><span class="line">    consumerContext.refresh();</span><br><span class="line">    <span class="comment">// 返回服务消费方 Annotation 配置上下文</span></span><br><span class="line">    <span class="keyword">return</span> consumerContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的引导类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.bootstrap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ConsumerConfiguration;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ProviderConfiguration;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.consumer.AnnotationDemoServiceConsumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务消费端引导类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动服务提供方上下文</span></span><br><span class="line">        startProviderContext();</span><br><span class="line">        <span class="comment">// 启动并且返回服务消费方上下文</span></span><br><span class="line">        ApplicationContext consumerContext = startConsumerContext();</span><br><span class="line">        <span class="comment">// 获取 AnnotationDemoServiceConsumer Bean</span></span><br><span class="line">        AnnotationDemoServiceConsumer consumer = consumerContext.getBean(AnnotationDemoServiceConsumer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行 doSayHello 方法</span></span><br><span class="line">        String message = consumer.doSayHello(<span class="string">"World"</span>);</span><br><span class="line">        <span class="comment">// 输出执行结果</span></span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动并且返回服务消费方上下文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AnnotationConfigApplicationContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext <span class="title">startConsumerContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务消费方 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext consumerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册服务消费方配置 Bean</span></span><br><span class="line">        consumerContext.register(ConsumerConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 启动服务消费方上下文</span></span><br><span class="line">        consumerContext.refresh();</span><br><span class="line">        <span class="comment">// 返回服务消费方 Annotation 配置上下文</span></span><br><span class="line">        <span class="keyword">return</span> consumerContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务提供方上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startProviderContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext providerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册配置 Bean</span></span><br><span class="line">        providerContext.register(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 启动服务提供方上下文</span></span><br><span class="line">        providerContext.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>ConsumerBootstrap</code>结果，仍然符合期望，<code>AnnotationDemoServiceConsumer</code> 输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello , World</span><br></pre></td></tr></table></figure>
<h4 id="Spring-AOP-支持"><a href="#Spring-AOP-支持" class="headerlink" title="Spring AOP 支持"></a>Spring AOP 支持</h4><p>前面提到 <code>&lt;dubbo:annotation&gt;</code> 注册 Dubbo <code>@Service</code> 组件后，在 Spring AOP 支持方面存在问题。事务作为 Spring AOP 的功能扩展，自然也会在 <code>&lt;dubbo:annotation&gt;</code>中不支持。</p>
<p><code>@DubboComponentScan</code> 针对以上问题，实现了对 Spring AOP 是完全兼容。将上述服务提供方 Annotation 配置做出一定的调整，标注<code>@EnableTransactionManagement</code> 以及自定义实现<code>PlatformTransactionManager</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span>(<span class="string">"com.alibaba.dubbo.demo.provider"</span>) <span class="comment">// 扫描 Dubbo 组件</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 激活事务管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略其他配置 Bean 定义</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义事务管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PlatformTransactionManager() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"get transaction ..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SimpleTransactionStatus();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"commit transaction ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"rollback transaction ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时调整 <code>AnnotationDemoService</code> - 增加<code>@Transactional</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略实现，保持不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行<code>ConsumerBootstrap</code> , 观察控制台输出内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get transaction ...</span><br><span class="line">commit transaction ...</span><br><span class="line">Hello , World</span><br></pre></td></tr></table></figure>
<p>输入内容中多处了两行，说明自定义 <code>PlatformTransactionManager</code> <code>getTransaction(TransactionDefinition)</code> 以及 <code>commit(TransactionStatus)</code> 方法被执行，进而说明 <code>AnnotationDemoService</code> 的<code>sayHello(String)</code> 方法执行时，事务也伴随执行。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><code>ConsumerConfiguration</code> 上的 <code>@DubboComponentScan</code> 并没有指定 <code>basePackages</code> 扫描，这种情况会将<code>ConsumerConfiguration</code> 当做 <code>basePackageClasses</code> ，即扫描<code>ConsumerConfiguration</code> 所属的 package <code>com.alibaba.dubbo.demo.config</code> 以及子 package。由于当前示例中，不存在标注 Dubbo <code>@Service</code>的类，因此在运行时日志（如果开启的话）会输出警告信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARN :  [DUBBO] No Spring Bean annotating Dubbo&apos;s @Service was found in Spring BeanFactory, dubbo version: 2.0.0, current host: 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>以上信息大可不必担忧，因为 <code>@DubboComponentScan</code> 除了扫描 Dubbo <code>@Service</code> 组件以外，还将处理 <code>@Reference</code>字段注入。然而读者特别关注<code>@Reference</code>字段注入的规则。</p>
<p>以上实现为例，<code>AnnotationDemoServiceConsumer</code> 必须申明为 Spring <code>@Bean</code> 或者 <code>@Component</code>（或者其派生注解），否则 <code>@DubboComponentScan</code> 不会主动将标注 <code>@Reference</code>字段所在的声明类提成为 Spring Bean，换句话说，如果 <code>@Reference</code>字段所在的声明类不是 Spring Bean 的话， <code>@DubboComponentScan</code> 不会处理<code>@Reference</code>注入，其原理与 Spring <code>@Autowired</code> 一致。</p>
<p>以上使用不当可能会导致相关问题，如 GitHub 上曾有小伙伴提问：<a href="https://github.com/alibaba/dubbo/issues/825" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/825</a></p>
<blockquote>
<p><strong>li362692680</strong> 提问：</p>
<blockquote>
<p>@DubboComponentScan 注解在消费端扫描包时扫描的是 @Service 注解？？不是@Reference 注解？？<br>启动时报<br>DubboComponentScanRegistrar-85]-[main]-[INFO] 0 annotated @Service Components { [] }</p>
</blockquote>
<p>笔者(<strong>mercyblitz</strong>)回复：</p>
<blockquote>
<p><code>@Reference</code> 类似于 <code>@Autowired</code> 一样，首先其申明的类必须被 Spring 上下文当做一个 Bean，因此，Dubbo 并没有直接将 <code>@Reference</code> 字段所在的类提升成 Bean。</p>
<p>综上所述，这并不是一个问题，而是用法不当！</p>
</blockquote>
</blockquote>
<h4 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h4><p>最新发布的 Dubbo <code>2.5.8</code> 中，<code>@DubboComponentScan</code> 在以下特殊场景下存在 Spring <code>@Service</code> 不兼容情况：</p>
<blockquote>
<p>假设有两个服务实现类 <code>A</code> 和 <code>B</code>，同时存放在<code>com.acme</code> 包下：</p>
<ul>
<li><code>A</code> 标注 Dubbo <code>@Service</code></li>
<li><code>B</code> 标注 Dubbo <code>@Service</code> 和 Spring <code>@Service</code></li>
</ul>
<p>当 Spring <code>@ComponentScan</code> 先扫描<code>com.acme</code> 包时，<code>B</code> 被当做 Spring Bean 的候选类。随后，<code>@DubboComponentScan</code> 也扫描相同的包。当应用启动时，<code>A</code> 和 <code>B</code> 虽然都是 Spring Bean，可仅 <code>A</code> 能够暴露 Dubbo 服务，<code>B</code> 则丢失。</p>
</blockquote>
<p>问题版本：<code>2.5.7</code>、<code>2.5.8</code></p>
<p>问题详情：<a href="https://github.com/alibaba/dubbo/issues/1120" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/1120</a></p>
<p>修复版本：<code>2.5.9</code>（下个版本）</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Java</category>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Java</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础-日期和时间</title>
    <url>/2017/11/22/2017-11-22_Programing-Python-Basic-date-time-intro/</url>
    <content><![CDATA[<hr>
<p>Python程序可以通过多种方式来处理日期和时间。<br>日期格式之间的转换是计算机的一个共同核心。Python的时间和日历模块能够帮助我们跟踪的日期和时间。</p>
<h2 id="什么是刻度？"><a href="#什么是刻度？" class="headerlink" title="什么是刻度？"></a>什么是刻度？</h2><p>时间间隔以秒为单位的浮点数。特别是在时间瞬间在自1970年1月1日(纪元)12点的表示。</p>
<p>在Python提供一个流行时间 time 模块，提供时间的的 函数功能，并可转换表示。函数 <code>time.time()</code>返回当前系统时间，从1970年1月1日12点起来的秒数。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time;  <span class="comment"># This is required to include time module.</span></span><br><span class="line"></span><br><span class="line">ticks = time.time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Number of ticks since 12:00am, January 1, 1970:"</span>, ticks)</span><br></pre></td></tr></table></figure>
<p>将产生一个结果，如下 -<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Number of ticks since <span class="number">12</span>:<span class="number">00</span>am, January <span class="number">1</span>, <span class="number">1970</span>: <span class="number">1568018748.2947338</span></span><br></pre></td></tr></table></figure></p>
<p>日期计算使用刻度线是很容易做到的。<br>然而，新纪元日期之前不能以这种形式表示。在未来的一个日期也不能表示这种方式, 分界点是在某个时候，在 UNIX和Windows上为 2038年。</p>
<a id="more"></a>
<h2 id="什么是TimeTuple？"><a href="#什么是TimeTuple？" class="headerlink" title="什么是TimeTuple？"></a>什么是TimeTuple？</h2><p>Python时间的函数处理时间9个数字的元组，如下图所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>字段</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4-digit year</td>
<td>2019</td>
</tr>
<tr>
<td>1</td>
<td>Month</td>
<td>1 to 12</td>
</tr>
<tr>
<td>2</td>
<td>Day</td>
<td>1 to 31</td>
</tr>
<tr>
<td>3</td>
<td>Hour</td>
<td>0 to 23</td>
</tr>
<tr>
<td>4</td>
<td>Minute</td>
<td>0 to 59</td>
</tr>
<tr>
<td>5</td>
<td>Second</td>
<td>0 to 61 (60 or 61 are leap-seconds)</td>
</tr>
<tr>
<td>6</td>
<td>Day of Week</td>
<td>0 to 6 (0 is Monday)</td>
</tr>
<tr>
<td>7</td>
<td>Day of year</td>
<td>1 to 366 (Julian day)</td>
</tr>
<tr>
<td>8</td>
<td>Daylight savings</td>
<td>-1, 0, 1, -1 means library determines DST</td>
</tr>
</tbody>
</table>
</div>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (time.localtime())</span><br></pre></td></tr></table></figure>
<p>这将产生一个结果如下 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.struct_time(tm_year=<span class="number">2019</span>, tm_mon=<span class="number">9</span>, tm_mday=<span class="number">9</span>, tm_hour=<span class="number">10</span>, tm_min=<span class="number">51</span>, tm_sec=<span class="number">9</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">252</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>上述元组相当于struct_time结构。这种结构具有以下属性 -</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>属性</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>tm_year</td>
<td>2019</td>
</tr>
<tr>
<td>1</td>
<td>tm_mon</td>
<td>1 to 12</td>
</tr>
<tr>
<td>2</td>
<td>tm_mday</td>
<td>1 to 31</td>
</tr>
<tr>
<td>3</td>
<td>tm_hour</td>
<td>1 to 23</td>
</tr>
<tr>
<td>4</td>
<td>tm_min</td>
<td>1 to 59</td>
</tr>
<tr>
<td>5</td>
<td>tm_sec</td>
<td>0 to 61 (60 or 61 are leap-seconds)</td>
</tr>
<tr>
<td>6</td>
<td>tm_wday</td>
<td>0 to 6 (0 is Monday)</td>
</tr>
<tr>
<td>7</td>
<td>tm_yday</td>
<td>1 to 366 (Julian day)</td>
</tr>
<tr>
<td>8</td>
<td>tm_isdst</td>
<td>-1, 0, 1, -1 means library determines DST</td>
</tr>
</tbody>
</table>
</div>
<h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><p>划时代浮点值从秒时刻转换生成为时间元组，浮点值传递给一个函数返回时间的元组并带上所有九个项目无效(例如，本地时间)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">localtime = time.localtime(time.time())</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Local current time :"</span>, localtime)</span><br></pre></td></tr></table></figure>
<p>这将产生以下结果，这可能会在任何其他像样形式被格式化.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Local current time : time.struct_time(tm_year=<span class="number">2019</span>, tm_mon=<span class="number">9</span>, tm_mday=<span class="number">9</span>, tm_hour=<span class="number">16</span>, tm_min=<span class="number">51</span>, tm_sec=<span class="number">9</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">252</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="获取格式化时间"><a href="#获取格式化时间" class="headerlink" title="获取格式化时间"></a>获取格式化时间</h2><p>可以在格式化任何时候按您的要求，但用来获得时间可读格式的简单方法是asctime() -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">localtime = time.asctime( time.localtime(time.time()) )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Local current time :"</span>, localtime)</span><br></pre></td></tr></table></figure>
<p>这将产生以下结果<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Local current time : Mon Sep  <span class="number">9</span> <span class="number">16</span>:<span class="number">57</span>:<span class="number">48</span> <span class="number">2019</span></span><br></pre></td></tr></table></figure></p>
<h2 id="获取一个月份的日历"><a href="#获取一个月份的日历" class="headerlink" title="获取一个月份的日历"></a>获取一个月份的日历</h2><p>日历模块提供各种各样年度和月度的日历方法。在这里，我们将打印给定月份(2008年1月)的日历 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"></span><br><span class="line">cal = calendar.month(<span class="number">2019</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Here is the calendar:"</span>)</span><br><span class="line"><span class="keyword">print</span> (cal)</span><br></pre></td></tr></table></figure>
<p>这将产生以下结果 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Here <span class="keyword">is</span> the calendar:</span><br><span class="line">   February <span class="number">2019</span></span><br><span class="line">Mo Tu We Th Fr Sa Su</span><br><span class="line">             <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span></span><br><span class="line"><span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span></span><br></pre></td></tr></table></figure>
<h3 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h3><p>Python提供一个流行时间模块，为时间和表示之间转换提供了相应函数。<br>这里是所有可用方法的列表<br>|序号|函数|描述|<br>|—-|—-|—-|<br>|1|time.altzone |如果定义则在当地的DST时区偏移，在UTC西部秒数。这是负值，如果当地的MST时区是UTC以东 (在西欧，包括英国).只使用这个，如果白天不为零。|<br>|2|time.asctime([tupletime]) |接受时间元组，并返回一个可读24个字符的字符串，如 ‘Tue Dec 11 18:07:14 2008’.|<br>|3|time.clock( ) |返回当前CPU时间为几秒钟的浮点数。要测量计算成本的不同的方法，time.clock()的值比time.time更有用。|<br>|4|time.ctime([secs])|类似 asctime(localtime(secs))和不带参数的 ctime()函数|<br>|5|time.gmtime([secs]) |接受从新纪元用秒表示瞬间和返回用UTC表示时间元组t。注: t.tm_isdst 总是为 0|<br>|6|time.localtime([secs]) |接受从新纪元用秒表示瞬间和返回本地时间的时间元组t(t.tm_isdst 为 0 或 1, 根据DST是否通过局部规则适用于时刻秒)|<br>|7|time.mktime(tupletime) |接受表示为本地时间的时间元组并返回从新纪元以秒表示瞬间的一个浮点值|<br>|8|time.sleep(secs) |线程暂停secs秒调用|<br>|9|time.strftime(fmt[,tupletime]) |接受表示为本地时间的时间元组瞬间，并返回表示由字符串指定 fmt 瞬间的字符串 |<br>|10|time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’) |解析 str 按照格式字符串格式化并返回时间元组格式的时间|<br>|11|time.time( ) |返回当前时刻，从新纪元以来的秒的浮点数|<br>|12|time.tzset() |通过重置库例程使用时间转换规则。 环境变量TZ指定如何做到这一点 |下列是时间模块提供两个重要属性：</p>
<p>下列是时间模块提供两个重要属性：<br>|序号|属性及说明|<br>|—-|—-|<br>|1|time.timezone |属性time.timezone是在本地时区以UTC的秒偏移量(不包括DST) |<br>|2|time.tzname |属性time.tzname是一对区域设置相关的字符串|</p>
<h2 id="calendar-日历模块"><a href="#calendar-日历模块" class="headerlink" title="calendar 日历模块"></a>calendar 日历模块</h2><p>calendar 模块提供日历相关的功能，包括函数用来打印给定月份或年份文本日历。默认情况下，日历采用星期一作为一周的第一天，周日是最后一个。如要改变这种情况，调用calendar.setfirstweekday()函数。这里是 calendar 模块可用的函数列表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>calendar.calendar(year,w=2,l=1,c=6)</td>
<td>返回一个多行字符串使用格式化成用c空格分隔的三列逐年的日历</td>
</tr>
<tr>
<td>2</td>
<td>calendar.firstweekday( )</td>
<td>返回每周工作日开始的当前设置。默认情况下，当日历被首次导入是0，这意味着星期一</td>
</tr>
<tr>
<td>3</td>
<td>calendar.isleap(year)</td>
<td>如果 year 是闰年返回True;否则为false</td>
</tr>
<tr>
<td>4</td>
<td>calendar.leapdays(y1,y2)</td>
<td>返回跨越润年在范围内(y1,y2)的总数</td>
</tr>
<tr>
<td>5</td>
<td>calendar.month(year,month,w=2,l=1)</td>
<td>返回一个多行字符串以及逐年月月份的日历，每周一行加上两个标题行。</td>
</tr>
<tr>
<td>6</td>
<td>calendar.monthcalendar(year,month)</td>
<td>返回列表的列表整数。</td>
</tr>
<tr>
<td>7</td>
<td>calendar.monthrange(year,month)</td>
<td>返回两个整数。</td>
</tr>
<tr>
<td>8</td>
<td>calendar.prcal(year,w=2,l=1,c=6)</td>
<td>类似打印 calendar.calendar(year,w,l,c).</td>
</tr>
<tr>
<td>9</td>
<td>calendar.prmonth(year,month,w=2,l=1)</td>
<td>类似打印 calendar.month(year,month,w,l).</td>
</tr>
<tr>
<td>10</td>
<td>calendar.setfirstweekday(weekday)</td>
<td>设定每个星期的第一天工作日代码。工作日代码是0(星期一)至6(星期日)</td>
</tr>
<tr>
<td>11</td>
<td>calendar.timegm(tupletime)</td>
<td>time.gmtime反转：接受时间元组形式的时刻，并返回同一时刻作为自新纪元以来秒的浮点数</td>
</tr>
<tr>
<td>12</td>
<td>calendar.weekday(year,month,day)</td>
<td>返回给定日期是星期几代码。 工作日代码是0(星期一)至60(星期日);月数是1(1月)到12(12月)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="其它模块和功能："><a href="#其它模块和功能：" class="headerlink" title="其它模块和功能："></a>其它模块和功能：</h2><p>如果你有兴趣，那么在这里你会发现其他重要的模块和功能的列表，包括在Python日期和时间的使用：</p>
<p>datetime模块<br><a href="https://docs.python.org/3/library/datetime.html#module-datetime" target="_blank" rel="noopener">https://docs.python.org/3/library/datetime.html#module-datetime</a></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础-常用术语对照表</title>
    <url>/2017/11/19/2017-11-19_Programing-Python-Basic-Common-Terms-table/</url>
    <content><![CDATA[<hr>
<p>下面内容主要摘抄自<code>python</code> 官网，<a href="https://docs.python.org/3.7/glossary.html#glossary" target="_blank" rel="noopener">https://docs.python.org/3.7/glossary.html#glossary</a>，部分内容有删减。</p>
<h3 id="2to3"><a href="#2to3" class="headerlink" title="2to3"></a>2to3</h3><p>一个将 <code>Python</code> 2.x 代码转换为 <code>Python</code> 3.x 代码的工具，能够处理大部分通过解析源码并遍历解析树可检测到的不兼容问题。</p>
<p>2to3 包含在标准库中，模块名为 lib2to3；并提供一个独立入口点 Tools/scripts/2to3。参见 2to3 - 自动将 <code>Python</code> 2 代码转为 <code>Python</code> 3 代码。</p>
<p>因为官方将在2020年不再支持 <code>Python</code> 2.x, 在遇到没有<code>Python</code> 2.X 版本 的code 的时候，可以尝试使用这个工具将代码转化成Python 的版本。</p>
<h3 id="abstract-base-class-—-抽象基类"><a href="#abstract-base-class-—-抽象基类" class="headerlink" title="abstract base class — 抽象基类"></a>abstract base class — 抽象基类</h3><p>抽象基类简称 ABC，是对 duck-typing 的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如 hasattr() 显得过于笨拙或有微妙错误（例如使用 魔术方法）。ABC 引入了虚拟子类，这种类并非继承自其他类，但却仍能被 isinstance() 和 issubclass() 所认可；详见 abc 模块文档。<code>Python</code> 自带许多内置的 ABC 用于实现数据结构（在 collections.abc 模块中）、数字（在 numbers 模块中）、流（在 io 模块中）、导入查找器和加载器（在 importlib.abc 模块中）。你可以使用 abc 模块来创建自己的 ABC。</p>
<h3 id="argument-—-参数"><a href="#argument-—-参数" class="headerlink" title="argument — 参数"></a>argument — 参数</h3><p>在调用函数时传给 function （或 method ）的值。参数分为两种：</p>
<ul>
<li>关键字参数: 在函数调用中前面带有标识符（例如 name=）或者作为包含在前面带有 ** 的字典里的值传入。<br>  举例来说，3 和 5 在以下对 complex() 的调用中均属于关键字参数:  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">complex(real=<span class="number">3</span>, imag=<span class="number">5</span>)</span><br><span class="line">complex(**&#123;<span class="string">'real'</span>: <span class="number">3</span>, <span class="string">'imag'</span>: <span class="number">5</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>位置参数: 不属于关键字参数的参数。位置参数可出现于参数列表的开头以及/或者作为前面带有 * 的 iterable 里的元素被传入。<br>  举例来说，3 和 5 在以下调用中均属于位置参数:  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">complex(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">complex(*(<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
参数会被赋值给函数体中对应的局部变量。有关赋值规则参见 调用 一节。根据语法，任何表达式都可用来表示一个参数；最终算出的值会被赋给对应的局部变量。</li>
</ul>
<p>另参见 parameter 术语表条目，常见问题中 参数与形参的区别 以及 PEP 362。</p>
<a id="more"></a>
<h3 id="asynchronous-context-manager-—-异步上下文管理器"><a href="#asynchronous-context-manager-—-异步上下文管理器" class="headerlink" title="asynchronous context manager — 异步上下文管理器"></a>asynchronous context manager — 异步上下文管理器</h3><p>此种对象通过定义 <strong>aenter</strong>() 和 <strong>aexit</strong>() 方法来对 async with 语句中的环境进行控制。由 PEP 492 引入。</p>
<h3 id="asynchronous-generator-—-异步生成器"><a href="#asynchronous-generator-—-异步生成器" class="headerlink" title="asynchronous generator — 异步生成器"></a>asynchronous generator — 异步生成器</h3><p>返回值为 asynchronous generator iterator 的函数。它与使用 async def 定义的协程函数很相似，不同之处在于它包含 yield 表达式以产生一系列可在 async for 循环中使用的值。</p>
<p>此术语通常是指异步生成器函数，但在某些情况下则可能是指 异步生成器迭代器。如果需要清楚表达具体含义，请使用全称以避免歧义。</p>
<p>一个异步生成器函数可能包含 await 表达式或者 async for 以及 async with 语句。</p>
<h3 id="attribute-—-属性"><a href="#attribute-—-属性" class="headerlink" title="attribute — 属性"></a>attribute — 属性</h3><p>关联到一个对象的值，可以使用点号表达式通过其名称来引用。例如，如果一个对象 o 具有一个属性 a，就可以用 o.a 来引用它。</p>
<h3 id="BDFL"><a href="#BDFL" class="headerlink" title="BDFL"></a>BDFL</h3><p>“终身仁慈独裁者”的英文缩写，即 Guido van Rossum，<code>Python</code> 的创造者。</p>
<h3 id="binary-file-—-二进制文件"><a href="#binary-file-—-二进制文件" class="headerlink" title="binary file — 二进制文件"></a>binary file — 二进制文件</h3><p>file object 能够读写 字节类对象。二进制文件的例子包括以二进制模式（’rb’, ‘wb’ or ‘rb+’）打开的文件、sys.stdin.buffer、sys.stdout.buffer 以及 io.BytesIO 和 gzip.GzipFile 的实例。</p>
<p>另请参见 text file 了解能够读写 str 对象的文件对象。</p>
<h3 id="bytes-like-object-—-字节类对象"><a href="#bytes-like-object-—-字节类对象" class="headerlink" title="bytes-like object — 字节类对象"></a>bytes-like object — 字节类对象</h3><p>支持 缓冲协议 并且能导出 C-contiguous 缓冲的对象。这包括所有 bytes、bytearray 和 array.array 对象，以及许多普通 memoryview 对象。字节类对象可在多种二进制数据操作中使用；这些操作包括压缩、保存为二进制文件以及通过套接字发送等。</p>
<p>某些操作需要可变的二进制数据。这种对象在文档中常被称为“可读写字节类对象”。可变缓冲对象的例子包括 bytearray 以及 bytearray 的 memoryview。其他操作要求二进制数据存放于不可变对象 (“只读字节类对象”)；这种对象的例子包括 bytes 以及 bytes 对象的 memoryview。</p>
<h3 id="bytecode-—-字节码"><a href="#bytecode-—-字节码" class="headerlink" title="bytecode — 字节码"></a>bytecode — 字节码</h3><p><code>Python</code> 源代码会被编译为字节码，即 C<code>Python</code> 解释器中表示 <code>Python</code> 程序的内部代码。字节码还会缓存在 .pyc 文件中，这样第二次执行同一文件时速度更快（可以免去将源码重新编译为字节码）。这种 “中间语言” 运行在根据字节码执行相应机器码的 virtual machine 之上。请注意不同 <code>Python</code> 虚拟机上的字节码不一定通用，也不一定能在不同 <code>Python</code> 版本上兼容。</p>
<h3 id="class-—-类"><a href="#class-—-类" class="headerlink" title="class — 类"></a>class — 类</h3><p>用来创建用户定义对象的模板。类定义通常包含对该类的实例进行操作的方法定义。</p>
<h3 id="class-variable-—-类变量"><a href="#class-variable-—-类变量" class="headerlink" title="class variable — 类变量"></a>class variable — 类变量</h3><p>在类中定义的变量，并且仅限在类的层级上修改 (而不是在类的实例中修改)。</p>
<h3 id="coercion-—-强制类型转换"><a href="#coercion-—-强制类型转换" class="headerlink" title="coercion — 强制类型转换"></a>coercion — 强制类型转换</h3><p>在包含两个相同类型参数的操作中，一种类型的实例隐式地转换为另一种类型。例如，int(3.15) 是将原浮点数转换为整型数 3，但在 3+4.5 中，参数的类型不一致（一个是 int, 一个是 float），两者必须转换为相同类型才能相加，否则将引发 TypeError。如果没有强制类型转换机制，程序员必须将所有可兼容参数归一化为相同类型，例如要写成 float(3)+4.5 而不是 3+4.5。</p>
<p>coroutine — 协程<br>协程是子例程的更一般形式。子例程可以在某一点进入并在另一点退出。协程则可以在许多不同的点上进入、退出和恢复。它们可通过 async def 语句来实现。参见 PEP 492。</p>
<p>coroutine function — 协程函数<br>返回一个 coroutine 对象的函数。协程函数可通过 async def 语句来定义，并可能包含 await、async for 和 async with 关键字。这些特性是由 PEP 492 引入的。</p>
<h3 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h3><p><code>Python</code> 编程语言的规范实现，在 <code>python</code>.org 上发布。<code>CPython</code> 一词用于在必要时将此实现与其他实现例如 <code>Jython</code> 或 <code>IronPython</code> 相区别。</p>
<h3 id="decorator-—-装饰器"><a href="#decorator-—-装饰器" class="headerlink" title="decorator — 装饰器"></a>decorator — 装饰器</h3><p>返回值为另一个函数的函数，通常使用 @wrapper 语法形式来进行函数变换。 装饰器的常见例子包括 classmethod() 和 staticmethod()。</p>
<p>装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(...)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">f = staticmethod(f)</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(...)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>同的样概念也适用于类，但通常较少这样使用。有关装饰器的详情可参见 函数定义 和 类定义 的文档。</p>
<h3 id="dictionary-—-字典"><a href="#dictionary-—-字典" class="headerlink" title="dictionary — 字典"></a>dictionary — 字典</h3><p>一个关联数组，其中的任意键都映射到相应的值。键可以是任何具有 <strong>hash</strong>() 和 <strong>eq</strong>() 方法的对象。在 Perl 语言中称为 hash。</p>
<h3 id="EAFP"><a href="#EAFP" class="headerlink" title="EAFP"></a>EAFP</h3><p>“求原谅比求许可更容易”的英文缩写。这种 <code>Python</code> 常用代码编写风格会假定所需的键或属性存在，并在假定错误时捕获异常。这种简洁快速风格的特点就是大量运用 try 和 except 语句。于其相对的则是所谓 LBYL 风格，常见于 C 等许多其他语言。</p>
<h3 id="expression-—-表达式"><a href="#expression-—-表达式" class="headerlink" title="expression — 表达式"></a>expression — 表达式</h3><p>可以求出某个值的语法单元。 换句话说，一个表达式就是表达元素例如字面值、名称、属性访问、运算符或函数调用的汇总，它们最终都会返回一个值。 与许多其他语言不同，并非所有语言构件都是表达式。 还存在不能被用作表达式的 statement，例如 while。 赋值也是属于语句而非表达式。</p>
<p>extension module — 扩展模块<br>以 C 或 C++ 编写的模块，使用 <code>Python</code> 的 C API 来与语言核心以及用户代码进行交互。</p>
<h3 id="file-object-—-文件对象"><a href="#file-object-—-文件对象" class="headerlink" title="file object — 文件对象"></a>file object — 文件对象</h3><p>对外提供面向文件 API 以使用下层资源的对象（带有 read() 或 write() 这样的方法）。<br>根据其创建方式的不同，文件对象可以处理对真实磁盘文件，对其他类型存储，或是对通讯设备的访问（例如标准输入/输出、内存缓冲区、套接字、管道等等）。<br>文件对象也被称为 <code>文件类对象</code> 或 <code>流</code>。</p>
<p>实际上共有三种类别的文件对象: <code>原始二进制文件</code>, <code>缓冲二进制文件</code> 以及 <code>文本文件</code>。它们的接口定义均在 io 模块中。<br>创建文件对象的规范方式是使用 open() 函数。</p>
<h3 id="floor-division-—-向下取整除法"><a href="#floor-division-—-向下取整除法" class="headerlink" title="floor division — 向下取整除法"></a>floor division — 向下取整除法</h3><p>向下舍入到最接近的整数的数学除法。向下取整除法的运算符是 // 。例如，表达式 11 // 4 的计算结果是 2 ，而与之相反的是浮点数的真正除法返回 2.75 。注意 (-11) // 4 会返回 -3 因为这是 -2.75 向下 舍入得到的结果。见 PEP 238 。</p>
<h3 id="function-—-函数"><a href="#function-—-函数" class="headerlink" title="function — 函数"></a>function — 函数</h3><p>可以向调用者返回某个值的一组语句。还可以向其传入零个或多个 参数 并在函数体执行中被使用。另见 parameter, method 和 函数定义 等节。</p>
<h3 id="future"><a href="#future" class="headerlink" title="future"></a><strong>future</strong></h3><p>一种伪模块，可被程序员用来启用与当前解释器不兼容的新语言特性。</p>
<p>通过导入 <strong>future</strong> 模块并对其中的变量求值，你可以查看新特性何时首次加入语言以及何时成为默认:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> __future__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__future__.division</span><br><span class="line">_Feature((<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="string">'alpha'</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'alpha'</span>, <span class="number">0</span>), <span class="number">8192</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="garbage-collection-—-垃圾回收"><a href="#garbage-collection-—-垃圾回收" class="headerlink" title="garbage collection — 垃圾回收"></a>garbage collection — 垃圾回收</h3><p>释放不再被使用的内存空间的过程。<br><code>Python</code> 是通过引用计数和一个能够检测和打破循环引用的循环垃圾回收器来执行垃圾回收的。<br>可以使用 gc 模块来控制垃圾回收器。</p>
<h3 id="global-interpreter-lock-—-全局解释器锁"><a href="#global-interpreter-lock-—-全局解释器锁" class="headerlink" title="global interpreter lock — 全局解释器锁"></a>global interpreter lock — 全局解释器锁</h3><p>C<code>Python</code> 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 <code>Python</code> bytecode。此机制通过设置对象模型（包括 dict 等重要内置类型）针对并发访问的隐式安全简化了 C<code>Python</code> 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性。</p>
<p>不过，某些标准库或第三方库的扩展模块被设计为在执行计算密集型任务如压缩或哈希时释放 GIL。此外，在执行 I/O 操作时也总是会释放 GIL。</p>
<p>创建一个（以更精细粒度来锁定共享数据的）“自由线程”解释器的努力从未获得成功，因为这会牺牲在普通单处理器情况下的性能。据信克服这种性能问题的措施将导致实现变得更复杂，从而更难以维护。</p>
<h3 id="IDLE"><a href="#IDLE" class="headerlink" title="IDLE"></a>IDLE</h3><p><code>Python</code> 的 IDE，“集成开发与学习环境”的英文缩写。是 <code>Python</code> 标准发行版附带的基本编程器和解释器环境。</p>
<h3 id="import-path-—-导入路径"><a href="#import-path-—-导入路径" class="headerlink" title="import path — 导入路径"></a>import path — 导入路径</h3><p>由多个位置（或 路径条目）组成的列表，会被模块的 path based finder 用来查找导入目标。在导入时，此位置列表通常来自 sys.path，但对次级包来说也可能来自上级包的 <strong>path</strong> 属性。</p>
<h3 id="iterable-—-可迭代对象"><a href="#iterable-—-可迭代对象" class="headerlink" title="iterable — 可迭代对象"></a>iterable — 可迭代对象</h3><p>能够逐一返回其成员项的对象。可迭代对象的例子包括所有序列类型（例如 list、str 和 tuple）以及某些非序列类型例如 dict、文件对象 以及定义了 <strong>iter</strong>() 方法或是实现了 Sequence 语义的 <strong>getitem</strong>() 方法的任意自定义类对象。</p>
<p>可迭代对象被可用于 for 循环以及许多其他需要一个序列的地方（zip()、map() …）。当一个可迭代对象作为参数传给内置函数 iter() 时，它会返回该对象的迭代器。这种迭代器适用于对值集合的一次性遍历。在使用可迭代对象时，你通常不需要调用 iter() 或者自己处理迭代器对象。for 语句会为你自动处理那些操作，创建一个临时的未命名变量用来在循环期间保存迭代器。参见 iterator、sequence 以及 generator。</p>
<h3 id="iterator-—-迭代器"><a href="#iterator-—-迭代器" class="headerlink" title="iterator — 迭代器"></a>iterator — 迭代器</h3><p>用来表示一连串数据流的对象。重复调用迭代器的 <strong>next</strong>() 方法（或将其传给内置函数 next()）将逐个返回流中的项。当没有数据可用时则将引发 StopIteration 异常。到这时迭代器对象中的数据项已耗尽，继续调用其 <strong>next</strong>() 方法只会再次引发 StopIteration 异常。迭代器必须具有 <strong>iter</strong>() 方法用来返回该迭代器对象自身，因此迭代器必定也是可迭代对象，可被用于其他可迭代对象适用的大部分场合。一个显著的例外是那些会多次重复访问迭代项的代码。容器对象（例如 list）在你每次向其传入 iter() 函数或是在 for 循环中使用它时都会产生一个新的迭代器。如果在此情况下你尝试用迭代器则会返回在之前迭代过程中被耗尽的同一迭代器对象，使其看起来就像是一个空容器。</p>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>由一个单独 expression 构成的匿名内联函数，表达式会在调用时被求值。<br>创建 lambda 函数的句法为 <code>lambda [parameters]: expression</code>。</p>
<h3 id="list-—-列表"><a href="#list-—-列表" class="headerlink" title="list — 列表"></a>list — 列表</h3><p><code>Python</code> 内置的一种 sequence。虽然名为列表，但更类似于其他语言中的数组而非链接列表，因为访问元素的时间复杂度为 O(1)。</p>
<h3 id="mapping-—-映射"><a href="#mapping-—-映射" class="headerlink" title="mapping — 映射"></a>mapping — 映射</h3><p>一种支持任意键查找并实现了 Mapping 或 MutableMapping 抽象基类 中所规定方法的容器对象。<br>此类对象的例子包括 <code>dict</code>, c<code>ollections.defaultdict</code>, <code>collections.OrderedDict</code> 以及 <code>collections.Counter</code>。</p>
<h3 id="metaclass-—-元类"><a href="#metaclass-—-元类" class="headerlink" title="metaclass — 元类"></a>metaclass — 元类</h3><p>一种用于创建类的类。类定义包含类名、类字典和基类列表。元类负责接受上述三个参数并创建相应的类。大部分面向对象的编程语言都会提供一个默认实现。<code>Python</code> 的特别之处在于可以创建自定义元类。大部分用户永远不需要这个工具，但当需要出现时，元类可提供强大而优雅的解决方案。它们已被用于记录属性访问日志、添加线程安全性、跟踪对象创建、实现单例，以及其他许多任务。</p>
<h3 id="method-—-方法"><a href="#method-—-方法" class="headerlink" title="method — 方法"></a>method — 方法</h3><p>在类内部定义的函数。如果作为该类的实例的一个属性来调用，方法将会获取实例对象作为其第一个 argument (通常命名为 self)。参见 <code>function</code> 。</p>
<h3 id="module-—-模块"><a href="#module-—-模块" class="headerlink" title="module — 模块"></a>module — 模块</h3><p>此对象是 <code>Python</code> 代码的一种组织单位。各模块具有独立的<code>命名空间</code>，可包含任意 <code>Python</code> 对象。模块可通过 importing 操作被加载到 <code>Python</code> 中。</p>
<p>另见 package。</p>
<h3 id="namespace-—-命名空间"><a href="#namespace-—-命名空间" class="headerlink" title="namespace — 命名空间"></a>namespace — 命名空间</h3><p>命名空间是存放变量的场所。命名空间有局部、全局和内置的，还有对象中的嵌套命名空间（在方法之内）。<br>命名空间通过防止命名冲突来支持模块化。例如，函数 <code>builtins.open</code> 与 <code>os.open()</code> 可通过各自的命名空间来区分。命名空间还通过明确哪个模块实现那个函数来帮助提高可读性和可维护性。<br>例如，<code>`random.seed() 或</code>itertools.islice()` 这种写法明确了这些函数是由 random 与 itertools 模块分别实现的。</p>
<h3 id="namespace-package-—-命名空间包"><a href="#namespace-package-—-命名空间包" class="headerlink" title="namespace package — 命名空间包"></a>namespace package — 命名空间包</h3><p>PEP 420 所引入的一种仅被用作子包的容器的 package，命名空间包可以没有实体表示物，其描述方式与 regular package 不同，因为它们没有 <code>__init__.py</code> 文件。</p>
<p>另可参见 module。</p>
<h3 id="object-—-对象"><a href="#object-—-对象" class="headerlink" title="object — 对象"></a>object — 对象</h3><p>任何具有状态（属性或值）以及预定义行为（方法）的数据。object 也是任何 new-style class 的最顶层基类名。</p>
<h3 id="package-—-包"><a href="#package-—-包" class="headerlink" title="package — 包"></a>package — 包</h3><p>一种可包含子模块或递归地包含子包的 <code>Python</code> module。从技术上说，包是带有 <strong>path</strong> 属性的 <code>Python</code> 模块。</p>
<p>另参见 regular package 和 namespace package。</p>
<h3 id="parameter-—-形参"><a href="#parameter-—-形参" class="headerlink" title="parameter — 形参"></a>parameter — 形参</h3><p>function （或方法）定义中的命名实体，它指定函数可以接受的一个 argument （或在某些情况下，多个实参）。有五种形参：</p>
<ul>
<li>positional-or-keyword：位置或关键字，指定一个可以作为 位置参数 传入也可以作为 关键字参数 传入的实参。<br>  这是默认的形参类型，例如下面的 foo 和 bar:  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(foo, bar=None)</span>:</span> ...</span><br></pre></td></tr></table></figure></li>
<li><p>positional-only：仅限位置，指定一个只能按位置传入的参数。<code>Python</code> 中没有定义仅限位置形参的语法。但是一些内置函数有仅限位置形参（比如 <code>abs()</code>）。</p>
</li>
<li><p>keyword-only：仅限关键字，指定一个只能通过关键字传入的参数。<br>仅限关键字形参可通过在函数定义的形参列表中包含单个可变位置形参或者在多个可变位置形参之前放一个 * 来定义，例如下面的 kw_only1 和 kw_only2:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg, *, kw_only1, kw_only2)</span>:</span> ...</span><br></pre></td></tr></table></figure></li>
<li>var-positional：可变位置，指定可以提供由一个任意数量的位置参数构成的序列（附加在其他形参已接受的位置参数之后）。这种形参可通过在形参名称前加缀 * 来定义。<br>例如下面的 args:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span> ...</span><br></pre></td></tr></table></figure></li>
<li>var-keyword：可变关键字，指定可以提供任意数量的关键字参数（附加在其他形参已接受的关键字参数之后）。这种形参可通过在形参名称前加缀 ** 来定义，例如上面的 kwargs。</li>
</ul>
<p>形参可以同时指定可选和必选参数，也可以为某些可选参数指定默认值。</p>
<h3 id="path-entry-—-路径入口"><a href="#path-entry-—-路径入口" class="headerlink" title="path entry — 路径入口"></a>path entry — 路径入口</h3><p>import path 中的一个单独位置，会被 path based finder 用来查找要导入的模块。</p>
<h3 id="PEP"><a href="#PEP" class="headerlink" title="PEP"></a>PEP</h3><p>“<code>Python</code> 增强提议”的英文缩写。<br>一个 PEP 就是一份设计文档，用来向 <code>Python</code> 社区提供信息，或描述一个 <code>Python</code> 的新增特性及其进度或环境。PEP 应当提供精确的技术规格和所提议特性的原理说明。</p>
<p>PEP 应被作为提出主要新特性建议、收集社区对特定问题反馈以及为必须加入 <code>Python</code> 的设计决策编写文档的首选机制。PEP 的作者有责任在社区内部建立共识，并应将不同意见也记入文档。</p>
<p>参见 PEP 1。</p>
<h3 id="sequence-—-序列"><a href="#sequence-—-序列" class="headerlink" title="sequence — 序列"></a>sequence — 序列</h3><p>一种 iterable，它支持通过 <strong>getitem</strong>() 特殊方法来使用整数索引进行高效的元素访问，并定义了一个返回序列长度的 <strong>len</strong>() 方法。<br>内置的序列类型有 list、str、tuple 和 bytes。注意虽然 dict 也支持   <code>__getitem__()</code> 和 <code>__len__()</code>，但它被认为属于映射而非序列，因为它查找时使用任意的 immutable 键而非整数。</p>
<p>collections.abc.Sequence 抽象基类定义了一个更丰富的接口，它超越了<code>__getitem__()</code> 和<code>__len__()</code>，添加了 <code>count()</code>, <code>index()</code>, <code>__contains__()</code> 和 <code>__reversed__()</code> 。 可以使用 <code>register()</code> 显式注册实现此扩展接口的类型。</p>
<h3 id="slice-—-切片"><a href="#slice-—-切片" class="headerlink" title="slice — 切片"></a>slice — 切片</h3><p>通常只包含了特定 sequence 的一部分的对象。<br>切片是通过使用下标标记来创建的，在 [] 中给出几个以冒号分隔的数字，例如 variable_name[1:3:5]。方括号（下标）标记在内部使用 slice 对象。</p>
<h3 id="statement-—-语句"><a href="#statement-—-语句" class="headerlink" title="statement — 语句"></a>statement — 语句</h3><p>语句是程序段（一个代码“块”）的组成单位。<br>一条语句可以是一个 expression 或某个带有关键字的结构，例如 if、while 或 for。</p>
<h3 id="text-encoding-—-文本编码"><a href="#text-encoding-—-文本编码" class="headerlink" title="text encoding — 文本编码"></a>text encoding — 文本编码</h3><p>用于将Unicode字符串编码为字节串的编码器。</p>
<h3 id="type-—-类型"><a href="#type-—-类型" class="headerlink" title="type — 类型"></a>type — 类型</h3><p>类型决定一个 <code>Python</code> 对象属于什么种类；每个对象都具有一种类型。<br>要知道对象的类型，可以访问它的 <code>__class__</code> 属性，或是通过 type(obj) 来获取。</p>
<p>type hint — 类型提示<br>annotation 为变量、类属性、函数的形参或返回值指定预期的类型。</p>
<p>类型提示属于可选项，<code>Python</code> 不要求提供，但其可对静态类型分析工具起作用，并可协助 IDE 实现代码补全与重构。</p>
<p>全局变量、类属性和函数的类型提示可以使用 typing.get_type_hints() 来访问，但局部变量则不可以。</p>
<p>参见 typing 和 PEP 484，其中有对此功能的详细描述。</p>
<h3 id="universal-newlines-—-通用换行"><a href="#universal-newlines-—-通用换行" class="headerlink" title="universal newlines — 通用换行"></a>universal newlines — 通用换行</h3><p>一种解读文本流的方式，将以下所有符号都识别为行结束标志：Unix 的行结束约定 ‘\n’、Windows 的约定 ‘\r\n’ 以及旧版 Macintosh 的约定 ‘\r’。<br>参见 PEP 278 和 PEP 3116 和 bytes.splitlines() 了解更多用法说明。</p>
<h3 id="virtual-machine-—-虚拟机"><a href="#virtual-machine-—-虚拟机" class="headerlink" title="virtual machine — 虚拟机"></a>virtual machine — 虚拟机</h3><p>一台完全通过软件定义的计算机。<br><code>Python</code> 虚拟机可执行字节码编译器所生成的 bytecode。</p>
<h3 id="Zen-of-Python-—-Python-之禅"><a href="#Zen-of-Python-—-Python-之禅" class="headerlink" title="Zen of Python — Python 之禅"></a>Zen of <code>Python</code> — <code>Python</code> 之禅</h3><p>列出 <code>Python</code> 设计的原则与哲学，有助于理解与使用这种语言。<br>定义在PEP 8 中。<br>每个版本的具体内容，可能会有差。查看当前版本的具体内容可在交互模式提示符中输入 “import this”。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>非科班出身，如何成为程序员？</title>
    <url>/2017/11/16/2017-11-16-Programing-becomer-a-coder-from-others/</url>
    <content><![CDATA[<h2 id="非科班出身，如何成为程序员"><a href="#非科班出身，如何成为程序员" class="headerlink" title="非科班出身，如何成为程序员"></a>非科班出身，如何成为程序员</h2><blockquote>
<p>本文是知乎的一篇回答</p>
</blockquote>
<p>身边有很多非科班出身的程序员，比如 sofish、粽神。当然我也是，所以决定结合自身经历强答一波。</p>
<h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><p>我本科学习的是「生物科学」，大学四年无非就是拿着 eppendorf 的实验枪，在超净台旁养着各种知名或不知名的微生物，有广为人知的「海拉细胞」有很多人没有听过的「毕赤酵母」，每逢寒暑假可能还会去山里或者某个海滨城市实习，在鸟巢旁边装一个微型摄像头，记录下喂食雏鸟的频率，去海边抓一些招潮蟹或者海月水母，也算乐在其中。我很享受大学这段时光，因为毕竟是我儿时的梦想，成为一个生物学家。</p>
<p>毕业后，进入了北京水产科学研究所，主要工作是「养鱼」，每天固定时间给「小西伯利亚鲟」喂点吃的，给鱼缸换水。很不幸…，在一次换水的过程中水龙头我忘关了，结果水沿着鱼缸溢了出来，小鲟鱼也在想「外面的世界那么大，我想去看看」，都顺着鱼缸溢出的水推力，游到了鱼缸外面，等我发现时，这些小生命都散落在鱼缸周围，也不跳了。主任没有批评我把一缸鱼都养死了，但是也再让我去喂鱼了，给了我一份新的差事，通过毕赤酵母来表达出促性腺激素，促进鲟鱼快速性成熟。实验做了大概一年，有一些成果，毕竟在一年中成功过一次。后来觉得愧对这份工作，就跟主任请辞了，主任就介绍了上海的一份工作给我，去欧莱雅研发中心做实验。现在想想主任真是难得的人生导师。</p>
<p>在欧莱雅工作了三年，每天也是重复相同的工作，工作内容只是从以前的养各种微生物变成了养「人造皮肤」，然后再把化妆品涂在人造皮肤上，看看化妆品对皮肤的效果，其实和大学拿老鼠、兔子做实验没什么区别，只是欧洲那边不让在活体上做化妆品实验。在欧莱雅的三年，慢慢消磨了我对「生物科学」的热情，重复的工作让我麻痹了我的思想。我决定做一些改变，那是2014年，我已经27了。</p>
<h3 id="学习编程的动机"><a href="#学习编程的动机" class="headerlink" title="学习编程的动机"></a>学习编程的动机</h3><p>还得从 13 年年底说起，在欧莱雅工作期间，命运多舛，出了一次车祸，右胫腓骨粉碎骨折，当时还是女朋友的老婆放弃了东京的工作回国来照顾我，在床上躺了三四个月，老婆回上海后也找了一份广告公司的工作，做 SEM。到了14年，腿伤基本恢复，我重新回到欧莱雅工作，经历了人生变故（车祸），住院期间把这一生中的生离死别都看完了，开始思考起人生，更加热爱生命。</p>
<a id="more"></a>
<p>老婆是做 SEM 工作的，其中很大一部分工作是做 SEO，也就是搜索引擎优化，文科出生的她（日语系）自然对 HTML标记语言、JS代码感到陌生，学习起来也有些吃苦，在区分 CSS 属性 color 和 background 也会疑惑。出于对她回国照顾我的感恩，以及责任。我从图书馆借了一本书「15天掌握HTML\CSS\JS」，开始学习起前端来，那时候我还不知道有前端这个职业，也不是为了转行做前端，仅仅是想自己学会了，然后帮她解决问题。</p>
<p>也许看了这本书，让我对当时欧莱雅的工作有了更深入的思考，在欧莱雅，我每天工作内容相同，做实验、处理实验数据，写 report。实验之余看看 paper。而学习 HTML\CSS\JS 可以创造不同网站，然后分享给世界各地浏览你网站的人。写网站比做实验似乎更能够给我带来成就感和满足感。于是我决定正式学习 web development，成为一个前端工程师，那是2014年八月，我已经27岁了。</p>
<h3 id="非科班出身怎么学习编程"><a href="#非科班出身怎么学习编程" class="headerlink" title="非科班出身怎么学习编程"></a>非科班出身怎么学习编程</h3><p>才发现，写到这儿才进入正题，正式开始学习编程是在2014年九月，我并没有辞掉当时的工作，我是白天工作，晚上回家学习，周一到周五每天大概学习5~6个小时左右，周末全天学习。我习惯每个月给自己制定一些任务和目标，然后按照自己的目标前进，比如下面是我2014年九月份制定的一些计划：</p>
<blockquote>
<p>九月份：《javascript》高级程序设计 + 慕课网练习（每天保证两小时coding）</p>
<p>十月份：学习 CSS2 和 CSS3，并对 javascript 的学习做个回顾，教材包括《精通CSS》，《javascript DOM编程艺术》，《javascript语言精粹》外加慕课网每天至少两小时coding！</p>
<p>十一月份：学习javascript库，jquery、prototype、html5。主要学习书籍《Javascript模式》、《锋利的jQuery》、《html5程序设计》、photoshop学习。</p>
<p>十二月份：主要任务是设计个人网站，主要书籍《精通javascript》、《编写可维护的Javascript》。</p>
</blockquote>
<p>这儿我并不是向大家推荐学习书籍，以及个人的计划，因为那是 2014 年制定的，可能已经不再适合现在入门学习者了，再者，推荐前端书籍的知乎问题不胜枚举。</p>
<p>周末的时候习惯带个电脑去普陀区图书馆，上海市的图书馆周末也挺多人的，所以不得不很早就去占座，突然又有了回到大学的感觉，关于电脑当时也是下了血本，游说当时还是女朋友的老婆，把他从日本带回来的十几万日元去中国银行换了人民币，然后买了一台 Macbook Pro。</p>
<p>2015年，我决定转行了，做一个前端工程师，那一年工作也忙了，学习的时间少了许多，为了找工作，我用 NodeJs + jQuery 搭建了一个多人博客系统，然后将自己的实现思路和技术栈连同博客地址发到了知乎和 NodeJs 社区，当然也附上了个人简历和邮箱地址，主要想看看以现在的水平，能不能够找到一份前端工作了。</p>
<p>那是15年八月，当时小鱼 sofish，推荐我去饿了么面试（估计是在 Nodejs 社区看到我发的帖子），但是由于知识体系的不健全，面试官可能觉得学习曲线会太陡，最终没有过初试，因为当时我还不知道 Promise，也不懂 Angular，更不会 Loopback。</p>
<p>于是我决定先找一份实习的工作，很幸运一家做 CRM 的公司愿意收留我，开的工资是4.5k，一下回到了刚毕业的水平，但是我很感谢这家公司，它给了我很大的学习空间，因为在这之前，我都是一个人在摸索，自学。甚至不知道真正的前端工程师到底做什么工作，而这家公司给了我机会，给我分配了导师，甚至在入职三个月内不用做任何业务，而是全身心学习。正是这三个月，我构建前自己的前端知识体系，从 JS 基础到 Angular 框架，从 HTML 到 CSS，从 Grunt 到 webpack，从NodeJs 到 Mongodb。在这三个月的学习期间，每天坚持早上九点到公司，晚上十点下班，每天坚持写周报，总结一天的学习，每个月完成一个小项目，三个月期间，自己写了一个所输及所得的 markdown 编辑器，写了一个 CSS selector 的 parser，通过 websocket 做了一个聊天工具。</p>
<p>当然，这三个月我也放弃了很多，因为刚入职，我放弃了和刚结婚老婆去度蜜月，两个人的蜜月，变成了她独自旅游。到现在也感到愧疚，争取明年补上。</p>
<p>三个月后，评级转正，当时的职级是 P5，我感到很欣慰，三个月的努力学习有了回报。和之前边工作边学习的离散学习完全不同，当然全职的效率更高，当然薪资也从4.5k 涨到了12k，说实话，对于刚入门的我，我很满意这薪资了。在这公司我工作了两年，合作和独立完成了几个项目，职级后来也再升了两级。在今年七月，我选择了离开，主要原因还是考虑个人发展，以及对饿了么的眷顾。</p>
<p>对的，我又参加了饿了么的面试，顺利入职饿了么前端工程师，感到很欣慰。好像实现了一个长久的夙愿。</p>
<h3 id="我为什么感到焦虑"><a href="#我为什么感到焦虑" class="headerlink" title="我为什么感到焦虑"></a>我为什么感到焦虑</h3><p>转行后，我无时不感到焦虑，毕竟是一个大龄转行程序员，身边的同事都是九零后甚至九五后，我无时不刻不在想我怎么规划我的职业，怎么做得更好，怎么缩短与科班出身的同事之间的差距。我没有后悔过转行，也没有后悔过那八年生物生涯（大学四年工作四年），毕竟那八年的生物学习，我快乐过，我不完整实现了儿时的梦想。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础-时间控制</title>
    <url>/2017/11/15/2017-11-15_Programing-Python-Basic-flow-control/</url>
    <content><![CDATA[<hr>
<p>这次主要介绍python 的基础流程控制。<br>包括 if 条件语句、for 循环 和 while 循环语句； continue 及 break 的用法等。<br>基本用法与 C 和 Java 差不多，无 switch 语句。</p>
<hr>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>语法：<code>if(...):</code>, 括号内为一表达式，当为<code>True</code>（即成立）时，执行对应的代码段。</p>
<blockquote>
<p>注意:所有条件语句后方都需加冒号 <code>:</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if 语句实例</span></span><br><span class="line"><span class="string">''' 判断用户输入的整数是几位数（暂不考虑用户输入非整数）</span></span><br><span class="line"><span class="string">    为0               输出     It's zero.</span></span><br><span class="line"><span class="string">    个位数             输出     It's a number below 10</span></span><br><span class="line"><span class="string">    两位数             输出     It's a two-digit number</span></span><br><span class="line"><span class="string">    三位数级以上        输出     It's digit is more than two</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">user_input = input(<span class="string">"Please input a number: "</span>)</span><br><span class="line"><span class="comment"># 用户输入的类型为字符串，转换为整数类型</span></span><br><span class="line">n = int(user_input)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span>):</span><br><span class="line">    print(<span class="string">"It's zero."</span>)</span><br><span class="line"><span class="keyword">elif</span> (n&lt;<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">"It's a number below 10"</span>)</span><br><span class="line"><span class="keyword">elif</span> (n&lt;<span class="number">100</span>):</span><br><span class="line">    print(<span class="string">"It's a two-digit number"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"It's digit is more than two"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可能会有零到多个 elif 部分，else 是可选的。</p>
</blockquote>
<p>关键字 “ elif ” 是 “else if ” 的缩写，这个可以有效地避免过深的缩进。<code>if ... elif ... elif ...</code> 序列于替代其它语言中的switch case语句。</p>
<a id="more"></a>
<hr>
<h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><p>Python 中的 <code>for</code> 语句和 C Pascal 中的 有不同。通常的循环可能会由用户来定义迭代步骤和中止条件（如 C ），Python 的 <code>for</code> 语句依据任意序列（链表或字符串）中的子项，按它们在序列中的顺序来进行迭代。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for 语句实例</span></span><br><span class="line">string = <span class="string">"python"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">    <span class="comment"># 字符串处理</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">list = [<span class="string">"l"</span>,<span class="string">"i"</span>,<span class="string">"s"</span>,<span class="string">"t"</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">    <span class="comment"># 列表处理</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># range()函数，range(5) 表示 0 到 4 </span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述示例仅感受下 for 语句的写法。</p>
<hr>
<h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><p><code>while(...)</code> 括号内表达式若为 <code>True</code>，则继续执行代码段；若为<code>False</code>，停止执行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># while语句实例</span></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>需要注意错误代码导致的无限循环，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>):</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="break-、-continue"><a href="#break-、-continue" class="headerlink" title="break 、 continue"></a>break 、 continue</h2><p><code>break</code> 用法和 C 中的类似，直接跳出循环，执行循环后的语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>continue</code> 用法也是从C中借鉴来的，跳出当前循环，并执行下一次循环<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-Basic-dirt_intro</title>
    <url>/2017/11/14/2017-11-14_Programing-Python-Basic-dirt-intro/</url>
    <content><![CDATA[<hr>
<p>每个键是从它的值由冒号(:)，即在项目之间用逗号隔开，整个东西是包含在大括号中。没有任何项目一个空字典只写两个大括号，就像这样：<code>{}</code>.</p>
<p>键在一个字典中是唯一的，而值则可以重复。字典的值可以是任何类型，但键必须是不可变的数据的类型，例如：字符串，数字或元组这样的类型。</p>
<h2 id="访问字典中的值"><a href="#访问字典中的值" class="headerlink" title="访问字典中的值"></a>访问字典中的值</h2><p>要访问字典元素，你可以使用方括号和对应键，以获得其对应的值。下面是一个简单的例子 -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br><span class="line">print(<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br></pre></td></tr></table></figure>
<p>当执行上面的代码，它产生以下结果 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict[<span class="string">'Name'</span>]:  Saul</span><br><span class="line">dict[<span class="string">'Age'</span>]:  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>如果我们试图使用一个键，但这是不字典访问数据项的一部分，我们会得到一个错误如下 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;;</span><br><span class="line">print(<span class="string">"dict['Alice']: "</span>, dict[<span class="string">'Alice'</span>])</span><br></pre></td></tr></table></figure>
<p>当执行上面的代码，它产生以下结果 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict[<span class="string">'Saul'</span>]:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(<span class="string">"dict['Alice']: "</span>, dict[<span class="string">'Alice'</span>])</span><br><span class="line">KeyError: <span class="string">'Alice'</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="更新字典"><a href="#更新字典" class="headerlink" title="更新字典"></a>更新字典</h2><p>可以通过添加新条目或键值对，修改现有条目，或删除现有条目，更新词典的简单例子如下图所示 -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># update existing entry</span></span><br><span class="line">dict[<span class="string">'Age'</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add new entry</span></span><br><span class="line">dict[<span class="string">'School'</span>] = <span class="string">"SPD School"</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dict['School']: "</span>, dict[<span class="string">'School'</span>])</span><br></pre></td></tr></table></figure>
<p>当执行上面的代码，它产生以下结果 -<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict[<span class="string">'Age'</span>]:  <span class="number">8</span></span><br><span class="line">dict[<span class="string">'School'</span>]:  SPD School</span><br></pre></td></tr></table></figure></p>
<h3 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h3><p>可以删除单个字典元素或清除字典的全部内容。也可以在一个单一的操作删除整个词典。</p>
<p>要明确删除整个词典，只要用 del 语句就可以做到。下面是一个简单的例子 -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove entry with key 'Name'</span></span><br><span class="line"><span class="keyword">del</span> dict[<span class="string">'Name'</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all entries in dict</span></span><br><span class="line">dict.clear()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># delete entire dictionary</span></span><br><span class="line"><span class="keyword">del</span> dict         </span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line">print(<span class="string">"dict['School']: "</span>, dict[<span class="string">'School'</span>])</span><br></pre></td></tr></table></figure>
<p>这将产生以下结果。请注意，将引发一个异常，因为执行 del dict 后字典不存在了-<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict[<span class="string">'Age'</span>]:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line">TypeError: <span class="string">'type'</span> object <span class="keyword">is</span> unsubscriptable</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注： del() 方法是在后续部分讨论。</p>
</blockquote>
<h2 id="字典键的属性"><a href="#字典键的属性" class="headerlink" title="字典键的属性"></a>字典键的属性</h2><p>字典的值没有限制。它们可以是任意Python对象，无论是标准的对象或用户定义的对象。但是，键却不能这样使用。</p>
<p>还有要记住字典的键的重要两点 -</p>
<ul>
<li>每个键对应多个条目是不允许的。这意味着重复键是不允许的。当键分配过程中遇到重复，以最后分配的为准。例如 -</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Name'</span>: <span class="string">'Manli'</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br></pre></td></tr></table></figure>
<p>当执行上面的代码，它产生以下结果<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">dict[<span class="string">'Name'</span>]:  Manli</span><br></pre></td></tr></table></figure></p>
<ul>
<li>键必须是不可变的。这意味着可以使用字符串，数字或元组作为字典的键，但是像[‘key’]是不允许的。下面是一个简单的例子：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br></pre></td></tr></table></figure>
<p>当执行上面的代码，它产生以下结果 -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line">TypeError: list objects are unhashable</span><br></pre></td></tr></table></figure>
<h2 id="内置字典函数和方法"><a href="#内置字典函数和方法" class="headerlink" title="内置字典函数和方法"></a>内置字典函数和方法</h2><h3 id="Python包括以下字典函数"><a href="#Python包括以下字典函数" class="headerlink" title="Python包括以下字典函数"></a>Python包括以下字典函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>cmp(dict1, dict2)</td>
<td>比较这两个字典的元素。</td>
</tr>
<tr>
<td>2</td>
<td>len(dict)</td>
<td>计算字典的总长度。这等于字典中的项的数目。</td>
</tr>
<tr>
<td>3</td>
<td>str(dict)</td>
<td>产生字典的可打印字符串表示</td>
</tr>
<tr>
<td>4</td>
<td>type(variable)</td>
<td>返回传递变量的类型。如果传递变量是字典，那么它会返回一个字典类型。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Python中包括以下字典方法"><a href="#Python中包括以下字典方法" class="headerlink" title="Python中包括以下字典方法 -"></a>Python中包括以下字典方法 -</h3><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>dict.clear()</td>
<td>删除字典 dict 中的所有元素</td>
</tr>
<tr>
<td>2</td>
<td>dict.copy()</td>
<td>返回字典 dict 的浅表副本</td>
</tr>
<tr>
<td>3</td>
<td>dict.fromkeys()</td>
<td>使用seq的键和值来设置创建新字典</td>
</tr>
<tr>
<td>4</td>
<td>dict.get(key, default=None)</td>
<td>对于键key，返回其值或default如果键不存在于字典中</td>
</tr>
<tr>
<td>5</td>
<td>dict.has_key(key)</td>
<td>返回true如果在字典dict有存在键key，否则为false</td>
</tr>
<tr>
<td>6</td>
<td>dict.items()</td>
<td>返回 dict (键，值)元组对的列表</td>
</tr>
<tr>
<td>7</td>
<td>dict.keys()</td>
<td>返回字典 dict 的键列表</td>
</tr>
<tr>
<td>8</td>
<td>dict.setdefault(key, default=None)</td>
<td>类似于get()方法，但会设定dict[key]=default，如果键不存在于dict中</td>
</tr>
<tr>
<td>9</td>
<td>dict.update(dict2)</td>
<td>添加字典dict2的键值对到dict</td>
</tr>
<tr>
<td>10</td>
<td>dict.values()</td>
<td>返回字典dict值列表</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础- I/O 简介</title>
    <url>/2017/11/13/2017-11-13_Programing-Python-Basic-IO-intro/</url>
    <content><![CDATA[<p>这里只讲述基本的 I/O 函数，更多函数请参考Python标准文档。</p>
<blockquote>
<p>Python 3.x I/O 标准文档位置  <a href="https://docs.python.org/3/library/io.html" target="_blank" rel="noopener">https://docs.python.org/3/library/io.html</a></p>
</blockquote>
<hr>
<h2 id="打印到屏幕"><a href="#打印到屏幕" class="headerlink" title="打印到屏幕"></a>打印到屏幕</h2><p>最简单的输出方法是用<code>print</code>函数，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></span><br><span class="line">print(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure>
<p>你的标准屏幕上会产生以下结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-e87780fd91230718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hello world"></p>
<h2 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h2><p>Python 3 提供了内置函数从标准输入读入一行文本，默认的标准输入是键盘。</p>
<a id="more"></a>
<h3 id="input-函数"><a href="#input-函数" class="headerlink" title="input 函数"></a>input 函数</h3><p><strong>input([prompt])</strong> 函数，<code>input</code> 可以接收一个Python表达式作为输入，并将运算结果返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></span><br><span class="line"> </span><br><span class="line">str = input(<span class="string">"请输入："</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"你输入的内容是: "</span>, str)</span><br></pre></td></tr></table></figure>
<p>这会产生如下的对应着输入的结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-7aaa0b67137263ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input"></p>
<hr>
<h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>现在，您已经可以向标准输入和输出进行读写。现在，来看看怎么读写实际的数据文件。</p>
<p>Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 <strong>file</strong> 对象做大部分的文件操作。</p>
<h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h3><p>你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file object = open(file_name [, access_mode][, buffering])</span><br></pre></td></tr></table></figure>
<p>各个参数的细节如下：</p>
<ul>
<li>file_name：<br>file_name变量是一个包含了你要访问的文件名称的字符串值。</li>
<li>access_mode：<br>access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li>
<li>buffering:<br>如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。</li>
</ul>
<p>不同模式打开文件的完全列表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>t</td>
<td>文本模式 (默认)。</td>
</tr>
<tr>
<td>x</td>
<td>写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式。</td>
</tr>
<tr>
<td>+</td>
<td>打开一个文件进行更新(可读可写)。</td>
</tr>
<tr>
<td>U</td>
<td>通用换行模式（不推荐）。</td>
</tr>
<tr>
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td>ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody>
</table>
</div>
<p>下图很好的总结了这几种模式：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-e33ee7e59b1f578c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不同模式打开文件"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>r</th>
<th>r+</th>
<th>w</th>
<th>w+</th>
<th>a</th>
<th>a+</th>
</tr>
</thead>
<tbody>
<tr>
<td>读</td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
</tr>
<tr>
<td>写</td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>创建</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>覆盖</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>指针在开始</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>指针在结尾</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="File对象的属性"><a href="#File对象的属性" class="headerlink" title="File对象的属性"></a>File对象的属性</h2><p>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。</p>
<p>以下是和file对象相关的所有属性的列表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>file.closed</td>
<td>返回true如果文件已被关闭，否则返回false。</td>
</tr>
<tr>
<td>file.mode</td>
<td>返回被打开文件的访问模式。</td>
</tr>
<tr>
<td>file.name</td>
<td>返回文件的名称。</td>
</tr>
<tr>
<td>file.softspace</td>
<td>如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td>
</tr>
</tbody>
</table>
</div>
<p>如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"文件名: "</span>, fo.name)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"是否已关闭 : "</span>, fo.closed)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"访问模式 : "</span>, fo.mode)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-6f26e4d45e1aadac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="close 文件"></p>
<h3 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h3><p>File 对象的 close()方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。</p>
<p>当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。</p>
<p>语法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.close()</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"文件名: "</span>, fo.name)</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure></p>
<p>以上实例输出结果：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/34293a3ecaa0cb2f69d381ae0453bbef.png" alt="image.png"></p>
<p>读写文件：</p>
<p>file对象提供了一系列方法，能让我们的文件访问更轻松。来看看如何使用read()和write()方法来读取和写入文件。</p>
<h3 id="write-方法"><a href="#write-方法" class="headerlink" title="write()方法"></a>write()方法</h3><p><code>write()</code>方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。</p>
<p><code>write()</code>方法不会在字符串的结尾添加换行符(‘\n’)：</p>
<p>语法：<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.write(string)</span><br></pre></td></tr></table></figure></p>
<p>在这里，被传递的参数是要写入到已打开文件的内容。</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">fo.write( <span class="string">"www.xiaozhuanlan.com!\nVery good site!\n"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<p>上述方法会创建temp.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.xiaozhuanlan.com!  </span><br><span class="line">Very good site!</span><br></pre></td></tr></table></figure></p>
<h3 id="read-方法"><a href="#read-方法" class="headerlink" title="read()方法"></a>read()方法</h3><p><code>read()</code>方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。</p>
<p>语法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.read([count])</span><br></pre></td></tr></table></figure></p>
<p>在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。</p>
<p>这里我们用到以上创建的 foo.txt 文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">str = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"读取的字符串是 : "</span>, str)</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-bea32e445d75c946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="read file"></p>
<h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><ul>
<li><p>tell()方法<br>告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。</p>
</li>
<li><p>seek（offset [,from]）方法<br>改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。</p>
<p>如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。</p>
</li>
</ul>
<p>例子：</p>
<p>就用我们上面创建的文件temp.txt。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">str = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"读取的字符串是 : "</span>, str</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查找当前位置</span></span><br><span class="line">position = fo.tell()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"当前文件位置 : "</span>, position)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把指针再次重新定位到文件开头</span></span><br><span class="line">position = fo.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">str = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> （<span class="string">"重新读取字符串 : "</span>, str）</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure></p>
<p>以上实例输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-9dfe3cba7f0a9e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="重命名和删除文件"><a href="#重命名和删除文件" class="headerlink" title="重命名和删除文件"></a>重命名和删除文件</h2><p>Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。</p>
<p>要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。</p>
<p>rename()方法：</p>
<p>rename()方法需要两个参数，当前的文件名和新文件名。</p>
<p>语法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rename(current_file_name, new_file_name)</span><br></pre></td></tr></table></figure></p>
<p>例子：</p>
<p>下例将重命名一个已经存在的文件 temp.txt。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重命名文件temp.txt到temp-1.txt。</span></span><br><span class="line">os.rename( <span class="string">"temp.txt"</span>, <span class="string">"temp-1.txt"</span> )</span><br></pre></td></tr></table></figure>
<h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h3><p>你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。</p>
<p>语法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(file_name)</span><br></pre></td></tr></table></figure></p>
<p>例子：</p>
<p>下例将删除一个已经存在的文件temp-1.txt。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除temp-1.txt。</span></span><br><span class="line">os.remove( <span class="string">"temp-1.txt"</span>)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="Python里的目录："><a href="#Python里的目录：" class="headerlink" title="Python里的目录："></a>Python里的目录：</h2><p>所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。</p>
<h3 id="mkdir-方法"><a href="#mkdir-方法" class="headerlink" title="mkdir()方法"></a>mkdir()方法</h3><p>可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。</p>
<p>语法：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.mkdir(<span class="string">"newdir"</span>)</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<p>下例将在当前目录下创建一个新目录test。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建目录test</span></span><br><span class="line">os.mkdir(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="chdir-方法"><a href="#chdir-方法" class="headerlink" title="chdir()方法"></a>chdir()方法</h3><p>可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.chdir(<span class="string">"newdir"</span>)</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<p>下例将进入”test”目录。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建目录test</span></span><br><span class="line">os.chdir(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure></p>
<p>getcwd()方法：</p>
<p>getcwd()方法显示当前的工作目录。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<p>下例给出当前目录：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给出当前的目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br></pre></td></tr></table></figure></p>
<h3 id="rmdir-方法"><a href="#rmdir-方法" class="headerlink" title="rmdir()方法"></a>rmdir()方法</h3><p>rmdir()方法删除目录，目录名称以参数传递。在删除这个目录之前，它的所有内容应该先被清除。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rmdir()</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<p>以下是删除” test”目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给出当前的目录</span></span><br><span class="line">os.rmdir(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="文件、目录相关的方法"><a href="#文件、目录相关的方法" class="headerlink" title="文件、目录相关的方法"></a>文件、目录相关的方法</h2><p>File 对象和 OS 对象提供了很多文件与目录的操作方法，可以通过点击下面链接查看详情：</p>
<ul>
<li><a href="https://docs.python.org/3/tutorial/inputoutput.html" target="_blank" rel="noopener">File 对象方法</a>: file 对象提供了操作文件的一系列方法。</li>
<li><a href="https://docs.python.org/3/library/os.html" target="_blank" rel="noopener">OS 对象方法</a>: 提供了处理文件及目录的一系列方法。</li>
</ul>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础-`yeild` 关键字使用</title>
    <url>/2017/11/12/2017-11-12_Programing-Python-Basic-use-yield/</url>
    <content><![CDATA[<hr>
<p>大家在阅读 Python 代码时，经常遇到带有 <code>yield</code> 的函数，通常此时我们都需要去想想这个<code>yield</code> 是个什么东西？这一段代码在讲什么事情呢？</p>
<p>那我们这里就来好好讲讲这个 <code>yield</code>。</p>
<p><code>yield</code> 是 Python 设计之初就保留的关键字之一。</p>
<p>在 Python 中被称之为 <code>generator</code>(中文翻译是 <code>“生成器”</code>)，那什么是 <code>generator</code> 呢 ？</p>
<p>我们先抛开 <code>generator</code>，以一个常见的编程题目来展示 <code>yield</code> 的概念。</p>
<hr>
<h2 id="从生成斐波那契数列开始"><a href="#从生成斐波那契数列开始" class="headerlink" title="从生成斐波那契数列开始"></a>从生成斐波那契数列开始</h2><p>斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。</p>
<p>用计算机程序输出斐波那契数列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出斐波那契数列前 N 个数第一版</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">       print(b)</span><br><span class="line">       a, b = b, a + b</span><br><span class="line">       n = n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fab(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>将上面的内容保存为 <code>.py</code> 后缀的文件，然后执行 ，我们可以得到如下输出：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-03a4c82710ec33e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果1"></p>
<p>结果没有问题，但有经验的开发者会指出，直接在 fab 函数中用 print 打印数字会导致该函数可复用性较差，因为 fab 函数返回 None，其他函数无法获得该函数生成的数列。</p>
<p>要提高 fab 函数的可复用性，最好不要直接打印出数列，而是返回一个 List。</p>
<p>以下是 fab 函数改写后的第二个版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出斐波那契数列前 N 个数第二版</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span> </span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> </span><br><span class="line">    L = [] </span><br><span class="line">    <span class="keyword">while</span> n &lt; max: </span><br><span class="line">        L.append(b) </span><br><span class="line">        a, b = b, a + b </span><br><span class="line">        n = n + <span class="number">1</span> </span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
<p>执行 ，我们可以得到如下输出：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-4c63ee7aa08c18ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果2"></p>
<p>改写后的 fab 函数通过返回 List 能满足复用性的要求，但是更有经验的开发者会指出，该函数在运行中占用的内存会随着参数 max 的增大而增大，如果要控制内存占用，最好不要用 List</p>
<p>来保存中间结果，而是通过 iterable 对象来迭代。例如，在 Python 中，<code>range()</code> 不返回 List，而是返回一个 <code>iterable</code>(中文翻译 <code>“可迭代的对象”</code>) 对象。</p>
<p>例如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过 iterable 对象来迭代</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>是在每次迭代中返回下一个数值，内存空间占用很小。</p>
<p>我们可以利用 <code>iterable</code> 的特性，把 fab 函数改写为一个支持 <code>iterable</code> 的 class，以下是第三个版本的 Fab：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出斐波那契数列前 N 个数第三版</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fab</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">       self.max = max</span><br><span class="line">       self.n, self.a, self.b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> self.n &lt; self.max:</span><br><span class="line">           r = self.b</span><br><span class="line">           self.a, self.b = self.b, self.a + self.b</span><br><span class="line">           self.n = self.n + <span class="number">1</span></span><br><span class="line">           <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">raise</span> StopIteration()</span><br><span class="line"><span class="comment"># Fab 类通过 next() 不断返回数列的下一个数，内存占用始终为常数：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> Fab(<span class="number">5</span>):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
<p>执行 ，我们可以得到如下输出：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-6f51a320b6673d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果3"></p>
<p>然而，使用 class 改写的这个版本，代码远远没有第一版的 fab 函数来得简洁。</p>
<p>如果我们想要保持第一版 fab 函数的简洁性，同时又要获得 <code>iterable</code> 的效果，<code>yield</code> 就派上用场了。</p>
<a id="more"></a>
<h2 id="使用-yield-生成斐波那契数列"><a href="#使用-yield-生成斐波那契数列" class="headerlink" title="使用 yield 生成斐波那契数列"></a>使用 <code>yield</code> 生成斐波那契数列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        <span class="comment"># print(b)</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
<p>第四个版本的 fab 和第一版相比，仅仅把 <code>print(b)</code> 改为了 <code>yield b</code> ，就在保持简洁性的同时获得了 <code>iterable</code> 的效果。</p>
<p>那么 <code>yield</code> 到底做了什么呢？</p>
<p>简单地讲，<code>yield</code> 的作用就是把一个函数变成一个 <code>generator</code>，带有 <code>yield</code> 的函数不再是一个普通函数，Python 解释器会将其视为一个 <code>generator</code>。</p>
<p>调用 <code>fab(5)</code> 不会执行 fab 函数，而是返回一个 <code>iterable</code> 对象！</p>
<p>在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 <code>yield b</code> 时，fab 函数就返回一个迭代值，下次迭代时，代码从 <code>yield b</code> 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 <code>yield</code>。</p>
<p>为了精通 <code>yield</code> ,你必须要理解：当你调用这个函数的时候，函数内部的代码并不立马执行 ，这个函数只是返回一个 <code>generator</code> 对象。</p>
<p>函数内的代码只有当你使用 <code>for</code> 进行迭代的时候(也就是 <code>for n in fab(5):</code> 这一句)。</p>
<p>现在到了关键点了！</p>
<p><strong>第一次迭代中你的函数会执行，从开始到达 yield 关键字，然后返回 yield 后的值作为第一次迭代的返回值. 然后，每次执行这个函数都会继续执行你在函数内部定义的那个循环的下一次，再返回那个值，直到没有可以返回的。</strong></p>
<p>如果 <code>generator</code> 内部没有定义 yield 关键字，那么这个 <code>generator</code> 被认为成空的。这种情况可能因为是循环进行没了，或者是没有满足 <code>if/else</code> 条件。</p>
<p>yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值，不仅代码简洁，而且执行流程异常清晰。</p>
<hr>
<h2 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h2><p>要注意区分 fab 和 fab(5)，fab 是一个 <code>generator function</code>，而 fab(5) 是调用 fab 返回的一个 <code>generator</code>，好比类的定义和类的实例的区别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类的定义和类的实例</span></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">print(isinstance(fab, types.GeneratorType))</span><br><span class="line"><span class="comment"># 将输出 False</span></span><br><span class="line">print(isinstance(fab(<span class="number">5</span>), types.GeneratorType))</span><br><span class="line"><span class="comment"># 将输出 True</span></span><br></pre></td></tr></table></figure>
<p>fab 是无法迭代的，而 fab(5) 是可迭代的：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">print(isinstance(fab, Iterable)）</span><br><span class="line"><span class="comment"># 将输出 False</span></span><br><span class="line">print(isinstance(fab(<span class="number">5</span>), Iterable))</span><br><span class="line"><span class="comment"># 将输出 True</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="yield-的实际使用"><a href="#yield-的实际使用" class="headerlink" title="yield 的实际使用"></a><code>yield</code> 的实际使用</h2><p>下面我们通过一个实际的例子来再次回顾下 <code>yield</code> 的用法。</p>
<p>通过 <code>yield</code> 来进行文件读取。如果直接对文件对象调用 <code>read()</code> 方法，会导致不可预测的内存占用。</p>
<p>好的方法是利用固定长度的缓冲区来不断读取文件内容。通过 <code>yield</code>，我们不再需要编写读文件的迭代类，就可以轻松实现文件读取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 yield 读取文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    BLOCK_SIZE = <span class="number">2048</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            block = f.read(BLOCK_SIZE)</span><br><span class="line">            <span class="keyword">if</span> block:</span><br><span class="line">                <span class="keyword">yield</span> block</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>以上内容介绍了 <code>yield</code> 的基本概念和用法。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Programing-Python-Basic-use_random</title>
    <url>/2017/11/11/2017-11-11_Programing-Python-Basic-use-random/</url>
    <content><![CDATA[<h2 id="一-获得-a-b-之间的随机整数"><a href="#一-获得-a-b-之间的随机整数" class="headerlink" title="一 获得[a, b]之间的随机整数"></a>一 获得[a, b]之间的随机整数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(random.randint(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h2 id="二-从一个非空序列中随机挑选一个元素"><a href="#二-从一个非空序列中随机挑选一个元素" class="headerlink" title="二 从一个非空序列中随机挑选一个元素"></a>二 从一个非空序列中随机挑选一个元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(random.choice([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>或<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从0～9中随机取一整数</span></span><br><span class="line">print(random.choice(range(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure></p>
<h2 id="三-按指定基数递增的集合中获取随机数"><a href="#三-按指定基数递增的集合中获取随机数" class="headerlink" title="三 按指定基数递增的集合中获取随机数"></a>三 按指定基数递增的集合中获取随机数</h2><p>基数缺省值为1<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># randrange([start,]stop[,step]) 取不到stop对应的值</span></span><br><span class="line">print(random.randrange(<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="四-随机打乱列表的元素"><a href="#四-随机打乱列表的元素" class="headerlink" title="四 随机打乱列表的元素"></a>四 随机打乱列表的元素</h2><p>就地修改，返回值为None<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">random.shuffle(lst)</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础-PEP 是什么？</title>
    <url>/2017/11/05/2017-11-05_Programing-Python-Basic-what-is-PEP/</url>
    <content><![CDATA[<h2 id="PEP-是什么？"><a href="#PEP-是什么？" class="headerlink" title="PEP 是什么？"></a>PEP 是什么？</h2><p>Python的 PEP 文档是一组不断发展的标准文档，PEP是 <code>Python Enhancement Proposal</code>的首字母缩写。就像TCPIP协议使用RFC来组织起不断发展的通信标准一样，PEP也是类似的用于发展Python的一组文档。</p>
<p>PEP的全称是Python Enhancement Proposals，其中Enhancement是增强改进的意思，Proposals则可译为提案或建议书，所以合起来，比较常见的翻译是 Python 增强提案或 Python 改进建议书。Python 核心开发者主要通过邮件列表讨论问题、提议、计划等，PEP 通常是汇总了多方信息，经过了部分核心开发者 review 和认可，最终形成的正式文档，起到了对外公示的作用。</p>
<p>PEP文档越多，说明 Python 社区越活跃，发展良好。</p>
<h2 id="PEP-的类型"><a href="#PEP-的类型" class="headerlink" title="PEP 的类型"></a>PEP 的类型</h2><p>每个PEP都有对应的类型（PEP Status Key）：</p>
<p>A – Accepted (Standards Track only) or Active proposal 已接受（仅限标准跟踪）或有效提案<br>D – Deferred proposal延期提案<br>F – Final proposal 最终提案<br>P – Provisional proposal 暂定提案<br>R – Rejected proposal 拒绝提案<br>S – Superseded proposal 被取代的提案<br>W – Withdrawn proposal 撤回提案</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-ffd775233a9043a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PEP Status"></p>
<h2 id="几个特殊的PEP"><a href="#几个特殊的PEP" class="headerlink" title="几个特殊的PEP"></a>几个特殊的PEP</h2><h3 id="PEP-0"><a href="#PEP-0" class="headerlink" title="PEP 0"></a>PEP 0</h3><p><a href="https://www.python.org/dev/peps/" target="_blank" rel="noopener">https://www.python.org/dev/peps/</a></p>
<p>这个文档是属于Information类的PEP文档，是所有PEP文档的索引。</p>
<h3 id="PEP-1"><a href="#PEP-1" class="headerlink" title="PEP 1"></a>PEP 1</h3><p><a href="https://www.python.org/dev/peps/pep-0001/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0001/</a></p>
<p>这个文档讲了PEP的目的和指引。</p>
<p>在PEP 1中的开头，就说明了PEP文档分成3个类型：</p>
<ol>
<li>标准，当然是Python语言的标准；</li>
<li>信息类；</li>
<li>过程类，记录Python语言发展过程中的一些信息。</li>
</ol>
<h3 id="PEP-8"><a href="#PEP-8" class="headerlink" title="PEP 8"></a>PEP 8</h3><p><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></p>
<p>PEP 8号文档，是Python官方出的编程规范.</p>
<a id="more"></a>
<h3 id="PEP-20"><a href="#PEP-20" class="headerlink" title="PEP 20"></a>PEP 20</h3><p><a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0020/</a><br>Python 之禅，就是我们在python 解释器中输入</p>
<p>每次Python官方发布新版本，新版本的New Features都有相应的PEP文档支撑，比如3.7.0版本，PEP文档成了Python发展的需求管理工具。如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-4e51d36b3d821fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Python 3.7.0版本关联的PEP"></p>
<p>Python新版本的New Features都有相应的PEP文档支撑</p>
<p>详见：<a href="https://www.python.org/downloads/release/python-370/" target="_blank" rel="noopener">https://www.python.org/downloads/release/python-370/</a></p>
<h3 id="其它需要重点关注的PEP"><a href="#其它需要重点关注的PEP" class="headerlink" title="其它需要重点关注的PEP"></a>其它需要重点关注的PEP</h3><ul>
<li>PEP 7 — Style Guide for C Code，C扩展</li>
<li>PEP 202 — List Comprehensions，列表生成式</li>
<li>PEP 274 — Dict Comprehensions，字典生成式</li>
<li>PEP 234 — Iterators，迭代器</li>
<li>PEP 257 — Docstring Conventions，文档注释规范</li>
<li>PEP 279 — The enumerate() built-in function，enumerate枚举</li>
<li>PEP 282 — A Logging System，日志模块</li>
<li>PEP 285 — Adding a bool type，布尔值</li>
<li>PEP 289 — Generator Expressions，生成器表达式</li>
<li>PEP 318 — Decorators for Functions and Methods，装饰器</li>
<li>PEP 342 — Coroutines via Enhanced Generators，协程</li>
<li>PEP 343 — The “with” Statement，with语句</li>
<li>PEP 380 — Syntax for Delegating to a Subgenerator，yield from语法</li>
<li>PEP 405 — Python Virtual Environments，虚拟环境</li>
<li>PEP 471 — os.scandir() function，遍历目录</li>
<li>PEP 484 — Type Hints，类型约束</li>
<li>PEP 492 — Coroutines with async and await syntax，async/await语法</li>
<li>PEP 498 — Literal String Interpolation Python，字面字符串插值</li>
<li>PEP 525 — Asynchronous Generators，异步生成器</li>
<li>PEP 572 — Assignment Expressions，表达式内赋值</li>
<li>PEP 3105 — Make print a function，print改为函数</li>
<li>PEP 3115 — Metaclasses in Python 3000，元类</li>
<li>PEP 3120 — Using UTF-8 as the default source encoding，默认UTF-8</li>
<li>PEP 3333 — Python Web Server Gateway Interface v1.0.1，Web开发</li>
<li>PEP 8000 — Python Language Governance Proposal Overview，GvR老爹推出决策层后，事关新决策方案</li>
</ul>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数组定义、使用、以及数组内存分析详解</title>
    <url>/2017/09/22/2017-09-22_Programing-Java-Basic-Java-array-user-guide/</url>
    <content><![CDATA[<p>本文主要是从容器概念到数组概念再到数组的三种定义以及各种情况的数组内存分析，以及一些数组常用的遍历以及反转、取最大值等操作。旨在全面性了解java数组。</p>
<h2 id="1、什么是容器"><a href="#1、什么是容器" class="headerlink" title="1、什么是容器"></a>1、什么是容器</h2><p>在讲数组之前，很有必要来谈谈容器的概念 所谓容器就是将多个数据存储到一起，每个数据称为该容器的元素。</p>
<blockquote>
<p>生活中的容器：水杯，衣柜，教室</p>
</blockquote>
<h2 id="2、什么是数组"><a href="#2、什么是数组" class="headerlink" title="2、什么是数组"></a>2、什么是数组</h2><p>所谓数组就是存储数据<strong>长度固定</strong>的<strong>容器</strong>，保证多个数据的<strong>数据类型一致</strong>。</p>
<h2 id="3、数组的三种定义"><a href="#3、数组的三种定义" class="headerlink" title="3、数组的三种定义"></a>3、数组的三种定义</h2><p>下面主要讲解下数组的三种定义方式。</p>
<h3 id="定义方式一"><a href="#定义方式一" class="headerlink" title="定义方式一"></a>定义方式一</h3><blockquote>
<p><code>数据类型[] 数组名字 = new 数据类型 [长度]</code> ;</p>
</blockquote>
<p>举例： 定义可以存储3个整数的数组容器，代码如： <code>int[] arr = new int[3]</code></p>
<h3 id="定义方式二"><a href="#定义方式二" class="headerlink" title="定义方式二"></a>定义方式二</h3><blockquote>
<p><code>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3...}</code>;</p>
</blockquote>
<p>举例： 定义存储1，2，3，4，5整数的数组容器。 <code>int[] arr = new int[]{1,2,3,4,5}</code>;</p>
<h3 id="定义方式三"><a href="#定义方式三" class="headerlink" title="定义方式三"></a>定义方式三</h3><blockquote>
<p><code>数据类型[] 数组名 = {元素1,元素2,元素3...};</code></p>
</blockquote>
<p>举例： 定义存储1，2，3，4，5整数的数组容器 <code>int[] arr = {1,2,3,4,5}</code>;</p>
<h2 id="4、数组的访问"><a href="#4、数组的访问" class="headerlink" title="4、数组的访问"></a>4、数组的访问</h2><p><strong>索引</strong>：从<code>0</code>开始，索引 (<code>index</code>)可以访问到数组中的元素。</p>
<p><strong>格式</strong>： <code>数组名[索引]</code></p>
<p><strong>数组长度属性</strong>： 数组长度是固定的，由于索引从0开始，所以数组的最大索引值为<code>数组名.length-1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="comment">//打印数组的属性，输出结果是5 </span></span><br><span class="line">System.out.println(arr.length); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、什么是内存"><a href="#5、什么是内存" class="headerlink" title="5、什么是内存"></a>5、什么是内存</h2><blockquote>
<p>在讲数组的原理内存前，必须了解的一个叫内存的概念。</p>
</blockquote>
<p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程 序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。 Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p>
<h3 id="5-1-Java虚拟机的内存划分"><a href="#5-1-Java虚拟机的内存划分" class="headerlink" title="5.1 Java虚拟机的内存划分"></a>5.1 Java虚拟机的内存划分</h3><p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。<br> <img src="https://upload-images.jianshu.io/upload_images/1940331-210e2332016efef9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java虚拟机的内存划分"></p>
<h3 id="5-2-数组在内存中的存储"><a href="#5-2-数组在内存中的存储" class="headerlink" title="5.2 数组在内存中的存储"></a>5.2 数组在内存中的存储</h3><h4 id="5-2-1-一个数组内存图"><a href="#5-2-1-一个数组内存图" class="headerlink" title="5.2.1 一个数组内存图"></a>5.2.1 一个数组内存图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">    System.out.println(arr);<span class="comment">//[I@5f150435 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上方法执行，输出的结果是<code>[I@5f150435</code>，这个是什么呢？是数组在内存中的地址。<code>new</code>出来的内容，都是在堆内存中存储的，而方法中的变量<code>arr</code>保存的是数组的地址。</p>
<p>输出<code>arr[0]</code>，就会输出arr保存的内存地址中数组中0索引上的元素，如没有具体确定值，则是类型的默认值！比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr=<span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">  System.out.println(arr);     <span class="comment">//  [Ljava.lang.String;@1b6d3586</span></span><br><span class="line">  System.out.println(arr[<span class="number">0</span>]);  <span class="comment">//  null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arrInt=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">  System.out.println(arrInt);    <span class="comment">// [I@1b6d3586</span></span><br><span class="line">  System.out.println(arrInt[<span class="number">0</span>]); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-28da6c1f89b1227e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组内存图"></p>
<h6 id="5-2-2-两个数组内存图"><a href="#5-2-2-两个数组内存图" class="headerlink" title="5.2.2 两个数组内存图"></a>5.2.2 两个数组内存图</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">    <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; </span><br><span class="line">    System.out.println(arr); </span><br><span class="line">    System.out.println(arr2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-93464f888eec949f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个数组内存图"></p>
<h6 id="5-2-3-两个变量指向一个数组"><a href="#5-2-3-两个变量指向一个数组" class="headerlink" title="5.2.3 两个变量指向一个数组"></a>5.2.3 两个变量指向一个数组</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 定义数组，存储3个元素 </span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">    <span class="comment">//数组索引进行赋值 </span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">5</span>; </span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">6</span>; </span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">7</span>; </span><br><span class="line">    <span class="comment">//输出3个索引上的元素值 </span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]); </span><br><span class="line">    <span class="comment">//定义数组变量arr2，将arr的地址赋值给arr2 </span></span><br><span class="line">    <span class="keyword">int</span>[] arr2 = arr; </span><br><span class="line">    arr2[<span class="number">1</span>] = <span class="number">9</span>; </span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-42b2add666df2164?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个变量指向一个数组"></p>
<h2 id="6、数组常见的异常"><a href="#6、数组常见的异常" class="headerlink" title="6、数组常见的异常"></a>6、数组常见的异常</h2><p>数组常见的异常主要有<code>数组越界异常</code>以及<code>空指针异常</code>，这是非常基础的，就不多做介绍了，这里主要分析下空指针异常在内存的情况<br> <img src="https://upload-images.jianshu.io/upload_images/1940331-e3c2b44c058df851?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组常见的异常"></p>
<h2 id="7、-数组遍历【重点】"><a href="#7、-数组遍历【重点】" class="headerlink" title="7、 数组遍历【重点】"></a>7、 数组遍历【重点】</h2><p>所谓数组遍历 就是将数组中的每个元素分别获取出来，就是遍历。遍历数组<strong>非常重要</strong>！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">4</span>]); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，我把这种方式叫做傻瓜式遍历，这种傻瓜式写法肯定不行，因此我们需要改 造成循环的写法。数组的索引是 <code>0</code> 到 <code>lenght-1</code> ，可以作为循环的条件出现。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i])</span><br><span class="line">       &#125; </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、数组获取最大值元素"><a href="#8、数组获取最大值元素" class="headerlink" title="8、数组获取最大值元素"></a>8、数组获取最大值元素</h2><blockquote>
<p>实现思路： 定义变量，保存数组0索引上的元素 遍历数组，获取出数组中的每个元素 将遍历到的元素和保存数组0索引上值的变量进行比较 如果数组元素的值大于了变量的值，变量记录住新的值 数组循环遍历结束，变量保存的就是数组中的最大值</p>
</blockquote>
<p><strong>真香警告</strong>：<strong>大家小心点，别被第一个和第二个婆娘给迷住了</strong> </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-1643dd7d135be094?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组获取最大值元素"></p>
<p> 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">15</span>, <span class="number">2000</span>, <span class="number">10000</span>, <span class="number">100</span>, <span class="number">4000</span> &#125;; </span><br><span class="line">    <span class="comment">//定义变量，保存数组中0索引的元素 </span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>]; </span><br><span class="line">    <span class="comment">//遍历数组，取出每个元素 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; </span><br><span class="line">    <span class="comment">//遍历到的元素和变量max比较 </span></span><br><span class="line">    <span class="comment">//如果数组元素大于max </span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; max) &#123; </span><br><span class="line">    <span class="comment">//max记录住大值 </span></span><br><span class="line">    max = arr[i]; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">System.out.println(<span class="string">"数组最大值是： "</span> + max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、-数组反转"><a href="#9、-数组反转" class="headerlink" title="9、 数组反转"></a>9、 数组反转</h2><p>所谓反转就是把数组元素位置颠倒过来</p>
<blockquote>
<p>实现思想：数组最远端的元素互换位置 实现反转，就需要将数组最远端元素位置交换 定义两个变量，保存数组的最小索引和最大索引 两个索引上的元素交换位置 最小索引++，最大索引—，再次交换位置 最小索引超过了最大索引，数组反转操作结束</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-ee48a8c6c306d894?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组反转"></p>
<p>具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </span><br><span class="line">    <span class="comment">/*循环中定义变量min=0最小索引 </span></span><br><span class="line"><span class="comment">    max=arr.length‐1最大索引 </span></span><br><span class="line"><span class="comment">    min++,max‐‐ */</span> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> min = <span class="number">0</span>, max = arr.length ‐ <span class="number">1</span>; min &lt;= max; min++, max‐‐)&#123;</span><br><span class="line">    <span class="comment">//利用第三方变量完成数组中的元素交换 </span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[min]; </span><br><span class="line">    arr[min] = arr[max]; </span><br><span class="line">    arr[max] = temp;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 反转后，遍历数组 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">     System.out.println(arr[i])</span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="10、数组作为方法参数和返回值"><a href="#10、数组作为方法参数和返回值" class="headerlink" title="10、数组作为方法参数和返回值"></a>10、数组作为方法参数和返回值</h2><p>首先明确一点：数组作为方法的返回值，返回的是数组的内存地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//调用方法，接收数组的返回值 </span></span><br><span class="line">     <span class="comment">//接收到的是数组的内存地址 </span></span><br><span class="line">     <span class="keyword">int</span>[] arr = getArray(); </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; </span><br><span class="line">     System.out.println(arr[i])</span><br><span class="line">        &#125; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 创建方法，返回值是数组类型创建方法，返回值是数组类型 </span></span><br><span class="line"><span class="comment">     return返回数组的地址 */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getArray() &#123; </span><br><span class="line">     <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">      <span class="comment">//返回数组的地址，返回到调用者</span></span><br><span class="line">     <span class="keyword">return</span> arr; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-a80fb17676058804?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法栈、堆"></p>
<h2 id="11、方法的参数类型区别"><a href="#11、方法的参数类型区别" class="headerlink" title="11、方法的参数类型区别"></a>11、方法的参数类型区别</h2><blockquote>
<p><strong>方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.</strong></p>
</blockquote>
<p>分析下列程序代码，计算输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; <span class="keyword">int</span> b = <span class="number">2</span>; </span><br><span class="line">    System.out.println(a); </span><br><span class="line">    System.out.println(b); </span><br><span class="line">    change(a, b); </span><br><span class="line">    System.out.println(a); </span><br><span class="line">    System.out.println(b); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">    a = a + b; b = b + a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析下列程序代码，计算输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; </span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">    change(arr); </span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">200</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结: 方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.</p>
</blockquote>
<p>相信各位已经将上面的代码 copy 到 eclipse 或者 idea 中运行了，是不是结果很意外？而且对总结不是很理解？这位童靴，我估计你可能是忽略了这一点：数组是引用类型，数组本身元素类型没有影响的，就像数组元素全是int，数组依旧是引用类型！</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Generator 基础指南</title>
    <url>/2017/09/19/2017-09-19-Programing-JavaScript-ES6-Generator-Guide/</url>
    <content><![CDATA[<h3 id="ES6-Generator-基础指南"><a href="#ES6-Generator-基础指南" class="headerlink" title="ES6 Generator 基础指南"></a>ES6 Generator 基础指南</h3><blockquote>
<p>本文翻译自：<a href="https://davidwalsh.name/es6-generators" target="_blank" rel="noopener">The Basics Of ES6 Generators</a></p>
<p>由于个人能力有限，翻译中难免有纰漏和错误，望不吝指正</p>
</blockquote>
<p>JavaScript ES6(译者注：ECMAScript 2015)中最令人兴奋的特性之一莫过于<strong>Generator</strong>函数，它是一种全新的函数类型。它的名字有些奇怪，初见其功能时甚至更会有些陌生。本篇文章旨在解释其基本工作原理，并帮助你理解为什么 Generator 将在未来 JS 中发挥强大作用。</p>
<h4 id="Generator-从运行到完成的工作方式"><a href="#Generator-从运行到完成的工作方式" class="headerlink" title="Generator 从运行到完成的工作方式"></a>Generator 从运行到完成的工作方式</h4><p>但我们谈论 Generator 函数时，我们首先应该注意到的是，从“运行到完成”其和普通的函数表现有什么不同之处。</p>
<p>不论你是否已经意识到，你已经潜意识得认为函数具有一些非常基础的特性：函数一旦开始执行，那么在其结束之前，不会执行其他 JavaScript 代码。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> don't ever do crazy long-running loops like this</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">1e10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 0..1E10</span></span><br><span class="line"><span class="comment">// "Hello World"</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>for</code>循环会执行相当长的时间，长于 1 秒钟，但是在<code>foo()</code>函数执行的过程中，我们带有<code>console.log(...)</code>的定时器并不能够中断<code>foo()</code>函数的运行。因此代码被阻塞，定时器被推入事件循环的最后，耐心等待<code>foo</code>函数执行完成。</p>
<p>倘若<code>foo()</code>可以被中断执行？它不会给我们的带来前所未有的浩劫吗？</p>
<a id="more"></a>
<p>函数可以被中断对于多线程编程来说确实是一个挑战，但是值得庆幸的是，在 JavaScript 的世界中我们没必要为此而担心，因为 JS 总是单线程的（在任何时间只有一条命令/函数被执行）。</p>
<p><strong>注意：</strong> Web Workers 是 JavaScript 中实现与 JS 主线程分离的独立线程机制，总的说来，Web Workers 是与 JS 主线程平行的另外一个线程。在这儿我们并不介绍多线程并发的一个原因是，主线程和 Web Workers 线程只能够通过异步事件进行通信，因此每个线程内部从运行到结束依然遵循一个接一个的事件循环机制。</p>
<h4 id="运行-停止-运行"><a href="#运行-停止-运行" class="headerlink" title="运行-停止-运行"></a>运行-停止-运行</h4><p>由于 ES6Generators 的到来，我们拥有了另外一种类型的函数，这种函数可以在执行的过程中暂停一次或多次，在将来的某个时间继续执行，并且允许在 Generator 函数暂停的过程中运行其他代码。</p>
<p>如果你曾经阅读过关于并发或者多线程编程的资料，那你一定熟悉“协程”这一概念，“协程”的意思就是一个进程（就是一个函数）其可以自行选择终止运行，以便可以和其他代码<strong>“协作”</strong>完成一些功能。这一概念和“preemptive”相对，preemptive 认为可以在进程/函数外部对其终止运行。</p>
<p>根据 ES6 Generator 函数的并发行为，我们可以认为其是一种“协程”。在 Generator 函数体内部，你可以使用<code>yield</code>关键字在函数内部暂停函数的执行，在 Generator 函数外部是无法暂停一个 Generator 函数执行的；每当 Generator 函数遇到一个<code>yield</code>关键字就将暂停执行。</p>
<p>然后，一旦一个 Generator 函数通过<code>yield</code>暂停执行，其不能够自行恢复执行，需要通过外部的控制来重新启动 generator 函数，我们将在文章后面部分介绍这是怎么发生的。</p>
<p>基本上，只要你愿意，一个 Generator 函数可以暂停执行/重新启动任意多次。实际上，你可以再 Generator 函数内部使用无限循环（比如非著名的<code>while (true) { .. }</code>）来使得函数可以无尽的暂停/重新启动。然后这在普通的 JS 程序中却是疯狂的行径，甚至会抛出错误。但是 Generator 函数却能够表现的非常明智，有些时候你确实想利用 Generator 函数这种无尽机制。</p>
<p>更为重要的是，暂停/重新启动不仅仅用于控制 Generator 函数执行，它也可以在 generator 函数内部和外部进行双向的通信。在普通的 JavaScript 函数中，你可以通过传参的形式将数据传入函数内容，在函数内部通过<code>return</code>语句将函数的返回值传递到函数外部。在 generator 函数中，我们通过<code>yield</code>表达式将信息传递到外部，然后通过每次重启 generator 函数将其他信息传递给 generator。</p>
<h4 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h4><p>然我们看看新奇并且令人兴奋的 generator 函数的语法是怎样书写的。</p>
<p>首先，新的函数声明语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现<code>*</code>符号没？显得有些陌生且有些奇怪。对于从其他语言转向 JavaScript 的人来说，它看起来很像函数返回值指针。但是不要被迷惑到了，<code>*</code>只是用于标识 generator 函数而已。</p>
<p>你可能会在其他的文章/文档中看到如下形式书写 generator 函数<code>function* foo(){}</code>，而不是这样<code>function *foo() {}</code>(<code>*</code>号的位置有所不同)。其实两种形式都是合法的，但是最近我认为后面一种形式更为准确，因此在本篇文章中都是使用后面一种形式。</p>
<p>现在，让我们来讨论下 generator 函数的内部构成吧。在很多方面，generator 函数和普通函数无异，只有在 generator 函数内部有一些新的语法。</p>
<p>正如上面已经提及，我们最先需要了解的就是<code>yield</code>关键字，<code>yield__</code>被视为“yield 表达式”（并不是一条语句），因为当我们重新启动 generator 函数的时候，我们可以传递信息到 generator 函数内部，不论我们传递什么进去，都将被视为<code>yield__</code>表达式的运行结果。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> <span class="string">"foo"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>yield &quot;foo&quot;</code>表达式会在 generator 函数暂停时把“foo”字符串传递到外部。同时，当 generator 函数恢复执行的时候，其他的值又会通过其他表达式传入到函数里面作为<code>yield</code>表达式的返回值加<code>1</code>最后再将结果赋值给<code>x</code>变量。</p>
<p>看到 generator 函数的双向通信了吗？generator 函数将‘’foo‘’字符串传递到外部，暂停函数执行，在将来的某个时间点（可能是立即也可能是很长一段时间后），generator 会被重启，并且会传递一个值给 generator 函数，就好像<code>yield</code>关键字就是某种发送请求获取值的请求形式。</p>
<p>在任意表达式中，你可以仅使用<code>yield</code>关键字，后面不跟任何表达式或值。在这种情况下，就相当于将<code>undefined</code>通过<code>yield</code>传递出去。如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// note: `foo(..)` here is NOT a generator!!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"x: "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>; <span class="comment">// just pause</span></span><br><span class="line">  foo(<span class="keyword">yield</span>); <span class="comment">// pause waiting for a parameter to pass into `foo(..)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Generator-迭代器"><a href="#Generator-迭代器" class="headerlink" title="Generator 迭代器"></a>Generator 迭代器</h4><p>“Generator 迭代器”，是不是相当晦涩难懂？</p>
<p>迭代器是一种特殊的行为，准确说是一种设计模式，当我们通过调用<code>next()</code>方法去遍历一组值的集合时，例如，我们通过在长度为 5 的数组<code>[1, 2, 3, 4, 5]</code>上面实现了迭代器。当我们第一次调用<code>next()</code>的时候，会返回<code>1</code>。第二次调用<code>next()</code>返回<code>2</code>,如此下去，当所有的值都返回后，再次调用<code>next()</code>将返回<code>null</code>或者<code>false</code>或其他值，这意味着你已经遍历完真个数组中的值了。</p>
<p>我们是通过和 generator 迭代器进行交互来在 generator 函数外部控制 generator 函数，这听起来比起实际上有些复杂，考虑下面这个愚蠢的（简单的）例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了遍历<code>*foo()</code>generator 函数中的所有值，我们首先需要构建一个迭代器，我们怎么去构建这个迭代器呢？非常简单！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = foo();</span><br></pre></td></tr></table></figure>
<p>如此之简单，我们仅仅想执行普通函数一样执行 generator 函数，其将返回一个迭代器，但是 generator 函数中的代码并不会运行。</p>
<p>这似乎有些奇怪，并且增加了你的理解难度。你甚至会停下来思考，问为什么不通过<code>var it = new foo()</code>的形式来执行 generator 函数呢，这语法后面的原因可能相当复杂并超出了我们的讨论范畴。</p>
<p>好的，现在让我们开始迭代我们的 generator 函数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = it.next();</span><br></pre></td></tr></table></figure>
<p>通过上面的语句，<code>yield</code>表达式将 1 返回到函数外部，但是返回的值可能比想象中会多一些。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>在每一调用<code>next()</code>后，我们实际上从<code>yield</code>表达式的返回值中获取到了一个对象，这个对象中有<code>value</code>字段，就是<code>yield</code>返回的值，同时还有一个布尔类型的<code>done</code>字段，其用来表示 generator 函数是否已经执行完毕。</p>
<p>然我们把迭代执行完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:4, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:5, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>有趣的是，当我们获取到值为<code>5</code>的时候，<code>done</code>字段依然是<code>false</code>。这因为，实际上 generator 函数还么有执行完全，我们还可以再次调用<code>next()</code>。如果我们向函数内部传递一个值，其将被设置为<code>yield 5</code>表达式的返回值，只有在这<strong>时候</strong>，generator 函数才执行完全。</p>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>所以最终结果是，我们迭代执行完我们的 generator 函数，但是最终却没有结果（由于我们已经执行完所有的<code>yield__</code>表达式）。</p>
<p>你可能会想，我能不能在 generator 函数中使用<code>return</code>语句，如果我这样这，返回值会不会在最终的<code>value</code>字段里面呢？</p>
<p><strong>是</strong>…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:2, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>… <strong>不是.</strong></p>
<p>依赖于 generator 函数的最终返回值也许并不是一个最佳实践，因为当我们通过<code>for--of</code>循环来迭代 generator 函数的时候（如下），最终<code>return</code>的返回值将被丢弃（无视）。</p>
<p>为了完整，让我们来看一个同时有双向数据通信的 generator 函数的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> y / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// note: not sending anything into `next()` here</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)); <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)); <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>你可以看到，我们依然可以通过<code>foo(5)</code>传递参数（在例子中是<code>x</code>）给 generator 函数，就像普通函数一样，是的参数<code>x</code>为<code>5</code>.</p>
<p>在第一次执行<code>next(..)</code>的时候，我们并没有传递任何值，为什么？因为在 generator 内部并没有<code>yield</code>表达式来接收我们传递的值。</p>
<p>假如我们真的在第一次调用<code>next(..)</code>的时候传递了值进去，也不会带来什么坏处，它只是将这个传入的值抛弃而已。ES6 表明，generator 函数在这种情况只是忽略了这些没有被用到的值。（<strong>注意</strong>：在写这篇文章的时候，Chrome 和 FF 的每夜版支持这一特性，但是其他浏览有可能没有完全支持这一特性甚至可能会抛出错误）（译者注：文章发布于 2014 年）</p>
<p><code>yield(x + 1)</code>表达式将传递值<code>6</code>到外部，在第二次调用<code>next(12)</code>时候，传递<code>12</code>到 generator 函数内部作为<code>yield(x + 1)</code>表达式的值，因此<code>y</code>被赋值为<code>12 * 2</code>，值为<code>24</code>。接下来，下一条<code>yield(y / 3)</code>(<code>yield (24 / 3)</code>)将向外传递值<code>8</code>。第三次调用<code>next(13)</code>传递<code>13</code>到 generator 函数内部，给<code>yield(y / 3)</code>。是的<code>z</code>被设置为<code>13</code>.</p>
<p>最后，<code>return (x + y + z)</code>就是<code>return (5 + 24 + 13)</code>，也就是<code>42</code>将会作为最终的值返回出去。</p>
<p><strong>重新阅读几遍上面的实例</strong>。最开始有些难以理解。</p>
<h4 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for..of循环"></a><code>for..of</code>循环</h4><p>ES6 在语法层面上大力拥抱迭代器模式，提供了<code>for..of</code>循环来直接支持迭代器的遍历。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(v); <span class="comment">// still `5`, not `6` :(</span></span><br></pre></td></tr></table></figure>
<p>正如你所见，通过调用<code>foo()</code>生成的迭代器通过<code>for..of</code>循环来迭代，循环自动帮你对迭代器进行遍历迭代，每次迭代返回一个值，直到<code>done: true</code>，只要<code>done: false</code>，每次循环都将从<code>value</code>属性上获取到值赋值给迭代的变量（例子中的<code>v</code>）。一旦当<code>done</code>为<code>true</code>。循环迭代结束。（<code>for..of</code>循环不会对 generator 函数最终的 return 值进行处理）</p>
<p>正如你所看到的，<code>for..of</code>循环忽略了 generator 最后的<code>return 6</code>的值，同时，循环没有暴露<code>next()</code>出来，因此我们也不能够向 generator 函数内传递数据。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>OK,上面是关于 generator 函数的基本用法，如果你依然对 generator 函数感到费解，不要担心，我们所有人在一开始感觉都是那样的。</p>
<p>我们很自然的想到这一外来的语法对我们实际代码有什么作用呢？generator 函数有很多作用，我们只是挖掘了其非常粗浅的一部分。在我们发现 generator 函数如此强大之前我们应该更加深入的了解它。</p>
<p>在你练习上面代码片段之后（在 Chrome 或者 FF 每夜版本，或者 0.11+带有<code>--harmony</code>的 node 环境下），下面的问题也许会浮出水面：（译者注：现代浏览器最新版本都已支持 Generator 函数）</p>
<ol>
<li>怎样处理 generator 内部错误？</li>
<li>在 generator 函数内部怎么调用其他 generator 函数？</li>
<li>异步代码怎么和 generator 函数协同工作？</li>
</ol>
<p>这些问题，或者其他的问题都将在随后的文章中覆盖，敬请期待。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Generator 基础指南</title>
    <url>/2017/09/17/2017-09-17-Programing-JavaScript-Generator-intro/</url>
    <content><![CDATA[<h3 id="ES6-Generator-基础指南"><a href="#ES6-Generator-基础指南" class="headerlink" title="ES6 Generator 基础指南"></a>ES6 Generator 基础指南</h3><blockquote>
<p>本文翻译自：<a href="https://davidwalsh.name/es6-generators" target="_blank" rel="noopener">The Basics Of ES6 Generators</a></p>
</blockquote>
<p>JavaScript ES6(译者注：ECMAScript 2015)中最令人兴奋的特性之一莫过于<strong>Generator</strong>函数，它是一种全新的函数类型。它的名字有些奇怪，初见其功能时甚至更会有些陌生。本篇文章旨在解释其基本工作原理，并帮助你理解为什么 Generator 将在未来 JS 中发挥强大作用。</p>
<h4 id="Generator-从运行到完成的工作方式"><a href="#Generator-从运行到完成的工作方式" class="headerlink" title="Generator 从运行到完成的工作方式"></a>Generator 从运行到完成的工作方式</h4><p>但我们谈论 Generator 函数时，我们首先应该注意到的是，从“运行到完成”其和普通的函数表现有什么不同之处。</p>
<p>不论你是否已经意识到，你已经潜意识得认为函数具有一些非常基础的特性：函数一旦开始执行，那么在其结束之前，不会执行其他 JavaScript 代码。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> don't ever do crazy long-running loops like this</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">1e10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 0..1E10</span></span><br><span class="line"><span class="comment">// "Hello World"</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>for</code>循环会执行相当长的时间，长于 1 秒钟，但是在<code>foo()</code>函数执行的过程中，我们带有<code>console.log(...)</code>的定时器并不能够中断<code>foo()</code>函数的运行。因此代码被阻塞，定时器被推入事件循环的最后，耐心等待<code>foo</code>函数执行完成。</p>
<p>倘若<code>foo()</code>可以被中断执行？它不会给我们的带来前所未有的浩劫吗？</p>
<p>函数可以被中断对于多线程编程来说确实是一个挑战，但是值得庆幸的是，在 JavaScript 的世界中我们没必要为此而担心，因为 JS 总是单线程的（在任何时间只有一条命令/函数被执行）。</p>
<p><strong>注意：</strong> Web Workers 是 JavaScript 中实现与 JS 主线程分离的独立线程机制，总的说来，Web Workers 是与 JS 主线程平行的另外一个线程。在这儿我们并不介绍多线程并发的一个原因是，主线程和 Web Workers 线程只能够通过异步事件进行通信，因此每个线程内部从运行到结束依然遵循一个接一个的事件循环机制。</p>
<p>&lt;!&gt;</p>
<h4 id="运行-停止-运行"><a href="#运行-停止-运行" class="headerlink" title="运行-停止-运行"></a>运行-停止-运行</h4><p>由于 ES6Generators 的到来，我们拥有了另外一种类型的函数，这种函数可以在执行的过程中暂停一次或多次，在将来的某个时间继续执行，并且允许在 Generator 函数暂停的过程中运行其他代码。</p>
<p>如果你曾经阅读过关于并发或者多线程编程的资料，那你一定熟悉“协程”这一概念，“协程”的意思就是一个进程（就是一个函数）其可以自行选择终止运行，以便可以和其他代码<strong>“协作”</strong>完成一些功能。这一概念和“preemptive”相对，preemptive 认为可以在进程/函数外部对其终止运行。</p>
<p>根据 ES6 Generator 函数的并发行为，我们可以认为其是一种“协程”。在 Generator 函数体内部，你可以使用<code>yield</code>关键字在函数内部暂停函数的执行，在 Generator 函数外部是无法暂停一个 Generator 函数执行的；每当 Generator 函数遇到一个<code>yield</code>关键字就将暂停执行。</p>
<p>然后，一旦一个 Generator 函数通过<code>yield</code>暂停执行，其不能够自行恢复执行，需要通过外部的控制来重新启动 generator 函数，我们将在文章后面部分介绍这是怎么发生的。</p>
<p>基本上，只要你愿意，一个 Generator 函数可以暂停执行/重新启动任意多次。实际上，你可以再 Generator 函数内部使用无限循环（比如非著名的<code>while (true) { .. }</code>）来使得函数可以无尽的暂停/重新启动。然后这在普通的 JS 程序中却是疯狂的行径，甚至会抛出错误。但是 Generator 函数却能够表现的非常明智，有些时候你确实想利用 Generator 函数这种无尽机制。</p>
<p>更为重要的是，暂停/重新启动不仅仅用于控制 Generator 函数执行，它也可以在 generator 函数内部和外部进行双向的通信。在普通的 JavaScript 函数中，你可以通过传参的形式将数据传入函数内容，在函数内部通过<code>return</code>语句将函数的返回值传递到函数外部。在 generator 函数中，我们通过<code>yield</code>表达式将信息传递到外部，然后通过每次重启 generator 函数将其他信息传递给 generator。</p>
<h4 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h4><p>然我们看看新奇并且令人兴奋的 generator 函数的语法是怎样书写的。</p>
<p>首先，新的函数声明语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现<code>*</code>符号没？显得有些陌生且有些奇怪。对于从其他语言转向 JavaScript 的人来说，它看起来很像函数返回值指针。但是不要被迷惑到了，<code>*</code>只是用于标识 generator 函数而已。</p>
<p>你可能会在其他的文章/文档中看到如下形式书写 generator 函数<code>function* foo(){}</code>，而不是这样<code>function *foo() {}</code>(<code>*</code>号的位置有所不同)。其实两种形式都是合法的，但是最近我认为后面一种形式更为准确，因此在本篇文章中都是使用后面一种形式。</p>
<p>现在，让我们来讨论下 generator 函数的内部构成吧。在很多方面，generator 函数和普通函数无异，只有在 generator 函数内部有一些新的语法。</p>
<p>正如上面已经提及，我们最先需要了解的就是<code>yield</code>关键字，<code>yield__</code>被视为“yield 表达式”（并不是一条语句），因为当我们重新启动 generator 函数的时候，我们可以传递信息到 generator 函数内部，不论我们传递什么进去，都将被视为<code>yield__</code>表达式的运行结果。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> <span class="string">"foo"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>yield &quot;foo&quot;</code>表达式会在 generator 函数暂停时把“foo”字符串传递到外部。同时，当 generator 函数恢复执行的时候，其他的值又会通过其他表达式传入到函数里面作为<code>yield</code>表达式的返回值加<code>1</code>最后再将结果赋值给<code>x</code>变量。</p>
<p>看到 generator 函数的双向通信了吗？generator 函数将‘’foo‘’字符串传递到外部，暂停函数执行，在将来的某个时间点（可能是立即也可能是很长一段时间后），generator 会被重启，并且会传递一个值给 generator 函数，就好像<code>yield</code>关键字就是某种发送请求获取值的请求形式。</p>
<p>在任意表达式中，你可以仅使用<code>yield</code>关键字，后面不跟任何表达式或值。在这种情况下，就相当于将<code>undefined</code>通过<code>yield</code>传递出去。如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// note: `foo(..)` here is NOT a generator!!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"x: "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>; <span class="comment">// just pause</span></span><br><span class="line">  foo(<span class="keyword">yield</span>); <span class="comment">// pause waiting for a parameter to pass into `foo(..)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Generator-迭代器"><a href="#Generator-迭代器" class="headerlink" title="Generator 迭代器"></a>Generator 迭代器</h4><p>“Generator 迭代器”，是不是相当晦涩难懂？</p>
<p>迭代器是一种特殊的行为，准确说是一种设计模式，当我们通过调用<code>next()</code>方法去遍历一组值的集合时，例如，我们通过在长度为 5 的数组<code>[1, 2, 3, 4, 5]</code>上面实现了迭代器。当我们第一次调用<code>next()</code>的时候，会返回<code>1</code>。第二次调用<code>next()</code>返回<code>2</code>,如此下去，当所有的值都返回后，再次调用<code>next()</code>将返回<code>null</code>或者<code>false</code>或其他值，这意味着你已经遍历完真个数组中的值了。</p>
<p>我们是通过和 generator 迭代器进行交互来在 generator 函数外部控制 generator 函数，这听起来比起实际上有些复杂，考虑下面这个愚蠢的（简单的）例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了遍历<code>*foo()</code>generator 函数中的所有值，我们首先需要构建一个迭代器，我们怎么去构建这个迭代器呢？非常简单！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = foo();</span><br></pre></td></tr></table></figure>
<p>如此之简单，我们仅仅想执行普通函数一样执行 generator 函数，其将返回一个迭代器，但是 generator 函数中的代码并不会运行。</p>
<p>这似乎有些奇怪，并且增加了你的理解难度。你甚至会停下来思考，问为什么不通过<code>var it = new foo()</code>的形式来执行 generator 函数呢，这语法后面的原因可能相当复杂并超出了我们的讨论范畴。</p>
<p>好的，现在让我们开始迭代我们的 generator 函数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = it.next();</span><br></pre></td></tr></table></figure>
<p>通过上面的语句，<code>yield</code>表达式将 1 返回到函数外部，但是返回的值可能比想象中会多一些。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>在每一调用<code>next()</code>后，我们实际上从<code>yield</code>表达式的返回值中获取到了一个对象，这个对象中有<code>value</code>字段，就是<code>yield</code>返回的值，同时还有一个布尔类型的<code>done</code>字段，其用来表示 generator 函数是否已经执行完毕。</p>
<p>然我们把迭代执行完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:4, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:5, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>有趣的是，当我们获取到值为<code>5</code>的时候，<code>done</code>字段依然是<code>false</code>。这因为，实际上 generator 函数还么有执行完全，我们还可以再次调用<code>next()</code>。如果我们向函数内部传递一个值，其将被设置为<code>yield 5</code>表达式的返回值，只有在这<strong>时候</strong>，generator 函数才执行完全。</p>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>所以最终结果是，我们迭代执行完我们的 generator 函数，但是最终却没有结果（由于我们已经执行完所有的<code>yield__</code>表达式）。</p>
<p>你可能会想，我能不能在 generator 函数中使用<code>return</code>语句，如果我这样这，返回值会不会在最终的<code>value</code>字段里面呢？</p>
<p><strong>是</strong>…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:2, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>… <strong>不是.</strong></p>
<p>依赖于 generator 函数的最终返回值也许并不是一个最佳实践，因为当我们通过<code>for--of</code>循环来迭代 generator 函数的时候（如下），最终<code>return</code>的返回值将被丢弃（无视）。</p>
<p>为了完整，让我们来看一个同时有双向数据通信的 generator 函数的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> y / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// note: not sending anything into `next()` here</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)); <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)); <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>你可以看到，我们依然可以通过<code>foo(5)</code>传递参数（在例子中是<code>x</code>）给 generator 函数，就像普通函数一样，是的参数<code>x</code>为<code>5</code>.</p>
<p>在第一次执行<code>next(..)</code>的时候，我们并没有传递任何值，为什么？因为在 generator 内部并没有<code>yield</code>表达式来接收我们传递的值。</p>
<p>假如我们真的在第一次调用<code>next(..)</code>的时候传递了值进去，也不会带来什么坏处，它只是将这个传入的值抛弃而已。ES6 表明，generator 函数在这种情况只是忽略了这些没有被用到的值。（<strong>注意</strong>：在写这篇文章的时候，Chrome 和 FF 的每夜版支持这一特性，但是其他浏览有可能没有完全支持这一特性甚至可能会抛出错误）（译者注：文章发布于 2014 年）</p>
<p><code>yield(x + 1)</code>表达式将传递值<code>6</code>到外部，在第二次调用<code>next(12)</code>时候，传递<code>12</code>到 generator 函数内部作为<code>yield(x + 1)</code>表达式的值，因此<code>y</code>被赋值为<code>12 * 2</code>，值为<code>24</code>。接下来，下一条<code>yield(y / 3)</code>(<code>yield (24 / 3)</code>)将向外传递值<code>8</code>。第三次调用<code>next(13)</code>传递<code>13</code>到 generator 函数内部，给<code>yield(y / 3)</code>。是的<code>z</code>被设置为<code>13</code>.</p>
<p>最后，<code>return (x + y + z)</code>就是<code>return (5 + 24 + 13)</code>，也就是<code>42</code>将会作为最终的值返回出去。</p>
<p><strong>重新阅读几遍上面的实例</strong>。最开始有些难以理解。</p>
<h4 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for..of循环"></a><code>for..of</code>循环</h4><p>ES6 在语法层面上大力拥抱迭代器模式，提供了<code>for..of</code>循环来直接支持迭代器的遍历。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(v); <span class="comment">// still `5`, not `6` :(</span></span><br></pre></td></tr></table></figure>
<p>正如你所见，通过调用<code>foo()</code>生成的迭代器通过<code>for..of</code>循环来迭代，循环自动帮你对迭代器进行遍历迭代，每次迭代返回一个值，直到<code>done: true</code>，只要<code>done: false</code>，每次循环都将从<code>value</code>属性上获取到值赋值给迭代的变量（例子中的<code>v</code>）。一旦当<code>done</code>为<code>true</code>。循环迭代结束。（<code>for..of</code>循环不会对 generator 函数最终的 return 值进行处理）</p>
<p>正如你所看到的，<code>for..of</code>循环忽略了 generator 最后的<code>return 6</code>的值，同时，循环没有暴露<code>next()</code>出来，因此我们也不能够向 generator 函数内传递数据。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>OK,上面是关于 generator 函数的基本用法，如果你依然对 generator 函数感到费解，不要担心，我们所有人在一开始感觉都是那样的。</p>
<p>我们很自然的想到这一外来的语法对我们实际代码有什么作用呢？generator 函数有很多作用，我们只是挖掘了其非常粗浅的一部分。在我们发现 generator 函数如此强大之前我们应该更加深入的了解它。</p>
<p>在你练习上面代码片段之后（在 Chrome 或者 FF 每夜版本，或者 0.11+带有<code>--harmony</code>的 node 环境下），下面的问题也许会浮出水面：（译者注：现代浏览器最新版本都已支持 Generator 函数）</p>
<ol>
<li>怎样处理 generator 内部错误？</li>
<li>在 generator 函数内部怎么调用其他 generator 函数？</li>
<li>异步代码怎么和 generator 函数协同工作？</li>
</ol>
<p>这些问题，或者其他的问题都将在随后的文章中覆盖，敬请期待。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 TensorFlow 实现神经网络</title>
    <url>/2017/09/04/2017-09-04-Programing-AI-ML-use-TensorFlow-do-NN/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>　　一直关注 <code>数据科学</code> 、 <code>机器学习</code> 的同学，一定会经常看到或听到关于 <code>深度学习</code> 和 <code>神经网络</code> 相关信息。如果你对 <code>深度学习</code> 感兴趣，但却还没有实际动手操作过，你可以从这里得到实践。 </p>
<p>　　在本文中，我将介绍 <code>TensorFlow</code> , 帮你了解 <code>神经网络</code> 的实际作用，并使用 <code>TensorFlow</code> 来解决现实生活中的问题。 读这篇文章前，需要知道 <code>神经网络</code> 的基础知识和一些熟悉编程理念，文章中的代码是使用 <code>Pyhton</code> 编写的，所以还需要了解一些 <code>Python</code> 的基本语法，才能更有利对于文章的理解。                  </p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#When-to-apply-neural-net">什么时候应用神经网络？</a></li>
<li><a href="#solve-problems">通常神经网络能解决的问题</a></li>
<li><a href="#popular-libraries">了解图像数据和主流的库来解决问题</a></li>
<li><a href="#What-is-TensorFlow">什么是 TensorFlow？</a></li>
<li><a href="#A-typical-flow">TensorFlow 一个 典型 的 “ 流 ”</a></li>
<li><a href="#MLP">在 TensorFlow 中实现 MLP</a></li>
<li><a href="#Limitations-of-TensorFlow">TensorFlow 的限制</a></li>
<li><a href="#vs-libraries">TensorFlow 与其他库</a></li>
<li><a href="#Where-to-go-from-here">从这里去哪里？</a></li>
</ul>
<h3 id="什么时候用神经网络？"><a href="#什么时候用神经网络？" class="headerlink" title="什么时候用神经网络？"></a><a name="When-to-apply-neural-net"></a>什么时候用神经网络？</h3><p>　　<code>神经网络</code> 已经在相当一段时间成为机器学习中的焦点。 对于 <code>神经网络</code> 和 <code>深度学习</code> 上这里有更详细的解释 <a href="https://www.analyticsvidhya.com/blog/2016/08/evolution-core-concepts-deep-learning-neural-networks/" target="_blank" rel="noopener">点击阅读</a> 。 其 “更深” 的功能在许多领域都有取得巨大的突破，如图像识别，语音和自然语言处理等。</p>
<p>　　主要的问题在于如何用好 <code>神经网络</code> ？现在，每天都会有许多新发现，这个领域就像一个金矿，为了成为这个 “淘金热” 的一部分，必须记住几件事：</p>
<ul>
<li><p><strong>首先，<code>神经网络</code> 需要有明确和翔实的数据（主要是大数据）训练</strong>， 试着想象 <code>神经网络</code> 作为一个孩子，它一开始会观察它父母走路，然后它试图自己走，每一步就像学习执行一个特定的任务。 它可能会失败几次，但经过几次失败的尝试，它将会如何走路。所以需要为孩子提供更多的机会，如果不让它走，它可能永远不会学习如何走路。</p>
</li>
<li><p><strong>一些人会利用 <code>神经网络</code> 解决复杂的问题，如图像处理，</strong>  <code>神经网络</code> 属于一类代表学习的算法，这些算法可以把复杂的问题分解为简单的形式，使他们成为可以理解的（或 “可表示”），就像吞咽食物之前的咀嚼，让我们更容易吸收和消化。这个分解的过程如果使用传统的算法来实现也可以，但是实现过程将会很困难。</p>
</li>
<li><p><strong>选择适当类型的 <code>神经网络</code> ，来解决问题，</strong>  每个问题的复杂情况都不一样，所以数据决定你解决问题的方式。 例如，如果问题是序列生成的问题，<code>递归神经网络</code> 更合适。如果它是图像相关的问题，想更好地解决可以采取 <code>卷积神经网络</code>。</p>
</li>
<li><p><strong>最后最重要的就是 <code>硬件</code> 要求了，硬件是运行 <code>神经网络</code> 模型的关键。</strong> 神经网被 “发现” 很久以前，他们在近年来得到推崇的主要的原因就是计算资源更好，能更大发挥它的光芒，如果你想使用 <code>神经网络</code> 解决这些现实生活中的问题，那么你得准备购买一些高端的硬件了😆！</p>
</li>
</ul>
<h3 id="通常神经网络解决的问题"><a href="#通常神经网络解决的问题" class="headerlink" title="通常神经网络解决的问题"></a><a name="solve-problems"></a>通常神经网络解决的问题</h3><p>　　神经网络是一种特殊类型的 机器学习（ML）算法。 因此，作为每个 ML 算法都遵循 数据预处理 、模型建立 和 模型评估 的工作流流程。为了简明起见，下面列出了如何处理 <code>神经网络</code> 问题的 TODO 列表。</p>
<ul>
<li>检查它是否为 神经网络 ，把它看成一个传统的算法问题</li>
<li>做一个调查，哪个 神经网络 框架最适合解决这个问题</li>
<li>定义 神经网络 框架，通过它选择对应的 编程语言 和 库</li>
<li>将数据转换为正确的格式并分批分割</li>
<li>根据您的需要预处理数据</li>
<li>增强数据以增加大小并制作更好的训练模型</li>
<li>批次供给到 神经网络</li>
<li>训练和监测，培训和验证数据集的变化</li>
<li>测试你的模型，并保存以备将来使用</li>
</ul>
<p>　　本文将专注于图像数据，我们从 TensorFlow 入手。</p>
<h3 id="了解图像数据和主流的库来解决问题"><a href="#了解图像数据和主流的库来解决问题" class="headerlink" title="了解图像数据和主流的库来解决问题"></a><a name="popular-libraries"></a>了解图像数据和主流的库来解决问题</h3><p>　　图像大多排列为 3-D 阵列，具体指 高度、宽度 和 颜色通道。例如，如果你使用电脑截屏，它将首先转换成一个 3-D 数组，然后压缩它为 ‘.jpeg’ 或 ‘.png’ 文件格式。</p>
<p>　　虽然这些图像对于人类来说很容易理解，但计算机很难理解它们。 这种现象称为“语义空隙”。我们的大脑可以看看图像，并在几秒钟内读懂完整的图片。但计算机会将图像看作一个数字数组，问题来了，它想知道这是一张什么样的图像，我们应该怎么样把图像解释给机器它才能读懂？</p>
<p>　　在早期，人们试图将图像分解为机器的 “可理解” 格式，如“模板”。例如，面部总是具有在每个人中有所保留的特定结构，例如眼睛，鼻子或我们的脸的形状。 但是这种方法将是有缺陷的，因为当要识别的对象的数量将增加到一定量级时，“模板” 将不成立。</p>
<p>　　2012年一个深层神经网络架构赢得了 ImageNet 的挑战，从自然场景中识别对象，它在即将到来的 ImageNet 挑战中继续统治其主权，从而证明了解决图像问题的有用性。<br>人们通常使用哪些 库 / 语言 来解决图像识别问题？</p>
<p>最流行的库举几个例子：</p>
<ul>
<li><a href="http://caffe.berkeleyvision.org/" target="_blank" rel="noopener">Caffe</a></li>
<li><a href="http://deeplearning4j.org/" target="_blank" rel="noopener">DeepLearning4j</a></li>
<li><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a></li>
<li><a href="http://www.deeplearning.net/software/theano" target="_blank" rel="noopener">Theano</a></li>
<li><a href="http://torch.ch/" target="_blank" rel="noopener">Torch</a></li>
</ul>
<p>现在，我们了解了图像的存储方式以及使用的常用库，让我们看看 <code>TensorFlow</code> 提供的功能。</p>
<h3 id="什么是-TensorFlow-？"><a href="#什么是-TensorFlow-？" class="headerlink" title="什么是 TensorFlow ？"></a><a name="What-is-TensorFlow"></a>什么是 TensorFlow ？</h3><p>让我们从官方定义开始.</p>
<p>　　“<code>TensorFlow</code> 是一个开源软件库，用于使用数据流图进行数值计算。图中的节点表示数学运算，而图边表示在它们之间传递的多维数据阵列（也称为张量）。 灵活的架构允许您使用单一 API 将计算部署到桌面、服务器或移动设备中的一个或多个的 CPU 或 GPU 中。</p>
<p><img src="http://www.tensorfly.cn/images/tensors_flowing.gif" alt>     </p>
<p>　　如果感觉这听起来太高大上，不要担心。这里有我简单的定义，<code>TensorFlow</code> 看起来没什么，只是 numpy 有些难以理解。如果你以前使用过 numpy ，理解 TensorFlow 将是手到擒来！ numpy 和 TensorFlow 之间的主要区别是 TensorFlow 遵循惰性编程范例。</p>
<p>TensorFlow 的操作基本上都是对 session 的操作，它首先构建一个所有操作的图形，当我们调用 session 时 TensorFlow 就开始工作了。它通过将内部数据表示转换为张量（Tensor，也称为多维数组）来构建为可扩展的。 构建计算图可以被认为是 TensorFlow 的主要成分。</p>
<p>　　通过上面的介绍，很容易将 TensorFlow 分类为神经网络库，但它不仅仅是如此。它被设计成一个强大的神经网络库， 但它有能力做更多的事情。可以构建它为其他机器学习算法，如 决策树 或 k-最近邻，你可以从字面上理解，你可以做一切你在 numpy 上能做的事情！我们暂且称它为 “全能的 numpy” 。</p>
<p><strong>使用 TensorFlow 的优点是：</strong></p>
<ul>
<li><strong>它有一个直观的结构</strong> ，顾名思义它有 “张量流”，你可以轻松地可视每个图中的每一个部分。</li>
<li><strong>轻松地在 cpu / gpu 上进行分布式计算</strong> </li>
<li><strong>平台的灵活性</strong>  。可以随时随地运行模型，无论是在移动端、服务器还是 PC 上。</li>
</ul>
<h3 id="TensorFlow-的典型-“流”"><a href="#TensorFlow-的典型-“流”" class="headerlink" title="TensorFlow 的典型 “流”"></a><a name="A-typical-flow"></a>TensorFlow 的典型 “流”</h3><p>　　每个库都有自己的“实现细节”，即一种写其遵循其编码范例的方式。 例如，当实现 scikit-learn 时，首先创建所需算法的对象，然后在训练和测试集上构建一个模型获得预测，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># define hyperparamters of ML algorithm</span></span><br><span class="line">clf = svm.SVC(gamma=<span class="number">0.001</span>, C=<span class="number">100.</span>)</span><br><span class="line"><span class="comment"># train </span></span><br><span class="line">clf.fit(X, y)</span><br><span class="line"><span class="comment"># test </span></span><br><span class="line">clf.predict(X_test)</span><br></pre></td></tr></table></figure>
<p>正如我前面所说，TensorFlow 遵循一种懒惰的方法。 在 TensorFlow 中运行程序的通常工作流程如下：</p>
<ul>
<li><strong>建立一个计算图</strong>， 任何的数学运算可以使用 TensorFlow 支撑。</li>
<li><strong>初始化变量</strong>， 编译预先定义的变量   </li>
<li><strong>创建 session</strong>， 这是神奇的开始的地方 ！  </li>
<li><strong>在 session 中运行图</strong>， 编译图形被传递到 session ，它开始执行它。</li>
<li><strong>关闭 session</strong>， 结束这次使用。</li>
</ul>
<p>TensoFlow 中使用的术语很少 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">placeholder：将数据输入图形的一种方法</span><br><span class="line">feed_dict：将数值传递到计算图的字典</span><br></pre></td></tr></table></figure>
<p>让我们写一个小程序来添加两个数字！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># import tensorflow</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># build computational graph</span><br><span class="line">a = tf.placeholder(tf.int16)</span><br><span class="line">b = tf.placeholder(tf.int16)</span><br><span class="line"></span><br><span class="line">addition = tf.add(a, b)</span><br><span class="line"></span><br><span class="line"># initialize variables</span><br><span class="line">init = tf.initialize_all_variables()</span><br><span class="line"></span><br><span class="line"># create session and run the graph</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    print &quot;Addition: %i&quot; % sess.run(addition, feed_dict=&#123;a: 2, b: 3&#125;)</span><br><span class="line"></span><br><span class="line"># close session</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure>
<h3 id="在-TensorFlow-中实现神经网络"><a href="#在-TensorFlow-中实现神经网络" class="headerlink" title="在 TensorFlow 中实现神经网络"></a><a name="MLP"></a>在 TensorFlow 中实现神经网络</h3><p><em>注意：我们可以使用不同的神经网络体系结构来解决这个问题，但是为了简单起见，我们在深入实施中讨论 <code>前馈多层感知器</code>。</em></p>
<p>让我们记住对神经网络的了解。</p>
<p>神经网络的典型实现如下：</p>
<ul>
<li>定义要编译的神经网络体系结构</li>
<li>将数据传输到模型</li>
<li>整个运行中，数据首先被分成批次，以便它可以被摄取。首先对批次进行预处理，扩增，然后送入神经网络进行训练</li>
<li>然后，模型被逐步地训练</li>
<li>显示特定数量的时间步长的精度</li>
<li>训练后保存模型供将来使用</li>
<li>在新数据上测试模型并检查其运行方式</li>
</ul>
<p>在这里，我们解决了我们深刻的学习实践中的问题 - [识别数字]，让再我们花一点时间看看问题陈述。</p>
<p>　　我们的问题是图像识别，以识别来自给定的 28×28 图像的数字。 我们有一个图像子集用于训练，其余的用于测试我们的模型。首先下载训练和测试文件。数据集包含数据集中所有图像的压缩文件， train.csv 和 test.csv 都有相应的训练和测试图像的名称。数据集中不提供任何其他功能，只是原始图像以 “.png” 格式提供。</p>
<p>　　如之前说的，我们将使用 TensorFlow 来创建一个神经网络模型。 所以首先在你的系统中安装 TensorFlow 。 请参考 <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/g3doc/get_started/os_setup.md" target="_blank" rel="noopener">官方的安装指南</a> 进行安装，按您的系统规格。</p>
<p>我们将按照上述模板</p>
<ul>
<li>让我们来 导入所有需要的模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%pylab inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure>
<ul>
<li>让我们来 设置一个种子值，这样我们就可以控制我们的模型随机性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># To stop potential randomness</span></span><br><span class="line">seed = <span class="number">128</span></span><br><span class="line">rng = np.random.RandomState(seed)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一步是设置目录路径，以便保管！</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root_dir = os.path.abspath(<span class="string">'../..'</span>)</span><br><span class="line">data_dir = os.path.join(root_dir, <span class="string">'data'</span>)</span><br><span class="line">sub_dir = os.path.join(root_dir, <span class="string">'sub'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># check for existence</span></span><br><span class="line">os.path.exists(root_dir)</span><br><span class="line">os.path.exists(data_dir)</span><br><span class="line">os.path.exists(sub_dir)</span><br></pre></td></tr></table></figure>
<ul>
<li>现在让我们读取我们的数据集，这些是 .csv 格式，并有一个文件名以及相应的标签</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">train = pd.read_csv(os.path.join(data_dir，<span class="string">'Train'</span>，<span class="string">'train.csv'</span>))</span><br><span class="line">test = pd.read_csv(os.path.join（data_dir，<span class="string">'Test.csv'</span>))</span><br><span class="line">sample_submission = pd.read_csv(os.path.join(data_dir，<span class="string">'Sample_Submission.csv'</span>))</span><br><span class="line">train.head()</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">文件名</th>
<th style="text-align:right">标签</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">0.png</td>
<td style="text-align:right">4</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">1.png</td>
<td style="text-align:right">9</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">2.png</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">3.png</td>
<td style="text-align:right">7</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">4.png</td>
<td style="text-align:right">3</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>让我们看看我们的数据是什么样子！我们读取我们的形象并显示出来。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">img_name = rng.choice(train.filename)</span><br><span class="line">filepath = os.path.join(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'train'</span>, img_name)</span><br><span class="line"></span><br><span class="line">img = imread(filepath, flatten=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">pylab.imshow(img, cmap=<span class="string">'gray'</span>)</span><br><span class="line">pylab.axis(<span class="string">'off'</span>)</span><br><span class="line">pylab.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/3.png" alt>       </p>
<p>上面的图像表示为 numpy 数组，如下所示</p>
<p><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/one.png" alt>       </p>
<ul>
<li>为了方便数据操作，让我们 的存储作为 numpy 的阵列的所有图片</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">temp = []</span><br><span class="line"><span class="keyword">for</span> img_name <span class="keyword">in</span> train.filename:</span><br><span class="line">    image_path = os.path.join(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'train'</span>, img_name)</span><br><span class="line">    img = imread(image_path, flatten=<span class="literal">True</span>)</span><br><span class="line">    img = img.astype(<span class="string">'float32'</span>)</span><br><span class="line">    temp.append(img)</span><br><span class="line">    </span><br><span class="line">train_x = np.stack(temp)</span><br><span class="line"></span><br><span class="line">temp = []</span><br><span class="line"><span class="keyword">for</span> img_name <span class="keyword">in</span> test.filename:</span><br><span class="line">    image_path = os.path.join(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'test'</span>, img_name)</span><br><span class="line">    img = imread(image_path, flatten=<span class="literal">True</span>)</span><br><span class="line">    img = img.astype(<span class="string">'float32'</span>)</span><br><span class="line">    temp.append(img)</span><br><span class="line">    </span><br><span class="line">test_x = np.stack(temp)</span><br></pre></td></tr></table></figure>
<ul>
<li>由于这是典型的 ML 问题，为了测试我们的模型的正确功能，我们创建一个验证集，让我们以 70:30 的分割训练集 和 验证集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">split_size = int(train_x.shape[<span class="number">0</span>]*<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">train_x, val_x = train_x[:split_size], train_x[split_size:]</span><br><span class="line">train_y, val_y = train.label.values[:split_size], train.label.values[split_size:]</span><br></pre></td></tr></table></figure>
<ul>
<li>我们定义一些辅助函数，我们稍后在我们的程序中使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dense_to_one_hot</span><span class="params">(labels_dense, num_classes=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Convert class labels from scalars to one-hot vectors"""</span></span><br><span class="line">    num_labels = labels_dense.shape[<span class="number">0</span>]</span><br><span class="line">    index_offset = np.arange(num_labels) * num_classes</span><br><span class="line">    labels_one_hot = np.zeros((num_labels, num_classes))</span><br><span class="line">    labels_one_hot.flat[index_offset + labels_dense.ravel()] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> labels_one_hot</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preproc</span><span class="params">(unclean_batch_x)</span>:</span></span><br><span class="line">    <span class="string">"""Convert values to range 0-1"""</span></span><br><span class="line">    temp_batch = unclean_batch_x / unclean_batch_x.max()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp_batch</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_creator</span><span class="params">(batch_size, dataset_length, dataset_name)</span>:</span></span><br><span class="line">    <span class="string">"""Create batch with random samples and return appropriate format"""</span></span><br><span class="line">    batch_mask = rng.choice(dataset_length, batch_size)</span><br><span class="line">    </span><br><span class="line">    batch_x = eval(dataset_name + <span class="string">'_x'</span>)[[batch_mask]].reshape(<span class="number">-1</span>, <span class="number">784</span>)</span><br><span class="line">    batch_x = preproc(batch_x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> dataset_name == <span class="string">'train'</span>:</span><br><span class="line">        batch_y = eval(dataset_name).ix[batch_mask, <span class="string">'label'</span>].values</span><br><span class="line">        batch_y = dense_to_one_hot(batch_y)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> batch_x, batch_y</span><br></pre></td></tr></table></figure>
<ul>
<li>主要部分！ 让我们定义我们的神经网络架构。 我们定义一个神经网络具有 3 层，输入、隐藏 和 输出， 输入和输出中的神经元数目是固定的，因为输入是我们的 28×28 图像，并且输出是表示类的 10×1 向量。 我们在隐藏层中取 500 神经元。这个数字可以根据你的需要变化。我们把值 赋给 其余变量。 可以阅读 <a href="https://www.analyticsvidhya.com/blog/2016/03/introduction-deep-learning-fundamentals-neural-networks/" target="_blank" rel="noopener">神经网络的基础知识的文章</a> ，以更深的了解它是如何工作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### set all variables</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># number of neurons in each layer</span></span><br><span class="line"></span><br><span class="line">input_num_units = <span class="number">28</span>*<span class="number">28</span></span><br><span class="line"></span><br><span class="line">hidden_num_units = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">output_num_units = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define placeholders</span></span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="literal">None</span>, input_num_units])</span><br><span class="line">y = tf.placeholder(tf.float32, [<span class="literal">None</span>, output_num_units])</span><br><span class="line"></span><br><span class="line"><span class="comment"># set remaining variables</span></span><br><span class="line">epochs = <span class="number">5</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### define weights and biases of the neural network (refer this article if you don't understand the terminologies)</span></span><br><span class="line"></span><br><span class="line">weights = &#123;</span><br><span class="line">    <span class="string">'hidden'</span>: tf.Variable(tf.random_normal([input_num_units, hidden_num_units], seed=seed)),</span><br><span class="line">    <span class="string">'output'</span>: tf.Variable(tf.random_normal([hidden_num_units, output_num_units], seed=seed))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">biases = &#123;</span><br><span class="line">    <span class="string">'hidden'</span>: tf.Variable(tf.random_normal([hidden_num_units], seed=seed)),</span><br><span class="line">    <span class="string">'output'</span>: tf.Variable(tf.random_normal([output_num_units], seed=seed))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>现在创建我们的神经网络计算图</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">hidden_layer = tf.add(tf.matmul(x, weights[<span class="string">'hidden'</span>]), biases[<span class="string">'hidden'</span>])</span><br><span class="line">hidden_layer = tf.nn.relu(hidden_layer)</span><br><span class="line"></span><br><span class="line">output_layer = tf.matmul(hidden_layer, weights[<span class="string">'output'</span>]) + biases[<span class="string">'output'</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>此外，我们需要定义神经网络的成本</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output_layer, y))</span><br></pre></td></tr></table></figure>
<ul>
<li>设置优化器，即我们的反向传播算法。 这里我们使用 <a href="https://arxiv.org/abs/1412.6980" target="_blank" rel="noopener">Adam</a> ，这是梯度下降算法的高效变体。 有在 tensorflow 可用许多其它优化（参照 <a href="https://www.tensorflow.org/versions/r0.11/api_docs/python/train.html#optimizers" target="_blank" rel="noopener">此处</a> ）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(cost)</span><br></pre></td></tr></table></figure>
<ul>
<li>定义我们的神经网络结构后，让我们来 初始化所有的变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">init = tf.initialize_all_variables()</span><br></pre></td></tr></table></figure>
<ul>
<li>现在让我们创建一个 Session ，并在 Session 中运行我们的神经网络。我们还验证我们创建的验证集的模型准确性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># create initialized variables</span></span><br><span class="line">    sess.run(init)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">### for each epoch, do:</span></span><br><span class="line">    <span class="comment">###   for each batch, do:</span></span><br><span class="line">    <span class="comment">###     create pre-processed batch</span></span><br><span class="line">    <span class="comment">###     run optimizer by feeding batch</span></span><br><span class="line">    <span class="comment">###     find cost and reiterate to minimize</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        avg_cost = <span class="number">0</span></span><br><span class="line">        total_batch = int(train.shape[<span class="number">0</span>]/batch_size)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(total_batch):</span><br><span class="line">            batch_x, batch_y = batch_creator(batch_size, train_x.shape[<span class="number">0</span>], <span class="string">'train'</span>)</span><br><span class="line">            _, c = sess.run([optimizer, cost], feed_dict = &#123;x: batch_x, y: batch_y&#125;)</span><br><span class="line">            </span><br><span class="line">            avg_cost += c / total_batch</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Epoch:"</span>, (epoch+<span class="number">1</span>), <span class="string">"cost ="</span>, <span class="string">"&#123;:.5f&#125;"</span>.format(avg_cost)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nTraining complete!"</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># find predictions on val set</span></span><br><span class="line">    pred_temp = tf.equal(tf.argmax(output_layer, <span class="number">1</span>), tf.argmax(y, <span class="number">1</span>))</span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(pred_temp, <span class="string">"float"</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Validation Accuracy:"</span>, accuracy.eval(&#123;x: val_x.reshape(<span class="number">-1</span>, <span class="number">784</span>), y: dense_to_one_hot(val_y.values)&#125;)</span><br><span class="line">    </span><br><span class="line">    predict = tf.argmax(output_layer, <span class="number">1</span>)</span><br><span class="line">    pred = predict.eval(&#123;x: test_x.reshape(<span class="number">-1</span>, <span class="number">784</span>)&#125;)</span><br></pre></td></tr></table></figure>
<p>这将是上面代码的输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Epoch: <span class="number">1</span> cost = <span class="number">8.93566</span></span><br><span class="line">Epoch: <span class="number">2</span> cost = <span class="number">1.82103</span></span><br><span class="line">Epoch: <span class="number">3</span> cost = <span class="number">0.98648</span></span><br><span class="line">Epoch: <span class="number">4</span> cost = <span class="number">0.57141</span></span><br><span class="line">Epoch: <span class="number">5</span> cost = <span class="number">0.44550</span></span><br><span class="line"></span><br><span class="line">Training complete!</span><br><span class="line">Validation Accuracy: <span class="number">0.952823</span></span><br></pre></td></tr></table></figure>
<ul>
<li>验证我们自己的眼睛，让我们来 想象它的预言</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">img_name = rng.choice(test.filename)</span><br><span class="line">filepath = os.path.join(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'test'</span>, img_name)</span><br><span class="line"></span><br><span class="line">img = imread(filepath, flatten=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">test_index = int(img_name.split(<span class="string">'.'</span>)[<span class="number">0</span>]) - <span class="number">49000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Prediction is: "</span>, pred[test_index]</span><br><span class="line"></span><br><span class="line">pylab.imshow(img, cmap=<span class="string">'gray'</span>)</span><br><span class="line">pylab.axis(<span class="string">'off'</span>)</span><br><span class="line">pylab.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Prediction <span class="keyword">is</span>:  <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/8.png" alt></p>
<ul>
<li>我们看到的模型性能是相当不错！ 现在让我们 创建一个提交</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sample_submission.filename = test.filename</span><br><span class="line"> </span><br><span class="line">sample_submission.label = pred</span><br><span class="line"></span><br><span class="line">sample_submission.to_csv(os.path.join(sub_dir, <span class="string">'sub01.csv'</span>), index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>　　终于完成了！ 我们刚刚创建了自己的训练神经网络！</p>
<h3 id="TensorFlow-的限制"><a href="#TensorFlow-的限制" class="headerlink" title="TensorFlow 的限制"></a><a name="Limitations-of-TensorFlow"></a>TensorFlow 的限制</h3><ul>
<li>尽管 TensorFlow 是强大的，它仍然是一个低水平库，例如，它可以被认为是机器级语言，但对于大多数功能，您需要自己去模块化和高级接口，如 keras</li>
<li>它仍然在继续开发和维护，这是多么👍啊！</li>
<li>它取决于你的硬件规格，配置越高越好</li>
<li>不是所有变成语言能使用它的 API 。</li>
<li>TensorFlow 中仍然有很多库需要手动导入，比如 OpenCL 支持。</li>
</ul>
<p>上面提到的大多数是在 TensorFlow 开发人员的愿景，他们已经制定了一个路线图，计划库未来应该如何开发。</p>
<h3 id="TensorFlow-与其他库"><a href="#TensorFlow-与其他库" class="headerlink" title="TensorFlow 与其他库"></a><a name="vs-libraries"></a>TensorFlow 与其他库</h3><p>　　TensorFlow 建立在类似的原理，如使用数学计算图表的 Theano 和 Torch，但是随着分布式计算的额外支持，TensorFlow 更好地解决复杂的问题。 此外，TensorFlow 模型的部署已经被支持，这使得它更容易用于工业目的，打开一些商业的三方库，如 Deeplearning4j ，H2O 和 Turi。 TensorFlow 有用于 Python，C ++ 和 Matlab 的 API 。 最近还出现了对 Ruby 和 R 等其他语言的支持。因此，TensorFlow 试图获得通用语言支持。</p>
<h3 id="从这里去哪里？"><a href="#从这里去哪里？" class="headerlink" title="从这里去哪里？"></a><a name="Where-to-go-from-here"></a>从这里去哪里？</h3><p>　　以上你看到了如何用 TensorFlow 构建一个简单的神经网络，这段代码是为了让人们了解如何开始实现 TensorFlow。 要解决更复杂的现实生活中的问题，你必须在这篇文章的基础上在调整一些代码才行。</p>
<p>　　许多上述功能可以被抽象为给出无缝的端到端工作流，如果你使用 scikit-learn ，你可能知道一个高级库如何抽象“底层”实现，给终端用户一个更容易的界面。尽管 TensorFlow 已经提取了大多数实现，但是也有更高级的库，如 TF-slim 和 TFlearn。</p>
<h3 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h3><ul>
<li><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFlow 官方库</a> </li>
<li>Rajat Monga（TensorFlow负责人） <a href="https://youtu.be/wmw8Bbb_eIE" target="_blank" rel="noopener">“TensorFlow为大家”</a>  的视频</li>
<li><a href="https://github.com/jtoy/awesome-tensorflow/#github-projects" target="_blank" rel="noopener">一个专用资源的策划列表</a>  </li>
</ul>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>AI</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>「体能训练理论」之金字塔</title>
    <url>/2017/08/17/2017-08-17-Life-Exercise-Pyramid/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>体能，人体基础运动能力的统称，人体的本质属性，它支撑着日常生活工作的需要，也支撑着运动技战术的表现。 </p>
<p>体能思路，是指导我们设计实施体能训练的思维方式，分析逻辑。</p>
<h2 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h2><p>体能训练是一门实践科学，实践先于理论，而理论印证实践。体能训练有四大基础学科，分别是运动解剖学、运动生理学、运动生物力学和运动训练学。</p>
<p>五大运动素质对应生理学和运动训练学；动力链对应解剖学和运动生物力学；功能性对应着生理和生物力。而金字塔则对应了它们全部！或者说金字塔其实是诸学科在体能训练中的交汇，它囊括了所有之前的理论，并且赋予了更深层的意义。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fhg20ydk8uj30go0brwh1.jpg" alt></p>
<p>金字塔代表了人体运动能力发展的客观规律，它是一个流程的引领，思维的分级，以及训练阶段的划分。</p>
<p>这里包括 <strong>关节功能+核心控制</strong>、<strong>基础动作模式</strong>、<strong>基础力量</strong>、<strong>综合体能</strong>、<strong>专项运动</strong>。他们在逻辑上互为基础和进阶，关节是动作的基础，动作承载力量，力量支撑各个运动素质，而专项是各个运动素质在具体运动中的表现。</p>
<p>也许这么说可能不能够让大家有清晰的认识，那么接下来我就把每层的内容和它们之间的逻辑关系简单的跟大家分享一下。 99%的运动者都是基础不足，上层过度。我们从基础开始，从下往上说起。</p>
<h3 id="运动基础（关节功能-核心控制）"><a href="#运动基础（关节功能-核心控制）" class="headerlink" title="运动基础（关节功能 + 核心控制）"></a>运动基础（关节功能 + 核心控制）</h3><p>运动基础主要内容包括 <strong>关节功能</strong> 和 <strong>核心控制</strong> 能力。<br><a id="more"></a><br>人体的关节功能有两个属性，一个是灵活性，一个是稳定性。举例来说，很多人由于长期缺乏锻炼，肩关节灵活性缺失，第一次学习竖直上举时，怎么努力都举不到头顶，显然应该先改善肩关节灵活性。再比如，膝关节的结构导致它只能进行屈伸的运动，所以我们要保证运动过程中不出现膝内扣，膝外翻的现象，也就是膝关节需要具备的稳定能力。在健身之前我们，应该先评估我们的关节功能。</p>
<p>运动基础中的第二部分内容就是核心控制能力。很多健身者入门者都会觉得核心是腹肌，觉得练核心的目的是拥有一个好看的腹肌。实际上，腹肌只是核心的一部分，核心是指一个区域，我们的整个躯干都属于核心区域。</p>
<p>运动的外在表现虽来源于四肢，比如跑步时你的四肢在运动，但是一个出色的外在运动表现是建立在稳定的核心基础之上的。如果躯干不稳定，在跑步的过程中整个脊柱很松散，甩来甩去，这样是很难提高跑步速度的。所以在学习动作之前，应该先加强核心控制能力。</p>
<p>所以我们会推荐没有进行过抗阻训练、长期久坐的同学先去练习一段时间的瑜伽和普拉提，瑜伽可以很好地改善关节灵活性，进而提高身体的柔韧性；而普拉提能提高的核心控制能力，并提高关节稳定性。<br>一个合格的健身训练者，应该了解不同的训练体系，他要知道自身还缺乏什么，然后向不同的训练体系去借鉴，以提高自己。</p>
<h3 id="基础动作模式"><a href="#基础动作模式" class="headerlink" title="基础动作模式"></a>基础动作模式</h3><h4 id="什么是基础动作模式？"><a href="#什么是基础动作模式？" class="headerlink" title="什么是基础动作模式？"></a>什么是基础动作模式？</h4><p>简单地说就是，所有动作肢体特有的运动程序。人体就这么些零件，所以很多的动作之间都存在着些许的共性，我们将这些共性提炼出来并进行功能上的抽象，那么就形成了我们现在所要说的基础动作模式——<strong>双腿蹲</strong>、<strong>单腿蹲</strong>、<strong>推</strong>、<strong>拉</strong>、<strong>旋转</strong>、<strong>屈髋</strong>。</p>
<ul>
<li><strong>蹲</strong>：分为单腿蹲、双腿蹲。对应的训练动作有剪蹲和深蹲。</li>
<li><strong>推</strong>：分为水平推、竖直推。对应的训练动作是卧推和实力举。</li>
<li><strong>拉</strong>：分为竖直拉、水平拉。竖直拉包括引体向上、高位下拉，水平拉包括弹力带划船等等。</li>
<li><strong>屈髋</strong>：最具代表性的动作就是硬拉。</li>
<li><strong>旋转</strong>：动作比较复杂，在训练当中比较少出现，适合比较资深的训练者，比如说劈和砍，比如下劈球，比如拿锤子砸轮胎。前期不建议做，当你有一定训练水平的时候再去做旋转类动作。</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fhg20yeticj30go0ptdmg.jpg" alt></p>
<h4 id="基础动作模式的意义是什么？"><a href="#基础动作模式的意义是什么？" class="headerlink" title="基础动作模式的意义是什么？"></a>基础动作模式的意义是什么？</h4><ol>
<li>教会我们如何正确的使用我们的身体</li>
<li>评估你的是否存在关节功能缺陷</li>
</ol>
<p>基于基础动作模式的学习意义和诊断意义，我们对待健身者或者需要进行体能训练的人很多时候都从这里开始。如果诊断结果良好，那么我们学习动作之后就可以上升到基础力量训练，如果诊断出关节功能缺陷，我们就要进行针对性的解决。</p>
<h3 id="基础力量（肌肉力量）"><a href="#基础力量（肌肉力量）" class="headerlink" title="基础力量（肌肉力量）"></a>基础力量（肌肉力量）</h3><p>力量是所有运动素质的基础，如果你没有足够的力量，很多事情都很难完成。你想学习倒立，如果上肢力量足够，只需要了解动作技巧和细节，可能半个小时就能学会倒立。但是如果力量水平很低，就算把各种技巧和细节都学会了，也没有力气把自身撑起来，更不可能完成倒立。日常生活中，力量水平不足经常会成为我们突破运动瓶颈的障碍，有足够的力量才能跑得更快、跑得更远、跳得更高。所以，力量是所有运动素质的基础。</p>
<p>因此，在金字塔的这层，我们就要从徒手训练的阶段进阶到自由力量训练的阶段。负重和徒手的训练效果差异非常大，它不仅仅在于力量的提高，在重心控制、身体平衡、协调性控制等方面的区别也很大。力量训练能让身体各项能力同时提高，只有真正进入力量训练阶段（对于健身来说），才可以说真正踏上健身入门之路。</p>
<h3 id="训练目标（综合体能和专项体能）"><a href="#训练目标（综合体能和专项体能）" class="headerlink" title="训练目标（综合体能和专项体能）"></a>训练目标（综合体能和专项体能）</h3><p>最后，我们来到了金字塔的顶端，这就是我们的最终追求。</p>
<p>综合体能在此指的是体能所包含的五大运动素质——力量，速度，灵敏，耐力，柔韧。对于有专项运动需求的人，我们需要有针对性的重点发展这五大运功素质中的某几个。</p>
<p>当我们身体各关节灵活性和稳定性都可以满足要求，且核心控制能力也很强的情况下，又在标准动作的基础上储备了足够的肌肉力量，那么，不管你的目标是减肥，增肌，或者是进行某一个竞技性运动项目，你都可以相对安全且轻松地达成你的目标。</p>
<p>一般我们把还处在第一第二层的健身者称为健身入门者。不管你是刚刚走进健身房的新手，还是健身多年的老司机，都可以根据这个健身发展流程来审视自己目前的训练处在哪一个阶段。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>体能训练金字塔告诉我们，体能训练要从关节功能和核心控制开始训练，通过六大基础运动模式的训练增强身体基础力量，只有基础力量够了，我们才能真正开始我们的训练目标，根据我们训练的项目增强专项体能，比如拳击，我们要增强力量，耐力，灵敏。</p>
<p>清楚了这个体能训练金字塔之后，更重要的事还是要去执行。执行层面会涉及更多技术问题，也就是我们常说的如何做标准的动作，如何制定适合自己的训练计划等等。</p>
<p>健身是一项系统性工程，愿每一个人都能找到方法，科学有效地塑造自己的身体。</p>
<blockquote>
<p>参考 </p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/20801623" target="_blank" rel="noopener">《体能训练之金字塔》</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>锻炼</category>
      </categories>
      <tags>
        <tag>锻炼</tag>
        <tag>日常生活</tag>
      </tags>
  </entry>
  <entry>
    <title>「体能训练理论」之动力链</title>
    <url>/2017/08/16/2017-08-16-Life-Exercise-Kinetic-Chain/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>与其说体能训练是一种行为，不如说体能训练是一种程序。只要符合逻辑，就可以自由组合。</p>
<h2 id="动力链"><a href="#动力链" class="headerlink" title="动力链"></a>动力链</h2><p>如果说 <strong>五大运动素质</strong>（力量、速度、耐力、灵敏、柔韧）代表了体能的宏观表现，那么动力链理论则阐释了人体解剖结构在运动中的客观规律，这二者同为人体的本质属性。</p>
<p>动力链这一理论早在1875年就被提出过，当时的定义还很简单，就是指几个相邻的关节所组成的复杂动作单元。后来在不断地实践与研究中，动力链理论也不断的升级，越来越清晰，越来越客观，也越来越复杂，并且逐渐成为了体能训练师们必备的思考工具之一。</p>
<p>来看看动力链的英文解释:</p>
<blockquote>
<p>The concept of the kinetic chain originated in 1875, when a mechanical engineer named Franz Reuleaux proposed that if a series of overlapping segments were connected via pin joints, these interlocking joints would create a system that would allow the movement of one joint to affect the movement of another joint within the kinetic link. Dr. Arthur Steindler adapted this theory in 1955, and included an analysis of human movement. Steindler suggested that the extremities be viewed as a series of rigid, overlapping segments and defined the kinetic chain as a “combination of several successively arranged joints constituting a complex motor unit.” The movements that occur within these segments present as two primary types—open and closed.</p>
</blockquote>
<p>这种模糊形容根本无法让人们理解它真正的内核，虽然它看起来就像是一堆联动的齿轮和杠杆。实际上它也真的很像一堆齿轮和杠杆，有的负责驱动，有的负责传力，有的负责稳定。</p>
<p>为了方便大家理解，下面我要将这个理论拆解开来跟大家分享。<br><a id="more"></a><br>首先，我们需要从以上的定义中提炼出来一些关键词，比如说 “运动”、“几个”、“相邻”等等。那么这几个词分别代表了什么？</p>
<ol>
<li>我们讨论问题的角度是<strong>运动</strong>的；</li>
<li>我们需要考虑的<strong>人体解剖结构</strong>问题；</li>
<li>我们需要考虑相邻关节的<strong>协作关系</strong>；</li>
<li>我们需要分析每一个关节的<strong>使用特点</strong>。</li>
</ol>
<p>所以，它似乎并不能被完美的定义，而是只可意会不可言传。<br> 那么关于动力链，我们需要掌握两个最基本的知识：<strong>动力链模型</strong>、<strong>开链与闭链</strong>。</p>
<h3 id="动力链模型"><a href="#动力链模型" class="headerlink" title="动力链模型"></a>动力链模型</h3><p>在动力链理论中，我们考虑运动的最小单位是<strong>关节</strong>，诸多关节运动的协作产生了整体上的复杂动作。所以每一个关节的功能就决定了整体动作的表现，任何一个关节功能受限都会导致整体动作的失衡。 </p>
<p>而我们所指的关节功能，可以从生物力学角度简单的概括为：</p>
<ul>
<li><strong>灵活</strong>(<strong>M</strong>,Mobility)</li>
<li><strong>稳定</strong>(<strong>S</strong>,Stability)</li>
</ul>
<p>但看起来简单的两个词，其实意义非常。</p>
<h4 id="什么是灵活？"><a href="#什么是灵活？" class="headerlink" title="什么是灵活？"></a>什么是灵活？</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg2avap5sj30ao08rdg4.jpg" alt></p>
<p>很多人的第一反应就是能自由的运动呗~然后部分专业人士可能会想到活动度。但是你的关节如果仅仅具备很好的活动度就能够胜任运动中的需求么？显然是不能的。所以灵活的意义远不止关节活动度，关节活动度仅仅是灵活的基础，而更重要的还有产力的能力。没错，这里的灵活既包括关节主被动活动范围，也包括产力的能力，比如产力的大小，产力的快慢等等。<br> 举个例子：小明的髋关节活动范围非常好，能竖叉能横叉，但是臀大肌并没有很好的力量，所以不能够支撑你的跑步与跳跃，所以此时的髋关节灵活性仍然是不足的，只不过这里强调的是力量的缺失。</p>
<h4 id="什么是稳定？"><a href="#什么是稳定？" class="headerlink" title="什么是稳定？"></a>什么是稳定？</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg2b1gendj30fa08t74f.jpg" alt></p>
<p>稳定就是稳定呗~就是待着不动呗~就是牢固呗~灵活还能说出个关节活动度，而稳定的定义真的让很多人摸不到头脑，因为似乎“稳定”一词已经很好地形容了关节的功能表现。但是实际上我们仍然可以对其进行深究，并且这样做是有意义的，因为表现的不同直接影响训练的手段。</p>
<p>如果我们把“稳定”定义为是一种提供安全性的保护，那么我们就可以假想出两个现象：</p>
<ol>
<li>一个非常贵重的瓷器抱在手中，我不能把它摔碎，所以我抱着不动~</li>
<li>同样是这个非常贵重的瓷器抱在手中，我不能把它摔碎，但是我可以慢慢的把它放在地上。<br>同样是保护瓷器不被摔碎，但是却有两个表现，一个是hold住，另外一个是慢慢的放在地上，一个不动，一个动。所以我们人体关节的稳定也是如此，既包括保持身体姿态，关节位置的相对固定，也包括有控制的缓冲外力，退让做功。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fhg2b6eo7uj30m80h477k.jpg" alt></p>
<p>举个例子：我们的核心区域在运动中应该尽可能的保持姿态的稳定，所以是抱着瓷器不动；我们的膝关节在走路与跑步中从伸到屈，缓冲脚落地产生的冲击力，所以是抱着瓷器往下放。 </p>
<p>在了解了 SM (稳定和灵活)的意义之后，更重要的是明白：这两种并不会孤立的存在，而是相辅相成同时存在的，只不过在人体整体动力链中体现的侧重点不一样，在肢体的协同运动中扮演的角色不一样。比如对于核心区域来说，灵活恰是其稳定的基础，因为不同体位下脊柱的排列形式直接影响稳定的表现。</p>
<p>当 SM 代表了关节功能之后，在人体的整体运动结构中，不同的关节所凸显出来的功能是不同的，并且它们遵循一定的逻辑分布。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fhg2bewsh2j30hs0b0t8y.jpg" alt></p>
<p>从下往上说：</p>
<ol>
<li><p>足弓——稳定</p>
<p> 第一个缓冲冲击力的关节，并且没有多大的关节活动度。</p>
</li>
<li><p>足踝——灵活</p>
<p> “足” “踝”形成了一个稳定与灵活兼备的整体，但是在运动中它是下肢蹬伸最后一个主动发力的关节，并且无时无刻不在调整着身体与地面之间的位置关系，所以在这里我们更强调它的灵活性。</p>
</li>
<li><p>膝关节——稳定</p>
<p> 强大的承重关节，且仅存在屈伸的动作（屈膝位的内外旋的意义是提供可控的缓冲空间，并非叫你主动旋转），更重要的是，无论走路、跑步、跳跃，膝关节都是非常重要的离心缓冲关节。</p>
</li>
<li><p>髋关节——灵活</p>
<p> 强大的发力关节，而且活动范围也非常广泛，它引领着下肢的动作产生。但是由于位置与功能的特殊，所以其稳定性也相当重要，直接可以影响核心的稳定结构，特别是在闭链状态下。</p>
</li>
<li><p>腰椎——稳定</p>
<p> 相对的绝对稳定体。所谓绝对，是因为腰椎所处的位置恰好为核心地带，这里的功能是维持姿态以及为上下肢的运动提供稳定基础，所以要“抱着缸不动”。而所谓相对，是因为不同的体位下腰椎的姿态是需要随之调整的，并不能以不变应万变。</p>
</li>
<li><p>胸椎——灵活</p>
<p> 胸椎的灵活性其实并不好，但是相比于腰椎来说就好太多了，特别是在旋转动作上。在旋转鞭打的动作模式中，胸椎是继下肢产力之后的第一个角速度放大的关节，其灵活程度直接影响了上肢的鞭打效果。当然，在更多的时候胸椎要参与承重，但即便承重，也是以其良好的灵活性为基础的，比如说手臂上举过头负重的动作。</p>
</li>
<li><p>颈椎——稳定</p>
<p> 虽然很灵活，但却需要很稳定！因为头部的位置变化会直接改变身体肌张力的大小分布，这个不仅可以让我们身体姿态发生变化，还会破坏掉本体感觉的准确性。当然，这也是猫在空中可以转体的原因，以及为什么我们打拳的时候不能回头。</p>
</li>
<li><p>肩胛胸关节——稳定</p>
<p> 这是一个很奇葩的关节，从动力链结构上看，它是稳定关节，但稳定的并不是它自己，而是肩关节。在实际运动中，肩胛胸关节和肩关节是联动运动的，而且前者为后者提供稳定性，是后者得以安全展现灵活的基础。但是这个“稳定”恰恰是通过肩胛胸关节本身的灵活性来展现的，比如手臂上举时的上回旋。</p>
</li>
<li><p>肩关节——灵活</p>
<p> 没的说，人体最灵活的关节，也是人体最不稳定的关节，其球窝关节的解剖结构已经说明了一切。</p>
</li>
<li><p>肘关节——稳定</p>
<p>结构上跟膝关节相对，但是实际上要比膝关节灵活的多。所以如果进化论成立的话，人类从四脚着地变成双脚着地的过程，使我们的下肢关节趋向于稳定，上肢关节趋向于灵活。而这正与 “开链”或者“闭链”的需求相适应。</p>
</li>
</ol>
<h3 id="开链-amp-闭链"><a href="#开链-amp-闭链" class="headerlink" title="开链&amp;闭链"></a>开链&amp;闭链</h3><p>我们的关节同时存在S与M，而在整体的运动中有不同的体现，甚至于同样是S或者M的上下肢关节却存在了显著的差别。那么在此我们需要引出一个新的概念：<strong>开链</strong> &amp; <strong>闭链</strong>。</p>
<h4 id="开链"><a href="#开链" class="headerlink" title="开链"></a>开链</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg2bltahoj30dg09h74k.jpg" alt></p>
<p>开链，简单地说就是我们身体产生力量，改变了外界物体的运动状态。比如说哑铃二头弯举，投掷，摘苹果等动作都是开链动作。我们可以认为我们的身体在对抗趋于无穷小的阻力，那么我们就可以随意改变物体的运动状态，随便摆弄它，所以此时我们的肢体的灵活性就可以充分的发挥。比如我们的上肢就是以开链运动为主的，所以它整体表现出更好的灵活性。</p>
<h4 id="闭链"><a href="#闭链" class="headerlink" title="闭链"></a>闭链</h4><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fhg2bq4z76j30fk0dp0tf.jpg" alt></p>
<p>闭链，简单的说就是我们的身体产生力量，却没能推动外界的物体，反而改变了我们自身的运动状态。比如说跑步与深蹲，我们扒地，我们蹬地，并没有让地板产生位移，我们自己却向前或者向上运动了。所以我们可以认为闭链运动时，我们的身体在对抗趋于无穷大的阻力，我们根本不可能改变它，所以只能运动我们自己。而在面对这样无穷大的阻力的时候，我们需要将我们的关节摆在力学结构最优的位置上才能发挥我们自身的最大经济性和效率，而且在这个状态下，各个关节的位置直接影响了身体的整体姿态和状态，所以灵活性被抑制。我们的下肢，最擅长、做的最多的就是闭链运动，所以它更加的趋于稳定。</p>
<p>开链和闭链直接影响我们的训练适应，因为它们所表现的力学结构是不同的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解动力链并不是让我们<strong>装逼</strong>的，而是让我们更加了解人体的客观规律来指导训练的。</p>
<p>它是一个非常好的思考工具。比如我们在训练下肢力量的时候，我们就需要考虑髋关节灵活性对于下肢力量表现的影响，于是乎我们可能更加重点强化髋的产力能力。但是当考虑到屈髋动作时，也许实际中更多的是开链的屈髋，所以我们就能以此为依据来选择髂腰肌和股直肌的训练动作。</p>
<p>除此之外，每个关节本身的功能完整性是非常重要的，如果一个关节有功能缺陷，那么在整体运动中它就不能够尽到它的职责，所以一定会有另外一个或者几个关节来代偿它的功能，那么就相当于一个3人的团队，一个请假了，另外两个就得加班。如果一次两次没关系，它要是请了一年的产假，那么另外俩人可能会由于长期超负荷工作而积劳成疾。当然，对于公司来说我可以再雇人，但是我们的人体可没有能再多长一个关节之说。</p>
<p>所以其实很多跑步膝的问题恰是由于髋和踝的功能缺陷而导致的。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fhg2buv4nwj30ia0a2dfx.jpg" alt></p>
<p><strong>最后我要再次强调</strong>：任何一个关节，稳定与灵活同时存在，只不过体现的程度和侧重不同。在动力链中，灵活的关节不代表没有稳定，更不代表稳定不重要；稳定的关节也需要灵活，而且灵活可能是稳定的基础。</p>
<p>了解了动力链，你会更懂运动中的人体，也许你有了思考问题的方向，但仍然缺少方法，所以你还需要具备<a href="http://qiubaiying.github.io/2017/07/10/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA-%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%80%A7/" target="_blank" rel="noopener">「功能性」</a>的思维方式。</p>
<blockquote>
<p>转自 <a href="https://zhuanlan.zhihu.com/p/20774747" target="_blank" rel="noopener">《体能训练之动力链》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>锻炼</category>
      </categories>
      <tags>
        <tag>锻炼</tag>
        <tag>日常生活</tag>
      </tags>
  </entry>
  <entry>
    <title>「体能训练理论」之功能性</title>
    <url>/2017/08/15/2017-08-15-Life-Exercise-Functional/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>体能训练是一种开源的程序它所依仗的并不是固有的方法手段，而是能够贯穿始终的逻辑，它是一种指导实践的思维方式，我们管它叫“体能思路”。</p>
<p>体能思路有两个方向，一个是原点，一个是过程。所谓原点我们认为是人体的本质属性，比如之前我们分享的五大运动素质以及动力链理论。所谓过程是我们分析问题实现目的的思考方向以及逻辑，它主要体现在接下来要跟大家分享的功能性原则和金字塔。</p>
<p>今天先来说功能性原则。</p>
<h2 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a>功能性</h2><p>我们所说的功能性是一种解决问题的思维方式，而功能性训练则定义了一种多关节参与，多平面运动的复杂练习。功能性训练是具体的，比较好理解，我就不赘述了，也不评价其优劣，因为在“功能性”的思维方式下，只存在目标之下的合适与否。</p>
<h3 id="什么是功能性？"><a href="#什么是功能性？" class="headerlink" title="什么是功能性？"></a>什么是功能性？</h3><p>我们把它定义为目标导向下的效率，所以它是一种程度的体现。如果一个练习与目标的相关性强，那么我们认为它具备较强的功能意义；而如果一个练习与它的目标背道而驰，那么我们就认为它缺乏功能意义。</p>
<a id="more"></a>
<p>举个例子，对于偏瘫患者来说，一个手指的屈伸就已经具备非常强的功能意义了，而对于一个马拉松爱好者来说，静蹲的价值可能并不是想象中那么高。</p>
<p>一般来说，在思考功能性问题的时候我习惯从以下三个方面入手：<strong>肌肉的生理适应</strong> 、<strong>动作模式</strong> 和 <strong>专项需求</strong>。</p>
<h4 id="1-肌肉的生理适应"><a href="#1-肌肉的生理适应" class="headerlink" title="1. 肌肉的生理适应"></a>1. 肌肉的生理适应</h4><p>其实练肌肉谁都会，是一个相对好入手的技能，但是当你给这个行为赋予体能训练使命的时候就需要思考一些问题，比如说你现在练习所发展的东东真的是你实际运动中所需要的东东么？</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fhg24pm22dj30e709474v.jpg" alt></p>
<p>我们都知道肌肉的生理收缩模式可以简单的分为向心收缩，离心收缩和静力收缩。现在的研究表明，这三种收缩模式的练习所产生的适应性提高存在显著的特异性。也就是说我向心练习所发展的能力只在向心运动中表现最好，在离心和静力中都不佳。同样，离心收缩也只能获得最好的离心能力收益。而静力就更变态，其训练最佳效果仅仅体现在所锻炼的关节角度下，换一个角度能够迁移的效果有可能都不到一半儿。这样看来，你的训练是不是并没有达到你想要的效果呢？</p>
<p>举个例子：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fhg251pmatj30go0b5q5d.jpg" alt></p>
<p>为什么静蹲对于跑步爱好者来说可能并没有那么理想？因为膝关节股四头肌在跑步中以离心缓冲为主，而且角度在伸膝末端的30°左右，而静蹲却是在屈曲90°左右的角度下呆着不动……着不动……不动……动……</p>
<p>除此之外，需要考虑的问题还很多，比如说发力模式，是加速？减速？还是匀速？再比如关节活动角度上发力点的位置，是伸展末端发力？屈曲极限发力？还是在屈伸过程中的某一点发力？阻力加在哪里，就会在哪里产生最好的适应，那么功能的意义就体现在这里。</p>
<h4 id="2-动作模式"><a href="#2-动作模式" class="headerlink" title="2. 动作模式"></a>2. 动作模式</h4><p>动作模式是动作程序的体现，而基础动作模式是诸多复杂动作模式共性的抽象体现，并且基础动作模式一定是符合解剖结构和生物力学特点的，说白了也就是我们人体被设计来应该完成的动作。</p>
<p>如果说大多数运动都可以认为是基础动作模式的升级与排列组合，同时基础动作模式本身又能衍生出来很多训练动作，那么选择和实际运动相对应的练习就是另一个功能性的体现了。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg25l7ep2j30g609o0ue.jpg" alt></p>
<p>比如说发展起跳能力，因为跳是蹲的升级，所以我一定首选深蹲练习；再比如说跑步，存在大量的下肢摆动与支撑的交替，摆动可以认为是下肢开链屈髋与蹬伸，而支撑可以认为是下肢单腿蹲的一瞬间，那么我会选择箱式单腿蹲，保加利亚蹲，悬垂屈髋等等；再再比如，拳击是基于“旋转”加“上肢推”加“单腿蹲”的动作模式，那么我就要练习剪蹲…旋转…单臂…推举…吗？</p>
<p>其实动作模式的选择要结合动力链一起去思考，这里除了要思考开链还是闭链之外，还要考虑动力链的完整性以及发力的顺序或者说是力学结构。说到上肢推的动作模式，水平推的话我相信很多人都会想到卧推和俯卧撑，那么这两个动作的功能性如何评价呢？</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg26a2ve0j30go0ce76n.jpg" alt></p>
<p><strong>卧推</strong>，一个挺奇葩的动作，奇葩在哪呢？来，咱们数数卧推的主动关节都有哪些：肩关节，肘关节。那么我们上肢链在上肢推动作模式下参与的关节都有哪些呢？肩关节，肘关节！就这些么？再想想！其实你还疏漏了一个非常重要的关节——<strong>肩胛胸关节</strong>！几乎所有上肢的动作都以肩胛胸关节的运动为基础，而卧推却并没有，特别是标准的卧推~</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fhg26h6oejj30go09lwgj.jpg" alt></p>
<p><strong>俯卧撑</strong>，虽然肩胛胸，肩关节，肘关节全面参与到运动中去，但不巧的是它是一个闭链运动，而实际运动中我们的上肢会以开链为主！呵呵~</p>
<p>别着急，认真你就输了！上面两段其实是个伪命题，我这么做主要是想通过这个平易近人的例子来帮助大家掌握的分析问题的思路！如果你需要发展上肢最大力量表现，那么显然卧推是你的首选。而如果你要优化上肢的力学结构，特别是水平推的发力顺序，那么俯卧撑是你首选。再如果你要提高上肢的延展性以及伴随旋转的加速能力，那么单臂水平推的练习给你的帮助最大！</p>
<p>所以，选择什么，看目标喽~</p>
<h4 id="3-专项需求"><a href="#3-专项需求" class="headerlink" title="3. 专项需求"></a>3. 专项需求</h4><p>其实这个非常好理解，也是功能性原则的根本目的，但是为了和上面两个方向区分开，这里主要针对的是不同的运动素质需求。</p>
<p>Q：对一个英超的后卫进行长距离高强度的游泳练习是否具备功能性意义？！</p>
<p>A：具备！</p>
<p>Q：为什么？</p>
<p>A：因为他喜欢游泳，这个可以让他心情愉悦然后更好的训练和比赛！</p>
<p>咳咳！当然，这样的答案是合情合理的！但是我们不妨换一个角度去分析。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg26rdi6vj30go0b4goo.jpg" alt></p>
<p>英超，几乎是足球联赛中对抗最强的，他们的后卫每场比赛动不动就跑个8千1万的，而这8千1万真心不是慢慢悠悠颠儿下来的，而是各种加速减速变向拼抢，所以其强度非常之大。那么这就需要很好的心肺系统功能，一方面体现在有氧与无氧耐力上，另一方面呼吸器官的机能上。游泳练习，不仅可以提高有氧以及无氧耐力，其水环境还可以给胸扩张带来阻力，直接锻炼了呼吸肌的收缩能力。另外，水环境真的能够给人们带来愉悦的感觉，特别是水流水压给肌肉和筋膜的按摩效果，真的是一举两得的“功能性”训练。</p>
<p>还有，你以为篮球运动员的拳击练习真的只是给枯燥乏味的体能训练增加一点乐趣么？并不是！</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg276m81pj31h50rgtbv.jpg" alt></p>
<p><strong>1. 拳击可以在发生场内冲突的时候很好地保护自己；</strong></p>
<p><strong>2. 拳击运动可以强化旋转动作模式下的速度、稳定、和准确性；</strong></p>
<p><strong>3. 拳击是手脚高度协调的运动，对于发展手脚搭配的动作灵敏有神奇的效果。</strong></p>
<p>而这些不就是一名篮球运动员所需要的么？！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以，功能性原则，解决的是“<strong>为什么练</strong>（for！not why）以及 <strong>练什么</strong>”的问题！</p>
<p>如果我们是简单活动活动身体那就算了，但如果我们要进行一个有针对性的体能训练，那么请琢磨琢磨你选择的动作是否合理，是否能够满足你的专项需求！</p>
<p>所以，招财猫式弹力带抗阻外旋真的是练习肩袖首推的动作么？</p>
<p>所以，蚌式练习和dirty dog真的是发展髋外旋外展能力最好的练习么？</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg28jvnhqj30dw099q3z.jpg" alt></p>
<p>所以，仰卧卷腹发展出来的腹直肌是好看呢？还是好用呢？</p>
<p>所以，我们真的要来一次大清洗，摒弃掉我们以前那些练习么？</p>
<p>当然不要！每一个动作都有它存在的意义，都有它的价值所在！有可能这个动作和你要发展的能力不直接相关，但是它可能是你进行“功能性”训练的基础，你不得不去做它！</p>
<p>所以，训练的逻辑很重要！</p>
<blockquote>
<p>转自<a href="https://zhuanlan.zhihu.com/p/20786373" target="_blank" rel="noopener">《体能训练之功能性》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>锻炼</category>
      </categories>
      <tags>
        <tag>锻炼</tag>
        <tag>日常生活</tag>
      </tags>
  </entry>
  <entry>
    <title>通过漫画形式来解释 ArrayBuffers 和 SharedArrayBuffers</title>
    <url>/2017/08/07/2017-08-07-Programing-JavaScript-ArrayBuffers-SharedArrayBuffers/</url>
    <content><![CDATA[<h1 id="通过漫画形式来解释-ArrayBuffers-和-SharedArrayBuffers"><a href="#通过漫画形式来解释-ArrayBuffers-和-SharedArrayBuffers" class="headerlink" title="通过漫画形式来解释 ArrayBuffers 和 SharedArrayBuffers"></a>通过漫画形式来解释 ArrayBuffers 和 SharedArrayBuffers</h1><p>这是本系列三篇文章中的第二篇：</p>
<ol>
<li><em>内存管理速成手册</em></li>
<li><em>通过漫画形式来解释 ArrayBuffers 和 SharedArrayBuffers</em></li>
<li><em>使用 Atomics 来在 SharedArrayBuffers 中避免竞用条件</em></li>
</ol>
<p>在上一篇中，我解释了一些自动内存管理的语言比如 JavaScript 怎么管理内存。同时我也解释了例如 C 语言，如何进行手动内存管理。</p>
<p>那么这和我们将要讨论的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffers</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" target="_blank" rel="noopener">SharedArrayBuffers</a> 有什么关系呢？这是因为 ArrayBuffer 也使得你能够手动处理数据，尽管这是在 JavaScript 中，一种具有自动内存管理的语言。</p>
<p>那么，你为什么想要进行手动处理呢？正如上一篇文章所描述，在使用自动内存管理上有一个权衡。自动内存管理使得开发者开发程序变得相对容易，但是它也带来了一些困扰。在某些场景中，自动内存管理可能会带来性能上的问题。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_01.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_01-500x285.png" alt="A balancing scale showing that automatic memory management is easier to understand, but harder to make fast"></a></p>
<p>例如，当你使用 JS 创建一个变量的时候，JS 引擎不得不猜测这个 JS 变量所包含数据的类型以及怎样在内存中进行存储。因为这些猜测，JS 引擎通常会为这些变量实际需要的内存分配更大的内存空间。根据不同的变量，分配的内存空间可能是实际所需的 2-8 倍，这将导致极大的内存浪费。除此之外，特性模式的创建和使用 JS 对象也将会使得其很难被 JS 引擎垃圾回收。</p>
<p>如果你正在进行手动的内存管理，你可以根据自己工作上的使用场景自己选择内存分配和解除分配的策略。当时在很多时候，却并不值得这样做。因为在很多使用场景下我们的程序并没有那么性能敏感以至于需要采用手动得内存管理。甚至在通常的使用中，手动内存管理甚至会使得程序更慢。但是在有些时候，你需要从一些更底层的操作来时的你的代码运行的更快，那么 ArrayBuffers 和 SharedArrayBuffers 将是很好的选择。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_02.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_02-500x285.png" alt="A balancing scale showing that manual memory management gives you more control for performance fine-tuning, but requires more thought and planning"></a></p>
<p>那么 ArrayBuffer 是怎么工作的呢？基本上和其他的 JavaScript 数组没有什么区别。除了，当你使用 ArrayBuffer 的时候，你不可以将任意的 JavaScript 数据类型到 ArrayBuffer 中，例如 objects 或者 strings。唯一能够放入 ArrayBuffer 中的只有字节（可以通过数字来表示）。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_03.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_03-500x377.png" alt="Two arrays, a normal array which can contain numbers, objects, strings, etc, and an ArrayBuffer, which can only contain bytes"></a></p>
<p>另外一件我必须明确说明的是，你并不能够直接的将字节放入 ArrayBuffer。这是因为，ArrayBuffer 并不知道一个字节有多大，也不知道不同的数字转化成字节的区别。ArrayBuffer 仅仅是一个「0」和「1」组成一行的二进制串。ArrayBuffer 也不知道分隔符应该放在该二进制串的什么位置。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_04.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_04-500x61.png" alt="A bunch of ones and zeros in a line"></a></p>
<p>为了给 ArrayBuffer 提供上下文，将上面的二进制串分割在相同尺寸的盒子里，我们需要一个称作「视窗」概念将二进制串分割到不同的盒子里。这些二进制数据上的视窗可以以带类型的数组存储，同时在 ArrayBuffer 中有不同带类型数组。比如，你可以通过 8 位整数的类型数组将上面的 ArrayBuffer 8 位一字节分割开来。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_05.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_05-500x177.png" alt="Those ones and zeros broken up into boxes of 8"></a></p>
<p>或者你可以使用无符号 16 位整数的数组，这样就将上面的 ArrayBuffer 分割成了 16 位一字节的不同块中，然后依然想无符号整数一样对其操作。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_06.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_06-500x153.png" alt="Those ones and zeros broken up into boxes of 16"></a></p>
<p>你甚至可以在同一个基础 buffer 上面拥有不同的「视窗」。不同的「视窗」在相同的操作下会带来不同的结果。比如，在 Int8 视窗中，你可能会得到 <code>0 &amp; 1</code> 表达式，而在同样的 buffer 下，在 Uint16 视窗下你可能会得到其他结果，尽管他们都拥有相同的二进制位串。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_07.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_07-500x262.png" alt="Those ones and zeros broken up into boxes of 16"></a></p>
<p>在上面描述得工作方式下，ArrayBuffer 的角色仅仅是向一块原始的内存。它模拟了像在 C 语言中直接获取\操作 内存的工作。你可能会产生疑问，为什么 JS 不直接提供给使用者直接获取/操作内存的接口而是添加 ArrayBuffer 这一抽象层呢？这是因为直接获取/操作内存可能会导致一些安全漏洞。我将在将来的文章中讨论这一块内容。那么，SharedArrayBuffers 又是什么呢？</p>
<p>为了解释 SharedArrayBuffers，我需要先简略解释 JavaScript 中并行运行代码。为了并行运行代码，你需要将工作拆分成不同部分。但是在一个典型的 app 中，所有的工作都是在一个独立的线程中完成。在之前的文章中我也提及过这一点…这个主线程就像一个全栈工程师一样。它掌管着 JavaScript、DOM、以及视图布局。所有你能够操作的工作都是在这个主线程帮助下完成的。在某些特定环境下，ArrayBuffers 可以减轻主线程的负担，代替完成主线程的部分工作。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_08.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_08-500x350.png" alt="The main thread standing at its desk with a pile of paperwork. The top part of that pile has been removed"></a></p>
<p>但是有时候减少主线程的工作依然是不够的。有时候你需要引进增援…你需要将工作分开。在很多编程语言中，将工作分成不同块每一块也就称作一个线程。这个多人共同完成一个项目是一个道理。</p>
<p>如果你有一些任务，同时该任务和其他任务相对独立，那么你就可以在其他线程中完成这些任务。因此，不同的线程就可以在同一时间完成互相独立的分离任务。在 JavaScript 中，我们可以通过被称作<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">web worker</a>的工具来完成以上工作。这些 web workers 与您在其他语言中使用的线程略有不同。默认情况下，它们不共享内存。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_09.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_09-500x360.png" alt="Two threads at desks next to each other. Their piles of paperwork are half as tall as before. There is a chunk of memory below each, but not connected to the other&#39;s memory"></a></p>
<p>这也就意味着，如果你想和其他线程共享数据，那么你就需要将数据从一个地方复制到另外一个地方。这是通过函数<a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" target="_blank" rel="noopener">postMessage</a> 完成的。postMessage 将所有输入的对象序列化，将其发送到另一个 web worker，并将其反序列化并放入内存中。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_10.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_10-500x355.png" alt="Thread 1 shares memory with thread 2 by serializing it, sending it across, where it is copied into thread 2&#39;s memory"></a></p>
<p>这事一个相当慢的过程，比如一些类型的数据，像 ArrayBuffers，你可以转移内存。这意味着你可以将某一特定的内存块移动到其他地方，这样其他的 web worker 就可以获取/操作 该内存块。但是之前的 web worker 将不能够再获取到该内存块了。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_11.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_11-500x360.png" alt="Thread 1 shares memory with thread 2 by transferring it. Thread 1 no longer has access to it"></a></p>
<p>这也许在某些场景中适用，但是在更多的情况，你可能需要更高效得并行策略，在这些场景下，你可能真实的想要共享内存单元。ShareArrayBuffer 能够帮助你达到此目的。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_12.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_12-500x349.png" alt="The two threads get some shared memory which they can both access"></a></p>
<p>通过 ShareArrayBuffer，web worker、不同线程可以在相同的内存块中读写数据。这也意味着你不爱需要通过 postMessage 来在不同的线程中通信传递数据。不同的 web worker 都有获取/操作数据的权限。但是这也会带来一些问题，比如两个线程在同一时间对数据进行操作。这也就是通常被称作「竞用条件」的现象。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13-500x201.png" alt="Drawing of two threads racing towards memory"></a></p>
<p>我将在<a href="https://hacks.mozilla.org/2017/06/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/" target="_blank" rel="noopener">下一篇文章</a>中解释什么是竞用条件。那么 SharedArrayBuffers 现阶段处于什么地位呢？庆幸得，在不久的将来，所有主流浏览器都贱支持 SharedArrayBuffers。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_14.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_14-500x169.png" alt="Logos of the major browsers high-fiving"></a></p>
<p>SharedArrayBuffers 在 Safari（Safari 10.1）中已经可以使用。Firefox 和 Chrome 也将在今年的七八月发布的版本中包含此项功能。Edge 浏览器计划在今年的秋天完成此项功能的更新。但是即使所有主流浏览器都已经支持 SharedArrayBuffers，我们也不希望应用程序开发人员直接使用它。</p>
<p>实际上，我们发对这样做。你应该在其之上进行抽象，使用更高层的一些库。我们所期待的是框架或库的开发者们能够创建一些工具库，这些工具库能够帮助我们更方便、安全的使用 SharedArrayBuffer。除此之外，一旦 SharedArrayBuffers 在平台上实现，WebAssembly 可以使用它来实现多线程。到时候，你就能够向 Rust 语言一样使用并发的抽象层，它将无所畏惧得将并发作为其主要目标。在下一篇文章中，我们将解释工具（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics" target="_blank" rel="noopener">Atomics</a> ）以及工具开发者是怎样来实现这一抽象层并如何避免竞用条件的。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15-500x335.png" alt="Layer diagram showing SharedArrayBuffer + Atomics as the foundation, and JS libaries and WebAssembly threading building on top"></a></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理速成手册</title>
    <url>/2017/08/05/2017-08-05-Programing-JavaScript-Memory-Manager/</url>
    <content><![CDATA[<h2 id="内存管理速成手册"><a href="#内存管理速成手册" class="headerlink" title="内存管理速成手册"></a>内存管理速成手册</h2><blockquote>
<p><a href="https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management/" target="_blank" rel="noopener">原文地址</a></p>
<p>_这是本系列文章中的第一篇：</p>
</blockquote>
<ol>
<li><em>内存管理速成手册</em></li>
<li><em>通过漫画形式来解释 ArrayBuffers 和 SharedArrayBuffers</em></li>
<li><em>使用 Atomics 来在 SharedArrayBuffers 中避免竞用条件</em></li>
</ol>
<p>在弄懂 <code>ArrayBuffer</code> 和 <code>SharedArrayBuffer</code> 为什么添加到 JavaScript 之前，你首先需要了解一些关于内存管理的知识。你可以把机器中的内存比喻成一组箱子，就像我把内存想象成办公室内部的信箱一样，或者是为学龄前儿童准备的用于存储杂物的小房间，如果你想给某位孩子准备一些礼物，你可以将物品放到某个箱子里。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_01.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_01-500x353.png" alt="A column of boxes with a child putting something in one of the boxes"></a></p>
<p>在每个箱子旁边都有一个与之对应的数字，这就是内存地址。正是因为有了地址，你才能够告诉别人你为其准备动物品存放的位置。每个箱子具有相同的尺寸，也因此每个内存箱子也具有相同的容量来存储信息。箱子的尺寸是根据不同的机器而定的。箱子的尺寸被称作「字长」。它通常被标识为「32 位」或者「64 位」。但是为了简单的展示，在本文中我们使用「8 位」的字长。（译者注：一个字长包含 8 个二进制位，也就是说一个内存单元的容量是 8 位）</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_02.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_02-500x121.png" alt="A box with 8 smaller boxes in it"></a></p>
<p>如果你打算将数字 2 放进其中一个内存箱子里，这将非常容易做到，因为数字可以很容易通过二进制来表示。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_03.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_03-500x229.png" alt="The number two, converted to binary 00000010 and put inside the boxes"></a></p>
<p>倘若我们想放入内存箱子中的不是数字，而比如是字母「H」，怎么办呢？我们需要通过某种方法将其转化成可以使用数字来表示。为了完成此项工作，我们需要编码。类似于 <a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a> 。同时我们需要某种工具来按照 UTF-8 中的对应关系将字符转化成数字…比如说一个编码环。有了编码和编码环后，我们就可以将任意字符存入到内存箱子中了。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_04.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_04-500x277.png" alt="The letter H, put through an encoder ring to get 72, which is then converted to binary and put in the boxes"></a></p>
<p>当我们打算将我们存入内存箱子中的信息取出时，我们需要将其放入一个解码器中，通过解码器将存放的数字转换成字母「H」。当你使用 JavaScript 工作时，你无须关心内存是怎样分配和使用的，因为在 JavaScript 中内存是自动管理的，内存管理和你的代码完全隔离。这意味着你不能够直接操作内存。JS 引擎将作为中介的角色，帮我们管理内存。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_05.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_05-500x371.png" alt="A column of boxes with a rope in front of it and the JS engine standing at that rope like a bouncer"></a></p>
<p>让我们一些 JS 代码，比如在 React 中，我们需要创建一个变量并对其赋值。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_06.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_06-500x373.png" alt="Same as above, with React asking the JS engine to create a variable"></a></p>
<p>JS 引擎的工作就是通过编码器将变量名转换成二进制表示。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_07.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_07-500x370.png" alt="The JS engine using an encoder ring to convert the string to binary"></a></p>
<p>然后在内存中找到闲余的空间用来存放上面转换后的二进制表示。这一过程被称作分配内存。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_08.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_08-500x367.png" alt="The JS engine finding space for the binary in the column of boxes"></a></p>
<p>接下来，JS 引擎会跟踪该变量并判断在程序中该变量是否还能够获取到。如果该变量不能够再被获取到，那么该内存箱子将会被回收再利用，以便 JS 引擎能够分配新的值到该内存中。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_09.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_09-500x379.png" alt="The garbage collector clearing out the memory"></a></p>
<p>JS 引擎监听变量所代表的字符串、对象、以及内存中的其他数据类型的数据，当这些值不能再被获取到的时候，JS 引擎将会把它们清除出内存，这一过程被称作「垃圾回收」。比如 JavaScript 语言，代码不能够直接操纵内存，被称作自动内存管理语言。这一自动内存管理机制会使得开发变得相对简单。但是自动内存管理也会带来一些头疼的地方。比如自动内存管理可能会带来性能不可预测。而手动进行内存管理的语言就不会有这些问题。比如，通过 C 语言内存管理的方式来写 React 代码（当然，通过<a href="https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/" target="_blank" rel="noopener">WebAssembly</a> 已经使得其<a href="https://www.youtube.com/watch?v=3GHJ4cbxsVQ" target="_blank" rel="noopener">成为现实</a>）。C 语言没有 JavaScript 自动内存管理的这一层功能抽象。所以，你可以直接操作内存，你可以从内存中对去数据，你也可以操作内存将数据存入内存中。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_10.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_10-500x360.png" alt="A WebAssembly version of React working with memory directly"></a></p>
<p>当你讲其它语言比如 C 语言传递给 WebAssembly，你使用的工具将会添加一些代码到 WebAssembly 中，比如，将添加对字节进行编码和解码的代码。这些代码被称作运行时环境。运行时环境也将像 JS 引擎在 JavaScript 语言中的作用一样，处理一些与之相同的工作。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_11.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_11-500x361.png" alt="An encoder ring being shipped down as part of the .wasm file"></a></p>
<p>但是对于手动内存管理的语言来说，运行时环境并不包含垃圾回收。这就意味着你必须手动来进行垃圾回收，即使是手动内存管理的语言，你通常也可以从该语言运行时环境中获取一些帮助。比如，在 C 语言中，C 语言运行时将会跟踪那些未被使用的内存，并将内存地址存储在一个链表中，该列表被称作「free list」。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_12.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_12-500x360.png" alt="A free list next to the column of boxes, listing which boxes are free right now"></a></p>
<p>你可以使用 <code>malloc</code> 函数（memory allocate 简写）来请求运行时环境来寻找能够存放你数据的内存地址。这会使得这些内存地址从「free list」中移除。当你使用数据完成工作后，你必须通过<code>free</code>函数来讲该内存释放。</p>
<p>这样该内存地址将会被重新添加至「free list」中。你必须知道什么时候该调用这些函数。这也是为什么称为手动内存管理的原因所在 -- 你完全自己管理程序中的内存。作为开发者，断定什么时候该清除内存是一件相当困难的事。</p>
<p>如果在错误的时间点清除内存，将导致程序 bug，甚至一些安全漏洞。如果不对不在使用的内存进行处理，又将导致内存用尽。这也就是为什么现代语言都是用自动内存管理的原因 -- 避免人为错误。但是这也将会产生一些性能上的问题。</p>
<p>将在<a href="https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/" target="_blank" rel="noopener">下一篇</a>对此进行说明。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 修改历史记录</title>
    <url>/2017/03/24/2017-03-24-Programing-Git-Git-change-history/</url>
    <content><![CDATA[<h2 id="聊聊-Git-「改变历史」"><a href="#聊聊-Git-「改变历史」" class="headerlink" title="聊聊 Git 「改变历史」"></a>聊聊 Git 「改变历史」</h2><p>在本篇文章中，聊聊 Git 怎么改变历史记录。</p>
<h2 id="重写最后一次提交"><a href="#重写最后一次提交" class="headerlink" title="重写最后一次提交"></a>重写最后一次提交</h2><p>在我们开发的过程中，我们经常会遇到这样的问题，当我们进行了一次「冲动」的 Git 提交后。发现我们的 commit 信息有误，或者我们把不应该这次提交的文件添加到了此次提交中，或者有的文件忘记提交了，怎么办？这些问题都可以通过如下命令来进行弥补。</p>
<blockquote>
<p>git commit —amend</p>
</blockquote>
<p>举个例子，在一个刚初始化的 Git 仓库中，有如下两个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">total 0</span><br><span class="line">-rw-r--r--  1 ransixi  staff     0B  9 19 16:35 should-commit.js</span><br><span class="line">-rw-r--r--  1 ransixi  staff     0B  9 19 16:35 should-not-commit.js</span><br></pre></td></tr></table></figure>
<p>其中 should-commit.js 文件应该被提交，而 should-not-commit.js 不应该被提交，但是由于「冲动」，我把 should-not-commit.js 文件提交了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其实应该添加 should-commit.js 文件</span></span><br><span class="line">git add should-not-commit.js</span><br><span class="line"><span class="meta">#</span><span class="bash"> 啊哈，由于笔误，我把 commit 写成了 commmit</span></span><br><span class="line">git commit -m 'commmit 1'</span><br></pre></td></tr></table></figure>
<p>通过 git log 命令打印下当前的历史提交记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit fba6199e7fd5f325cc0bfcec4c599c93603d48f8 (HEAD -&gt; master)</span><br><span class="line">Author: ran.luo03 &lt;ran.luo03@ele.me&gt;</span><br><span class="line">Date:   Tue Sep 19 16:49:57 2017 +0800</span><br><span class="line"></span><br><span class="line">    commmit 1</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这样的错误的提交一定不能够给别人看到！是时候该祭出 git commit —amend 了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先，需要将 should-commit.js 文件添加到暂存区</span></span><br><span class="line">git add should-commit.js</span><br><span class="line"><span class="meta">#</span><span class="bash"> 其次，将 should-not-commit.js 文件从已暂存状态转为未暂存状态，不会删除 should-not-commit.js 文件。</span></span><br><span class="line">git rm --cache should-not-commit.js</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后，通过git commit --amend 修改提交信息</span></span><br><span class="line">git commit--amend</span><br></pre></td></tr></table></figure>
<p>当键入 git commit —amend 命令后，会打开 Git 默认编辑器，内容包括了上次错误提交的信息，我们只需将 commmit 1 改为 commit 1 就行了，然后保存退出编辑器。这样我们就完成了错误提交的修改，让我们再通过 git log 来查看一下历史提交记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit 2a410384e14dadaff9b98f823b9f239da055637d (HEAD -&gt; master)</span><br><span class="line">Author: ran.luo03 &lt;ran.luo03@ele.me&gt;</span><br><span class="line">Date:   Tue Sep 19 16:49:57 2017 +0800</span><br><span class="line"></span><br><span class="line">    commit 1</span><br></pre></td></tr></table></figure>
<p>啊哈，整个历史记录中只有我最新修改后的历史提交，你完全找不到上一次的提交踪迹了。是不是很酷呢？</p>
<p><strong>思考 1：</strong>怎么使用 git reset 命令修改最后一次提交记录？</p>
<h2 id="多个提交合并、排序、删除操作"><a href="#多个提交合并、排序、删除操作" class="headerlink" title="多个提交合并、排序、删除操作"></a>多个提交合并、排序、删除操作</h2><p>在一个大型项目中，为了保持提交历史的简洁和可逆，往往一个功能点或者一个 bug fix 对应一个提交，但是在我们实际开发的过程中，我们并不是完成整个功能才进行一次提交的，往往是开发了功能点的一部分，就需要给小伙伴们进行 code review，小的 commit 保证了 code review 的效率和准确性，想象一下如果一次给小伙伴 review 上千行代码，几十个文件，他一定会疯掉的。同时 code review 后的反馈，我们可能需要修改代码，然后再次提交。但是这些提交之间的反复修改不应该体现在最终的 PR 上面，因此， 我们需要根据功能点的前后对 commit 进行排序，对相同功能的 commits 进行合并，并删除一些不需要的 commit，根据最终的提交历史提 PR。</p>
<p>举个例子，将王之涣的<strong>登鹳雀楼</strong>摘抄到我的读书笔记中。</p>
<p>首先创建 poem 文件，将「黄河入海流」这句诗添加到了文件中，创建第一个 commit 如下：</p>
<p>通过 git log —oneline 命令来看看提交记录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">da5ee49 (HEAD -&gt; master) add 黄河入海流</span><br></pre></td></tr></table></figure>
<p>后来觉得，摘抄一句有些单调，不如将其前面一句也摘抄到笔记中吧，于是又出现了第二个 commit 如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">622c3c8 (HEAD -&gt; master) add 百日依山尽</span><br><span class="line">da5ee49 add 黄河入海流</span><br></pre></td></tr></table></figure>
<p>…</p>
<p>觉得自己太随性，摘抄一首诗竟然添加了如此之多的 commits，commits 如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">953aabb (HEAD -&gt; master) add 文章出处</span><br><span class="line">7fad941 add 摘抄时间</span><br><span class="line">731d00b add 作者：王焕之</span><br><span class="line">9a22044 add 标题：登鹳雀楼</span><br><span class="line">4fee22a add 更上一层楼</span><br><span class="line">d1293c5 add 欲穷千里目</span><br><span class="line">622c3c8 add 百日依山尽</span><br><span class="line">da5ee49 add 黄河入海流</span><br></pre></td></tr></table></figure>
<p>再看看上面的提交历史，觉得如此多的 commits 确实有些冗余了，commits 的顺序似乎也有些问题，因为 commits 的顺序并不是按照正常摘抄一首诗的顺序来组织的。而且觉得添加摘抄时间有些多余了，git 的历史提交记录就已经帮我记录了添加时间。</p>
<p>让我们来一步一步通过「重写历史」来修改上面的问题。</p>
<p>这次我使用的命令是 git rebase -i 或者 git rebase - -interactive， Git 官方文档对其如下解释：</p>
<blockquote>
<p>Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode can also be used to split commits</p>
</blockquote>
<p>可以看出，该命令罗列了将要 rebase 的提交记录，打开 Git 设置的编辑器，让用户有更多的选择，可以进行 commit 合并，对 commits 重新排序，删除 commit 等。</p>
<p><strong>第一步：删除「add 摘抄时间」commit</strong></p>
<p>运行命令</p>
<blockquote>
<p>git rebase -i HEAD~2</p>
</blockquote>
<p>Git 打开默认编辑器，出来如下对话信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick 7fad941 add 摘抄时间</span><br><span class="line">pick 953aabb add 文章出处</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Rebase 731d00b..953aabb onto 731d00b (2 commands)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Commands:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> p, pick = use commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> e, edit = use commit, but stop <span class="keyword">for</span> amending</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> f, fixup = like <span class="string">"squash"</span>, but discard this commit<span class="string">'s log message</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x, <span class="built_in">exec</span> = run <span class="built_in">command</span> (the rest of the line) using shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> d, drop = remove commit</span></span><br></pre></td></tr></table></figure>
<p>上面的对话信息中包含七条可选命令，很明显最后一条 d，drop 正式我需要的，因为我正打算删除 commit。于是我把第一行中的 pick 命令改为了 drop 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drop 7fad941 add 摘抄时间</span><br><span class="line">pick 953aabb add 文章出处</span><br></pre></td></tr></table></figure>
<p>保存并推出编辑器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Auto-merging poem</span><br><span class="line">CONFLICT (content): Merge conflict in poem</span><br><span class="line">error: could not apply 953aabb... add 文章出处</span><br><span class="line"></span><br><span class="line">When you have resolved this problem, run "git rebase --continue".</span><br><span class="line">If you prefer to skip this patch, run "git rebase --skip" instead.</span><br><span class="line">To check out the original branch and stop rebasing, run "git rebase --abort".</span><br><span class="line"></span><br><span class="line">Could not apply 953aabb... add 文章出处</span><br></pre></td></tr></table></figure>
<p>OMG!竟然竟然提示 poem 文件中有冲突！打开 poem 文件，手动删除不需要的内容及冲突的标记符号，按照上面的提示，运行 git rebase —continue 命令。心想，这下总该好了吧！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">poem: needs merge</span><br><span class="line">You must edit all merge conflicts and then</span><br><span class="line">mark them as resolved using git add</span><br></pre></td></tr></table></figure>
<p>rebase 依然没有成功，原来忘记将解决冲突的修改添加到暂存区了，通过运行 git add 命令后，再次执行 git rebase —continue。</p>
<p>出来一个对话框，提示我可以修改 commit 信息，没有修改，直接保存退出。来看看此时的提交历史记录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">b8f0233 (HEAD -&gt; master) add 文章出处</span><br><span class="line">731d00b add 作者：王焕之</span><br><span class="line">9a22044 add 标题：登鹳雀楼</span><br><span class="line">4fee22a add 更上一层楼</span><br><span class="line">d1293c5 add 欲穷千里目</span><br><span class="line">622c3c8 add 百日依山尽</span><br><span class="line">da5ee49 add 黄河入海流</span><br></pre></td></tr></table></figure>
<p>和之前的 commits log 信息进行对比，发现 <code>7fad941 add 摘抄时间</code> 提交，已经被我成功得删除了，虽然期间有些波折。同时我还注意到了，「add 文章出处」的 SHA1 的 hash 值也从 953aabb 变成了 b8f0233。说明，该 commit 是新创建的 commit。</p>
<p><strong>第二步：调整 commits 顺序</strong></p>
<p>看着上面提交历史记录总会有些别扭，因为不是安装诗本身的顺序来进行提交的，现在我需要修改提交的顺序。好吧，又该是 git rebase -i 命令大显身手的时候到了。</p>
<p>但是现在有个问题，git rebase -i 命令并不能够编辑最初的提交。不巧的是，我正需要改变第一个 commit 的顺序，这儿需要一点小技巧，用到 <code>--root</code> 选项，通过该选项，我们就能够编辑初始化的提交了。运行命令如下：</p>
<blockquote>
<p>git rebase -i —root</p>
</blockquote>
<p>Git 再次打开编辑器，提示如下对话信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick da5ee49 add 黄河入海流</span><br><span class="line">pick 622c3c8 add 百日依山尽</span><br><span class="line">pick d1293c5 add 欲穷千里目</span><br><span class="line">pick 4fee22a add 更上一层楼</span><br><span class="line">pick 9a22044 add 标题：登鹳雀楼</span><br><span class="line">pick 731d00b add 作者：王焕之</span><br><span class="line">pick b8f0233 add 文章出处</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Rebase b8f0233 onto a69da76 (7 commands)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Commands:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> p, pick = use commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> e, edit = use commit, but stop <span class="keyword">for</span> amending</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> f, fixup = like <span class="string">"squash"</span>, but discard this commit<span class="string">'s log message</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x, <span class="built_in">exec</span> = run <span class="built_in">command</span> (the rest of the line) using shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> d, drop = remove commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>
<p>修改上面的提交顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick 622c3c8 add 百日依山尽</span><br><span class="line">pick da5ee49 add 黄河入海流</span><br><span class="line">pick d1293c5 add 欲穷千里目</span><br><span class="line">pick 4fee22a add 更上一层楼</span><br><span class="line">pick 9a22044 add 标题：登鹳雀楼</span><br><span class="line">pick 731d00b add 作者：王焕之</span><br><span class="line">pick b8f0233 add 文章出处</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后保存并推出编辑器。</p>
<p>OMG，依然存在冲突，解决冲突，运行 git add . 和 git rebase —continue。最后来看看现在的历史提交记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ddb6576 (HEAD -&gt; master) add 文章出处</span><br><span class="line">a6e40b3 add 作者：王焕之</span><br><span class="line">ce83346 add 标题：登鹳雀楼</span><br><span class="line">cae4916 add 更上一层楼</span><br><span class="line">f79b9ac add 欲穷千里目</span><br><span class="line">fb65570 add 黄河入海流</span><br><span class="line">8e25185 add 白日依山尽</span><br></pre></td></tr></table></figure>
<p><strong>第三步：合并 commits</strong></p>
<p>添加标题和添加作者貌似应该放到一个 commit 里面，也就是说，我需要将<code>a6e40b3 add 作者：王焕之</code> 提交和 <code>ce83346 add 标题：登鹳雀楼</code> 合并成一个提交。这样显得提交更加简洁明晰。</p>
<p>依然使用命令</p>
<blockquote>
<p>git rebase -i HEAD~3</p>
</blockquote>
<p>Git 大概如下对话框：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick ce83346 add 标题：登鹳雀楼</span><br><span class="line">pick a6e40b3 add 作者：王焕之</span><br><span class="line">pick ddb6576 add 文章出处</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Rebase cae4916..ddb6576 onto cae4916 (3 commands)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Commands:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> p, pick = use commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> e, edit = use commit, but stop <span class="keyword">for</span> amending</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> f, fixup = like <span class="string">"squash"</span>, but discard this commit<span class="string">'s log message</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x, <span class="built_in">exec</span> = run <span class="built_in">command</span> (the rest of the line) using shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> d, drop = remove commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>
<p>这次我使用的命令是 s, squash。该命令用于合并两个或多个 commits，会将选择的 commit 合并到前一个 commt 中。修改上面对话第二行如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick ce83346 add 标题：登鹳雀楼</span><br><span class="line">squash a6e40b3 add 作者：王焕之</span><br><span class="line">pick ddb6576 add 文章出处</span><br></pre></td></tr></table></figure>
<p>然后保存并推出编辑器，啊哈，Git 似乎有点疑惑，它并不知道选择哪个 commit 信息作为合并的最终 commit 信息，于是 Git 打开了新的对话框，让我自己输入新的合并提交信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This is a combination of 2 commits.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the 1st commit message:</span></span><br><span class="line"></span><br><span class="line">add 标题：登鹳雀楼</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the commit message <span class="comment">#2:</span></span></span><br><span class="line"></span><br><span class="line">add 作者：王焕之</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>
<p>修改如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This is a combination of 2 commits.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the 1st commit message:</span></span><br><span class="line"></span><br><span class="line">add 标题：登鹳雀楼 作者：王焕之</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the commit message <span class="comment">#2:</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> add 作者：王焕之</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>
<p>保存上面的修改，并推出编辑器。</p>
<p>再来看看最后的历史提交记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* b907e51 - (2 hours ago) add 文章出处 - ran.luo (HEAD -&gt; master)</span><br><span class="line">* bd0bfed - (3 hours ago) add 标题：登鹳雀楼 作者：王焕之 - ran.luo</span><br><span class="line">* cae4916 - (3 hours ago) add 更上一层楼 - ran.luo</span><br><span class="line">* f79b9ac - (3 hours ago) add 欲穷千里目 - ran.luo</span><br><span class="line">* fb65570 - (3 hours ago) add 黄河入海流 - ran.luo</span><br><span class="line">* 8e25185 - (3 hours ago) add 白日依山尽 - ran.luo</span><br></pre></td></tr></table></figure>
<p>啊哈，该历史提交记录终于是我想要的了。</p>
<p><strong>思考 2：</strong>假如通过 rebase 合并了多个 commits 后，发现并不是我们想要的结果，怎么使用 git reset 将其恢复到合并前状态？</p>
<p><strong>思考 3：</strong> 在上面的例子中，由于 git rebase -i 不能够直接编辑最初的提交记录，因而使用了 <code>--root</code> 选项，那么有没有什么<a href="https://stackoverflow.com/questions/645450/insert-a-commit-before-the-root-commit-in-git" target="_blank" rel="noopener">方法</a>可以在最初的 commit 之前添加一个 root commit 呢？这样 git rebase -i 就可以直接使用了。</p>
<h2 id="将其他分支的某个提交附加到当前分支"><a href="#将其他分支的某个提交附加到当前分支" class="headerlink" title="将其他分支的某个提交附加到当前分支"></a>将其他分支的某个提交附加到当前分支</h2><p>还记得文章开头提及的那个问题吗？修复了一个 master 分支上的线上 Bug，完成了项目的测试发布后，发现当前开发分支 dev 也存在同样的问题，怎么办？是把修复 Bug 的代码从 master 分支上线复制一遍到 dev 分支上，这显然效率不高，而且容易复制错误。还是以一个最小的例子来分析 Git 怎么帮我们解决这个问题。</p>
<p>当前版本库有两个分支，master 分支和 dev 分支，master 分支包含一个文件 file1，已经发布到线上，dev 分支是从 master 分支上分离出来的一个新的分支，并且已经完成了新功能的开发，添加了另外一个文件 file2。当前的提交图如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* 132cabb - (4 minutes ago) dev add file2 - ran.luo (dev)</span><br><span class="line">* daaae54 - (4 minutes ago) add file1 - ran.luo (HEAD -&gt; master)</span><br></pre></td></tr></table></figure>
<p>上面代码可以看出，当前 HEAD 指向 master 分支，并且发现一个线上 bug，需要紧急修复，我对 file1 文件内容进行修改，修复了该 bug。并提交一个新的 commit。当前的提交图如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* c6607dc - (4 seconds ago) master fix bug - ran.luo (HEAD -&gt; master)</span><br><span class="line">| * 132cabb - (6 minutes ago) dev add file2 - ran.luo (dev)</span><br><span class="line">|/</span><br><span class="line">* daaae54 - (7 minutes ago) add file1 - ran.luo</span><br></pre></td></tr></table></figure>
<p>因为 dev 分支是从 master 分支上分离出来的新分支，因此先前 master 分支上面的 bug 在 dev 分支上也存在，但是又有谁想再次手写代码修复一遍 bug 呢？这时候我们就需要用到 git cherry-pick 命令。Git 官方文档对其解释如下：</p>
<blockquote>
<p>git-cherry-pick - Apply the changes introduced by some existing commits</p>
</blockquote>
<p>由官网文档可知，git-cherry-pick 命令常用于将版本库的一个分支上的特定提交引入到另一个分支上，也就是说，其可以将其他分支带来的改变直接作用到当前分支，这不就是本例所需要的吗？</p>
<p>首先需要切换到 dev 分支，由于我们需要的是版本库中 master 分支上面的最新的一个关于 bug fix 的提交，将其附加到 dev 分支后面，使用如下命令：</p>
<blockquote>
<p>git cherry-pick master</p>
</blockquote>
<p>执行完毕后，我们切回 master 分支，再来看看当前的提交图：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* 439cb35 - (14 minutes ago) master fix bug - ran.luo (dev)</span><br><span class="line">* 132cabb - (20 minutes ago) dev add file2 - ran.luo</span><br><span class="line">| * c6607dc - (14 minutes ago) master fix bug - ran.luo (HEAD -&gt; master)</span><br><span class="line">|/</span><br><span class="line">* daaae54 - (21 minutes ago) add file1 - ran.luo</span><br></pre></td></tr></table></figure>
<p>啊哈，成功得将 master 分支的最新提交附加到了 dev 分支上面，又双叒叕一次改变了历史，心中的自豪感悠然而生。</p>
<p><strong>思考 4：</strong>既然 git cherry-pick 可以将某一分支上面的制定提交附加到当前分支上线，那么这样是否可能通过不同的操作顺序来对将要附加的提交进行排序呢？</p>
<p><strong>思考 5：</strong>有时候可能一次需要将版本库中某一分支上面的多个连续的提交一次性的附加到当前分支上面，git cherry-pick （git cherry-pick X..Y）命令是否也能够满足我们的需求呢？</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>当我还沉浸在改变历史的成就中难以自拔的时候，身边大佬的一句话让我清醒过来：「历史（记录）没有因你而变，而只是改变了历史（记录）的呈现方式」。当我查阅了.git/objects 中的关于记录 commit 的文件后，才发现我还是<code>too young too simple</code>。我并没有改变或删除这些记录 commit 的文件，而只是生成了一些新的 commit 文件，尽然以为我改变了历史记录，可笑！这也是我们为什么能够恢复到改变历史记录前状态的原因，关于 Git 中 hash、commit、history 的实质，请参考 <a href="https://zhuanlan.zhihu.com/p/27474934" target="_blank" rel="noopener">git inside —simplified —part ‘1’</a>。</p>
<p><strong>Warning</strong></p>
<p>改变历史提交提交记录并非完美，你需要遵循如下准则，只要没有其他开发人员获取到你版本库的副本，或者没有共享你的提交记录，那么你就可以尽情的完善你的提交记录，可以修改提交信息，合并或者拆分多个提交，对多个提交进行排序等等。不过，记住一点，如果你的版本库已经公开，并且其他开发人员已经共享了你的提交记录，那么你就不应该重写、修改该版本库中的任意部分。否则，你的合作者会埋怨你，你的家人和朋友也会嘲笑你、抛弃你。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>React 学习 - 开发环境搭建</title>
    <url>/2017/02/19/2017-02-19-Programing-React-setup-react-environment/</url>
    <content><![CDATA[<h2 id="1-安装-Yarn"><a href="#1-安装-Yarn" class="headerlink" title="1. 安装 Yarn"></a>1. 安装 Yarn</h2><p>包管理可以用 npm 或者 yarn，好多人推荐 yarn，我这里就用这个了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install yarn</span><br></pre></td></tr></table></figure>
<h2 id="2-初始化项目文件夹"><a href="#2-初始化项目文件夹" class="headerlink" title="2. 初始化项目文件夹"></a>2. 初始化项目文件夹</h2><p>首先要做的是创建一个工程目录，然后在目录中执行 yarn 初始化即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="3-安装-Webpack"><a href="#3-安装-Webpack" class="headerlink" title="3. 安装 Webpack"></a>3. 安装 Webpack</h2><p>Webpack 可以让整个开发过程及其方便，这里只讲如何使用它来搭建 React 开发环境</p>
<p>安装webpack</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack webpack-dev-server path</span><br></pre></td></tr></table></figure>
<p>创建 webpack 配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch webpack.config.js</span><br></pre></td></tr></table></figure>
<p>写入以下内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Html webpack plugin setting</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPluginConfig = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: <span class="string">'./client/index.html'</span>,</span><br><span class="line">  filename: <span class="string">'index.html'</span>,</span><br><span class="line">  inject: <span class="string">'body'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open browser plugin setting</span></span><br><span class="line"><span class="keyword">var</span> OpenBrowserPlugin = <span class="built_in">require</span>(<span class="string">'open-browser-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./client/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(<span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'index_bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">loader</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.jsx$/</span>, <span class="attr">loader</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style-loader!css-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    HtmlWebpackPluginConfig,</span><br><span class="line">    <span class="keyword">new</span> OpenBrowserPlugin(&#123; <span class="attr">url</span>: <span class="string">'http://localhost:8080'</span> &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要说明一下：</p>
<ul>
<li>entry: 整个项目的入口文件</li>
<li>output: 编译好的文件输出位置</li>
<li>loaders: 用来告诉loaders处理哪些文件</li>
<li>plugins: 启用的webpack插件</li>
</ul>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add html-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>上面我设置了 html 插件用来帮助把编译后的文件添加到body最后面，所以bundle.js这个js不需要我自己来添加到index.html中了</p>
<h3 id="css-loader-和-style-loader"><a href="#css-loader-和-style-loader" class="headerlink" title="css-loader 和 style-loader"></a>css-loader 和 style-loader</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add css-loader style-loader</span><br></pre></td></tr></table></figure>
<p>然后在webpack.config.js中就可以使用 css-loader 和 style-loader 了</p>
<p>之后我们在需要使用css的时候，直接用以下方式即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./App.css"</span>;</span><br></pre></td></tr></table></figure>
<p>另外在写 react 应用时，也可以直接使用内敛样式，例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> style = &#123;</span><br><span class="line">  backgroundColor: <span class="string">'#EEE'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">        &lt;h1&gt;Hello world&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="open-browser-webpack-plugin"><a href="#open-browser-webpack-plugin" class="headerlink" title="open-browser-webpack-plugin"></a>open-browser-webpack-plugin</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add open-browser-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>这个插件的作用是编译完成以后，打开浏览器</p>
<h2 id="设置-Babel"><a href="#设置-Babel" class="headerlink" title="设置 Babel"></a>设置 Babel</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add babel-loader babel-core babel-preset-es2015 babel-preset-react --dev</span><br></pre></td></tr></table></figure>
<p>preset 是 babel 的插件，用来让 babel 帮忙转译。然后再创建一个 babel 配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch .babelrc</span><br></pre></td></tr></table></figure>
<p>写入内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>:[</span><br><span class="line">        <span class="string">"es2015"</span>, <span class="string">"react"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-设置-React-环境"><a href="#4-设置-React-环境" class="headerlink" title="4. 设置 React 环境"></a>4. 设置 React 环境</h2><p>安装 React</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom</span><br></pre></td></tr></table></figure>
<p>当前目录是这个样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .babelrc</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── webpack.config.js</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>
<p>接下来我们加入 React 需要的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── client</span><br><span class="line">│   ├── components</span><br><span class="line">│   │   └── App.js</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── index.js</span><br><span class="line">├── package.json</span><br><span class="line">├── webpack.config.js</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>
<p>在 index.html 中写入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React App Setup<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 index.js 中写入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router, Route, hashHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  (<span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;hashHistory&#125;</span>&gt;</span></span></span><br><span class="line">    &lt;Route path="/" component=&#123;App&#125;/&gt;</span><br><span class="line">    &lt;Route path="/about" component=&#123;App&#125; /&gt;</span><br><span class="line">  &lt;/Router&gt;),</span><br><span class="line">  document.getElementById('root')</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在 App.js 中写入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">     &lt;div style=&#123;&#123;<span class="attr">textAlign</span>: <span class="string">'center'</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;h1&gt;Hello World&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-设置-React-Router"><a href="#5-设置-React-Router" class="headerlink" title="5. 设置 React-Router"></a>5. 设置 React-Router</h2><p>想要完成页面跳转以及一些复杂的多页面操作，可以使用 React-Router 来支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react-router</span><br></pre></td></tr></table></figure>
<p>使用例子可以看上面index.js内容</p>
<h2 id="6-启动-React"><a href="#6-启动-React" class="headerlink" title="6. 启动 React"></a>6. 启动 React</h2><p>修改package.json，加入scripts</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "webpack-dev-server",</span><br><span class="line">    "build": "webpack --progress --colors"</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>build 方法会把网站打包一下，然后放到之前定义好的目录里面。start 可以直接开启开发模式，并且开启预览</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure>
<h2 id="7-start-kit"><a href="#7-start-kit" class="headerlink" title="7. start kit"></a>7. start kit</h2><p>这些配置不需要每次都跑一次，我自己的放在 <a href="https://github.com/suyan/react-start-kit" target="_blank" rel="noopener">Github</a> 上。下载下来运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn install</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>
<p>即可开启一个 Web App 的开发了</p>
<h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><p><a href="https://scotch.io/tutorials/setup-a-react-environment-using-webpack-and-babel" target="_blank" rel="noopener">Setup a React Environment Using webpack and Babel</a></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 代码回滚回的正确姿势</title>
    <url>/2017/01/15/2017-01-15-Programing-Git-Git-revert-and-reset/</url>
    <content><![CDATA[<h1 id="git-revert-和-git-reset-的区别"><a href="#git-revert-和-git-reset-的区别" class="headerlink" title="git revert 和 git reset 的区别"></a><strong>git revert</strong> 和 <strong>git reset</strong> 的区别</h1><p> 先看图：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fcr9tu6vdjj30t30ez0y8.jpg" alt></p>
<p><strong>sourceTree</strong> 中 <strong>revert</strong> 译为<strong><code>提交回滚</code></strong>，作用为忽略你指定的版本，然后提交一个新的版本。新的版本中已近删除了你所指定的版本。</p>
<p><strong>reset</strong> 为 <strong>重置到这次提交</strong>，将内容重置到指定的版本。<code>git reset</code> 命令后面是需要加2种参数的：<code>–-hard</code> 和 <code>–-soft</code>。这条命令默认情况下是 <code>-–soft</code>。</p>
<p>执行上述命令时，这该条commit号之 后（时间作为参考点）的所有commit的修改都会退回到git缓冲区中。使用<code>git status</code> 命令可以在缓冲区中看到这些修改。而如果加上<code>-–hard</code>参数，则缓冲区中不会存储这些修改，git会直接丢弃这部分内容。可以使用 <code>git push origin HEAD --force</code> 强制将分区内容推送到远程服务器。</p>
<h2 id="代码回退"><a href="#代码回退" class="headerlink" title="代码回退"></a>代码回退</h2><p>默认参数 <code>-soft</code>,所有commit的修改都会退回到git缓冲区<br>参数<code>--hard</code>，所有commit的修改直接丢弃</p>
<pre><code>$ git reset --hard HEAD^         回退到上个版本
$ git reset --hard commit_id    退到/进到 指定commit_id
</code></pre><p>推送到远程    </p>
<pre><code>$ git push origin HEAD --force
</code></pre><a id="more"></a>    
<h2 id="可以吃的后悔药-gt-版本穿梭"><a href="#可以吃的后悔药-gt-版本穿梭" class="headerlink" title="可以吃的后悔药-&gt;版本穿梭"></a>可以吃的后悔药-&gt;版本穿梭</h2><p>当你回滚之后，又后悔了，想恢复到新的版本怎么办？</p>
<p>用<code>git reflog</code>打印你记录你的每一次操作记录</p>
<pre><code>$ git reflog

输出：
c7edbfe HEAD@{0}: reset: moving to c7edbfefab1bdbef6cb60d2a7bb97aa80f022687
470e9c2 HEAD@{1}: reset: moving to 470e9c2
b45959e HEAD@{2}: revert: Revert &quot;add img&quot;
470e9c2 HEAD@{3}: reset: moving to 470e9c2
2c26183 HEAD@{4}: reset: moving to 2c26183
0f67bb7 HEAD@{5}: revert: Revert &quot;add img&quot;
</code></pre><p>找到你操作的id如：<code>b45959e</code>，就可以回退到这个版本</p>
<pre><code>$ git reset --hard b45959e
</code></pre>]]></content>
      <categories>
        <category>编程技术</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 基础命令使用</title>
    <url>/2017/01/03/2017-01-03_Programing-Git-Git-command/</url>
    <content><![CDATA[<blockquote>
<p>随便整理的一些自用的Git指令</p>
</blockquote>
<h1 id="GitHub创建仓库提示代码"><a href="#GitHub创建仓库提示代码" class="headerlink" title="GitHub创建仓库提示代码"></a>GitHub创建仓库提示代码</h1><pre><code>echo &quot;# 项目名&quot; &gt;&gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin git@github.com:youdaily/youdaily.git
git push -u origin master
</code></pre><p>若仓库存在直接push</p>
<pre><code>git remote add origin git@github.com:youdaily/youdaily.git
git push -u origin master
</code></pre><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="创建仓库（初始化）"><a href="#创建仓库（初始化）" class="headerlink" title="创建仓库（初始化）"></a>创建仓库（初始化）</h2><pre><code>在当前指定目录下创建
git init

新建一个仓库目录
git init [project-name]

克隆一个远程项目
git clone [url]
</code></pre><h2 id="添加文件到缓存区"><a href="#添加文件到缓存区" class="headerlink" title="添加文件到缓存区"></a>添加文件到缓存区</h2><pre><code>添加所有变化的文件
 git add .

添加名称指定文件
git add text.txt
</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code>设置提交代码时的用户信息
git config [--global] user.name &quot;[name]&quot;
git config [--global] user.email &quot;[email address]&quot;
</code></pre><a id="more"></a>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><pre><code>提交暂存区到仓库区
git commit -m &quot;msg&quot;

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><pre><code># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><pre><code># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre><h2 id="标签Tags"><a href="#标签Tags" class="headerlink" title="标签Tags"></a>标签Tags</h2><pre><code>添加标签 在当前commit
git tag -a v1.0 -m &#39;xxx&#39; 

添加标签 在指定commit
git tag v1.0 [commit]

查看
git tag

删除
git tag -d V1.0

删除远程tag
git push origin :refs/tags/[tagName]

推送
git push origin --tags

拉取
git fetch origin tag V1.0

新建一个分支，指向某个tag
git checkout -b [branch] [tag]
</code></pre><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><pre><code># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><pre><code># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code># 生成一个可供发布的压缩包
$ git archives
</code></pre>]]></content>
      <categories>
        <category>编程技术</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中 ABC 模块使用</title>
    <url>/2016/12/03/2016-12-03-Programing-Python-Basic-ABC-Module/</url>
    <content><![CDATA[<h2 id="1-abc模块作用"><a href="#1-abc模块作用" class="headerlink" title="1.abc模块作用"></a>1.abc模块作用</h2><p>Python本身不提供抽象类和接口机制，要想实现抽象类，可以借助abc模块。ABC是Abstract Base Class的缩写。</p>
<h2 id="2-模块中的类和函数"><a href="#2-模块中的类和函数" class="headerlink" title="2.模块中的类和函数"></a>2.模块中的类和函数</h2><h3 id="abc-ABCMeta"><a href="#abc-ABCMeta" class="headerlink" title="abc.ABCMeta"></a>abc.ABCMeta</h3><p>这是用来生成抽象基础类的元类。由它生成的类可以被直接继承。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span>:</span></span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line"></span><br><span class="line">MyABC.register(tuple)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> issubclass(tuple, MyABC)</span><br><span class="line"><span class="keyword">assert</span> isinstance((), MyABC)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>上面这个例子中，首先生成了一个MyABC的抽象基础类，然后再将tuple变成它的虚拟子类。然后通过issubclass或者isinstance都可以判断出tuple是不是出于MyABC类。</p>
<p>另外，也可以通过复写<code>__subclasshook__(subclass)</code>来实现相同功能，它必须是classmethod</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_iterator</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterable</span>:</span></span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_iterator</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__iter__()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> MyIterable:</span><br><span class="line">            <span class="keyword">if</span> any(<span class="string">"__iter__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">MyIterable.register(Foo)</span><br></pre></td></tr></table></figure>
<h3 id="abc-abstractmethod-function"><a href="#abc-abstractmethod-function" class="headerlink" title="abc.abstractmethod(function)"></a>abc.abstractmethod(function)</h3><p>表明抽象方法的生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_method</span><span class="params">(self, ...)</span>:</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<h3 id="abc-abstractproperty-fget-fset-fdel-doc"><a href="#abc-abstractproperty-fget-fset-fdel-doc" class="headerlink" title="abc.abstractproperty([fget[,fset[,fdel[,doc]]]])"></a>abc.abstractproperty([fget[,fset[,fdel[,doc]]]])</h3><p>表明一个抽象属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line"><span class="meta">    @abstractproperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_property</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>上例只是只读属性，如果是读写属性，可以如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span> ...</span><br><span class="line">    x = abstractproperty(getx, setx)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Programing-Hexo-Paging_function</title>
    <url>/2016/11/23/2016-11-23_Programing-Hexo-Paging-function/</url>
    <content><![CDATA[<p>我们在搭建完Hexo + Github pages的博客后，会发现他的主页会默认显示很多的文章（默认 10 篇），而我们也许需要自定义分页进行管理主页博客的显示数量。</p>
<p>因此，本教程教会大家，如何设置主页的文章显示数量.</p>
<a id="more"></a>
<hr>
<p>首先我们找到Hexo的根配置文件_config.yml，注意不是主题的配置文件。<br>然后按照下面图片中的内容搜索：per_page，在图片中对应位置修改数字即可<br><img src="/2016/11/23/2016-11-23_Programing-Hexo-Paging-function/hexoPerPage-01.jpg" class title="设定"></p>
<p>之后我们就可以在我们的博客主页看到分页的效果啦！<br><img src="/2016/11/23/2016-11-23_Programing-Hexo-Paging-function/hexoPerPage-02.jpg" class title="结果"></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Programing-Hexo-Hexo_blog_read_more_button</title>
    <url>/2016/11/22/2016-11-22_Programing-Hexo-Hexo_blog_read_more_button/</url>
    <content><![CDATA[<p>我们在搭建好博客后，肯定是第一时间写一篇文章测试一下啦！但是细心的你一定会发现一个问题，那就是——主页为什么会展示每一篇文章的所有内容？而不是首页只展示文章的部分内容，再提供一个阅读全文的按钮呢？</p>
<p>本篇博客就是帮助各个同学实现阅读全文的功能，同时根据自己的使用经验给出意见和建议。要实现阅读全文，目前存在两种方法，我们会一个个讨论，评价其优缺点的。</p>
<h2 id="方法一：配置文件设置"><a href="#方法一：配置文件设置" class="headerlink" title="方法一：配置文件设置"></a>方法一：配置文件设置</h2><p>首先我们需要找到Hexo所使用主题的主配置文件_config.yml，注意此处不是Hexo的主配置文件，而是主题的。博主所使用的是NexT主题，因此在此以此为例。</p>
<a id="more"></a>
<p>方法一是搜索此处的 <code>auto_excerpt</code>，将 <code>enable</code> 改为 true，就自动可以对每一篇文章进行分割了，length 属性就是定义显示的字符数量。<br><img src="/2016/11/22/2016-11-22_Programing-Hexo-Hexo_blog_read_more_button/auto_excerpt_setting.png" class title="auto_excerpt_setting"></p>
<p>但是不得不说，很不建议使用此方法，主要原因是：</p>
<p>作者不能灵活控制显示内容，只能固定遵循字数设置<br>会丢失Markdown语法的格式，只显示纯文本<br>对！没错！Markdown的格式会全部丢失，所以整个首页的博客预览会非常难看。而主题作者推荐的做法也写的非常明显了，就是在图片中红框当中的内容。</p>
<h2 id="方法二：手动分割文章"><a href="#方法二：手动分割文章" class="headerlink" title="方法二：手动分割文章"></a>方法二：手动分割文章</h2><p>在文章当中需要分割的位置手动插入以下语句即可：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- more --&gt;</span></span></span><br></pre></td></tr></table></figure><br>效果还是很不错的，如图所示：<br><img src="/2016/11/22/2016-11-22_Programing-Hexo-Hexo_blog_read_more_button/read-more.png" class title="read more 按键"></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
      </tags>
  </entry>
</search>
