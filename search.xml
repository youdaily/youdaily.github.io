<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网易裁员事件-《网易裁员，让保安把身患绝症的我赶出公司。我在网易亲身经历的噩梦》</title>
    <url>/2019/11/24/2019-11-24-Life-WY-issues-log/</url>
    <content><![CDATA[<p>以下为《网易裁员，让保安把身患绝症的我赶出公司。我在网易亲身经历的噩梦！》全文内容：</p>
<p>我是网易的一名游戏策划。14年从上海交大毕业后就进入网易工作，5年里，我和大部分网易员工一样以“网易人”的称号为傲。</p>
<p>直到18年底开始传出网易毁约应届生、年前最后一天裁员、威胁员工的消息时，仍不愿相信这是网易的所为，更想不到不久后我就会在身患绝症的情况下亲身经历逼迫、算计、监视、陷害、威胁，甚至被保安赶出公司。</p>
<p>01 患病</p>
<p>这5年里，除了某段时间经常在后半夜两三点钟下班，主管说第二天早上可以请病假晚到一会儿之外，我请病假的次数屈指可数。</p>
<p>但去年年底感冒后开始头晕体虚，爬楼梯开始吃力，这才开始多次向主管和代理主管请病假就医。</p>
<p>今年1月底，被确诊为扩张型心肌病。心脏扩大近一倍。期间跟代理主管说了是心脏出了问题，但只是请病假更方便了一些，没有因病减少或耽误丝毫工作。</p>
<p>3月底主管找我谈绩效，说他跟代理主管聊过了，这次准备给我评D绩效，因为我现在不适合在这里继续工作了。</p>
<p>当时我很懵，因为我和代理主管每天吃饭的时候都在讨论项目的开发方向，很多重要的功能也都是我俩加班讨论确定的，重要功能他也都交给我做，组内的业绩排名也基本是他第一我第二。</p>
<p>我不明白他为什么要突然捅我一刀。</p>
<p>我又问主管原因，结果主管给出的都是因为组内人数过多，因为老员工的评判标准要比新员工高这种很敷衍的理由。</p>
<p>02 威胁不让拿N+1</p>
<p>因为这半年项目的管理工作都是由代理主管负责的，主管完全没有参与项目管理。</p>
<p>所以我又找主管说这个D绩效和我的实际工作不符，并亲自阐述我这半年的业绩。</p>
<p>结果刚阐述没几句就被主管打断，说我现在已经不适合继续在这工作下去了，说我只能接受这个结果并在一个月内离职，而且这期间要把我积攒的11天年假休完，并在年假前把离职申请发了，电脑也还了。</p>
<p>4月总共21个工作日，除掉我的年假，额外给我的时间是10个工作日。</p>
<p>我不愿发申请，主管和HR就轮番找我谈话逼我，并且变相威胁说拿N+1的话会对我非常不利，句句都是以“怕影响我找下一份工作”的角度劝我不要拿N+1。</p>
<p>接下来我发现不止我一个，周围还有其他同事被主管约谈劝退。</p>
<p>随后发现网上有很多网易同事曝出公司裁员，并通过威胁不给赔偿的事实。然而其中的很多爆料却都被辟谣、删帖或举报言论不实了。</p>
<p>不过这些帖子却给了我很大的帮助和指引。让我知道接下来的谈话要录音，不能签字等。</p>
<p>其中印象最深的一个帖子，是一个网易同事被HR逼走之后，觉得很委屈。底下评论的人没有安慰他，而是骂他太窝囊。</p>
<p>当时我很不理解，但现在想起来，如果不是看到了那些骂声，恐怕我也会和那位同事一样。</p>
<p>虽然同事们的爆料都被压制住了，但却给我这个正在被裁的人带来了好处。</p>
<p>接下来HR和主管找我谈话的时候，竟然松口说可以给我约四分之一的补偿，不过仍然说拿N+1的话会对我很不利。</p>
<p>他们一边跟我说少拿那点补偿不算什么，一边又说公司会因为我多拿那点补偿对我这样那样的，让我有种公司比我个人还穷的错觉。</p>
<p>我说这次是因为要让我走强行给我打了D绩效，不给我N+1，那我原本应得的绩效奖金总可以给我吧？</p>
<p>然而HR说绩效奖金是不受法律保护的，而且已经分完了。</p>
<p>03 设陷阱阻拦我绩效申诉</p>
<p>接下来我开始找工作，并主动说了自己患扩张型心肌病的实情，结果都被拒绝了。</p>
<p>期间我又去医院看了几位医生，这才意识到原来药物只是控制我的病情恶化速度，原来可能只有几年时间，然后只能靠心脏移植来续命。</p>
<p>期间主管和HR继续找我谈话，每次我都试图和他们谈我的工作内容，然而他们每次谈话都不停地强调就是要裁掉我，和绩效无关，即便绩效高也要裁掉我。</p>
<p>而且不停地让我觉得留下来没有意义，好像我留在公司就是累赘一样。</p>
<p>5年来，我第一次开始想要逃离这里，而且每一次谈话就强烈一次。然而我无处可逃。</p>
<p>唯一有所不同的是，他们再次用背调威胁我的时候，我感觉不到害怕了。</p>
<p>一直以来把前途看得无比重要的我，终于不用再为前途担忧了。</p>
<p>和绩效无关，那我能想到的这半年来我犯的别的错就只有生病了，然而这个错我改不了，所以我还是只能从绩效的角度出发。</p>
<p>这时我收到了绩效通知邮件，说不回复邮件就算认同此次绩效评定，于是我回邮件进行绩效申诉。</p>
<p>结果申诉后主管找我谈话，说绩效申诉对我没什么好处，所以他跟HR说这个流程可以稍缓缓，还说他特批我可以不用来公司打卡了。</p>
<p>平时请病假和即将到期的年假都要保证丝毫不影响工作，如今对员工这么好，实在不敢消受。</p>
<p>当天HR也找我谈话，要撤掉我的工位，还说接下来就不用来公司打卡了，并再次催我请年假，且在这之前把电脑还了，离职手续先办掉。</p>
<p>第二天我依旧去上班，结果发现已经被踢出了工作圈，很多证据因此无法收集。</p>
<p>当天收到了HR要求提供绩效复核证据的邮件，要求两天内提供绩效复核的证据，否则就又视为认可此次绩效结果。</p>
<p>也就是说如果我按照主管和HR说的还了电脑第二天开始不去公司了，就会稀里糊涂地认可了绩效结果。</p>
<p>幸好我已经提前准备了一些业绩证据，于是很快提交了复核证据。</p>
<p>04 监视和旷工威胁</p>
<p>差不多从这时候开始，我就经常在公司看到几个面生的人。</p>
<p>之后我的工位被调到远离策划组的过道角落位置，他们几个间或从我座位旁经过。</p>
<p>有时去我旁边的会议室打电话时还不时看向我。搞得我每次用u盘拷证据都很紧张很小心。</p>
<p>我一度想拍下来，又怕真是同事被误伤，觉得被监视这种事离自己太遥远了。</p>
<p>等待绩效复核的同时，我按照网上大家说的对付非法裁员的常用方法，不发离职申请，也不请年假，每天按时打卡上下班。</p>
<p>结果HR又给我发消息说如果不请年假就算我旷工。（迟到早退旷工公司是可以直接开除且不需要支付补偿金的）</p>
<p>▲ HR聊天截图</p>
<p>我在网易的5年时间里，一次迟到早退都没有。</p>
<p>不管是连续几周加班到后半夜，还是连续的996，第二天我都没有迟到过。</p>
<p>感冒发烧身体不舒服，强撑着也要在周维护的早上爬起去公司，也要等半夜周版本测试结束才能离开公司，我依然没有迟到早退。</p>
<p>我坚持了5年，可坚持到最后，只是因为我不愿意接受他们的摆布，就威胁要强行算我旷工。</p>
<p>我不服。于是仍然拒绝按HR说的做，坚持等绩效复核。</p>
<p>05 强行挑刺</p>
<p>之前HR给我发的邮件都是两天内不申诉就算认同绩效结果、两天内不提供证据就算认同绩效结果，让我以为很快就会开展绩效复核。</p>
<p>可等我提供完证据后，复核却一再推迟。</p>
<p>绩效复核开始前的一个小时，主管再次找我谈话，说如果真的走到绩效复核这一步，那他就跟HR说直接走辞退流程，接下来就要很严格地去做了。</p>
<p>我问他为什么不能进行绩效复核，如果我拿到我应得的绩效呢？</p>
<p>主管说那也是走辞退流程，还问我现在手上已经没有工作要做了，接下来打算怎么办呢。</p>
<p>可他越是阻拦，我就越是坚持要绩效复核。</p>
<p>虽然3月底这次谈的这次绩效名义上是“2018年下半年绩效”，但以往主管和我谈的都是最近半年的业绩，所以我提供的业绩证明也是18年10月-19年3月的。</p>
<p>结果在之后的绩效复核中，主管说要从18年5月开始算半年的工作量。</p>
<p>19年3月底谈的半年绩效，怎么算能把18年5月份算进来？</p>
<p>但我能理解主管要这么算的目的。5月中旬我才因为前一个项目组解散进入这个项目组，还在熟悉项目内容。而6月我又休了一个很长的年假（网易的年假6月30日清空，当时小主管也是刁难不愿给假，另外一个同事年假期间还要每天下午去公司干活儿）。</p>
<p>所以按照主管的算法，自然会对我的业绩影响很大。</p>
<p>而且这样一来，我提供的业绩证明就基本都没用了。</p>
<p>关于我的工作业绩，我不做任何主观的评价，只想客观说明几点：</p>
<p>公司有游戏设计专家进行业绩评审，我18年11月底刚刚通过评审晋升。</p>
<p>而项目组有业绩排名，在项目周报上公示。</p>
<p>▲ 18年11月业绩排名</p>
<p>▲ 18年12月业绩排名</p>
<p>11月份我的业绩排名在组内7人中排名第2，12月份在组内6人中排名第2，而我负责的功能bug率为全组最低。即便确诊后病情严重期，我的排名也基本稳定第2名。</p>
<p>尤其是3月，如果不是主管让人把我负责的已经完成的单子转到别人名下，我应该是第一名。</p>
<p>被我反驳后主管又强行挑刺说我有一个bug，我反驳说这个bug是接口bug，不是我的bug，而且影响很小。</p>
<p>结果主管说所有的问题都是策划的问题，问我同意吗。</p>
<p>那现在如果我说所有的错也都是主管的错，不知主管你同意吗？那你愿意也为这个接口bug引咎辞职吗？</p>
<p>现场只有一个HR旁听，完全就是走个过场而已，绩效申诉的真正作用应该也就是为了让员工默认绩效结果。</p>
<p>真心觉得自己患病后还那么卖力地工作没有一点意义。</p>
<p>06 用保安威胁我</p>
<p>复核结束后主管和HR找我谈话，说要在绩效复核结果出来之前就让我离职，并再次强调不管我的绩效是什么都要让我离职。</p>
<p>又说项目运营不下去我有责任，想通过变相背锅的方式让我离职。</p>
<p>然而这半年来我和代理主管不停地讨论着怎么修补之前主管和小主管们留下的设计缺陷。</p>
<p>其中有两个缺陷导致游戏后期完全无法继续运营下去，一个是让玩家花一两百块通过该系统获得的属性强过之前玩家需要花十几万才能获得的属性，另一个则是彻底打破了职业平衡。</p>
<p>即便主管这半年都没有负责项目组的工作，可只要他一直在玩我们的游戏，就不可能发现不了这么严重的问题。</p>
<p>然而主管和小主管只是在游戏开服时暗示我们充值过万才能做出好的设计，半强制地带动组内策划们充一波钱。</p>
<p>当时主管布置给我们策划的一项任务，就是每人要“维护”游戏内的几个大R玩家，并每周作为工作内容来汇报。</p>
<p>两个月后，维护的大R基本都走了，主管和小主管们就不怎么登陆游戏了。只有我和代理主管每天努力地把游戏等级维持在服务器最高等级。</p>
<p>而游戏里玩家们的行为也如他们所期，都是进来充几十万，两个月后，就没几个玩家在玩了。好不容易留下的那几个大R，在后期看到自己十几万获得的属性，只要百来块就能获得了，也愤而退游。</p>
<p>某位小主管凭借这两个设计晋升了策划主管。</p>
<p>而我何德何能，身患重病还有此殊荣为不作为的主管和犯错的小主管背完最后一口锅。</p>
<p>谈话时主管多次数落我说你看xxx（其他在他手底下被裁的同事）多久就走了？xxx可是没拿补偿金的。好像我应该和其他同事攀比谁更快签字离职，谁不拿补偿金似的。</p>
<p>又举其他人离开的例子，说这次很多人都走了，问我跟我一起进来的人还有几个在的？多吗？</p>
<p>说严选、考拉、邮箱比我们裁得更厉害，让我接受这个结果。（我主管的职级是高级经理，在网易内部绝对的高管，他的话可以代表网易承认裁员的事实）还说在其他公司，都只会上午通知，下午就让员工走人，也没有N+1，不按劳动法来也是很正常的。</p>
<p>说他没有说上午通知我，下午就让我走，还耐着性子跟我沟通了这么多，没有要HR和IT直接来收我的机器，收我的工牌让我走对吗？</p>
<p>接着说我只有两个选择，一是主动签字，二是被动签字。</p>
<p>我问他如果我不签字呢？</p>
<p>结果主管说那接下来就是保安和IT的事了。</p>
<p>我问跟保安有什么关系，他说他也不知道，他只是猜测而已。</p>
<p>从他用保安来威胁我时，我就决定了，我一定不会签字，一定要去仲裁。</p>
<p>不过我还是很害怕，也不敢想象被保安赶出公司的狼狈。</p>
<p>然而我只是一个在网易兢兢业业加班了5年患了重病的老员工，只是被主管HR威胁逼迫时不愿意签字而已。</p>
<p>不签字难道不是员工的自由吗？为什么到了网易这里却成了员工必须遵守的规则，不遵守就要用保安赶出去？</p>
<p>公司可以一而再再而三地威胁算计员工，员工却不能反抗？</p>
<p>07 住院时的威胁</p>
<p>疾病再加上主管和HR的一再威胁逼迫，压得我每天都透不过气来，每分每秒都处在要崩溃的边缘，最后终于撑不住住院了。</p>
<p>而我将住院的事情告知主管请假后，HR给我打电话问我住院的地址，说主管和HR很关心我的病情，有一个文件要寄给我。</p>
<p>我问文件内容是什么，HR说让我先签收自己看。</p>
<p>我说我都不知道内容是什么，而且我在住院不方便，不能签收。</p>
<p>结果HR说“收个稿件你觉得会影响你养病？”“如果你觉得现在收不方便，那我们寄回你老家，让你家人帮你收也可以的。”</p>
<p>我想如果他们也有父母的话，应该也会知道父母年龄大了受不了刺激。</p>
<p>背调威胁、旷工威胁、保安威胁、住院了还要威胁，而且还用我的家人来威胁。</p>
<p>而且所有的威胁都是变相威胁，或许他们觉得这样就能掩盖威胁员工的本质了吧！</p>
<p>在我住院的时候，项目也迎来了最重要的一次活动，3个活动玩法中两个核心玩法都是我之前制作的。而再之前的次重要活动也是我负责制作的。</p>
<p>当我躺在病床上看着主管们朋友圈转发我的活动时，再没有丝毫的自豪感，只是觉得有些悲凉。</p>
<p>在网易这么多年，见过程序被分配了超负荷工作量最后被挑刺说有bug的，也见过UI累死累活两年在项目马上上线时主管向UI主管说坏话给调走的，我只是比他们更惨了一点而已。</p>
<p>在网易，你努力了还是会有回报的，只是不一定回报在你身上。</p>
<p>接下来的3个月，我度过了人生中最漫长的一个病假。</p>
<p>上一次这么长时间无所事事地闲着，似乎还是小学升初中的暑假。</p>
<p>这期间我想通了两件事。</p>
<p>一件关于生存。</p>
<p>虽然在网易游戏工作，但我的收入并不高，早年好不容易涨薪也只多拿了800块钱，主要的工资涨幅也都在被裁前的那几个月，拿了没多久就要被裁掉。</p>
<p>5年来我拿到的项目分红奖金加起来也只有不到3000块。</p>
<p>除去支付公司附近高昂的房租和偿还上学时家里欠的债，所剩无几，也曾因此买不起高端手机和没有在游戏中充值足够多的金额而影响了绩效评价。</p>
<p>现在的我无房无车，未来还需要生活费医药费以及巨额的心脏移植费用。</p>
<p>父母年龄大了，而我未来非但不能赡养父母，还要指望父母去借钱给我治病。</p>
<p>他们借钱供我读完了大学，而现在，我不能再让他们去借钱了。因为上学时借的钱我毕业了可以赚钱还，而现在再借钱很可能会成为死账，没人可以还了。</p>
<p>所以我一定要继续工作。</p>
<p>另一件是为什么之前经受网易裁员手段的同事都想仲裁想曝光网易的行为。</p>
<p>网易的行为其实就是在卸磨杀驴。</p>
<p>气愤的不是卸了磨之后不给水喝，而是卸了磨非但不给水喝，还用刀子对着你。</p>
<p>然而同事们都担心影响前途，所以不敢做。</p>
<p>那如果我注定没有前途了的话，为什么我不来做这件事呢？</p>
<p>08 被早退</p>
<p>7月份的时候，因为继续休病假公司就要额外多支付我半个月工资的补偿金，于是主管给我发消息说要接听HR的电话才可以继续休病假。</p>
<p>为了避免再次在电话里被威胁，我回复说已经依法提供了病假所需的全部材料，如果公司觉得还缺少什么材料我可以补充，结果主管回复说必须接听HR电话才能继续休病假。</p>
<p>因为我已经仔细查过相关法律条文，确定自己依法提供了病假所需材料，于是拒绝接听。</p>
<p>结果7月底，我上系统看了一眼，发现自己竟平白多出了4次早退记录。</p>
<p>网易的考勤系统只显示上班打卡时间，下班打卡时间是隐藏的。所以除了证明没迟到外，员工很难进行其他和考勤有关的维权。</p>
<p>不过我在请病假前留了张自己的考勤截图。</p>
<p>▲ 5-10考勤记录</p>
<p>▲ 7-31考勤记录</p>
<p>5月10号是我请病假前在公司的最后一天，可以看到，当时还没有早退记录。</p>
<p>而5月10号开始我一直在休病假。</p>
<p>所以这4次早退记录到底是从医院早退，还是从家里早退？</p>
<p>09 被诬陷发反动内容</p>
<p>接下来我联系了一些网易同事，说了自己想仲裁和曝光公司的想法。</p>
<p>结果两天后有关部门突然找到我家，说我有反动倾向和自杀倾向，依据是我搜索和浏览过相关内容。说要找我调查情况，让我母亲赶快把我交出来。</p>
<p>我母亲说我患病并苦苦哀求，保证会看好我不做任何事，他们才没有找我调查。</p>
<p>紧接着我收到HR的邮件，说必须回公司去签署一份告知书，否则会对我后续休病假十分不利。</p>
<p>因为担心回去之后会被以早退等理由开除，我给老板发了投诉邮件，阐述了以往绩效评定中就存在的种种不公平之处，以及近期主管和HR通过强行打低绩效达到变相裁员的目的和他们威胁算计我的种种行为。</p>
<p>当然重点是附上了详细的业绩证据，可以证明主管给我的评定理由不成立以及我的实际业绩，申请专业的绩效复核。</p>
<p>这时候我依然相信主管和HR的行为只是个人的处理方式，相信公司会给我一个公正的评判。</p>
<p>之后我去公司，HR找我谈话时竟清楚地知道有关部门找我的事以及下的定论，还把定论升级为“有关部门说我发反党反政府”，试图以此作为我无法继续留下工作的一个理由。（公司的规定是员工有自杀、反动等倾向及发表任何不利公司的言论，公司均可直接开除并不支付任何补偿金）</p>
<p>我这才想起来，在被主管用保安威胁后，我把内部聊天软件的个性签名改成了“此去泉台招旧部，旌旗十万斩阎罗”，这是我能想到的唯一一件和发反党反政府内容有关的事了。</p>
<p>而整个病假期间，我除了和几个网易同事聊过仲裁曝光公司的事情外，没通过网络发表发送过任何内容。</p>
<p>所以这件事有三种可能：</p>
<p>1.有关部门确实和公司这样说的，但我没发，那这就是在诬陷我。</p>
<ol>
<li><p>有关部门没和公司这样说，那就是公司在诬陷有关部门。</p>
</li>
<li><p>是公司向有关部门这样举报我的。那就是公司在诬陷我。</p>
</li>
</ol>
<p>我想如果病假期间我为了找工作把之前的工作内容发给HR或猎头，可能就是这样的结局了吧。</p>
<p>▲ 其他同事经历</p>
<p>10 老板知情后的继续威胁</p>
<p>这次谈话的人多了一个HR总监。</p>
<p>他没提签告知书继续休病假的事情，却提出之前主管和HR提过的要求，让我回家办公，不用来公司打卡。我拒绝了。</p>
<p>然后他又说如果我不按他说的做，那他就不管了，说公司有那么多的法务和专业人员，交给他们处理。我就想我又没犯法，就算公司有1000个法务和我有什么关系？于是再次拒绝。</p>
<p>他又提出公司要给我提供一次心理咨询，我拒绝了。</p>
<p>然后他又提出让我签字授权他们和我的医生聊一下以及让我到他们指定的医疗机构去检查，但不告诉我这样做的目的。</p>
<p>因为当时我的症状还是比较严重，担心会被说成“医疗期结束后仍无法从事工作”，于是跟他说签字可以，但是公司要保证不会以“医疗期结束后仍无法从事工作”为由开除我，结果他说不能保证，于是我又拒绝了。</p>
<p>而根据HR总监和HR之后的表述，老板把我的投诉邮件给他们看过了。</p>
<p>于是接下来HR找我谈话时，换了更隐晦的威胁方式。</p>
<p>跟我说仲裁就算我赢了，公司也会通过不断上诉拖我两年时间，我耗不起的。</p>
<p>至此，我彻底对来自公司的公正评判不抱任何希望了，还有些后悔将我掌握的全部业绩证明发给老板了。</p>
<p>大公司的确有比小公司更完善的制度，但更多的都是维护公司利益的。</p>
<p>不过他们承诺如果同意签字，可以给到高于N+1的金额。</p>
<p>关键是要拿这笔钱是有附加条件的，要分12个月拿。这意味着不仅要放弃后续一切的法律途径维权，而且变得没有保障。</p>
<p>其实如果我相信公司的话，可能也会选择接受，毕竟于我而言，每一分钱都是救命钱。</p>
<p>然而此前千方百计逼我走，威胁不让我拿N+1，不肯给我应得的奖金，连病假都不愿让我休，中秋礼盒都没我的份……我经历的这一切让我已经不敢相信公司了。</p>
<p>事实证明公司在这方面的确是毫无信用可言。</p>
<p>在公司后来给出的单方解除通知书上，明确写着N+1和应发的工资会在9月9日前发放。然而9月9日我没有收到一分钱。</p>
<p>最后N+1还是我去申请劳动仲裁后才拿到的。（其他同事的大额赔偿金也有被公司一直拖着不给，去申请了仲裁公司才给的。）</p>
<p>因为我拒绝接受他们开出的条件，并且表达了会通过法律途径维权，于是HR给我母亲打电话，说我生了这个病就没法继续在这工作了。</p>
<p>我母亲说确诊后也一直在加班，是因为他们一直威胁我特别是最后主管威胁要让保安赶我出去才会病情加重。</p>
<p>结果HR说让我母亲劝我，否则他们也不愿意看到保安来清退我。</p>
<p>我母亲说网易这样欺负人我们就向社会求助。</p>
<p>巧的是，第二天一早，又有工作人员来敲门，拿着电话说有关部门人员要找我母亲，问我母亲我的情绪怎么样，跟我母亲说我现在离职还没离职，让看好我不要做出什么事来。</p>
<p>我母亲怕出事，于是劝我说要不主动签字算了。</p>
<p>而我却感觉自己好像被无数的铁链捆绑着，喘不过气来。勒得越紧，我就越是想挣脱。</p>
<p>但是我的身体还是太没用了，于是我没能去公司，又去了医院。</p>
<p>请了病假之后，HR给我打电话，在我告知了人在医院身体状态不好的情况下，仍然要让我去一趟公司。</p>
<p>我说我需要休息，如果身体状况好些就过去。结果回去刚睡下，就被HR接二连三的电话吵醒。最后我母亲接了电话，告诉她我实在去不了她才肯作罢。</p>
<p>11 保安暴力驱赶</p>
<p>周末休息了两天，周一我去了公司。</p>
<p>HR和HR总监找我谈话，我又陈述了病假回来后仍然被他们排挤的事情。HR总监冷嘲热讽地说他也能感觉到我留在这里并不愉悦，不明白我为什么还不走。</p>
<p>你们千方百计排挤我边缘化我，想要逼我主动离职，我当然不愉悦了。可如果我主动离职，不就中了你们的下怀了吗？</p>
<p>所以不好意思，就算给我的是一坨屎，我也要咽下去。</p>
<p>期间我表明了自己拒不接受公司开出的条件、要用法律来维权的态度。</p>
<p>而HR和HR总监再一次变相威胁要让保安赶我走，还说要让保安来清点我的个人物品。</p>
<p>至此，主管、HR总监和HR三个人均以保安驱赶作威胁，也说明这不是个人临时决定的行为，而是一项自上而下用来压迫员工的方针。</p>
<p>即便再次被威胁，最后从会议室离开的时候我还是先问HR总监我可以回去了吗？他说可以我才走的。</p>
<p>HR总监、HR谈话变声后来自你的游戏我的心00:0016:02</p>
<p>结果我刚回到工位，HR和HR总监就忽然带着几个保安围了上来，然后保安开始拆我的电脑，搜查我的个人物品。</p>
<p>除此之外还有另外几个不是穿着保安服的人在稍远处等着，不时和HR总监交涉，总共加起来有七八个人。</p>
<p>其中就有我之前频繁看到，怀疑是在监视我的人。</p>
<p>虽然此前已经被用保安驱赶威胁过3次了，可真的发生时我还是被这阵仗吓到了。</p>
<p>我想我但凡有一丁点的阻拦，那就又不知道是什么后果了。</p>
<p>于是9月9日，我和隔壁阿里的创始人同一天“退休”了。</p>
<p>我俩一样是在退休前“被早退”，也一样是被簇拥着离开公司的。只不过他被员工簇拥着，我被保安、HR和其他不知什么职位的人簇拥着。</p>
<p>这一天见证了一个互联网行业的伟大人物离场，一个互联网大时代的落幕。</p>
<p>而就在十几米外的另一边，一个互联网公司的绝症老员工被保安赶出了公司，一个互联网人的小时代也落幕了。</p>
<p>再次声明，我不是临时工，不是外包人员，在网易的5年里，我的职位一直是高级数值策划，是一名正式员工。</p>
<p>需要员工的时候就让其无限度地加班，不需要了就无所不用其极地要立马赶走，千方百计不让员工拿到奖金和法定的补偿金，还不许员工维权和抗争。</p>
<p>在我患病之后，我没有感受到他们哪怕一丁点的关怀，有的只是算计和威胁。</p>
<p>我想这些才是网易的规则吧。</p>
<p>离开时我也验证了一件事。</p>
<p>就是之前我频繁见到的生面孔，最后一天我被保安驱赶时，看到他们和保安HR们汇合了。</p>
<p>现在我想请公司证明一下，我和他们的频繁相遇真的是因为缘分，而不是公司安排他们监视我想搜集我什么把柄。</p>
<p>还想请公司澄清一下，HR、HR总监谈话时有意无意地提到我住在哪个小区，真的只是在拉家常而已。</p>
<p>不然我胆子小，会担心发完这篇文章我会有人身危险。</p>
<p>回想起刚进网易那会儿，午餐有酸奶，晚餐有水果，生日的时候有超市现金卡，下班后有免费的健身课。</p>
<p>后来酸奶水果都没了，工资强行打入网易宝，健身课要自费，员工的吃饭时间也被严格限制。</p>
<p>以前便宜又实惠的自动售货机也被换成了昂贵的严选零食，生日礼物也变成了考拉严选的折扣券和满减券，工作邮箱里充斥着大量的严选考拉等喊着员工福利实际却并没让利多少的促销邮件。</p>
<p>真不明白这样赚员工的钱又能赚多少呢？</p>
<p>如今又取消桶装水，限制纸巾，缩减奖金，坑应届生，威胁员工……</p>
<p>以前这里的确是养猪场，但现在在我眼里更像是屠宰场。</p>
<p>虽然现在这些都和我无关了，可我还是想说，公司怎么对待玩家，怎么对待员工，这些迟早都有一天会反作用于公司。即便没有立刻反应出来，可这些效应其实一直都在滚雪球。</p>
<p>如果有一天无论是从业者还是用户，在提起网易时都嗤之以鼻，那时该如何收场？</p>
<p>人散了，还能网聚起来。人心散了，就真的聚不起来了。</p>
<p>12 举步维艰的维权</p>
<p>经过这几个月的时间，我也统计出了这5年来我在网易加班的总时长，大约4000个小时，基本都是项目组强制的加班。</p>
<p>因为很大一部分证据无法收集，以及被保安驱赶时丢失的u盘和电脑里没能拷出来的证据，最后我带出来的只有一部分加班证据，但是能证明的加班时长还是有2400个小时。</p>
<p>当时我甚至觉得加班也有成就感，觉得那些朝九晚五的人就是在虚度人生。</p>
<p>可回过头来看时，我发现我们大部分的加班、迭代甚至推倒重做，都只是在为主管们的错误决策买单而已。</p>
<p>他们的KPI其实都是底层员工透支健康堆起来的。</p>
<p>主管们让员工超负荷自己却落得清闲，其实真正应该加班认真做决策把控方向的，恰恰是他们自己。</p>
<p>而对我个人而言，这些加班其实并没有太大的意义，这才是最可悲的地方。</p>
<p>5年的加班我也只拿到了1天的加班工资，还是公司设计的陷阱。</p>
<p>被赶出公司后我开始追讨加班工资，然而公司辩称我所有的加班都是不合规的。</p>
<p>那仅有的1天加班工资也成为了我所有其他加班不合规的佐证。</p>
<p>不过追讨加班工资的官司我还是会和公司打到底的，因为那每一分钱都是我的血汗钱。</p>
<p>上个月我去医院拿药发现医保用不了，查了一下才发现我的社保8月份就已经停保了。</p>
<p>离职证明公司也拖了一个半月不给我，即便我找劳动监察投诉，又跟HR说等着离职证明要领失业金，HR还是跟我说他们要考虑给不给我。</p>
<p>之后好不容易拿到离职证明去办理失业登记，又被工作人员告知公司开的证明不合规，于是我又联系HR说明了马上就要过了失业金办理期限，让帮忙盖公司公章。</p>
<p>结果HR回复我说她请示过了，因为我和公司对于解除劳动关系的理由存在争议，所以不能给我盖公章。言外之意就是我要放弃劳动仲裁，他们才肯给我盖章。</p>
<p>最后又是一番交涉，我才终于拿到证明材料，办理了失业证。未来的8个月时间里，我可以领到失业金了。</p>
<p>虽然我从未想过自己有一天要靠失业金生存下去。</p>
<p>要工资条的经过也和要离职证明的经过一样难。</p>
<p>前两次我给监察大队长打电话说公司没有提供工资条，每次大队长都说他联系公司让公司提供，可是公司根本就不给提供。</p>
<p>第三次我给大队长打电话问工资条的事，大队长说公司跟他说上了法庭再说。</p>
<p>我问为什么我要一张工资条也要到了法庭上才能拿到？并坚决要求尽快拿到工资条。</p>
<p>就这样我才终于从HR手上拿到了工资条，此时距离大队长第一次说打电话让公司提供工资条已经过去了一周多。</p>
<p>可我拿到工资条发现上面只有一个最终发给我的金额。我跟HR说我要工资条就是想看各项明细，知道为什么是这个最终金额的。</p>
<p>结果HR说我们公司的工资条就是这样的，不可能为你一个人提供单独的工资条，反正工资条我们已经给你了。说完转身就走。</p>
<p>我连忙说这样的工资条我不能收，然后把工资条还给了她们，并再次给监察大队长打电话说了这件事。</p>
<p>大队长也说让我收下公司给的工资条，说法律上没有规定工资条上必须要有明细。</p>
<p>如果我拿了这张工资条，公司就算是提供了工资条，但是我拿到这样一张工资条有什么用呢？那我要工资条这件事不就成了走个过场了吗？</p>
<p>每一次的维权都让我觉得举步维艰，也让我对后续的维权有了深深的担忧，我很怕后续的所有维权都成了走个过场。</p>
<p>关于违法解除的仲裁，我之前咨询过律师，说赢的几率大。</p>
<p>如果输了，我不怪任何人，但我会公开我和公司双方的证据，让大家给一个公正的评判。</p>
<p>13 可能是人生的终局之战</p>
<p>这些天经常站在窗边看平时上下班走的那条路，恍然记起以前凌晨两三点从公司回住处，打着哆嗦一边骑车一边唱“直到整条街上，剩我和路灯”。回去躺在床上还在兴奋地想着工作上的事。</p>
<p>那时我觉得房子、车子、另一半，所有的一切都在向我走来。</p>
<p>但是现在我又意识到，可能人生总要有一个点，你无法再通过努力改变自己的前途和命运，使自己的人生变得更好了。</p>
<p>我想我已经接近这个点了。</p>
<p>对不起，真的对不起，但是我真的尽力了。</p>
<p>事到如今我没有什么不敢面对的，但我唯独不敢面对我的父母。</p>
<p>那时候不管家里再穷，我的学习用品都是最好的。</p>
<p>我很怕看到母亲哭，我不知道该说什么。</p>
<p>我最大的愿望就是让父母过上好日子，不让他们再受累了，但我可能做不到了。</p>
<p>从今年年初到现在，我一直被各种恐惧笼罩着，害怕会晕倒，害怕会猝死，害怕父母成为失独老人，害怕失业，害怕无法生存下去，害怕被威胁到前途，害怕被保安赶出去，害怕被自杀，害怕被关押，害怕曝光会被压制被报复。</p>
<p>然而每一次害怕的时候，脑海里总是冒出那句“包拯今日冒死闯法场救贤王，根本就没想过要活着离开。包拯一死，何足挂齿。”</p>
<p>或许我感觉什么都能打倒我的时候，恰恰也是什么都无法打倒我的时候。</p>
<p>至少我还能一战。</p>
<p>我知道于网易这个庞然大物而言，这篇文章微不足道。然而于我个人而言，却是一生中最重要的仪式之一。</p>
<p>这篇文章发出来会有什么后果，我其实能够预料到，因为我的力量太小了。</p>
<p>我知道我最终还是无法击败任何人，我只是击败了我自己而已。</p>
<p>就像亲手推倒一座自己建造的高楼，用了二十几年一砖一瓦精心搭建，垮掉却是一瞬间的。</p>
<p>但我相信每一个细小的反抗的声音，都会汇成一条汹涌的河。</p>
<p>相信无论任何公司或领导，以任何手段侵害员工的权益，威胁压制不许员工反抗，不管权势再大，最终都一定会受到应有的惩罚。</p>
<p>这篇文章中仅仅陈述了和我的权益被侵害相关的事实，证据中可能涉及公司机密和个人隐私的部分也都模糊掉了。</p>
<p>如果我还是像之前曝光的同事一样受到起诉威胁，那我无能为力。</p>
<p>我知道接下来很长一段时间里，我还是要一个人对抗网易的HR团队、公关团队、法务团队和其他叫不出名字的团队，但这一次我不想再退缩了。</p>
<p>人在，塔在。</p>
]]></content>
      <categories>
        <category>日常生活</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>网易裁员事件</tag>
      </tags>
  </entry>
  <entry>
    <title>今日一文：妈妈的手套</title>
    <url>/2019/11/20/2019-11-20_Life-Wenxin-wen/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>昨天晚上给妈妈打电话的时候，妈妈说预报里面说：明天家里要下雪了，你那边冷吗？你要多穿点衣服，不要冻着啦！</p>
<h2 id="妈妈的手套"><a href="#妈妈的手套" class="headerlink" title="妈妈的手套"></a>妈妈的手套</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-fed24a8c6ace4bf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手套"></p>
<blockquote>
<p>图文无关</p>
</blockquote>
<p>记得那年冬天，我上初二，学校周末放假了，我和弟弟两个人闹矛盾，然后我的手不小心被刀划伤了。小时候的我们，都不是让母亲省心的孩子。弟弟那时还小，把我划伤后就和其它的小伙伴出去玩了。妈妈听到了我的哭声，从地里回来，带着我去村上的医疗室包扎伤口。医生仔细检查完伤口，进行了消毒包扎，然后对妈妈说：现在天冷，注意手不要冻着了，不然会很麻烦的。</p>
<p>回家后，妈妈让我坐在椅子上烤火看电视，然后自己又到田里去忙了。我在家里看着电视，听着外面呼呼的风声，心想天可真冷啊。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-afdea73a422163cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="北风吹"></p>
<a id="more"></a>
<p>第二天是周一，我们要一大早就去学校上课，并且我要在学习住校，周末才能回家。一大早，妈妈帮我收拾好东西，临出门的时候妈妈从房间拿出来一个很 <code>丑</code> 的 <code>手套</code>，递给我然后说道：这几点带着这个，天冷了主要别冻着了。我看着手里的手套，那是一个很大的<code>手套</code>，完全不符合我现在手的尺寸;  <code>手套</code> 腕部的地方很长，手指的部分除了大拇指有一个手指外，其它的几个手指都 是一个整体、并且没有封口; 看着就像是现在我们常用的护腕，只是多了大拇指那一点；<code>手套</code> 是使用的灰色的毛线织成的。妈妈看我不太情愿，拿起 <code>手套</code> 准备套在我受伤的手上。我把手往后缩了缩，妈妈顿了顿，一把抓过我的手，边小心地往受伤的手上套边说道：不想带就别受伤啊。我突然就哭了起来，但还是任由妈妈套上了手套，期间有几次妈妈碰到了伤口，我哭的更厉害了。妈妈没有安慰我，套完手套就进屋去了，我看着外面在等我的同学，我抹了抹眼泪和他们一起到学校去了。</p>
<p>一离开妈妈的视线，我就尝试 <code>扯</code> 下手套，但是试了几次，单手不太方便、伤口被碰了几次，最后还是放弃了。</p>
<p>到学校后，受伤的手给我的生活带来了很多的不便，原来能够很快完成的事情，现在很慢才能完成，例如扣衣服、上厕所完了提裤子。</p>
<p>比起生活上的不便，我更在意的是同学对我 <code>手套</code> 的评论。有些同学，会问怎么回事？有些同学会直接说：手套真丑，剩下的大部分同学都选择了忽视。我还是尝试要拿掉手套，但是终究还是没成功，本来最后一次都要成功了，忽然想到了医生那句：冻坏了就麻烦了，只得作罢。之后，我把受伤的手，放在桌子下面、衣服兜里、用手护着，反正就是减少被同学看到的机会。</p>
<p>终于又到了回家的日子。回到家后，我没看看妈妈，在上小学的弟弟说妈妈到田里去忙了，弟弟对我说道：哥哥，对不起，我不是故意弄伤你的。你也不要怪妈妈，那个手套是妈妈那天晚上花了一晚上织成的，毛线是妈妈从爸爸的毛衣上面拆下来的。那天你走了后，妈妈在家里哭了好久。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-1964f27924a42e33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="妈妈不哭"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>天冷了，你那边冷吗？你要多穿点衣服，不要冻着啦！</p>
<hr>
<p>图片来源于网络，侵删。</p>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>公众号</category>
        <category>天冷了</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>公众号</tag>
        <tag>天冷了</tag>
      </tags>
  </entry>
  <entry>
    <title>今日一文：国足又输球了</title>
    <url>/2019/11/18/2019-11-18_Life-Wenxin-wen/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>11 月 14 日晚，中国男足又输球了。</p>
<h2 id="比赛相关"><a href="#比赛相关" class="headerlink" title="比赛相关"></a>比赛相关</h2><p>11 月 14 日晚，2022 年世界杯亚洲区预选赛预赛阶段（四十强赛）A组的一场关键战役在此间打响，中国男足和叙利亚队伍的比赛正式上演。此前，中国队已踢过三场小组赛，分别以 <strong>5:0</strong> 和 <strong>7:0</strong> 战胜了马尔代夫和关岛，以 <strong>0:0</strong> 踢平菲律宾队。</p>
<p>比赛中中国男足在上半场扳平比分后，下半场因为一粒乌龙球以 <strong>1:2</strong> 遗憾负于小组最强对手叙利亚队，目前在小组中仅以净胜球优势排在第二位。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-11f7aa4a650f9008?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足比分"></p>
<p>在 <strong>1:2</strong> 不敌叙利亚队，再一次，将出线主动权拱手让出。本场战罢，中国队 2 胜 1 平 1 负积 7 分，以净胜球优势领先菲律宾队排在四十强赛 A 组的第二位，叙利亚队则以四战全胜积 12 分排名第一。依照“四十强赛”的规则，总共 40 支球队分成 8 个小组参加世界杯亚洲区的预选赛，8 个小组的第一名以及 4 个表现最佳的第二名球队也得以参加预选赛下一轮的比赛。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-9eb2079921b316e7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分组"></p>
<p>中国队唯一一次入围世界杯是在 2002 年的日韩世界杯，当时中国队输掉了所有三场比赛，并且未进一球。</p>
<a id="more"></a>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-5509e9a7619401a0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足比赛经过"></p>
<p>根据亚足联安排，国足在四十强赛A组的下一轮比赛定于 2020 年 3 月 26 日举行，届时国足将在主场迎战马尔代夫队。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-76d171ffee9dcfe1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足新赛程"></p>
<p>在赛后新闻发布会上中国男足主教练里皮宣布辞职并承担输球责任。“我们今晚输球了，我的年薪收入非常高，这场输球我承担全部责任，所以我向大家宣布现在辞职，不再担任中国队主教练。”，没等翻译讲完，里皮便离开了新闻发布会，留下一脸茫然的记者和工作人员。对于这位拿着2300万欧元年薪、全球收入最高国家队主教练来说，他和国足的缘分，真的到头了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-f3470af85020cae7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="里皮辞职"></p>
<p>11 月 15 日早上，足协官方微博上发表声明对国家队失利”深表歉意”。声明称：“接受里皮的辞职请求。并表示接下来“将会深刻反思，重组男足国家队，打好接下来的四十强赛”。”</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-ef20fb7f3ed632ee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足协道歉"></p>
<h2 id="中国女足的世界杯之旅"><a href="#中国女足的世界杯之旅" class="headerlink" title="中国女足的世界杯之旅"></a>中国女足的世界杯之旅</h2><p>上面是中国男足的情况，那作为另一个极端的中国女足的情况呢？</p>
<p>2019年法国女足世界杯上，中国女足先是 1:0 不敌德国队，后以 1:0 战胜南非队，在最后一轮则与西班牙队战平，最终以小组第三的成绩出线。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-211119c43021cb6d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="女足比赛日程"></p>
<p>但是在1/8决赛中 0-2 不敌意大利女足，无缘 8 强。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-a966191a7aff8ce8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="女足比赛日程"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>世界杯的比赛暂时告一段落，男足主教练“银狐”也离开了，中足协也道歉了，广大球迷也吐槽了，事件的热点也慢慢地退去了。但是，作为中国的足球事业却是刚刚起步，很多的问题需要解决。有人说是球员问题，有人说是教练问题，有人说是体制问题。其实对于广大的 “吃瓜群众” 来说，是谁的问题并不重要，重要的是什么时候才能真正的赢一场呢？</p>
<p>中国足球加油，中国加油…</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-71ce94dc3aff39e9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中国加油"></p>
<hr>
<p>图片来源于网络，侵删。</p>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>公众号</category>
        <category>世界杯</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>公众号</tag>
        <tag>世界杯</tag>
      </tags>
  </entry>
  <entry>
    <title>今日一文：三罢对香港经济的影响</title>
    <url>/2019/11/15/2019-11-15_Life-Wenxin-wen/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我们都知道，最近香港的局势不太稳定，暴徒们恶意破坏的行径，已经严重影响到香港居民的方方面面。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-41ab7b2376308e2c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一条满是砖块垃圾的马路"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-c28106337cf53a62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在沙田，一列火车因抗议者的扰乱而暂停服务，乘客被迫下车"></p>
<p>我们都知道，动荡的社会环境中，社会生产活动肯定会受到影响，这些影响最后将以经济数据的形式呈现出来。8 月份开始的 “三罢（罢工、罢课、罢市）” 活动，更是将对经济的影响放大了。这篇文章里，我们将尝试从香港政府已经公布的经济数据中，去发现暴力活动对香港经济造成的影响。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-20fdf6abb39bee30?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<blockquote>
<p>因为经济数据，具有一定的延后性，我们这里只从现有的数据出发，去分析问题。至于当下实际的情况，只能通过后续更新的数据再去分析啦。</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="三罢对香港经济的影响"><a href="#三罢对香港经济的影响" class="headerlink" title="三罢对香港经济的影响"></a>三罢对香港经济的影响</h2><p>三罢（罢工、罢课、罢市）对经济的影响对经济的影响是巨大的。</p>
<p>香港私人消费总额的年度变化在今年第三季罕有地出现负增长。虽然背后的最大成因仍需科学验证，但初步认为与全球经济衰退、美中贸易战和香港的社会动荡和罢市行动有关。而私人消费 (Private Consumption) 是香港的经济产值(GDP)中占最大份额组成，2018年的占比比高达68.3% (图1)，因此每当私人消费下跌，经常伴随经济衰退。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-fa7bd48162dceffa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1 香港各项经济环节佔经济产值的百分比，2018年。资料来源：贸易发展局 (2019) [1]"></p>
<p>但到底是经济衰退带动私人消费下跌，还是其他外在因素引发私人消费下跌，从而令GDP下跌？这里有两种不同的说法<br>说法一：由于通胀和人口增长等因素，私人消费一般长期持续正增长，但当经济衰退，预期和实际失业人数增加，打击私人消费信心，导致私人消费下跌；<br>说法二：当外在因素如罢市行动或支持节约消费行动生效，私人消费下跌，因而造成经济衰退。</p>
<p>在过去大半年的香港却同时出现以上两种情况，消费下跌的真正原因仍有待进一步研究。</p>
<p>数据方面，私人消费的年度增长率由今年第二季的 +1.3% 转为第三季的 -3.5%，虽然跌幅比其他组别为细，但由于占比巨大，对GDP增长的影响举足轻重 (图2)：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-d20d0dfb20690132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2 香港生产总值各项分项的年度增长率，2019年第二及第三季比较，资料来源：香港统计处[2]"></p>
<p>私人消费的组成以「零售总值」和「食肆收益」两项最具代表，图3是过去一年零售总值的每月年度变化率，自今年2月起至最新的9月份数字均是负数，而且有持续扩大迹象，最新8、9月份的跌幅更急跌两成多，打破了过去十几年的记录。但由于早自2月份已经出现双位数跌幅，远早于罢市行动，反映部份原因与罢市和社会动动荡等近期本地因素无关。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-b364e626da46cc57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3 香港零售总值年度变化2018年9月-2019年9月。资料来源：Trading Economics"></p>
<p>但零售数据较难分析成因，因为随着网络科技和智能手机的普及，愈来愈多的购物是透过网购完成，而零售总值的统计仍然只限于实体零售，网购未有定期统计数据 (事实上亦较难准确统计，尤其是二手货网购平台和非本地网购等)，因此部份零售总值的下跌可能源于愈来愈多消费者由实体店购物改为网购而已，同时，当社会动荡，经常变相戒严，亦会鼓励更多消费者改为网购，因此零售总值数据对反映私人消费变化有重大缺点。</p>
<p>食肆收益数据亦出现类似情况，不外出用餐可改为在家用餐，但如此一来已直接造成GDP减少 (因为GDP是不计算家庭成员的家务工作产出价值)，二来也影响商用物业租用，间接影响GDP数据。</p>
<p>图4显示食肆收益价值指数及其年度变化，过去十年持续正增长，平均年增长4%，但自今年4月起已经出现负值 (若以收益数量指数计算，更早在2月起已经变负)，最新9月份的跌幅高达13.1%，比2009年国际金融风暴时的跌幅还要大得多。</p>
<p>图4 香港食肆收益价值指数及其年度变化 2009 - 2019年9月。资料来源：香港统计处 [3]</p>
<p>其中各类餐饮均出现大幅下跌，只有快餐继续上升，这通常反映消费信心疲弱，减少在高级食肆消费，转食较经济的快餐。</p>
<p>图5显示中式餐饮自2月起已经出现下跌，但6月起跌幅扩大至双位数，最新9月份跌幅更达-20.3%；非中式餐馆的收益下跌相比没有中式的严重，9月份的跌幅为-14.5%，而且负增长由4月起才出现；酒吧的收益下跌最突然，由6月起突然由正转负，且一跌就跌双位数，9月份跌幅为-18.8%，可能与旅游警示、游客减少有关。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-447a5ecf51a117ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5 香港四类食肆的收益价值指数年度变化 2009 - 2019年9月。资料来源：香港统计处 [3]"></p>
<p>各类私人消费自6月起均有较明显的下跌，反映6月起市场出现突变，但由于同期美中贸易谈判曾经破裂，直到10月中美之间才再次开启了新一轮的和谈，但因为10月份的数据还没有对外公布，需待下个月数据出台再作分析。</p>
<p>参考：</p>
<p>[1]  香港贸易发展局 (2019) 香港经济概况，10月25日。<br><a href="http://hong-kong-economy-research.hktdc.com/business-news/article/%E5%B8%82%E5%A0%B4%E7%92%B0%E5%A2%83/%E9%A6%99%E6%B8%AF%E7%B6%93%E8%B2%BF%E6%A6%82%E6%B3%81/etihk/tc/1/1X000000/1X09OVUL.htm" target="_blank" rel="noopener">http://hong-kong-economy-research.hktdc.com/business-news/article/%E5%B8%82%E5%A0%B4%E7%92%B0%E5%A2%83/%E9%A6%99%E6%B8%AF%E7%B6%93%E8%B2%BF%E6%A6%82%E6%B3%81/etihk/tc/1/1X000000/1X09OVUL.htm</a></p>
<p>[2] 香港统计处 (2019) 二零一九年第三季本地生产总值预先估计数字，香港政府 10月31日。<br><a href="https://www.censtatd.gov.hk/press_release/pressReleaseDetail.jsp?charsetID=2&amp;pressRID=4506" target="_blank" rel="noopener">https://www.censtatd.gov.hk/press_release/pressReleaseDetail.jsp?charsetID=2&amp;pressRID=4506</a></p>
<p>[3] 香港统计处 (2019) 表E088：按食肆类别划分的食肆收益，香港政府 11月5日。<br><a href="https://www.censtatd.gov.hk/hkstat/sub/sp320_tc.jsp?productCode=D5600088" target="_blank" rel="noopener">https://www.censtatd.gov.hk/hkstat/sub/sp320_tc.jsp?productCode=D5600088</a></p>
<hr>
<p>PS: 图片来源于互联网，侵删。</p>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>公众号</category>
        <category>香港</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>公众号</tag>
        <tag>香港</tag>
      </tags>
  </entry>
  <entry>
    <title>今日一文-矛盾的日本人</title>
    <url>/2019/11/14/2019-11-14_Life-Wenxin-wen/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>早上的时候，因为工作需要和日本的客户开了个会，就是我们作为方案提供方，想客户推广公司的产品，我基本全程 <code>打酱油</code>，主讲的另外的两个同事。主要通过英语进行讲解，日本那边有一个英语翻译，复杂将双方的意思进行传达。会议讲述的内容是已经在很多场合下讲过很多次了，客户也没有问特别深奥的问题，整个过程下来感觉也没有给客户留下特别的印象。</p>
<p>会上的一件小事，却让我感到有点吃惊。</p>
<p>既然是推广，那肯定会有答疑环节，日方的翻译和同事就一个问题讨论了几分钟了，突然有个声音出现，说着日语，然后那个翻译很快地就用几句话结束了交谈。</p>
<p>我还在郁闷，这是怎么回事呢？怎么突然就结束啦。正当我还在疑惑的时候，旁边的同事说道：“1个小时过的真快，这就结束了”。</p>
<p>然后同事有顺口提到：日本人也真是的，说一小时就一小时，多一分钟都不行。我们约的一个小时的会议，我们 10 点 55 开始的会议，现在刚11：54 就结束了会议。</p>
<p>会后，我对这个话题比较的感兴趣，就去搜索了相关的内容。这一搜，发现了一个重要的事实：日本人对待时间这件事情上就是一个 <code>矛盾</code> 的混合体。一方面，日本人有很重的时间观念，对于 <code>守时</code> 这件事情上的表现近乎刻板。另一方面，日本人也是“加班狂人”。为什么会出现这种看似 <code>矛盾</code> 的现象呢，这背后的原因是什么呢？</p>
<p>顺着这个思路，来展开我们今天的话题。</p>
<a id="more"></a>
<h2 id="日本人-守时-到什么程度呢？"><a href="#日本人-守时-到什么程度呢？" class="headerlink" title="日本人 守时 到什么程度呢？"></a>日本人 <code>守时</code> 到什么程度呢？</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-52e923987fe896e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>和日本人有过接触经验的人，都对日本人的 <code>守时</code> 的时间观念印象深刻。</p>
<p>日本人开会从来不迟到，也不会无故延长会议时间。就想我们今天遇到的这样，说是 1 个小时的会员，一定不会开到 1 小时零 1 分。日本人守时的习惯，尤其是“不迟到”这点更是多数日本人天生养成的习惯。比如在企业、公共机构或与他人会面的方方面面，必定“正确守时”即便是准时到达也会视为“迟到”，这已成为常识。关系亲密的人之间也有迟到的，不过也会事先邮件通知。</p>
<p>日本人不光在私人小事上，做到守时，在很复杂的系统上也能做到守时。</p>
<p>日本的新干线列车的晚点时间是以分钟计算延迟的，就是说延迟 1 分钟以上就算是延迟了。作为对比，在其他国家，如意大利定为 15 分钟、英国为 10 分钟、连号称规矩严谨与日本不相上下的德国也只定为 5 分钟。几年前的一个道歉事件，曾经被广泛报道。经营日本筑波快线（Tsukuba Express）的日本首都圈新都市铁道公司原定于 11 月 14 日上午 9 点 44 分 40 秒发出，但由于操作员的失误，结果列车没有按照原定计划，在 9 点 44 分 20 秒提前 20 秒发了车。令人意想不到的是，铁路公司竟然郑重其事的在网页上发布了如下的道歉声明。日本铁路公司的电车只要晚1分钟，车内必定播放道歉的广播。而新干线的到达和出发时刻是以15秒为单位设定的。</p>
<p>日本的机场在守时上也不输铁路，OAG 发布的最新准点率统计表明，<code>大阪国际机场</code> 在全球小型机场中准点率排名第一，<code>东京羽田机场</code> 在名列大型机场准点排行第一。准点率是衡量一个机场成熟度的重要指标。</p>
<p>铁路和机场，这样复杂的系统都没有阻止日本人守时的脚步，这些复杂系统做到这么 <code>精确</code> 的守时背后，是许许多多的小个体守时的缩影，可以说，<code>守时</code> 观念已经深入了日本人的骨髓。</p>
<h2 id="日本人独特的-“加班文化”"><a href="#日本人独特的-“加班文化”" class="headerlink" title="日本人独特的 “加班文化”"></a>日本人独特的 “加班文化”</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-075be3d4d4be32f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>如果说日本人 <code>不迟到</code> 是一个特色，那与之相关的一定是另一个特色—- <code>加班文化</code>。</p>
<p>在日本，加班对于每一个职场人士来说是“家常便饭”，乃至于“过劳死”成为日本加班文化的一个显著特征。日本是出名的“加班大国”，在日文中有“超勤文化”的表述，有时被说成“过劳文化”。日本人以加班为荣，对他们来说加班才是常态，晚上写字楼里的灯光也有个专有名词——“劳工之光”。对不少日本男性来说，“朝6晚11”的工作模式相当普遍，这比之前国内的“996”，似乎还要厉害一点。清早从家乘地铁到公司，上班然后“例行”加班后，再和同事酌酒交际到深夜，便是正常一天的工作行程。日本妻子也大多习惯了丈夫早出晚归，甚至在很多日本女人的观念里，丈夫如果每天正常下班回家是一种在职场上无能的表现。</p>
<p>那是什么原因让日本的加班文化如此盛行呢？</p>
<p>首先，由于连年的经济不景气，日本公司不断地缩减人工规模，员工随时可能被裁员，剩下的员工不得不处理大量的工作任务来减少自己被裁的可能性，从而导致加班不可避免。</p>
<p>第二，日本的终身雇佣制度使得就业市场缺乏活力，员工很难跳槽寻找更好的工作，被迫工作更长时间。</p>
<p>第三，日本企业大多实行终身雇佣制和工龄薪酬制度，工作时间更长意味着更易获得成功，每周多工作几个小时的员工被提升到管理岗位的机会更大，同时也可以获得更多的薪酬。</p>
<p>第四，日本独特的职场文化：强调不带条件的服从和忠诚，以集体主义为最高目标，个人在集体中只有义务，个人的需求会被自动忽视。</p>
<p>第五点，日本人内向拘谨，不愿给别人添麻烦，因此，他们工作勤奋、守规则、敬业心强、对企业忠诚。</p>
<p>与加班文化同时伴生的一个问题是：工作效率低下。2013年日本每小时劳动生产价值为41.3美元，不到挪威的一半，在34个经合组织国家中排名20位，“日本人以工作努力闻名，但效率低下和官僚作风同样有名”，一家英国的每天曾经这样评价日本的加班文化。</p>
<h2 id="其实这就是真实的日本人"><a href="#其实这就是真实的日本人" class="headerlink" title="其实这就是真实的日本人"></a>其实这就是真实的日本人</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-6001b03e5fd58a72?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>近乎苛责的 <code>守时</code>  和独特的 <code>加班文化</code> 夹杂在一起的日本人，就是一对矛盾的集合体，同时，这也是最真实的日本人。</p>
<p>好消息是，情况正在向好的方向发展。最近几届的日本政府都在积极推动“禁止加班”，通过立法的手段来禁止 日益加剧的 <code>加班文化</code> 。同时企业也通过内部改革来减少加班文化的土壤，例如减少时薪。最近看到的消息说：微软日本公司，已经实现每周休假 3  天的制度。</p>
<p>没有谁的生活是容易的，简单生活，才能更好的享受生活。</p>
<hr>
<p>PS: 图片来源于互联网，侵删。</p>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>公众号</category>
        <category>矛盾</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>公众号</tag>
        <tag>矛盾</tag>
      </tags>
  </entry>
  <entry>
    <title>副业赚钱？ 我用自己的教训来给你指路</title>
    <url>/2019/11/13/2019-11-13_Life-Wenxin-wen/</url>
    <content><![CDATA[<p><code>副业赚钱</code>, 是每个人读梦寐以求的，毕竟 <code>躺着就能把钱挣了</code> 还是很舒服的。</p>
<p>最近在不断的总结和反思着一个多月以来的 <code>折腾之旅</code> , 得到了下面的几点教训。这里分享出来给大家参考。</p>
<h2 id="涉及的东西太多"><a href="#涉及的东西太多" class="headerlink" title="涉及的东西太多"></a>涉及的东西太多</h2><p>自从 9 月份开始说要开始自己的折腾之旅开始，先后试过下面平台及方向。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>平台</th>
<th>内容、方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>简书</td>
<td>书写、技术付费文章</td>
<td></td>
</tr>
<tr>
<td>公众号</td>
<td>书写、图片转载</td>
</tr>
<tr>
<td>头条号</td>
<td>图片转载</td>
</tr>
<tr>
<td>悟空问答</td>
<td>影视领域认证</td>
</tr>
<tr>
<td>抖音</td>
<td>视频搬运</td>
</tr>
<tr>
<td>TiTok</td>
<td>视频搬运</td>
</tr>
<tr>
<td>微视</td>
<td>视频搬运</td>
</tr>
<tr>
<td>好看视频</td>
<td>视频搬运</td>
</tr>
<tr>
<td>Youtobe</td>
<td>视频搬运</td>
</tr>
<tr>
<td>Gitbook</td>
<td>技术付费文章</td>
</tr>
<tr>
<td>小专栏</td>
<td>技术付费专栏</td>
</tr>
</tbody>
</table>
</div>
<p>还有很多就试过一两次的，然后觉得不靠谱的就不再列出来了，如果列出来这份清单会很长很长。</p>
<p>上面的这些内容，大部分都在上班时间抽空来完成的。质量可定也好不到哪里去，基本上可以说大部分的内容都是拼凑完成的，另外一些内容，虽然加入了自己的一些东西，但是大部分都不是太深入。</p>
<a id="more"></a>
<h2 id="没有明确的方向"><a href="#没有明确的方向" class="headerlink" title="没有明确的方向"></a>没有明确的方向</h2><p>上面的那份清单里面，已经列出来了，目前试过的方向包括</p>
<ul>
<li>技术付费文章</li>
<li>视频搬运</li>
<li>图片转载</li>
</ul>
<p>上面的每个领域，都是很大的领域，在其中的领域如果做的好，都可以做的很成功。但是毫无疑问，每个领域的成功都需要投入很多的精力，包括但不限于：时间，金钱。</p>
<blockquote>
<p>为什么是为了赚钱的，怎么还需要投入金钱呢？这里解释下原因：很多领域开始赚钱前是需要一个“门槛”的，有些门槛对新人来说感觉很高，此时适当的金钱投入，是可以帮我们快速跨过这个门槛的。</p>
</blockquote>
<h2 id="无法持续的输出"><a href="#无法持续的输出" class="headerlink" title="无法持续的输出"></a>无法持续的输出</h2><p>上面的那份清单里面的每一个，都需要持续不断的 <code>原创</code> 输出，才有可能成功。如果只是 <code>转载</code>、<code>搬运</code>、<code>洗稿</code>，成功的可能性基本没有。</p>
<blockquote>
<p>这里为什么不把话说满呢？因为现实中的的确确出现一些，<code>山寨货</code> 最后逆袭 <code>正版货</code> 的故事。福建莆田的鞋类生产就是一个很好的例子。</p>
</blockquote>
<p>为什么我们一定要坚持原创呢？因为原创是制约你走的更远的决定性条件。在刚开始的时候，你 <code>搬运</code> 了，没人会关注到你，因为你太小了。如果有一天你长大了，很多人都可以看到你的时候，你的所有问题都会暴露在众人面前，一旦发生了问题，众人的 <code>口水</code> 真的就把你淹没了,然后就真的没有然后了。</p>
<blockquote>
<p>大家可以参看下 <code>李现ins点赞</code> 的 <code>故事</code>。</p>
</blockquote>
<p>可能走的越远，越能体会到 <code>人言可畏</code> 这句话的真正威力吧。</p>
<hr>
<p>上面的内容是对自己这一段时间的复盘，下面来简短的写下自己接下来的计划。</p>
<h2 id="精简自己的内容"><a href="#精简自己的内容" class="headerlink" title="精简自己的内容"></a>精简自己的内容</h2><div class="table-container">
<table>
<thead>
<tr>
<th>平台</th>
<th>内容、方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>简书</td>
<td>书写、技术付费文章</td>
</tr>
<tr>
<td>公众号</td>
<td>书写、技术付费文章</td>
</tr>
<tr>
<td>Gitbook</td>
<td>技术付费文章</td>
</tr>
</tbody>
</table>
</div>
<p>之所以这么选择，理由如下：</p>
<ul>
<li><code>技术文章</code> 基本就是自己平时工作、学习的再记录。把学到的东西分享出去，不仅可以促进自己不断的学习，还能把自己的知识分享给更多的人，这是多方共赢的。</li>
<li><code>书写</code> 主要的目的是记录平时生活、工作，同时系统化的构建自己的知识体系。</li>
</ul>
<p>下面对着3个平台的功能进行下区分，</p>
<ul>
<li><code>简书</code> 上面是所有的内容的整合地，类似于目录的作用。</li>
<li><code>公众号</code> 上面主要是日常生活的中的见闻分享。通过日常的一个点，去发散开来，理论上不设任何的领域限制。</li>
<li><code>Gitbook</code> 上面主要是</li>
</ul>
<h2 id="持续原创输出"><a href="#持续原创输出" class="headerlink" title="持续原创输出"></a>持续原创输出</h2><p>上面提到的两个方向都是需要持续不断的更新内容，才能看到后来的光明。<br>其实对于各个行业都需要持续不断的的产出，才有可能成功。坚持下来，才有可能看到阳光；如果不坚持，一定就看不到阳光。</p>
<p>即使 <code>强</code> 如李佳琦也会有翻船的时候。</p>
<blockquote>
<p>具体事件可以参见这篇文章 <a href="https://new.qq.com/rain/a/20191105A0PNQX00" target="_blank" rel="noopener">https://new.qq.com/rain/a/20191105A0PNQX00</a></p>
</blockquote>
<p>虽然李佳琦带货会翻车，但是不可否认李佳琦的带货能力，毕竟他是曾经打败过 <code>马爸爸</code> 的男人。</p>
<p>上面写就是我这一段时间来的总结，是一个悲伤的故事，说出来让大家笑一笑。</p>
<p>最后附上我的微信公众号，欢迎大家关注。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-9b2b8d44ef7010f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" &quot;you的日常&quot; 公众号 "></p>
<blockquote>
<p>有需要的朋友，请到评论区留言吧，我们来互相关注啊。</p>
</blockquote>
<p>希望大家都能够早日通过 “副业” 赚到钱。</p>
<p>加油…</p>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>公众号</category>
        <category>副业</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>公众号</tag>
        <tag>副业</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python Flask 实现 RESTful API</title>
    <url>/2019/10/18/2019-10-18-Programing-Python-Advanded-use-Flask-create-RESTful-API-Services/</url>
    <content><![CDATA[<hr>
<p>在工作学习中，我们经常会需要将自己的开发成果对外提供服务，此时的选择很多，但是什么才是最高效的呢？</p>
<p>想必聪明的你，已经想到了：通过 <code>API</code> 的方式对外提供服务。既然我们在学习 Python 过程中，那我们就使用 Python 来实现自己的 API 吧。</p>
<p>下面将从下面几个方面进行讲解：</p>
<ul>
<li>API 简介</li>
<li>RESTful API 简介</li>
<li>使用Python Flask 实现 RESTful API</li>
</ul>
<hr>
<h2 id="API-简介"><a href="#API-简介" class="headerlink" title="API 简介"></a>API 简介</h2><p>API 是英语 <code>Application Programming Interfaces</code> 的3个首字母组成的，翻译成中文即 <code>应用程序编程接口</code>。</p>
<p>API 通常是由服务器（Server）提供（服务器有各种各样的类型，一般我们浏览网页用到的是web server，即网络服务器），通过调用 API，本地计算机可以读取、编辑网站数据，就像人类可以加载网页、提交信息等。</p>
<p>通俗地，API可以理解为家用电器的插头，用户(本地电脑)只需要将插头插入插座的，不需要考虑电器内部(服务器)里面是如何运作的。通过提供 API, 将内部的实现细节封装了起来，对本地电脑简化的流程，同时减少了出错的可能。</p>
<p>另外一个角度上讲API是一套协议，规定了与外界的沟通方式：如何发送请求和接受响应。只有大家同遵循同样的方式，就可以很快速的接入我们的服务。</p>
<hr>
<h2 id="RESTful-API-简介"><a href="#RESTful-API-简介" class="headerlink" title="RESTful API 简介"></a>RESTful API 简介</h2><p>RESTful API 即满足 RESTful 风格设计的API，RESTful 表示的是一种互联网软件架构(以网络为基础的应用软件的架构设计)，如果一个架构符合 <code>REST</code> (Representational State Transfer的缩写，翻译成中文是 <code>&quot;表现层状态转化&quot;</code>.)原则，就称它为 RESTful 架构。</p>
<p>那什么是 <code>REST</code> 原则呢？<code>Representational State Transfer</code> 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，基本就理解了什么是 <code>REST</code> 设计原则。</p>
<p>从下面几个角度来分解这个问题。</p>
<blockquote>
<p>下面的部分内容可以忽略，可以直接跳到总结的部分。</p>
</blockquote>
<a id="more"></a>
<h3 id="资源（Resources）"><a href="#资源（Resources）" class="headerlink" title="资源（Resources）"></a>资源（Resources）</h3><p>REST 的名称”表现层状态转化”中，省略了主语。 <code>&quot;表现层&quot;</code> 其实指的是 <code>&quot;资源&quot;</code> （Resources）的 <code>&quot;表现层&quot;</code> 。</p>
<p>所谓 <code>&quot;资源&quot;</code> ，就是网络上的一个实体，或者说是网络上的一个具体信息。</p>
<p>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。<br>你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
<p>所谓 <code>上网</code>，就是与互联网上一系列的 <code>&quot;资源&quot;</code> 互动，调用它的URI。</p>
<h3 id="表现层（Representation）"><a href="#表现层（Representation）" class="headerlink" title="表现层（Representation）"></a>表现层（Representation）</h3><p><code>&quot;资源&quot;</code> 是一种信息实体，它可以有多种外在表现形式。我们把 <code>&quot;资源&quot;</code> 具体呈现出来的形式，叫做它的 <code>&quot;表现层&quot;</code> （Representation）。</p>
<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
<p>URI只代表资源的实体，不代表它的形式。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对 <code>&quot;表现层&quot;</code> 的描述。</p>
<h3 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h3><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。</p>
<p>因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 <code>&quot;表现层状态转化&quot;</code>。</p>
<p>客户端用到的手段，只能是HTTP协议。</p>
<p>具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p>
<p>它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>RESTful 架构的特点：</p>
<ul>
<li>每一个URI代表一种资源；</li>
<li><p>客户端和服务器之间，传递这种资源的某种表现层；把 <code>&quot;资源&quot;</code> 具体呈现出来的形式，叫做它的 <code>&quot;表现层&quot;</code> （Representation）。</p>
<p>  比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
</li>
<li><p>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<p>  四个表示操作方式的动词分别是：GET、POST、PUT、DELETE。</p>
<p>  它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
</li>
</ul>
<p>完整的 RESTful API 的简介在这里：</p>
<p><a href="https://www.restapitutorial.com/lessons/whatisrest.html" target="_blank" rel="noopener">https://www.restapitutorial.com/lessons/whatisrest.html</a> </p>
<blockquote>
<p>英文版，可能需要翻墙。</p>
</blockquote>
<p>简单总结下官方的介绍的内容：</p>
<ul>
<li>Client-Server：服务器端与客户端分离。</li>
<li>Stateless（无状态）：每次客户端请求必需包含完整的信息，换句话说，每一次请求都是独立的。</li>
<li>Cacheable（可缓存）：服务器端必需指定哪些请求是可以缓存的。</li>
<li>Layered System（分层结构）：服务器端与客户端通讯必需标准化，服务器的变更并不会影响客户端。</li>
<li>Uniform Interface（统一接口）：客户端与服务器端的通讯方法必需是统一的。</li>
<li>Code on demand（按需执行代码）：服务器端可以在上下文中执行代码或者脚本。</li>
</ul>
<hr>
<h2 id="使用Python-Flask-实现Restful-API"><a href="#使用Python-Flask-实现Restful-API" class="headerlink" title="使用Python Flask 实现Restful API"></a>使用Python Flask 实现Restful API</h2><p>前面啰嗦了这么久终于到这里了，这里才是我们实作的重头戏。</p>
<p>这部分将从下面的几个环节展开：</p>
<ul>
<li>Flask 框架简介</li>
<li>RESTful services 规划</li>
<li>Python 实现上面的规划</li>
<li>优化上面的实现</li>
</ul>
<p>下面让我们开始。</p>
<h3 id="Flask-框架简介"><a href="#Flask-框架简介" class="headerlink" title="Flask 框架简介"></a>Flask 框架简介</h3><p>我们在前面有几篇文章已经介绍过 Flask 框架。</p>
<p><strong>python-高级-Flask Hello World </strong><br><a href="https://xiaozhuanlan.com/topic/7256839401" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/7256839401</a></p>
<p><strong>Python-高级-Flask 路由</strong><br><a href="https://xiaozhuanlan.com/topic/0758412369" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/0758412369</a></p>
<p>里面介绍了 Flask 框架的相关基础知识，同时我们也介绍了关于 Flask 框架路由的知识，如果没看过，请移步到那里去看看。</p>
<p>在 <code>Python-高级-Flask Hello World</code> 里面，我们写了个最简单的 <code>Hello World</code> 的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, World!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>我们下面的内容，将基于这个例子进行扩展。</p>
<p>HTTP(与web应用会话的协议)有许多不同的访问URL方法。<br>默认情况下，<code>Flask</code> 路由只回应GET请求，但是通过 <code>route()</code> 装饰器传递 <code>method</code> s参数可以改变这个行为。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/login', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        do_the_login()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        show_the_login_form()</span><br></pre></td></tr></table></figure>
<p>HTTP 方法（通常也被叫做“谓词”，如上面code 里面的 <code>GET</code> 和 <code>POST</code> ）告知服务器，客户端想对请求的页面做些什么。</p>
<p>下面的都是非常常见的方法：</p>
<ul>
<li>GET(方法)浏览器告知服务器：只 获取 页面上的信息并发给我。这是最常用的方法。</li>
<li>POST(方法)浏览器告诉服务器：想在 URL 上发布新信息。并且，服务器必须确保 数据已存储且仅存储一次。这是 HTML 表单通常发送数据到服务器的方法。</li>
<li>PUT(方法)类似 POST 但是服务器可能触发了存储过程多次，多次覆盖掉旧值。你可能会问这有什么用，当然这是有原因的。考虑到传输中连接可能会丢失，这种情况下浏览器和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。因为 <code>POST</code> 它只触发一次，所以用 <code>POST</code> 是不可能的。</li>
<li>DELETE(方法)删除给定位置的信息。</li>
</ul>
<h3 id="RESTful-services-规划"><a href="#RESTful-services-规划" class="headerlink" title="RESTful services 规划"></a>RESTful services 规划</h3><p>经过上面知识的准备，我们开始来规划我们的RESTful services。</p>
<p>这里的规划，通常会与实际的需求有关系。所有的程序设计行为都是要与需求相关联的，如果做出来的东西不符合需求，那做得再好的程序也不是合格的程序。</p>
<p>回归到这里，我们假设我们的需求如下：写一个 <code>To Do List</code> 应用，并且设计一个web service, 方便使用中查看、添加、修改、删除 这些任务。</p>
<p><code>To Do List</code> 应用，通常长这样<br><img src="https://images.xiaozhuanlan.com/photo/2019/711398c10c7e7dee36a0e17a28efb00a.png" alt="`To Do List` 应用"></p>
<p>可能会比较简单，实际的需求会比这个复杂的多。这里举个简单的例子，只是起到 <code>抛砖引玉</code> 的作用。</p>
<p>我们将分下面几步走来规划这个。</p>
<h4 id="规划一个根URL"><a href="#规划一个根URL" class="headerlink" title="规划一个根URL"></a>规划一个根URL</h4><p>例如：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://[hostname]/todo/api/v1.0/</span><br></pre></td></tr></table></figure></p>
<p>上面的URL包括了应用程序的名称、API版本，这是十分有用的，既提供了命名空间的划分，同时又与其它系统区分开来。</p>
<p>版本号在升级新特性时十分有用，当一个新功能特性增加在新版本下面时，并不影响旧版本。</p>
<h4 id="规划资源的URL"><a href="#规划资源的URL" class="headerlink" title="规划资源的URL"></a>规划资源的URL</h4><p>这个例子十分简单，只有任务清单。</p>
<p>我们定义有以下字段：<br>|HTTP 方法|URL|作用|<br>|—-|—-|—-|<br>|GET|<a href="http://[hostname]/todo/api/v1.0/tasks|查看所有的任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks|查看所有的任务|</a><br>|GET|<a href="http://[hostname]/todo/api/v1.0/tasks/task_id|查看特定" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks/task_id|查看特定</a> id 的任务|<br>|PSOT|<a href="http://[hostname]/todo/api/v1.0/tasks|创建一个新的任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks|创建一个新的任务|</a><br>|PUT|<a href="http://[hostname]/todo/api/v1.0/tasks/task_id|更新一个已有的任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks/task_id|更新一个已有的任务|</a><br>|DELETE|<a href="http://[hostname]/todo/api/v1.0/tasks/task_id|删除一个任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks/task_id|删除一个任务|</a></p>
<p>同时定义一条任务清单包含下面的几个字段：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>描述</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>task_id</td>
<td>唯一标识</td>
<td>整型</td>
</tr>
<tr>
<td>title</td>
<td>简短的任务描述</td>
<td>字符串型</td>
</tr>
<tr>
<td>description</td>
<td>完整的任务描述</td>
<td>文本型</td>
</tr>
<tr>
<td>done</td>
<td>任务完成状态</td>
<td>布尔值型</td>
</tr>
</tbody>
</table>
</div>
<p>到这里我们的service 规划就完成了，下面我们将使用 Python 来进行实现。</p>
<h3 id="Python-实现上面的规划"><a href="#Python-实现上面的规划" class="headerlink" title="Python 实现上面的规划"></a>Python 实现上面的规划</h3><p>我们先实现第一个web service的入口点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 python_mastery 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/python_mastery'</span>,</span><br><span class="line">        <span class="string">'done'</span>: <span class="literal">False</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 pythonml 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/pythonml'</span>,</span><br><span class="line">        <span class="string">'done'</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: tasks&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里我们看到 <code>jsonify</code> 模块，这个与标准的 <code>json</code> 库的差别，对于目前我们的使用来说，基本可以忽略不计，如果非要深究这个问题，请移步到这里：<a href="https://www.jianshu.com/p/a25357f2d930" target="_blank" rel="noopener">https://www.jianshu.com/p/a25357f2d930</a>.</p>
</blockquote>
<p>和最开始的例子相比，并没有改变太多代码。</p>
<p>我们将任务清单存储在 list 内（内存），list 存放两个非常简单的数组字典。每个实体就是我们上面定义的字段。</p>
<p>而 index 入口点有一个 <code>get_tasks</code> 函数与 <code>/todo/api/v1.0/tasks</code> URI关联，只接受 HTTP 的 <code>GET</code> 方法。</p>
<p>这个响应并非一般文本，而是 JSO N格式的数据，是经过 Flask 框架的 <code>jsonify</code> 模块格式化过的数据。</p>
<p>运行 app.py 。</p>
<p>使用浏览器去测试 web service 并不是一个好的办法，因为要创建不同种类的 HTTP 请求。这里我们选择第三方工具 <code>postman</code> 来进行验证。</p>
<p>如果没有安装 <code>postman</code> ，快点去安装一个。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/93a094856a1e7c74ab3c92f4e180ba66.png" alt="GET `/todo/api/v1.0/tasks`"></p>
<p>这样就调用了一个RESTful service方法！</p>
<p>现在，我们写第二个版本的GET方法获取特定的任务。获取单个任务：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> abort</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_task</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    task = list(filter(<span class="keyword">lambda</span> t: t[<span class="string">'id'</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> len(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'task'</span>: task[<span class="number">0</span>]&#125;)</span><br></pre></td></tr></table></figure>
<p>第二个函数稍稍复杂了一些。任务的 id 包含在 URL 内，Flask 将 task_id 参数传入了函数内。</p>
<p>通过参数，检索 tasks 数组。如果参数传过来的 id 不存在于数组内，我们需要返回错误代码 404 ，按照 HTTP 的规定，404 意味着是 “Resource Not Found”，资源未找到。</p>
<p>如果找到任务在内存数组内，我们通过 <code>jsonify</code> 模块将字典打包成 JSON 格式，并发送响应到客户端上。就像处理一个实体字典一样。</p>
<p>试试 <code>postman</code> 来进行验证<br><img src="https://images.xiaozhuanlan.com/photo/2019/7216c0b416a349237ddec9b2a5cfcdf9.png" alt="请求 `#2 id` 的资源"></p>
<p>当我们请求 <code>#2 id</code> 的资源时，可以获取，但是当我们请求<code>#3</code> 的资源时返回了 <code>404</code> 错误。并且返回了一段奇怪的 HTML 错误，而不是我们期望的 JSON，这是因为 Flask 产生了默认的 404 响应。<br><img src="https://images.xiaozhuanlan.com/photo/2019/1efeaa08c6403904824c96b21b528b81.png" alt="默认的 404 响应"></p>
<p>客户端需要收到的都是 JSON 的响应，因此我们需要改进 404 错误处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> make_response</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_found</span><span class="params">(error)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> make_response(jsonify(&#123;<span class="string">'error'</span>: <span class="string">'Not found'</span>&#125;), <span class="number">404</span>)</span><br></pre></td></tr></table></figure>
<p>这样我们就得到了友好的API错误响应：<br><img src="https://images.xiaozhuanlan.com/photo/2019/fafa73efa68f6532801f92d4c1f9627c.png" alt="友好的API错误响应"></p>
<p>接下来我们实现 POST 方法，插入一个新的任务到数组中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json <span class="keyword">or</span> <span class="keyword">not</span> <span class="string">'title'</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    task = &#123;</span><br><span class="line">        <span class="string">'id'</span>: tasks[<span class="number">-1</span>][<span class="string">'id'</span>] + <span class="number">1</span>,</span><br><span class="line">        <span class="string">'title'</span>: request.json[<span class="string">'title'</span>],</span><br><span class="line">        <span class="string">'description'</span>: request.json.get(<span class="string">'description'</span>, <span class="string">""</span>),</span><br><span class="line">        <span class="string">'done'</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">    tasks.append(task)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'task'</span>: task&#125;), <span class="number">201</span></span><br></pre></td></tr></table></figure>
<p>request.json 里面包含请求数据，如果不是 JSON 或者里面没有包括 title 字段，将会返回 <code>400</code> 的错误代码。</p>
<p>当创建一个新的任务字典，使用最后一个任务 id 数值加 1 作为新的任务 id（最简单的方法产生一个唯一字段）。这里允许不带 description 字段，默认将 done 字段值为 <code>False</code> 。</p>
<p>将新任务附加到 tasks 数组里面，并且返回客户端 <code>201</code> 状态码和刚刚添加的任务内容。HTTP定义了 <code>201</code> 状态码为“Created”。</p>
<p>测试上面的新功能：<br><img src="https://images.xiaozhuanlan.com/photo/2019/672c558fba34aa19096446cfbc82dbb1.png" alt="创建一个新的任务"></p>
<p>其中 <code>postman</code> 上的设定：<br><img src="https://images.xiaozhuanlan.com/photo/2019/a637eb063fc96ceb8c483e74fe956f41.png" alt="header"><br><img src="https://images.xiaozhuanlan.com/photo/2019/b5fbbda40e05b9f774f245493f9f9e14.png" alt="body"></p>
<p>完成上面的事情，就可以看到更新之后的 list 数组内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"专栏Link： https://xiaozhuanlan.com/python_mastery"</span>,</span><br><span class="line">            <span class="attr">"done"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"订阅 python_mastery 专栏"</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"专栏Link： https://xiaozhuanlan.com/pythonml"</span>,</span><br><span class="line">            <span class="attr">"done"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"订阅 pythonml 专栏"</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"link https://xiaozhuanlan.com/topic/0758412369"</span>,</span><br><span class="line">            <span class="attr">"done"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Read 专栏文章"</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成剩下的功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['PUT'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_task</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    task = list(filter(<span class="keyword">lambda</span> t: t[<span class="string">'id'</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> len(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'title'</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'description'</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'done'</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> type(request.json[<span class="string">'done'</span>]) <span class="keyword">is</span> <span class="keyword">not</span> bool:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">'title'</span>] = request.json.get(<span class="string">'title'</span>, task[<span class="number">0</span>][<span class="string">'title'</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">'description'</span>] = request.json.get(<span class="string">'description'</span>, task[<span class="number">0</span>][<span class="string">'description'</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">'done'</span>] = request.json.get(<span class="string">'done'</span>, task[<span class="number">0</span>][<span class="string">'done'</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'task'</span>: task[<span class="number">0</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['DELETE'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_task</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    task = list(filter(<span class="keyword">lambda</span> t: t[<span class="string">'id'</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> len(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    tasks.remove(task[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'result'</span>: <span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure>
<p> <code>delete_task</code> 函数没什么太特别的。<br> <code>update_task</code> 函数需要检查所输入的参数，防止产生错误的 bug 。确保是预期的 JSON 格式写入数据库里面。</p>
<p>测试将任务 #2 的 <code>done</code> 字段变更为 <code>done</code> 状态：<br><img src="https://images.xiaozhuanlan.com/photo/2019/0c57c10023df70c913da73e3ad2bbbbf.png" alt=" `done` 状态"></p>
<p>其中 <code>postman</code> 上的设定：<br><img src="https://images.xiaozhuanlan.com/photo/2019/a637eb063fc96ceb8c483e74fe956f41.png" alt="header"><br><img src="https://images.xiaozhuanlan.com/photo/2019/9cf8ee53537e2369b88a0de7a18389c4.png" alt="body"></p>
<p>经过上面的操作，我们理论上已经完成了基本的开发任务了。虽我们的目前的service 还存在很多可以改进的地方，例如</p>
<ul>
<li>更方便的扩展</li>
<li>安全性验证</li>
<li>使用数据库</li>
<li>其它可优化的地方</li>
</ul>
<p>下面针对这3个点，来做具体分析，但是这也只是假设的情况，请实际根据需求来完成。</p>
<h3 id="优化上面的实现"><a href="#优化上面的实现" class="headerlink" title="优化上面的实现"></a>优化上面的实现</h3><h4 id="更方便的扩展"><a href="#更方便的扩展" class="headerlink" title="更方便的扩展"></a>更方便的扩展</h4><p>假设现在使用者想修改 一个任务的 <code>done</code> 为 <code>True</code>, 他需要自己组合请求的 URL, 那服务器端可以直接返回 API URL 吗？</p>
<p>答案是可以。</p>
<p>我们可以通过下面的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> url_for</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_public_task</span><span class="params">(task)</span>:</span></span><br><span class="line">    new_task = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> field <span class="keyword">in</span> task:</span><br><span class="line">        <span class="keyword">if</span> field == <span class="string">'id'</span>:</span><br><span class="line">            new_task[<span class="string">'uri'</span>] = url_for(<span class="string">'get_task'</span>, task_id=task[<span class="string">'id'</span>], _external=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_task[field] = task[field]</span><br><span class="line">    <span class="keyword">return</span> new_task</span><br></pre></td></tr></table></figure>
<p>通过 Flask 的 url_for 模块，获取任务时，将任务中的 id 字段替换成 uri 字段，并且把值改为 uri 值。</p>
<p>当我们返回包含任务的 list 时，通过这个函数处理后，返回完整的 uri 给客户端。</p>
<p>把之前的 <code>get_tasks()</code> 做一些简单的修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: list(map(make_public_task, tasks))&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意变化是： <code>return jsonify({&#39;tasks&#39;: list(map(make_public_task, tasks))})</code></p>
</blockquote>
<p>检查下结果<br><img src="https://images.xiaozhuanlan.com/photo/2019/c401c2b24ac93baedb12910bb6f771db.png" alt="替换 URL "></p>
<p>这种办法拿到的是完整 <code>uri</code> 而不是一个 <code>id</code> 。</p>
<h4 id="安全性验证"><a href="#安全性验证" class="headerlink" title="安全性验证"></a>安全性验证</h4><p>我们已经基本完成了整个功能，但是我们还有一个问题: web service 任何人都可以访问的，在当前爬虫满地跑的年代。这可不行。</p>
<p>当前 service 是所有客户端都可以连接的，如果有别人知道了这个API就可以写个客户端随意修改数据了。这是个十分严重的问题。</p>
<p>那要怎么解决这个问题呢？</p>
<p>最简单的办法是在 web service 中，只允许用户名和密码验证通过的客户端连接。</p>
<p>在一个常规的web应用中，应该有登录表单提交去认证，同时服务器会创建一个会话过程去进行通讯。</p>
<p>这个会话过程id会被存储在客户端的cookie里面。不过这样就违返了我们REST中无状态的规则，因此，我们需求客户端每次都将他们的认证信息发送到服务器。</p>
<p>此我们有两种方法表单认证方法去做，分别是 Basic 和 Digest。</p>
<p>这个问题已经有很多大佬已经提供了完整的解决方案，我们只是拿来使用就可以了。Flask 插件中的 Flask-HTTPAuth 就可以满足这个功能。</p>
<p><a href="https://github.com/miguelgrinberg/flask-httpauth" target="_blank" rel="noopener">https://github.com/miguelgrinberg/flask-httpauth</a></p>
<p>老规矩，首先安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install flask_httpauth</span><br></pre></td></tr></table></figure>
<p>然后就是实现功能。假设web service只有用户 <code>python</code> 和密码为 <code>python_mastery</code> 的用户接入。下面就设置了一个Basic HTTP认证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask.ext.httpauth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line">auth = HTTPBasicAuth()</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.get_password</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_password</span><span class="params">(username)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">'python'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'python_mastery'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.error_handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unauthorized</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> make_response(jsonify(&#123;<span class="string">'error'</span>: <span class="string">'Unauthorized access'</span>&#125;), <span class="number">401</span>)</span><br></pre></td></tr></table></figure>
<p><code>get_password</code> 函数是一个回调函数，获取一个已知用户的密码。</p>
<blockquote>
<p>在实际的系统中，函数是需要到数据库中检查的，这里只是一个小示例。</p>
</blockquote>
<p>当发生认证错误之后，<code>error_handler</code> 回调函数会发送错误的代码给客户端。这里我们自定义一个错误代码 401，返回 JSON 数据，而不是 HTML 。</p>
<p>将 <code>@auth.login_required</code> 装饰器添加到需要验证的函数上面：</p>
<p>修改之前的函数实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="meta">@auth.login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: tasks&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里的不同是：<code>@auth.login_required</code></p>
</blockquote>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/e6dd4df100b1ac6b504726810dfa2646.png" alt="Unauthorized access"></p>
<p>这里表示了没通过验证，下面试着把用户名与密码一起带过去进行验证：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/b749b5151105a428c450b07baa5de32f.png" alt="一起验证"></p>
<p>其中 <code>postman</code> 设定：<br><img src="https://images.xiaozhuanlan.com/photo/2019/2af3f6b1c73091f4c29c777df0ec06dc.png" alt="base_auth"></p>
<p>这个认证插件十分灵活，可以随指定需要验证的APIs。</p>
<h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><p>对于复杂的系统，使用数据库进行数据管理，那是基础条件。鉴于这是另外一个很大的主题，这里就不再深入讨论了。感兴趣的可以去阅读相关的文档及资料。</p>
<blockquote>
<p>刚发现，这个专栏里面也相关的入门文章。<br>如果感兴趣，请移步：<a href="https://xiaozhuanlan.com/topic/0789431562" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/0789431562</a></p>
</blockquote>
<h4 id="其它可优化的地方"><a href="#其它可优化的地方" class="headerlink" title="其它可优化的地方"></a>其它可优化的地方</h4><p>目前我们的系统基本实现了最简单的一个功能，一些复杂的功能，暂时还没有考虑进来。<br>例如：</p>
<ul>
<li>处理多用户。<br>  如果系统支持多用户认证，则任务清单也是对应多用户的。此时的问题复杂度就翻倍了，我们同时要提供用户信息的管理，同时要把用户的任务对应关联起来。</li>
<li>通过 GET 请求检索任务清单时，我们一次性的返回了所有的任务，但是在任务及用户巨量的时候，这是无法接受的。<br>  有很多办法可以进扩展。<ul>
<li>第一，添加分页参数，使客户端只请求一部份数据。</li>
<li>第二，添加筛选关键字等。所有这些元素可以添加到URL上面的参数。</li>
</ul>
</li>
</ul>
<p>上面就是这次分享的全部内容，谢谢大家的阅读。</p>
<p><strong>如果文章有帮助到你，请帮忙宣传，谢谢。</strong></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
        <category>高级技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程技术</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-高级-实用-操作 Excel</title>
    <url>/2019/10/15/2019-10-15-Programing-Python-Advanded-Excel-operation-with-xlwings/</url>
    <content><![CDATA[<hr>
<h1 id="Python-高级-实用-操作-Excel"><a href="#Python-高级-实用-操作-Excel" class="headerlink" title="Python-高级-实用-操作 Excel"></a>Python-高级-实用-操作 Excel</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>Excel 是我们日常工作学习中都会使用到的很重要的工具。但是处理过程中难免会遇到重复的操作，同时面对大量数据时手工操作也可能因为误操作导致错误发生。我们刚好在学习 Python, 那有没有办法通过 code 来读取 Excel 文件。</p>
<p>答案是肯定的，下面我们就使用 Python 来进行操作 Excel 文件。</p>
<h2 id="模块选择"><a href="#模块选择" class="headerlink" title="模块选择"></a>模块选择</h2><p>熟悉 Python 世界的读者，就会明白：在 Python 的世界里，做一件事情，官方建议只有一种方法。但是现实中，大佬太多，互相之间看不上别人做的东西，重复造轮子的现象比较严重。</p>
<p>如果百度或google 一下：“Python Excel”, 下面的几个第三方模块库常常出现在推荐列表中</p>
<ul>
<li>openpyxl</li>
<li>xlsxwriter</li>
<li>xlutils</li>
<li>xlwings</li>
</ul>
<p>经过实际的验证(验证过程略), 我挑选 <code>xlwings</code> 作为实际使用的模块。</p>
<h2 id="xlwings-简介"><a href="#xlwings-简介" class="headerlink" title="xlwings 简介"></a><code>xlwings</code> 简介</h2><p>众所周知，VBA 可以很高效的操作 Excel，提高办公效率。<br>在 Python 中，我们可以通过 pywin32 来调用 windows 系统的 API 来实现 VBA 的很多功能，但是写起来比较复杂。</p>
<p><code>xlwings</code> 是基于 BSD-licensed 的一个 Python 第三方的模块，对 <code>pywin32</code> 进行了封装，可以很方便的和 Excel 进行交互，它有以下优点：</p>
<ul>
<li>语法接近 VBA</li>
<li>可以用 Python 代码取代 VBA 编写宏</li>
<li>在 windows 可以用 Python 编写 Excel 用户自定义函数</li>
<li>全功能支持 Numpy Pandas matplotlib 等科学计算库</li>
<li>支持 Windows 和 MacOS</li>
<li>支持 Py3.3+</li>
</ul>
<a id="more"></a>
<p>官方地址： <a href="https://www.xlwings.org/" target="_blank" rel="noopener">https://www.xlwings.org/</a></p>
<h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="推荐的方式"><a href="#推荐的方式" class="headerlink" title="推荐的方式"></a>推荐的方式</h4><p>推荐使用 <code>Anaconda</code>  来安装，可以省去很多麻烦，</p>
<blockquote>
<p>Anaconda 是一个包含了Python 常用模块的第三方整合的包，里面包含了很多实用的工具及模块，是Python 快速学习及开发比较推荐的方式。同时他也提供命令行工具 <code>conda</code> 方便来对模块进行安装，其功能类似于Python 官方的 <code>pip</code> 工具。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install xlwings</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="自己手动安装"><a href="#自己手动安装" class="headerlink" title="自己手动安装"></a>自己手动安装</h4><p>当然自己手动安装也是可以的，下面是自己手动使用 <code>pip</code> 安装的过程。<br>使用 <code>pip</code> 安装，需要先手动安装 <code>pywin32</code> , 这是一个将 OS 的一些底层操作进行高级封装的模块，简化了对系统的复杂操作。 </p>
<p>下载地址:<br><a href="https://sourceforge.net/projects/pywin32/files/pywin32/" target="_blank" rel="noopener">https://sourceforge.net/projects/pywin32/files/pywin32/</a></p>
<p>安装 pywin32 后，使用 pip 安装 <code>xlwings</code>即可<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install xlwings</span><br></pre></td></tr></table></figure></p>
<p><code>xlwings</code>的 官方安装文档,<br><a href="https://docs.xlwings.org/en/stable/installation.html" target="_blank" rel="noopener">https://docs.xlwings.org/en/stable/installation.html</a></p>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>引入库<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br></pre></td></tr></table></figure></p>
<p>打开Excel程序，默认设置：程序可见，只打开不新建工作薄<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app = xw.App(visible=True,add_book=False)</span><br><span class="line"># 新建工作簿 (如果不接下一条代码的话，Excel会一闪而过就走了）</span><br><span class="line"></span><br><span class="line">wb = app.books.add()</span><br></pre></td></tr></table></figure></p>
<p>打开已有工作簿（支持绝对路径和相对路径）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wb = app.books.open(<span class="string">'temp.xlsx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接使用下面这条</span></span><br><span class="line"><span class="comment">#wb = xw.Book('temp.xlsx')</span></span><br><span class="line"><span class="comment"># 这样的话就不会频繁打开新的Excel</span></span><br></pre></td></tr></table></figure></p>
<p>保存工作簿<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wb.save(<span class="string">'example.xlsx'</span>)</span><br></pre></td></tr></table></figure></p>
<p>退出工作簿（可省略）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wb.close()</span><br></pre></td></tr></table></figure></p>
<p>退出Excel<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app.quit()</span><br></pre></td></tr></table></figure></p>
<p>引用Excel工作表，单元格<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 引用工作表</span></span><br><span class="line">sht = wb.sheets[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#sht = wb.sheets[第一个sheet名]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用单元格</span></span><br><span class="line">rng = sht.range(<span class="string">'a1'</span>)</span><br><span class="line"><span class="comment"># rng = sht['a1']</span></span><br><span class="line"><span class="comment"># rng = sht[0,0] 第一行的第一列即a1,相当于pandas的切片</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用区域</span></span><br><span class="line">rng = sht.range(<span class="string">'a1:a5'</span>)</span><br><span class="line"><span class="comment"># rng = sht['a1:a5']</span></span><br><span class="line"><span class="comment"># rng = sht[:5,0]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h2><h3 id="一份完整的sample-代码"><a href="#一份完整的sample-代码" class="headerlink" title="一份完整的sample 代码"></a>一份完整的sample 代码</h3><p>我们把刚刚的过程，写到一起，再来回顾下函数的基础使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"><span class="comment"># 打开一个新的 workbook </span></span><br><span class="line">wb = xw.Book()</span><br><span class="line"><span class="comment"># 打开当前目录已经存在的一个 workbook </span></span><br><span class="line">wb = xw.Book(<span class="string">'temp.xlsx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入完整的路径打开一个 workbook </span></span><br><span class="line">FileName = <span class="string">"C:\\python\\to\\temp.xlsx"</span></span><br><span class="line"><span class="comment"># FileName = r"C:\python\to\temp.xlsx"</span></span><br><span class="line"></span><br><span class="line">wb = xw.Book(fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 sheet 的三种方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 打开第一个 sheet</span></span><br><span class="line">sheet = wb.sheets[<span class="number">0</span>]</span><br><span class="line"><span class="comment">## 打开名字为 "youdaily" sheet</span></span><br><span class="line">sheet = wb.sheets[<span class="string">"youdaily"</span>]</span><br><span class="line"><span class="comment">## 打开当前活动的 sheet</span></span><br><span class="line">sheet = wb.sheets.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读写数据到 sheet </span></span><br><span class="line"><span class="comment">## 当前活动的 sheet 中读写一个单元格的数据</span></span><br><span class="line"></span><br><span class="line">sht = wb.sheets.active</span><br><span class="line">sht.range(<span class="string">'A1'</span>).value = <span class="string">"youdaily"</span></span><br><span class="line">print(sht.range(<span class="string">'A1'</span>).value)</span><br><span class="line"><span class="comment">## youdaily</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前活动的 sheet 中读写一行单元格的数据</span></span><br><span class="line"><span class="comment">## 将列表储存在A1：C1中</span></span><br><span class="line">sht.range(<span class="string">'A1'</span>).value=[<span class="string">"youdaily"</span>,<span class="string">"age"</span>,<span class="string">"gender"</span>]</span><br><span class="line">print(sht.range(<span class="string">'A1:C1'</span>).value)</span><br><span class="line"><span class="comment">## ['youdaily', 'age', 'gender']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># #当前活动的 sheet 中读写一列单元格的数据</span></span><br><span class="line"><span class="comment"># 将列表储存在A1:A3中</span></span><br><span class="line">sht.range(<span class="string">'A1'</span>).options(transpose=<span class="literal">True</span>).value=[<span class="string">"youdaily"</span>,<span class="number">18</span>,<span class="number">1</span>]</span><br><span class="line">print(sht.range(<span class="string">"A1:A3"</span>).value)</span><br><span class="line"><span class="comment">## ['youdaily', 18.0, 1.0]</span></span><br><span class="line"></span><br><span class="line">sht.range(<span class="string">'A1:A3'</span>).value = [<span class="string">"youdaily"</span>, <span class="number">20</span>, <span class="number">2</span>]</span><br><span class="line">print(sht.range(<span class="string">"A1:A3"</span>).value)</span><br><span class="line"><span class="comment">## ['youdaily', 18.0, 1.0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 当前活动的 sheet 中读写多行多列单元格的数据</span></span><br><span class="line"><span class="comment">## 将2x2表格，即二维数组，储存在A1:B2中，如第一行1，2，第二行3，4</span></span><br><span class="line">wb = xw.Book()</span><br><span class="line">sht = wb.sheets.active</span><br><span class="line">sht.range(<span class="string">'A1'</span>).options(expand=<span class="string">'table'</span>).value=[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">print(sht.range(<span class="string">"A1"</span>).expand().value)</span><br><span class="line"><span class="comment">## [[1.0, 2.0], [3.0, 4.0]]</span></span><br><span class="line"><span class="comment">## expand 的详细用法请参考文档</span></span><br><span class="line">sht.range(<span class="string">'A1:B2'</span>).value = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">print(sht.range(<span class="string">'A1:B2'</span>).value)</span><br><span class="line"><span class="comment">## [[1.0, 2.0], [3.0, 4.0]]</span></span><br></pre></td></tr></table></figure>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>有了上面的回顾后，我们再来一个实例来再学习一次。</p>
<p>需求：删除 Excel 文件中，满足条件的单元格所在的一整行.</p>
<p>我们的Excel 文件长这样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-a73d9fda25c0a8fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="excel"></p>
<blockquote>
<p>你当然可以在Excel 中使用Excel 自带的方法，来实现去重的功能，但是那不是手动了吗？<br>现在是数据少的时候，如果数据多了呢？手动操作，出错的概率会大大的增加。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2019-11-09 17:14:03</span></span><br><span class="line"><span class="comment"># @Author  : youdaily (youdaily)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"></span><br><span class="line">fn = <span class="string">"temp.xlsx"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeleteTools</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    删除满足某些条件的行</span></span><br><span class="line"><span class="string">    data.xlsx 中有很多重复的数据    </span></span><br><span class="line"><span class="string">    需要删除那些重复的</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        super(DeleteTools, self).__init__()</span><br><span class="line">        self.ExistSet = set()</span><br><span class="line">        self.ToDelList = list()</span><br><span class="line">        self.fn = fn</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rule</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 可以自定义规则来操作</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># visible 控制 Excel 打开是否显示界面</span></span><br><span class="line">        <span class="comment">## add_book 控制是否添加新的 workbook</span></span><br><span class="line">        app = xw.App(visible=<span class="literal">True</span>, add_book=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># app.display_alerts = False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开 temp.xlsx 文件到 wookbook 中</span></span><br><span class="line">        wb = app.books.open(fn)</span><br><span class="line">        <span class="comment"># 切换到当前活动的 sheet 中</span></span><br><span class="line">        sheet = wb.sheets.active</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择 A1 所在的一列</span></span><br><span class="line">        <span class="comment">## 当 Excel 格式复杂的时候,不建议使用 expand</span></span><br><span class="line">        <span class="comment">## 可以这样选择</span></span><br><span class="line">        ARange = sheet.range(<span class="string">"A1:A100"</span>)</span><br><span class="line">        <span class="comment"># ARange = sheet.range("A1").expand("download")</span></span><br><span class="line">        <span class="keyword">for</span> A <span class="keyword">in</span> ARange:</span><br><span class="line">            <span class="keyword">if</span> str(A.value).strip() <span class="keyword">not</span> <span class="keyword">in</span> self.ExistSet:</span><br><span class="line">                self.ExistSet.add(str(A.value).strip())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># address = A.address</span></span><br><span class="line">                <span class="comment">## 获取 A 所在的位置坐标</span></span><br><span class="line">                self.ToDelList.append(A.address)</span><br><span class="line">                <span class="comment">## print(A.value)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.ToDelList:</span><br><span class="line">            td = self.ToDelList.pop()</span><br><span class="line">            <span class="comment"># 删除 A 所在的一行</span></span><br><span class="line">            sheet.range(td).api.EntireRow.Delete()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 保存 wookbook</span></span><br><span class="line">        <span class="comment">## 相当于Excel 的 Ctrl+S 快捷键</span></span><br><span class="line">        sheet.autofit()</span><br><span class="line">        wb.save()</span><br><span class="line">        app.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    d = DeleteTools(fn)</span><br><span class="line">    d.Delete()</span><br></pre></td></tr></table></figure>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>通过 <code>xlwings</code> 模块去自动操作 excel , 将日常需要手动操作的过程通过代码来自动操作，减少犯错的可能，一次次的不犯错，就是巨大的成功，在迎娶“白富美”的路上越走越远了。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
        <category>高级技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程技术</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-高级-爬虫-Requests 库高级使用</title>
    <url>/2019/10/13/2019-10-13-Programing-Python-Advanded-Requests-intro-2/</url>
    <content><![CDATA[<hr>
<h2 id="Headers（定制请求头）"><a href="#Headers（定制请求头）" class="headerlink" title="Headers（定制请求头）"></a>Headers（定制请求头）</h2><h3 id="什么是Headers请求头呢？"><a href="#什么是Headers请求头呢？" class="headerlink" title="什么是Headers请求头呢？"></a>什么是Headers请求头呢？</h3><p>请求头就是访问网页时的各种简单的证明信息，里面包含了很多内容。</p>
<p>比如你要获取信息的格式、访问的时间、是否用了代理（使用透明代理时浏览器依旧会发送你的真实IP，只有高匿代理才不会）、浏览器标识（User-Agent）等。</p>
<p>提示：给大家举一个非常直白的例子，浏览器就像是你的专属外卖配送员，各网站就像外卖商家，配送员到商家取餐时，需要提供订单号、我是谁的配送员、要取什么餐等等信息。</p>
<p>这里以chrome浏览器为例，首先 F12 打开调试模式，然后访问一个网站，将会在NetWork下看到对目标网页的请求信息，如下图：<br><img src="https://images.xiaozhuanlan.com/photo/2019/b2f2ccdcfc8c21bd8cf347564f09ec12.png" alt></p>
<p>通过设置header可以跳过一些简单的反爬或者防盗链措施。对付防盗链，服务器会识别 headers 中的 referer 是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在 headers 中加入 referer 。</p>
<blockquote>
<p>爬虫和反爬虫就像是双生兄弟一样，其中</p>
</blockquote>
<h3 id="一个响应内容的小例子"><a href="#一个响应内容的小例子" class="headerlink" title="一个响应内容的小例子"></a>一个响应内容的小例子</h3><p>这里以上海证券交易所为例，比如我要获取整个市场当日的基金成交信息，地址：<a href="http://www.sse.com.cn/market/funddata/overview/day/" target="_blank" rel="noopener">http://www.sse.com.cn/market/funddata/overview/day/</a><br><img src="https://images.xiaozhuanlan.com/photo/2019/4fa96803c51d0ccd800998dc044d5560.png" alt="当日的基金成交信息"></p>
<p>经过分析，其数据所在网址为<br><a href="http://query.sse.com.cn/marketdata/tradedata/queryNewTradingByProdTypeData.do?jsonCallBack=jsonpCallback10558&amp;searchDate=2019-10-08&amp;prodType=jj&amp;_=1570591517567" target="_blank" rel="noopener">http://query.sse.com.cn/marketdata/tradedata/queryNewTradingByProdTypeData.do?jsonCallBack=jsonpCallback10558&amp;searchDate=2019-10-08&amp;prodType=jj&amp;_=1570591517567</a></p>
<p>里面几个参数 <code>searchDate=2019-10-08</code> 和 <code>_=1570591517567</code> 很明显是时间戳，如果需要定时访问时，还是要构造一个url的。</p>
<p>使用time库的time方法即可。</p>
<a id="more"></a>
<p>时间戳的长度跟url中有差别，是因为精度问题，只需要乘以1000然后取整即可。</p>
<p>构造好url后，直接访问以下试试：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">timestamp = int(time.time()*<span class="number">1000</span>)</span><br><span class="line">url = <span class="string">'http://query.sse.com.cn/marketdata/tradedata/queryTradingByProdTypeData.do?jsonCallBack=jsonpCallback21071&amp;searchDate=&amp;prodType=jj&amp;_=&#123;&#125;'</span>.format(timestamp)</span><br><span class="line">res = requests.get(url)</span><br><span class="line">html = res.content.decode()</span><br><span class="line">print(html)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到结果</span></span><br><span class="line">jsonpCallback21071(&#123;“jsonCallBack”:”jsonpCallback21071″,”success”:”false”,”error”:”系统繁忙…”,”errorType”:”ExceptionInterceptor”&#125;)</span><br></pre></td></tr></table></figure><br>虽然有一些信息，但明显是出错了。<br><img src="https://images.xiaozhuanlan.com/photo/2019/a52113b1b8f0f60145e15418c2c2a611.png" alt="出错了"></p>
<p>我们通过浏览器来查看这个链接的请求头到底是什么：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/b8451173af49b6f9b5c59c093079b477.png" alt="请求头"></p>
<p>复制过来，构造一个dict类型的header字典，再次访问试试：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">myheaders = &#123;</span><br><span class="line">        <span class="string">'Referer'</span>: <span class="string">'http://www.sse.com.cn/market/funddata/overview/day/'</span>, </span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span></span><br><span class="line">             &#125;</span><br><span class="line">timestamp = int(time.time()*<span class="number">1000</span>)</span><br><span class="line">url = <span class="string">'http://query.sse.com.cn/marketdata/tradedata/queryTradingByProdTypeData.do?jsonCallBack=jsonpCallback21071&amp;searchDate=&amp;prodType=jj&amp;_=&#123;&#125;'</span>.format(timestamp)</span><br><span class="line">res = requests.get(url, headers=myheaders)</span><br><span class="line">html = res.content.decode()</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><br>完全没毛病了：<br><img src="https://images.xiaozhuanlan.com/photo/2019/338ebf5fb19f485f6e5abe8b105c5867.png" alt="成功了"></p>
<h3 id="Headers各主要字段的解释"><a href="#Headers各主要字段的解释" class="headerlink" title="Headers各主要字段的解释"></a>Headers各主要字段的解释</h3><p>在Requests Headers中各主要字段的解释如下：</p>
<ul>
<li>User-Agent<br> 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求</li>
<li>Content-Type<br>  在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。</li>
<li>application/xml<br> 在 XML RPC，如 RESTful/SOAP 调用时使用</li>
<li>application/json<br> 在 JSON RPC 调用时使用</li>
<li>application/x-www-form-urlencoded<br>  浏览器提交 Web 表单时使用</li>
</ul>
<blockquote>
<p>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</p>
</blockquote>
<h3 id="其他响应方式"><a href="#其他响应方式" class="headerlink" title="其他响应方式"></a>其他响应方式</h3><p>二进制响应内容：res.content，解码前，是byte格式。</p>
<p>JSON 响应内容：Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据 <code>res.json()</code> 。如果 JSON 解码失败， r.json() 就会抛出一个异常。例如，响应内容是 401 (Unauthorized)，尝试访问 r.json() 将会抛出  <code>ValueError: No JSON object could be decoded</code>异常。</p>
<p>原始响应内容：在罕见的情况下，你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw。 如果你确实想这么干，那请你确保在初始请求中设置了 <code>stream=True</code>。</p>
<h2 id="构造Url"><a href="#构造Url" class="headerlink" title="构造Url"></a>构造Url</h2><p>前文中目标 url 有很多参数，一方面很不美观，也容易出错，我们完全可以把参数全部摘出来放到一个 dict 字典中，然后在请求网页数据时将这个字典数据传递给 <code>params</code> 参数，如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">myheaders = &#123;</span><br><span class="line">    <span class="string">'Referer'</span>: <span class="string">'http://www.sse.com.cn/market/funddata/overview/day/'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timestamp = int(time.time()*<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">localtime = time.localtime()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里以当前日期为例，如果需要特定日期，直接为`searchDate` 赋值就可以了</span></span><br><span class="line"><span class="comment"># searchDate = "&#123;0&#125;-&#123;1&#125;-&#123;2&#125;".format("2019"， "10"， "08")</span></span><br><span class="line">searchDate = <span class="string">"&#123;&#125;-&#123;:0&gt;2d&#125;-&#123;:0&gt;2d&#125;"</span>.format(localtime.tm_year,localtime.tm_mon, localtime.tm_mday)</span><br><span class="line"></span><br><span class="line">pp = &#123;</span><br><span class="line">    <span class="string">'jsonCallBack'</span>: <span class="string">'jsonpCallback22341'</span>,</span><br><span class="line">    <span class="string">'searchDate'</span>: searchDate,</span><br><span class="line">    <span class="string">'prodType'</span>: <span class="string">'jj'</span>,</span><br><span class="line">    <span class="string">'_'</span>: timestamp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://query.sse.com.cn/marketdata/tradedata/queryTradingByProdTypeData.do'</span></span><br><span class="line">res = requests.get(url, headers=myheaders, params=pp)</span><br><span class="line">html = res.content.decode()</span><br><span class="line"></span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure></p>
<h2 id="Timeout-超时设置"><a href="#Timeout-超时设置" class="headerlink" title="Timeout(超时设置)"></a>Timeout(超时设置)</h2><p>连接超时指的是在你的客户端实现到远端机器端口的连接时（对应的是<code>connect()</code>_），Request 会等待的秒数。<br>一个很好的实践方法是把连接超时设为比 3 的倍数略大的一个数值，因为 TCP 数据包重传窗口 (<code>TCP packet retransmission window</code>) 的默认大小是 3。</p>
<p>有时候，我们访问的网页可能挂了、或者网络不稳定，或者网速太差等等原因导致整个程序卡在某个页面上了，这就非常耽误事，毕竟爬虫需要批量抓很多内容的，有些内容我们可以临时放弃并做标记，将所有都爬完后再考虑是否重新爬之前超时的页面。为防止服务器不能及时响应，大部分发至外部服务器的请求都应该带着 timeout 参数。</p>
<p>在默认情况下，除非显式指定了 timeout 值，requests 是不会自动进行超时处理的。</p>
<p>如果没有 timeout，你的代码可能会挂起若干分钟甚至更长时间。</p>
<p>你可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">requests.get(‘https://xiaozhuanlan.com/python_mastery’, timeout=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>timeout 仅对连接过程有效，与响应体的下载无关。</p>
</blockquote>
<p>timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）<code>If no timeout is specified explicitly, requests do not time out.</code>。</p>
<p>如果远端服务器很慢，你可以让 Request 永远等待，传入一个 None 作为 timeout 值，然后就可以了。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">'https://xiaozhuanlan.com/python_mastery'</span>, timeout=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
        <category>高级技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程技术</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-高级-爬虫-Requests 库基础使用</title>
    <url>/2019/10/10/2019-10-10-Programing-Python-Advanded-Requests-intro/</url>
    <content><![CDATA[<hr>
<h2 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h2><p><code>Requests</code> 库就非常优雅，虽然不是原生python模块，但自己安装也非常简单，只需要使用以下命令即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>
<p>作为 GitHub上关注数最多的 Python 项目之一，使用的是 urllib3，继承了urllib2的所有特性。requests实现了 HTTP协议中绝大部分功能，它提供的功能包括 Keep-Alive、连接池、Cookie持久化、内容自动解压、HTTP代理、SSL认证、连接超时、Session等很多特性，最重要的是它同时兼容 python2 和 python3。</p>
<p>同时，Requests对于HEAD, POST, PUT, PATCH, 和 DELETE方法的api同样简单。它可以处理多部分上传，同样支持自动转码，文档更好，还有更多的特性。</p>
<blockquote>
<p>值得注意的是，网络上有种言论是因为requests不支持异步，所以不推荐使用，但是随着 Python 语言本身的发展，现在已经可以很方便的将<code>requests</code>转为异步。</p>
</blockquote>
<h3 id="查看所安装-Requests-的版本"><a href="#查看所安装-Requests-的版本" class="headerlink" title="查看所安装 Requests 的版本"></a>查看所安装 Requests 的版本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.__version__</span><br><span class="line"><span class="string">'2.21.0'</span></span><br></pre></td></tr></table></figure>
<h2 id="常用的-Requests-方法及说明"><a href="#常用的-Requests-方法及说明" class="headerlink" title="常用的 Requests 方法及说明"></a>常用的 Requests 方法及说明</h2><h3 id="请求URL：GET"><a href="#请求URL：GET" class="headerlink" title="请求URL：GET"></a>请求URL：GET</h3><p>当我们导入requests模块之后就可以使用get命令来获取网页了，我们以自己的小专栏为例，测试一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.get(<span class="string">'https://xiaozhuanlan.com/python_mastery'</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>请求url之后，我们可以通过 <code>response.status_code</code> 或者 <code>response.ok</code> 命令来查看是否访问成功。</p>
<p>网页的具体内容则可以通过方法 <code>response.content.decode()</code> 来获取，其中 <code>decode()</code> 是用于解析内容编码的，如果网页编码格式是 <code>gb2312</code> 之类的，需要 <code>decode(&#39;gbk&#39;)</code> ，如果是 <code>utf8</code> ，则需要 <code>decode(&#39;utf-8&#39;)</code> 传入不同的参数。当参数为空时，默认为当前脚本的编码格式。<br><img src="https://images.xiaozhuanlan.com/photo/2019/e0ecacb5b5aab5cb0f1a9d34f7625038.png" alt="response.content.decode()"></p>
<p>其中对象response的属性 <code>status_code</code> 代表网页的htpp状态码，爬虫在抓取过程中经常遇到的的状态码有以下几种：</p>
<ul>
<li>200<br>  一切正常，网页资源正常获取到。</li>
<li>500<br>  如果在网页上会提示Bad Request，表示网页服务器返回给请求端的错误提示，提示请求端修复请求信息。</li>
<li>500<br>  Internal Server Error，网页服务器方面的问题，在爬虫抓取网站的过程中如果过快、被禁止等，会引发该类问题。表示服务器限制了客户端的访问。</li>
<li>404(“Not Found”) 和410(“Gone”)<br>  表示请求的网页资源不存在。</li>
<li>301<br>  重定向，请求的url呗重新定向到了另外一个url请求，通常需要请求端向另外一个url发送get请求才能得到所需要的网页资源。</li>
</ul>
<p>这里只是摘抄了部分返回值的情况，完整的内容请参见 https 状态码<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">HTTP 响应代码</a></p>
<h3 id="传递URL的参数"><a href="#传递URL的参数" class="headerlink" title="传递URL的参数"></a>传递URL的参数</h3><p>与后面要将到的 <code>post</code> 方式请求url相比，通过在url上添加参数也是网页服务器的设计之一，具体使用哪种方式是有网站程序来控制。</p>
<p>最经典、使用率最高的就是百度搜索了，百度搜索就是典型的通过 url 来传递搜索词和其他变量的，当然，也有一些 post 的内容在此处用不到暂时不展开讲。</p>
<p>用百度搜索一下，此处以关键词 “小专栏 Python 从入门到精通”为例，</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/649d4725ae4bde13071acda730a5c131.png" alt="百度搜索"></p>
<p>可以看到其中 <code>wd</code> 是关键词，<code>wd</code> 的具体值中空格变成了<code>+</code>，这是 url 转码导致的，在我们传递 url 参数时，有时候也需要这样的处理。</p>
<p>我们试着用requests来传递参数，目标地址：<code>https://www.baidu.com/s</code>，构造一个参数字典：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>params = &#123;<span class="string">'wd'</span>:<span class="string">'小专栏 Python 从入门到精通'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.get(<span class="string">'https://www.baidu.com/s'</span>, params=params)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.url)</span><br><span class="line">https://www.baidu.com/s?wd=%E5%B0%8F%E4%B8%93%E6%A0%8F+Python+%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A</span><br></pre></td></tr></table></figure><br>可以看到，url 已经传递了参数过来。浏览器访问该链接时中文讲自动解析。</p>
<blockquote>
<p>如果我们直接请求该网址，可能网页内容无法或许到，因为我们访问的是 <code>https</code> ，需要 <code>ssl</code> 证书，此后的教程中我会讲到该部分内容。</p>
</blockquote>
<h2 id="请求URL：POST"><a href="#请求URL：POST" class="headerlink" title="请求URL：POST"></a>请求URL：POST</h2><p>前面讲到传递 url 参数时提到 <code>post</code> 方法，<code>post</code> 方法就是 url 保持不变而具体的请求变量内容以 <code>post</code> 的形式发送过去。可以直接理解为将 url 中的参数改到了 <code>post</code> 的data中，<code>post</code> 还有一个好处是当传递的内容很长时，通过 url 是无法发送的（有最大长度），<code>post</code> 就没问题。而且，除了用于登录，像图片上传、文件上传，发表文章、论坛发帖顶贴等也基本使用的是 <code>post</code> 方法。</p>
<p>这里假设登录 wordpress 的博客后台来举例，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造一个post的form Data</span></span><br><span class="line">postdata = &#123;</span><br><span class="line"><span class="string">'log'</span>: <span class="string">'XXXXXXXXXXXX'</span>,</span><br><span class="line"><span class="string">'pwd'</span>: <span class="string">'XXXXXXXXXXXX'</span>,</span><br><span class="line"><span class="string">'wp-submit'</span>: <span class="string">'登录'</span>,</span><br><span class="line"><span class="string">'redirect_to'</span>: <span class="string">'http://xxx.xxx.xxx/'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行post命令</span></span><br><span class="line">response = requests.post(url, data=postdata)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看取得的网页内容</span></span><br><span class="line">response.content.decode()</span><br></pre></td></tr></table></figure>
<p>以上就是requests库的基础用法。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
        <category>高级技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程技术</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的掌握变量和类型了吗（二）类型转换</title>
    <url>/2019/09/08/2019-09-08-Programing-JavaScript-Type-conversion-Introduction-2/</url>
    <content><![CDATA[<h2 id="六、还有哪些引用类型"><a href="#六、还有哪些引用类型" class="headerlink" title="六、还有哪些引用类型"></a>六、还有哪些引用类型</h2><blockquote>
<p>在<code>ECMAScript</code>中，引用类型是一种数据结构，用于将数据和功能组织在一起。</p>
</blockquote>
<p>我们通常所说的对象，就是某个特定引用类型的实例。</p>
<p>在<code>ECMAScript</code>关于类型的定义中，只给出了<code>Object</code>类型，实际上，我们平时使用的很多引用类型的变量，并不是由<code>Object</code>构造的，但是它们原型链的终点都是<code>Object</code>，这些类型都属于引用类型。</p>
<ul>
<li><code>Array</code> 数组</li>
<li><code>Date</code> 日期</li>
<li><code>RegExp</code> 正则</li>
<li><code>Function</code> 函数</li>
</ul>
<h3 id="6-1-包装类型"><a href="#6-1-包装类型" class="headerlink" title="6.1 包装类型"></a>6.1 包装类型</h3><p>为了便于操作基本类型值，<code>ECMAScript</code>还提供了几个特殊的引用类型，他们是基本类型的包装类型：</p>
<ul>
<li><code>Boolean</code></li>
<li><code>Number</code></li>
<li><code>String</code></li>
</ul>
<p>注意包装类型和原始类型的区别：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> === <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"><span class="number">123</span> === <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// false</span></span><br><span class="line"><span class="string">"ConardLi"</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"ConardLi"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"ConardLi"</span>)); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"ConardLi"</span>); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用类型和包装类型的主要区别就是对象的生存期，使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"ConardLi"</span>;</span><br><span class="line">name.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.color); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-装箱和拆箱"><a href="#6-2-装箱和拆箱" class="headerlink" title="6.2 装箱和拆箱"></a>6.2 装箱和拆箱</h3><ul>
<li><p>装箱转换：把基本类型转换为对应的包装类型</p>
</li>
<li><p>拆箱操作：把引用类型转换为基本类型</p>
</li>
</ul>
<p>既然原始类型不能扩展属性和方法，那么我们是如何使用原始类型调用方法的呢？</p>
<p>每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而让我们能够调用一些方法和属性，例如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"ConardLi"</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = name.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>实际上发生了以下几个过程：</p>
<ul>
<li>创建一个<code>String</code>的包装类型实例</li>
<li>在实例上调用<code>substring</code>方法</li>
<li>销毁实例</li>
</ul>
<p>也就是说，我们使用基本类型调用方法，就会自动进行装箱和拆箱操作，相同的，我们使用<code>Number</code>和<code>Boolean</code>类型时，也会发生这个过程。</p>
<p>从引用类型到基本类型的转换，也就是拆箱的过程中，会遵循<code>ECMAScript规范</code>规定的<code>toPrimitive</code>原则，一般会调用引用类型的<code>valueOf</code>和<code>toString</code>方法，你也可以直接重写<code>toPeimitive</code>方法。一般转换成不同类型的值遵循的原则不同，例如：</p>
<ul>
<li>引用类型转换为<code>Number</code>类型，先调用<code>valueOf</code>，再调用<code>toString</code></li>
<li>引用类型转换为<code>String</code>类型，先调用<code>toString</code>，再调用<code>valueOf</code></li>
</ul>
<p>若<code>valueOf</code>和<code>toString</code>都不存在，或者没有返回基本类型，则抛出<code>TypeError</code>异常。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"valueOf"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"toString"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ConardLi"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj - <span class="number">1</span>); <span class="comment">// valueOf   122</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj&#125;</span>ConardLi`</span>); <span class="comment">// toString  ConardLiConardLi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"toPrimitive"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj2 - <span class="number">1</span>); <span class="comment">// valueOf   122</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"valueOf"</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"toString"</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj3 - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// valueOf</span></span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>除了程序中的自动拆箱和自动装箱，我们还可以手动进行拆箱和装箱操作。我们可以直接调用包装类型的<code>valueOf</code>或<code>toString</code>，实现拆箱操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"123"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num.valueOf()); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num.toString()); <span class="comment">//string</span></span><br></pre></td></tr></table></figure>
<h2 id="七、类型转换"><a href="#七、类型转换" class="headerlink" title="七、类型转换"></a>七、类型转换</h2><p>因为<code>JavaScript</code>是弱类型的语言，所以类型转换发生非常频繁，上面我们说的装箱和拆箱其实就是一种类型转换。</p>
<p>类型转换分为两种，隐式转换即程序自动进行的类型转换，强制转换即我们手动进行的类型转换。</p>
<p>强制转换这里就不再多提及了，下面我们来看看让人头疼的可能发生隐式类型转换的几个场景，以及如何转换：</p>
<h3 id="7-1-类型转换规则"><a href="#7-1-类型转换规则" class="headerlink" title="7.1 类型转换规则"></a>7.1 类型转换规则</h3><p>如果发生了隐式转换，那么各种类型互转符合下面的规则：</p>
<p><img src="http://www.conardli.top/img/bl/bl_8_convert.png" alt></p>
<h3 id="7-2-if-语句和逻辑语句"><a href="#7-2-if-语句和逻辑语句" class="headerlink" title="7.2 if 语句和逻辑语句"></a>7.2 if 语句和逻辑语句</h3><p>在<code>if</code>语句和逻辑语句中，如果只有单个变量，会先将变量转换为<code>Boolean</code>值，只有下面几种情况会转换成<code>false</code>，其余被转换成<code>true</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span>;</span><br><span class="line"><span class="literal">undefined</span>;</span><br><span class="line">(<span class="string">""</span>);</span><br><span class="line"><span class="literal">NaN</span>;</span><br><span class="line"><span class="number">0</span>;</span><br><span class="line"><span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-各种运数学算符"><a href="#7-3-各种运数学算符" class="headerlink" title="7.3 各种运数学算符"></a>7.3 各种运数学算符</h3><p>我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="literal">true</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span> - <span class="literal">null</span>; <span class="comment">//  1</span></span><br><span class="line"><span class="number">1</span> * <span class="literal">undefined</span>; <span class="comment">//  NaN</span></span><br><span class="line"><span class="number">2</span> * [<span class="string">"5"</span>]; <span class="comment">//  10</span></span><br></pre></td></tr></table></figure>
<p>注意<code>+</code>是个例外，执行<code>+</code>操作符时：</p>
<ul>
<li>1.当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li>
<li>2.当一侧为<code>Number</code>类型，另一侧为原始类型，则将原始类型转换为<code>Number</code>类型。</li>
<li>3.当一侧为<code>Number</code>类型，另一侧为引用类型，将引用类型和<code>Number</code>类型转换成字符串后拼接。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span> + <span class="string">"123"</span>; <span class="comment">// 123123   （规则1）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">null</span>; <span class="comment">// 123    （规则2）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">true</span>; <span class="comment">// 124    （规则2）</span></span><br><span class="line"><span class="number">123</span> + &#123;&#125;; <span class="comment">// 123[object Object]    （规则3）</span></span><br></pre></td></tr></table></figure>
<h3 id="7-4"><a href="#7-4" class="headerlink" title="7.4 =="></a>7.4 ==</h3><p>使用<code>==</code>时，若两侧类型相同，则比较结果和<code>===</code>相同，否则会发生隐式转换，使用<code>==</code>时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：</p>
<ul>
<li><strong>1.NaN</strong></li>
</ul>
<p><code>NaN</code>和其他任何类型比较永远返回<code>false</code>(包括和他自己)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>2.Boolean</strong></li>
</ul>
<p><code>Boolean</code>和其他任何类型比较，<code>Boolean</code>首先被转换为<code>Number</code>类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> == <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">"2"</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">"1"</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">"2"</span>]; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里注意一个可能会弄混的点：<code>undefined、null</code>和<code>Boolean</code>比较，虽然<code>undefined、null</code>和<code>false</code>都很容易被想象成假值，但是他们比较结果是<code>false</code>，原因是<code>false</code>首先被转换成<code>0</code>：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>3.String 和 Number</strong></li>
</ul>
<p><code>String</code>和<code>Number</code>比较，先将<code>String</code>转换为<code>Number</code>类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span> == <span class="string">"123"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == <span class="number">0</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>4.null 和 undefined</strong></li>
</ul>
<p><code>null == undefined</code>比较结果是<code>true</code>，除此之外，<code>null、undefined</code>和其他任何结果的比较值都为<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="string">""</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="string">""</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>5.原始类型和引用类型</strong></li>
</ul>
<p>当原始类型和引用类型做比较时，对象类型会依照<code>ToPrimitive</code>规则转换为原始类型:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"[object Object]"</span> == &#123;&#125;; <span class="comment">// true</span></span><br><span class="line"><span class="string">"1,2,3"</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>来看看下面这个比较：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] == ![]; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>!</code>的优先级高于<code>==</code>，<code>![]</code>首先会被转换为<code>false</code>，然后根据上面第三点，<code>false</code>转换成<code>Number</code>类型<code>0</code>，左侧<code>[]</code>转换为<code>0</code>，两侧比较相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">([<span class="literal">null</span>] ==</span><br><span class="line">  <span class="literal">false</span>[<span class="literal">undefined</span>]) == <span class="comment">// true</span></span><br><span class="line">  <span class="literal">false</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>根据数组的<code>ToPrimitive</code>规则，数组元素为<code>null</code>或<code>undefined</code>时，该元素被当做空字符串处理，所以<code>[null]、[undefined]</code>都会被转换为<code>0</code>。</p>
<p>所以，说了这么多，推荐使用<code>===</code>来判断两个值是否相等…</p>
<h3 id="7-5-一道有意思的面试题"><a href="#7-5-一道有意思的面试题" class="headerlink" title="7.5 一道有意思的面试题"></a>7.5 一道有意思的面试题</h3><p>一道经典的面试题，如何让：<code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code>。</p>
<p>根据上面的拆箱转换，以及<code>==</code>的隐式转换，我们可以轻松写出答案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  value: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="八、判断-JavaScript-数据类型的方式"><a href="#八、判断-JavaScript-数据类型的方式" class="headerlink" title="八、判断 JavaScript 数据类型的方式"></a>八、判断 JavaScript 数据类型的方式</h2><h3 id="8-1-typeof"><a href="#8-1-typeof" class="headerlink" title="8.1 typeof"></a>8.1 typeof</h3><p><strong>适用场景</strong></p>
<p><code>typeof</code>操作符可以准确判断一个变量是否为下面几个原始类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">"ConardLi"</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>你还可以用它来判断函数类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// function</span></span><br></pre></td></tr></table></figure>
<p><strong>不适用场景</strong></p>
<p>当你用<code>typeof</code>来判断引用类型时似乎显得有些乏力了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> /^\d*$/; <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>除函数外所有的引用类型都会被判定为<code>object</code>。</p>
<p>另外<code>typeof null === &#39;object&#39;</code>也会让人感到头痛，这是在<code>JavaScript</code>初版就流传下来的<code>bug</code>，后面由于修改会造成大量的兼容问题就一直没有被修复…</p>
<h3 id="8-2-instanceof"><a href="#8-2-instanceof" class="headerlink" title="8.2 instanceof"></a>8.2 instanceof</h3><p><code>instanceof</code>操作符可以帮助我们判断引用类型具体是什么类型的对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>() <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>我们先来回顾下原型链的几条规则：</p>
<ul>
<li>1.所有引用类型都具有对象特性，即可以自由扩展属性</li>
<li>2.所有引用类型都具有一个<code>__proto__</code>（隐式原型）属性，是一个普通对象</li>
<li>3.所有的函数都具有<code>prototype</code>（显式原型）属性，也是一个普通对象</li>
<li>4.所有引用类型<code>__proto__</code>值指向它构造函数的<code>prototype</code></li>
<li>5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的<code>__proto__</code>中去找</li>
</ul>
<p><code>[] instanceof Array</code>实际上是判断<code>Array.prototype</code>是否在<code>[]</code>的原型链上。</p>
<p>所以，使用<code>instanceof</code>来检测数据类型，不会很准确，这不是它设计的初衷：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>另外，使用<code>instanceof</code>也不能检测基本数据类型，所以<code>instanceof</code>并不是一个很好的选择。</p>
<h3 id="8-3-toString"><a href="#8-3-toString" class="headerlink" title="8.3 toString"></a>8.3 toString</h3><p>上面我们在拆箱操作中提到了<code>toString</code>函数，我们可以调用它实现从引用类型的转换。</p>
<blockquote>
<p>每一个引用类型都有<code>toString</code>方法，默认情况下，<code>toString()</code>方法被每个<code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，<code>toString()</code> 返回 <code>&quot;[object type]&quot;</code>，其中<code>type</code>是对象的类型。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.toString(); <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>
<p>注意，上面提到了<code>如果此方法在自定义对象中未被覆盖</code>，<code>toString</code>才会达到预想的效果，事实上，大部分引用类型比如<code>Array、Date、RegExp</code>等都重写了<code>toString</code>方法。</p>
<p>我们可以直接调用<code>Object</code>原型上未被覆盖的<code>toString()</code>方法，使用<code>call</code>来改变<code>this</code>指向来达到我们想要的效果。</p>
<p><img src="http://www.conardli.top/img/bl/bl_9_jc.png" alt></p>
<h3 id="8-4-jquery"><a href="#8-4-jquery" class="headerlink" title="8.4 jquery"></a>8.4 jquery</h3><p>我们来看看<code>jquery</code>源码中如何进行类型判断：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> class2type = &#123;&#125;;</span><br><span class="line">jQuery.each( <span class="string">"Boolean Number String Function Array Date RegExp Object Error Symbol"</span>.split( <span class="string">" "</span> ),</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"> i, name </span>) </span>&#123;</span><br><span class="line">	class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase();</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">type: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( obj == <span class="literal">null</span> ) &#123;</span><br><span class="line">		<span class="keyword">return</span> obj + <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"object"</span> || <span class="keyword">typeof</span> obj === <span class="string">"function"</span> ?</span><br><span class="line">		class2type[<span class="built_in">Object</span>.prototype.toString.call(obj) ] || <span class="string">"object"</span> :</span><br><span class="line">		<span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isFunction: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> jQuery.type(obj) === <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原始类型直接使用<code>typeof</code>，引用类型使用<code>Object.prototype.toString.call</code>取得类型，借助一个<code>class2type</code>对象将字符串多余的代码过滤掉，例如<code>[object function]</code>将得到<code>array</code>，然后在后面的类型判断，如<code>isFunction</code>直接可以使用<code>jQuery.type(obj) === &quot;function&quot;</code>这样的判断。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.ecma-international.org/ecma-262/9.0/index.html" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/9.0/index.html</a></li>
<li><a href="https://while.dev/articles/explaining-truthy-falsy-null-0-and-undefined-in-typescript/" target="_blank" rel="noopener">https://while.dev/articles/explaining-truthy-falsy-null-0-and-undefined-in-typescript/</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/28</a></li>
<li><a href="https://juejin.im/post/5bc5c752f265da0a9a399a62" target="_blank" rel="noopener">https://juejin.im/post/5bc5c752f265da0a9a399a62</a></li>
<li><a href="https://juejin.im/post/5bbda2b36fb9a05cfd27f55e" target="_blank" rel="noopener">https://juejin.im/post/5bbda2b36fb9a05cfd27f55e</a></li>
<li>《JS 高级程序设计》</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p>
<ul>
<li>了解<code>JavaScript</code>中的变量在内存中的具体存储形式，可对应实际场景</li>
<li>搞懂小数计算不精确的底层原因</li>
<li>了解可能发生隐式类型转换的场景以及转换原则</li>
<li>掌握判断<code>JavaScript</code>数据类型的方式和底层原理</li>
</ul>
<p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的掌握变量和类型了吗（一）数据类型</title>
    <url>/2019/09/03/2019-09-03-Programing-JavaScript-Type-conversion-Introduction-1/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>变量和类型是学习<code>JavaScript</code>最先接触到的东西，但是往往看起来最简单的东西往往还隐藏着很多你不了解、或者容易犯错的知识，比如下面几个问题：</p>
<ul>
<li><code>JavaScript</code>中的变量在内存中的具体存储形式是什么？</li>
<li><code>0.1+0.2</code>为什么不等于<code>0.3</code>?发生小数计算错误的具体原因是什么？</li>
<li><code>Symbol</code>的特点，以及实际应用场景是什么？</li>
<li><code>[] == ![]</code>、<code>[undefined] == false</code>为什么等于<code>true</code>?代码中何时会发生隐式类型转换？转换的规则是什么？</li>
<li>如何精确的判断变量的类型？</li>
</ul>
<p>如果你还不能很好的解答上面的问题，那说明你还没有完全掌握这部分的知识，那么请好好阅读下面的文章吧。</p>
<p>本文从底层原理到实际应用详细介绍了<code>JavaScript</code>中的变量和类型相关知识。</p>
<h2 id="一、JavaScript数据类型"><a href="#一、JavaScript数据类型" class="headerlink" title="一、JavaScript数据类型"></a>一、JavaScript数据类型</h2><p><a href="http://www.ecma-international.org/ecma-262/9.0/index.html" target="_blank" rel="noopener">ECMAScript标准</a>规定了<code>7</code>种数据类型，其把这<code>7</code>种数据类型又分为两种：原始类型和对象类型。</p>
<p><strong>原始类型</strong></p>
<ul>
<li><code>Null</code>：只包含一个值：<code>null</code></li>
<li><code>Undefined</code>：只包含一个值：<code>undefined</code></li>
<li><code>Boolean</code>：包含两个值：<code>true</code>和<code>false</code></li>
<li><code>Number</code>：整数或浮点数，还有一些特殊值（<code>-Infinity</code>、<code>+Infinity</code>、<code>NaN</code>）</li>
<li><code>String</code>：一串表示文本值的字符序列</li>
<li><code>Symbol</code>：一种实例是唯一且不可改变的数据类型</li>
</ul>
<p>(在<code>es10</code>中加入了第七种原始类型<code>BigInt</code>，现已被最新<code>Chrome</code>支持)</p>
<p><strong>对象类型</strong></p>
<ul>
<li><code>Object</code>：自己分一类丝毫不过分，除了常用的<code>Object</code>，<code>Array</code>、<code>Function</code>等都属于特殊的对象</li>
</ul>
<h2 id="二、为什么区分原始类型和对象类型"><a href="#二、为什么区分原始类型和对象类型" class="headerlink" title="二、为什么区分原始类型和对象类型"></a>二、为什么区分原始类型和对象类型</h2><h3 id="2-1-不可变性"><a href="#2-1-不可变性" class="headerlink" title="2.1 不可变性"></a>2.1 不可变性</h3><p>上面所提到的原始类型，在<code>ECMAScript</code>标准中，它们被定义为<code>primitive values</code>，即原始值，代表值本身是不可被改变的。</p>
<p>以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'ConardLi'</span>;</span><br><span class="line">str.slice(<span class="number">1</span>);</span><br><span class="line">str.substr(<span class="number">1</span>);</span><br><span class="line">str.trim(<span class="number">1</span>);</span><br><span class="line">str.toLowerCase(<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// ConardLi</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中我们对<code>str</code>调用了几个方法，无一例外，这些方法都在原字符串的基础上产生了一个新字符串，而非直接去改变<code>str</code>，这就印证了字符串的不可变性。</p>
<p>那么，当我们继续调用下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str += <span class="string">'6'</span></span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// ConardLi6</span></span><br></pre></td></tr></table></figure>
<p>你会发现，<code>str</code>的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解：</p>
<p>在<code>JavaScript</code>中，每一个变量在内存中都需要一个空间来存储。</p>
<p>内存空间又被分为两种，栈内存与堆内存。</p>
<a id="more"></a>
<p>栈内存：</p>
<ul>
<li>存储的值大小固定</li>
<li>空间较小</li>
<li>可以直接操作其保存的变量，运行效率高</li>
<li>由系统自动分配存储空间</li>
</ul>
<p><code>JavaScript</code>中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。</p>
<p><img src="http://www.conardli.top/img/bl/bl_1_stack.png" alt></p>
<p>由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的。</p>
<p>在上面的代码中，我们执行了<code>str += &#39;6&#39;</code>的操作，实际上是在栈中又开辟了一块内存空间用于存储<code>&#39;ConardLi6&#39;</code>，然后将变量<code>str</code>指向这块空间，所以这并不违背<code>不可变性的</code>特点。</p>
<p><img src="http://www.conardli.top/img/bl/bl_2_stack.png" alt></p>
<h3 id="2-2-引用类型"><a href="#2-2-引用类型" class="headerlink" title="2.2 引用类型"></a>2.2 引用类型</h3><p>堆内存：</p>
<ul>
<li>存储的值大小不定，可动态调整</li>
<li>空间较大，运行效率低</li>
<li>无法直接操作其内部存储，使用引用地址读取</li>
<li>通过代码进行分配空间</li>
</ul>
<p>相对于上面具有不可变性的原始类型，我习惯把对象称为引用类型，引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"ConardLi"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> obj4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p><img src="http://www.conardli.top/img/bl/bl_3_heap.png" alt></p>
<blockquote>
<p>由于内存是有限的，这些变量不可能一直在内存中占用资源，这里推荐下这篇文章<a href="https://juejin.im/post/5cb33660e51d456e811d2687" target="_blank" rel="noopener">JavaScript中的垃圾回收和内存泄漏</a>，这里告诉你<code>JavaScript</code>是如何进行垃圾回收以及可能会发生内存泄漏的一些场景。</p>
</blockquote>
<p>当然，引用类型就不再具有<code>不可变性</code>了，我们可以轻易的改变它们： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj1.name = <span class="string">"ConardLi6"</span>;</span><br><span class="line">obj2.age = <span class="number">19</span>;</span><br><span class="line">obj4.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name:"ConardLi6"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age:19&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>以数组为例，它的很多方法都可以改变它自身。</p>
<ul>
<li><code>pop()</code> 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素</li>
<li><code>push()</code>向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度</li>
<li><code>shift()</code>把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值</li>
<li><code>unshift()</code>向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度</li>
<li><code>reverse()</code>颠倒数组中元素的顺序，改变原数组，返回该数组</li>
<li><code>sort()</code>对数组元素进行排序，改变原数组，返回该数组</li>
<li><code>splice()</code>从数组中添加/删除项目，改变原数组，返回被删除的元素</li>
</ul>
<p>下面我们通过几个操作来对比一下原始类型和引用类型的区别：</p>
<h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><p>当我们把一个变量的值复制到另一个变量上时，原始类型和引用类型的表现是不一样的，先来看看原始类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = name;</span><br><span class="line">name2 = <span class="string">'code秘密花园'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// ConardLi;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://www.conardli.top/img/bl/bl_4_copy.png" alt></p>
<p>内存中有一个变量<code>name</code>，值为<code>ConardLi</code>。我们从变量<code>name</code>复制出一个变量<code>name2</code>，此时在内存中创建了一个块新的空间用于存储<code>ConardLi</code>，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。</p>
<p>复制一个引用类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj;</span><br><span class="line">obj2.name = <span class="string">'code秘密花园'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// code秘密花园</span></span><br></pre></td></tr></table></figure>
<p><img src="http://www.conardli.top/img/bl/bl_5_copy.png" alt></p>
<p>当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的<code>obj2</code>实际上和<code>obj</code>指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。</p>
<h3 id="2-4-比较"><a href="#2-4-比较" class="headerlink" title="2.4 比较"></a>2.4 比较</h3><p>当我们在对两个变量进行比较时，不同类型的变量的表现是不同的：</p>
<p><img src="http://www.conardli.top/img/bl/bl_6_compare.png" alt></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name === name2); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj === obj2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>对于原始类型，比较时会直接比较它们的值，如果值相等，即返回<code>true</code>。</p>
<p>对于引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为<code>false</code>。</p>
<h3 id="2-5-值传递和引用传递"><a href="#2-5-值传递和引用传递" class="headerlink" title="2.5 值传递和引用传递"></a>2.5 值传递和引用传递</h3><p>借助下面的例子，我们先来看一看什么是值传递，什么是引用传递：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  name = <span class="string">'code秘密花园'</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(name);</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，如果最终打印出来的<code>name</code>是<code>&#39;ConardLi&#39;</code>，没有改变，说明函数参数传递的是变量的值，即值传递。如果最终打印的是<code>&#39;code秘密花园&#39;</code>，函数内部的操作可以改变传入的变量，那么说明函数参数传递的是引用，即引用传递。</p>
<p>很明显，上面的执行结果是<code>&#39;ConardLi&#39;</code>，即函数参数仅仅是被传入变量复制给了的一个局部变量，改变这个局部变量不会对外部变量产生影响。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">'code秘密花园'</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// code秘密花园</span></span><br></pre></td></tr></table></figure>
<p>上面的代码可能让你产生疑惑，是不是参数是引用类型就是引用传递呢？</p>
<p>首先明确一点，<code>ECMAScript</code>中所有的函数的参数都是按值传递的。</p>
<p>同样的，当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递，下面我们再按一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">'ConardLi'</span>;</span><br><span class="line">  obj = &#123;<span class="attr">name</span>:<span class="string">'code秘密花园'</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// ConardLi</span></span><br></pre></td></tr></table></figure>
<p>可见，函数参数传递的并不是变量的<code>引用</code>，而是变量拷贝的副本，当变量是原始类型时，这个副本就是值本身，当变量是引用类型时，这个副本是指向堆内存的地址。所以，再次记住：</p>
<blockquote>
<p><code>ECMAScript</code>中所有的函数的参数都是按值传递的。</p>
</blockquote>
<h2 id="三、分不清的null和undefined"><a href="#三、分不清的null和undefined" class="headerlink" title="三、分不清的null和undefined"></a>三、分不清的null和undefined</h2><p><img src="http://www.conardli.top/img/bl/bl_7_null.png" alt></p>
<p>在原始类型中，有两个类型<code>Null</code>和<code>Undefined</code>，他们都有且仅有一个值，<code>null</code>和<code>undefined</code>，并且他们都代表无和空，我一般这样区分它们：</p>
<p><strong>null</strong></p>
<p>表示被赋值过的对象，刻意把一个对象赋值为<code>null</code>，故意表示其为空，不应有值。</p>
<p>所以对象的某个属性值为<code>null</code>是正常的，<code>null</code>转换为数值时值为<code>0</code>。</p>
<p><strong>undefined</strong> </p>
<p>表示“缺少值”，即此处应有一个值，但还没有定义，</p>
<p>如果一个对象的某个属性值为<code>undefined</code>，这是不正常的，如<code>obj.name=undefined</code>，我们不应该这样写，应该直接<code>delete obj.name</code>。</p>
<p><code>undefined</code>转为数值时为<code>NaN</code>(非数字值的特殊值)</p>
<p><code>JavaScript</code>是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是<code>undefined</code>的意义所在。对于<code>JAVA</code>这种强类型语言，如果有<code>&quot;undefined&quot;</code>这种情况，就会直接编译失败，所以在它不需要一个这样的类型。</p>
<h2 id="四、不太熟的Symbol类型"><a href="#四、不太熟的Symbol类型" class="headerlink" title="四、不太熟的Symbol类型"></a>四、不太熟的Symbol类型</h2><p><code>Symbol</code>类型是<code>ES6</code>中新加入的一种原始类型。</p>
<blockquote>
<p>每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。</p>
</blockquote>
<p>下面来看看<code>Symbol</code>类型具有哪些特性。</p>
<h3 id="4-1-Symbol的特性"><a href="#4-1-Symbol的特性" class="headerlink" title="4.1 Symbol的特性"></a>4.1 Symbol的特性</h3><p><strong>1.独一无二</strong></p>
<p>直接使用<code>Symbol()</code>创建新的<code>symbol</code>变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的<code>toString()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>();  <span class="comment">// Symbol() </span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym4 = <span class="built_in">Symbol</span>(&#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;); <span class="comment">// Symbol([object Object])</span></span><br><span class="line"><span class="built_in">console</span>.log(sym2 === sym3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>我们用两个相同的字符串创建两个<code>Symbol</code>变量，它们是不相等的，可见每个<code>Symbol</code>变量都是独一无二的。</p>
<p>如果我们想创造两个相等的<code>Symbol</code>变量，可以使用<code>Symbol.for(key)</code>。</p>
<blockquote>
<p>使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>.for(<span class="string">'ConardLi'</span>);</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">'ConardLi'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym1 === sym2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>2.原始类型</strong></p>
<p>注意是使用<code>Symbol()</code>函数创建<code>symbol</code>变量，并非使用构造函数，使用<code>new</code>操作符会直接报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// Uncaught TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>typeof</code>运算符判断一个<code>Symbol</code>类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>) === <span class="string">'symbol'</span></span><br></pre></td></tr></table></figure>
<p><strong>3.不可枚举</strong></p>
<p>当使用<code>Symbol</code>作为对象属性时，可以保证对象不会出现重名属性，调用<code>for...in</code>不能将其枚举出来，另外调用<code>Object.getOwnPropertyNames、Object.keys()</code>也不能获取<code>Symbol</code>属性。</p>
<blockquote>
<p>可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name:<span class="string">'ConardLi'</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'name2'</span>)]:<span class="string">'code秘密花园'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj); <span class="comment">// ["name"]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">// ["name"]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [Symbol(name)]</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-Symbol的应用场景"><a href="#4-2-Symbol的应用场景" class="headerlink" title="4.2 Symbol的应用场景"></a>4.2 Symbol的应用场景</h3><p>下面是几个<code>Symbol</code>在程序中的应用场景。</p>
<p><strong>应用一：防止XSS</strong></p>
<p>在<code>React</code>的<code>ReactElement</code>对象中，有一个<code>$$typeof</code>属性，它是一个<code>Symbol</code>类型的变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> REACT_ELEMENT_TYPE =</span><br><span class="line">  (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">'function'</span> &amp;&amp; <span class="built_in">Symbol</span>.for &amp;&amp; <span class="built_in">Symbol</span>.for(<span class="string">'react.element'</span>)) ||</span><br><span class="line">  <span class="number">0xeac7</span>;</span><br></pre></td></tr></table></figure>
<p><code>ReactElement.isValidElement</code>函数用来判断一个React组件是否是有效的，下面是它的具体实现。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object === <span class="string">'object'</span> &amp;&amp; object !== <span class="literal">null</span> &amp;&amp; object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可见<code>React</code>渲染时会把没有<code>$$typeof</code>标识，以及规则校验不通过的组件过滤掉。</p>
<p>如果你的服务器有一个漏洞，允许用户存储任意<code>JSON</code>对象， 而客户端代码需要一个字符串，这可能会成为一个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSON</span></span><br><span class="line"><span class="keyword">let</span> expectedTextButGotJSON = &#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    dangerouslySetInnerHTML: &#123;</span><br><span class="line">      __html: <span class="string">'/* put your exploit here */'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> message = &#123; <span class="attr">text</span>: expectedTextButGotJSON &#125;;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  &#123;message.text&#125;</span><br><span class="line">&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>而<code>JSON</code>中不能存储<code>Symbol</code>类型的变量，这就是防止<code>XSS</code>的一种手段。</p>
<p><strong>应用二：私有属性</strong></p>
<p>借助<code>Symbol</code>类型的不可枚举，我们可以在类中模拟私有属性，控制变量读写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> privateField = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>[privateField] = <span class="string">'ConardLi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  getField()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[privateField];</span><br><span class="line">  &#125;</span><br><span class="line">  setField(val)&#123;</span><br><span class="line">    <span class="keyword">this</span>[privateField] = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>应用三：防止属性污染</strong></p>
<p>在某些情况下，我们可能要为对象添加一个属性，此时就有可能造成属性覆盖，用<code>Symbol</code>作为对象属性可以保证永远不会出现同名属性。</p>
<p>例如下面的场景，我们模拟实现一个<code>call</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> result = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要在某个对象上临时调用一个方法，又不能造成属性污染，<code>Symbol</code>是一个很好的选择。</p>
<h2 id="五、不老实的Number类型"><a href="#五、不老实的Number类型" class="headerlink" title="五、不老实的Number类型"></a>五、不老实的Number类型</h2><p>为什么说<code>Number</code>类型不老实呢，相信大家都多多少少的在开发中遇到过小数计算不精确的问题，比如<code>0.1+0.2!==0.3</code>，下面我们来追本溯源，看看为什么会出现这种现象，以及该如何避免。</p>
<p>下面是我实现的一个简单的函数，用于判断两个小数进行加法运算是否精确：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeFloat</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> binaryN = n.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> binaryM = m.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>的二进制是    <span class="subst">$&#123;binaryN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;m&#125;</span>的二进制是    <span class="subst">$&#123;binaryM&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> MN = m + n;</span><br><span class="line">  <span class="keyword">const</span> accuracyMN = (m * <span class="number">100</span> + n * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> binaryMN = MN.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> accuracyBinaryMN = accuracyMN.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制是<span class="subst">$&#123;binaryMN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是    <span class="subst">$&#123;accuracyBinaryMN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制再转成十进制是<span class="subst">$&#123;to10(binaryMN)&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是再转成十进制是<span class="subst">$&#123;to10(accuracyBinaryMN)&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>在js中计算是<span class="subst">$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? <span class="string">''</span> : <span class="string">'不'</span>&#125;</span>准确的`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">to10</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pre = (n.split(<span class="string">'.'</span>)[<span class="number">0</span>] - <span class="number">0</span>).toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> arr = n.split(<span class="string">'.'</span>)[<span class="number">1</span>].split(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr.length) &#123;</span><br><span class="line">    result += arr[i] * <span class="built_in">Math</span>.pow(<span class="number">2</span>, -(i + <span class="number">1</span>));</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">judgeFloat(<span class="number">0.1</span>, <span class="number">0.2</span>);</span><br><span class="line">judgeFloat(<span class="number">0.6</span>, <span class="number">0.7</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制3.png" alt="image"></p>
<h3 id="5-1-精度丢失"><a href="#5-1-精度丢失" class="headerlink" title="5.1 精度丢失"></a>5.1 精度丢失</h3><p>计算机中所有的数据都是以<code>二进制</code>存储的，所以在计算时计算机要把数据先转换成<code>二进制</code>进行计算，然后在把计算结果转换成<code>十进制</code>。</p>
<p>由上面的代码不难看出，在计算<code>0.1+0.2</code>时，<code>二进制</code>计算发生了精度丢失，导致再转换成<code>十进制</code>后和预计的结果不符。</p>
<h3 id="5-2-对结果的分析—更多的问题"><a href="#5-2-对结果的分析—更多的问题" class="headerlink" title="5.2 对结果的分析—更多的问题"></a>5.2 对结果的分析—更多的问题</h3><p><code>0.1</code>和<code>0.2</code>的二进制都是以1100无限循环的小数，下面逐个来看JS帮我们计算所得的结果：</p>
<p><strong>0.1的二进制</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.0001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure>
<p><strong>0.2的二进制</strong>：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure></p>
<p><strong>理论上讲，由上面的结果相加应该：</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001100111</span></span><br></pre></td></tr></table></figure>
<p><strong>实际JS计算得到的0.1+0.2的二进制</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure>
<p>看到这里你可能会产生更多的问题：</p>
<blockquote>
<p>为什么 js计算出的 0.1的二进制 是这么多位而不是更多位？？？</p>
<p>为什么 js计算的（0.1+0.2）的二进制和我们自己计算的（0.1+0.2）的二进制结果不一样呢？？？</p>
<p>为什么 0.1的二进制 + 0.2的二进制 != 0.3的二进制？？？</p>
</blockquote>
<h3 id="5-3-js对二进制小数的存储方式"><a href="#5-3-js对二进制小数的存储方式" class="headerlink" title="5.3 js对二进制小数的存储方式"></a>5.3 js对二进制小数的存储方式</h3><p>小数的<code>二进制</code>大多数都是无限循环的，<code>JavaScript</code>是怎么来存储他们的呢？</p>
<p>在<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.19" target="_blank" rel="noopener">ECMAScript®语言规范</a>中可以看到，<code>ECMAScript</code>中的<code>Number</code>类型遵循<code>IEEE 754</code>标准。使用64位固定长度来表示。</p>
<p>事实上有很多语言的数字类型都遵循这个标准，例如<code>JAVA</code>,所以很多语言同样有着上面同样的问题。</p>
<p>所以下次遇到这种问题不要上来就喷<code>JavaScript</code>…</p>
<p>有兴趣可以看看下这个网站<a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">http://0.30000000000000004.com/</a>，是的，你没看错，就是<a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">http://0.30000000000000004.com/</a>！！！</p>
<h3 id="5-4-IEEE-754"><a href="#5-4-IEEE-754" class="headerlink" title="5.4 IEEE 754"></a>5.4 IEEE 754</h3><p><code>IEEE754</code>标准包含一组实数的二进制表示法。它有三部分组成：</p>
<ul>
<li><p>符号位</p>
</li>
<li><p>指数位</p>
</li>
<li><p>尾数位</p>
</li>
</ul>
<p>三种精度的浮点数各个部分位数如下：</p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制1.png" alt="image"></p>
<p><code>JavaScript</code>使用的是64位双精度浮点数编码，所以它的<code>符号位</code>占<code>1</code>位，指数位占<code>11</code>位，尾数位占<code>52</code>位。</p>
<p>下面我们在理解下什么是<code>符号位</code>、<code>指数位</code>、<code>尾数位</code>，以<code>0.1</code>为例：</p>
<p>它的二进制为：<code>0.0001100110011001100...</code></p>
<p>为了节省存储空间，在计算机中它是以科学计数法表示的，也就是</p>
<p><code>1.100110011001100...</code> X 2<sup>-4</sup></p>
<p>如果这里不好理解可以想一下十进制的数：</p>
<p><code>1100</code>的科学计数法为<code>11</code> X 10<sup>2</sup></p>
<p>所以：</p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制2.png" alt="image"></p>
<p><code>符号位</code>就是标识正负的，<code>1</code>表示<code>负</code>，<code>0</code>表示<code>正</code>；</p>
<p><code>指数位</code>存储科学计数法的指数；</p>
<p><code>尾数位</code>存储科学计数法后的有效数字；</p>
<p>所以我们通常看到的二进制，其实是计算机实际存储的尾数位。</p>
<h3 id="5-5-js中的toString-2"><a href="#5-5-js中的toString-2" class="headerlink" title="5.5 js中的toString(2)"></a>5.5 js中的toString(2)</h3><p>由于尾数位只能存储<code>52</code>个数字，这就能解释<code>toString(2)</code>的执行结果了：</p>
<p>如果计算机没有存储空间的限制，那么<code>0.1</code>的<code>二进制</code>应该是：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span>...</span><br></pre></td></tr></table></figure><br>科学计数法尾数位</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>...</span><br></pre></td></tr></table></figure>
<p>但是由于限制，有效数字第<code>53</code>位及以后的数字是不能存储的，它遵循，如果是<code>1</code>就向前一位进<code>1</code>，如果是<code>0</code>就舍弃的原则。</p>
<p>0.1的二进制科学计数法第53位是1，所以就有了下面的结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.0001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure>
<p><code>0.2</code>有着同样的问题，其实正是由于这样的存储，在这里有了精度丢失，导致了<code>0.1+0.2!=0.3</code>。</p>
<p>事实上有着同样精度问题的计算还有很多，我们无法把他们都记下来，所以当程序中有数字计算时，我们最好用工具库来帮助我们解决，下面是两个推荐使用的开源库：</p>
<ul>
<li><a href="https://github.com/nefe/number-precision" target="_blank" rel="noopener">number-precision</a></li>
<li><a href="https://github.com/josdejong/mathjs/" target="_blank" rel="noopener">mathjs/</a></li>
</ul>
<h3 id="5-6-JavaScript能表示的最大数字"><a href="#5-6-JavaScript能表示的最大数字" class="headerlink" title="5.6 JavaScript能表示的最大数字"></a>5.6 JavaScript能表示的最大数字</h3><p>由与<code>IEEE 754</code>双精度64位规范的限制：</p>
<p><code>指数位</code>能表示的最大数字：<code>1023</code>(十进制)</p>
<p><code>尾数位</code>能表达的最大数字即尾数位都位<code>1</code>的情况</p>
<p>所以JavaScript能表示的最大数字即位</p>
<p><code>1.111...</code>X 2<sup>1023</sup> 这个结果转换成十进制是<code>1.7976931348623157e+308</code>,这个结果即为<code>Number.MAX_VALUE</code>。</p>
<h3 id="5-7-最大安全数字"><a href="#5-7-最大安全数字" class="headerlink" title="5.7 最大安全数字"></a>5.7 最大安全数字</h3><p>JavaScript中<code>Number.MAX_SAFE_INTEGER</code>表示最大安全数字,计算结果是<code>9007199254740991</code>，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是<code>1.111...</code>X 2<sup>52</sup>。</p>
<p>我们同样可以用一些开源库来处理大整数：</p>
<ul>
<li><a href="https://github.com/justmoon/node-bignum" target="_blank" rel="noopener">node-bignum</a></li>
<li><a href="https://github.com/substack/node-bigint" target="_blank" rel="noopener">node-bigint</a></li>
</ul>
<p>其实官方也考虑到了这个问题，<code>bigInt</code>类型在<code>es10</code>中被提出，现在<code>Chrome</code>中已经可以使用，使用<code>bigInt</code>可以操作超过最大安全数字的数字。</p>
<p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写出一个惊艳面试官的深拷贝</title>
    <url>/2019/09/01/2019-09-01-Programing-JavaScript-How-to-Write-a-stunning-deep-copy-of-the-interviewer/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>最近经常看到很多<code>JavaScript</code>手写代码的文章总结，里面提供了很多<code>JavaScript Api</code>的手写实现。</p>
<p>里面的题目实现大多类似，而且说实话很多代码在我看来是非常简陋的，如果我作为面试官，看到这样的代码，在我心里是不会合格的，本篇文章我拿最简单的深拷贝来讲一讲。</p>
<p>看本文之前先问自己三个问题：</p>
<ul>
<li><p>你真的理解什么是深拷贝吗？</p>
</li>
<li><p>在面试官眼里，什么样的深拷贝才算合格？</p>
</li>
<li><p>什么样的深拷贝能让面试官感到惊艳？</p>
</li>
</ul>
<p>本文由浅入深，带你一步一步实现一个惊艳面试官的深拷贝。</p>
<h2 id="深拷贝和浅拷贝的定义"><a href="#深拷贝和浅拷贝的定义" class="headerlink" title="深拷贝和浅拷贝的定义"></a>深拷贝和浅拷贝的定义</h2><p>深拷贝已经是一个老生常谈的话题了，也是现在前端面试的高频题目，但是令我吃惊的是有很多同学还没有搞懂深拷贝和浅拷贝的区别和定义。例如前几天给我提<code>issue</code>的同学：</p>
<p><img src="https://i.loli.net/2019/08/30/8U5e2I6lmzBHcW9.jpg" alt></p>
<p>很明显这位同学把拷贝和赋值搞混了，如果你还对赋值、对象在内存中的存储、变量和类型等等有什么疑问，可以看看我这篇文章：<br><a href="https://juejin.im/post/5cec1bcff265da1b8f1aa08f" target="_blank" rel="noopener">https://juejin.im/post/5cec1bcff265da1b8f1aa08f</a> 。</p>
<p>你只要少搞明白<code>拷贝</code>和<code>赋值</code>的区别。</p>
<p>我们来明确一下深拷贝和浅拷贝的定义：</p>
<p>浅拷贝：</p>
<p><img src="https://i.loli.net/2019/08/30/N3CB7obYhn5Lvxz.jpg" alt></p>
<blockquote>
<p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
</blockquote>
<a id="more"></a>
<p>深拷贝：</p>
<p><img src="https://i.loli.net/2019/08/30/OFIGRqZeWkBn9cr.jpg" alt></p>
<blockquote>
<p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p>
</blockquote>
<p>话不多说，浅拷贝就不再多说，下面我们直入正题：</p>
<h2 id="乞丐版"><a href="#乞丐版" class="headerlink" title="乞丐版"></a>乞丐版</h2><p>在不使用第三方库的情况下，我们想要深拷贝一个对象，用的最多的就是下面这个方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify());</span><br></pre></td></tr></table></figure>
<p>这种写法非常简单，而且可以应对大部分的应用场景，但是它还是有很大缺陷的，比如拷贝其他引用类型、拷贝函数、循环引用等情况。</p>
<p>显然，面试时你只说出这样的方法是一定不会合格的。</p>
<p>接下来，我们一起来手动实现一个深拷贝方法。</p>
<h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><p>如果是浅拷贝的话，我们可以很容易写出下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        cloneTarget[key] = target[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性依次添加到新对象上，返回。</p>
<p>如果是深拷贝的话，考虑到我们要拷贝的对象是不知道有多少层深度的，我们可以用递归来解决问题，稍微改写上面的代码：</p>
<ul>
<li>如果是原始类型，无需继续拷贝，直接返回</li>
<li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行 <strong>深拷贝后</strong> 依次添加到新对象上。</li>
</ul>
<p>很容易理解，如果有更深层次的对象可以继续递归直到属性为原始类型，这样我们就完成了一个最简单的深拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看下面的测试用例进行测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: <span class="string">'ConardLi'</span>,</span><br><span class="line">    field4: &#123;</span><br><span class="line">        child: <span class="string">'child'</span>,</span><br><span class="line">        child2: &#123;</span><br><span class="line">            child2: <span class="string">'child2'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://i.loli.net/2019/08/31/Nxr21XJnVgqOTs5.png" alt></p>
<p>这是一个最基础版本的深拷贝，这段代码可以让你向面试官展示你可以用递归解决问题，但是显然，他还有非常多的缺陷，比如，还没有考虑数组。</p>
<h2 id="考虑数组"><a href="#考虑数组" class="headerlink" title="考虑数组"></a>考虑数组</h2><p>在上面的版本中，我们的初始化结果只考虑了普通的<code>object</code>，下面我们只需要把初始化代码稍微一变，就可以兼容数组了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行下面的测试用例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://i.loli.net/2019/08/31/2LokZ1hMcGbBYU7.jpg" alt></p>
<p>OK，没有问题，你的代码又向合格迈进了一小步。</p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>我们执行下面这样一个测试用例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br><span class="line">target.target = target;</span><br></pre></td></tr></table></figure>
<p>可以看到下面的结果：</p>
<p><img src="https://i.loli.net/2019/08/31/JMiLz6qt2BYdvjm.png" alt></p>
<p>很明显，因为递归进入死循环导致栈内存溢出了。</p>
<p>原因就是上面的对象存在循环引用的情况，即对象的属性间接或直接的引用了自身的情况：</p>
<p><img src="https://i.loli.net/2019/09/01/uYyaqztP23xh5Vf.jpg" alt></p>
<p>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。</p>
<p>这个存储空间，需要可以存储<code>key-value</code>形式的数据，且<code>key</code>可以是一个引用类型，我们可以选择<code>Map</code>这种数据结构：</p>
<ul>
<li>检查<code>map</code>中有无克隆过的对象</li>
<li>有 - 直接返回</li>
<li>没有 - 将当前对象作为<code>key</code>，克隆对象作为<code>value</code>进行存储</li>
<li>继续克隆</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new Map(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(target, cloneTarget);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key], map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再来执行上面的测试用例：</p>
<p><img src="https://i.loli.net/2019/08/31/z1OWfmFcAJ9SR8I.jpg" alt></p>
<p>可以看到，执行没有报错，且<code>target</code>属性，变为了一个<code>Circular</code>类型，即循环应用的意思。</p>
<p>接下来，我们可以使用，<code>WeakMap</code>提代<code>Map</code>来使代码达到画龙点睛的作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/09/01/AWrneLyJavhTfOG.jpg" alt></p>
<p>为什么要这样做呢？，先来看看<code>WeakMap</code>的作用：</p>
<blockquote>
<p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p>
</blockquote>
<p>什么是弱引用呢？</p>
<blockquote>
<p>在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。</p>
</blockquote>
<p>我们默认创建一个对象：<code>const obj = {}</code>，就默认创建了一个强引用的对象，我们只有手动将<code>obj = null</code>，它才会被垃圾回收机制进行回收，如果是弱引用对象，垃圾回收机制会自动帮我们回收。</p>
<p>举个例子：</p>
<p>如果我们使用<code>Map</code>的话，那么对象间是存在强引用关系的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span> : <span class="string">'ConardLi'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">target.set(obj,<span class="string">'code秘密花园'</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>虽然我们手动将<code>obj</code>，进行释放，然是<code>target</code>依然对<code>obj</code>存在强引用关系，所以这部分内存依然无法被释放。</p>
<p>再来看<code>WeakMap</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span> : <span class="string">'ConardLi'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">target.set(obj,<span class="string">'code秘密花园'</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>如果是<code>WeakMap</code>的话，<code>target</code>和<code>obj</code>存在的就是弱引用关系，当下一次垃圾回收机制执行时，这块内存就会被释放掉。</p>
<p>设想一下，如果我们要拷贝的对象非常庞大时，使用<code>Map</code>会对内存造成非常大的额外消耗，而且我们需要手动清除<code>Map</code>的属性才能释放这块内存，而<code>WeakMap</code>会帮我们巧妙化解这个问题。</p>
<p>我也经常在某些代码中看到有人使用<code>WeakMap</code>来解决循环引用问题，但是解释都是模棱两可的，当你不太了解<code>WeakMap</code>的真正作用时。我建议你也不要在面试中写这样的代码，结果只能是给自己挖坑，即使是准备面试，你写的每一行代码也都是需要经过深思熟虑并且非常明白的。</p>
<p>能考虑到循环引用的问题，你已经向面试官展示了你考虑问题的全面性，如果还能用<code>WeakMap</code>解决问题，并很明确的向面试官解释这样做的目的，那么你的代码在面试官眼里应该算是合格了。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>在上面的代码中，我们遍历数组和对象都使用了<code>for in</code>这种方式，实际上<code>for in</code>在遍历时效率是非常低的，我们来对比下常见的三种循环<code>for、while、for in</code>的执行效率：</p>
<p><img src="https://i.loli.net/2019/08/29/1ydBJ63LntlvZWO.jpg" alt></p>
<p>可以看到，<code>while</code>的效率是最好的，所以，我们可以想办法把<code>for in</code>遍历改变为<code>while</code>遍历。</p>
<p>我们先使用<code>while</code>来实现一个通用的<code>forEach</code>遍历，<code>iteratee</code>是遍历的回掉函数，他可以接收每次遍历的<code>value</code>和<code>index</code>两个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">        iteratee(array[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面对我们的<code>cloen</code>函数进行改写：当遍历数组时，直接使用<code>forEach</code>进行遍历，当遍历对象时，使用<code>Object.keys</code>取出所有的<code>key</code>进行遍历，然后在遍历时把<code>forEach</code>会调函数的<code>value</code>当作<code>key</code>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray(target);</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = isArray ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> keys = isArray ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line">        forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">                key = value;</span><br><span class="line">            &#125;</span><br><span class="line">            cloneTarget[key] = clone2(target[key], map);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们执行测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    f: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123;&#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">target.target = target;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> result = clone1(target);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> result2 = clone2(target);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://i.loli.net/2019/08/31/ZhMxNjFE9KYqH7l.jpg" alt></p>
<p>很明显，我们的性能优化是有效的。</p>
<p>到这里，你已经向面试官展示了，在写代码的时候你会考虑程序的运行效率，并且你具有通用函数的抽象能力。</p>
<h2 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h2><p>在上面的代码中，我们其实只考虑了普通的<code>object</code>和<code>array</code>两种数据类型，实际上所有的引用类型远远不止这两个，还有很多，下面我们先尝试获取对象准确的类型。</p>
<h3 id="合理的判断引用类型"><a href="#合理的判断引用类型" class="headerlink" title="合理的判断引用类型"></a>合理的判断引用类型</h3><p>首先，判断是否为引用类型，我们还需要考虑<code>function</code>和<code>null</code>两种特殊的数据类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> target;</span><br><span class="line">    <span class="keyword">return</span> target !== <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="获取数据类型"><a href="#获取数据类型" class="headerlink" title="获取数据类型"></a>获取数据类型</h3><p>我们可以使用<code>toString</code>来获取准确的引用类型：</p>
<blockquote>
<p>每一个引用类型都有<code>toString</code>方法，默认情况下，<code>toString()</code>方法被每个<code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，t<code>oString()</code> 返回 <code>&quot;[object type]&quot;</code>，其中type是对象的类型。</p>
</blockquote>
<p>注意，上面提到了如果此方法在自定义对象中未被覆盖，<code>toString</code>才会达到预想的效果，事实上，大部分引用类型比如<code>Array、Date、RegExp</code>等都重写了<code>toString</code>方法。</p>
<p>我们可以直接调用<code>Object</code>原型上未被覆盖的<code>toString()</code>方法，使用<code>call</code>来改变<code>this</code>指向来达到我们想要的效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/09/01/wvJgxWe17RdaEHY.jpg" alt></p>
<p>下面我们抽离出一些常用的数据类型以便后面使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapTag = <span class="string">'[object Map]'</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">'[object Set]'</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">'[object Array]'</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">'[object Object]'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">'[object Boolean]'</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">'[object Date]'</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">'[object Error]'</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">'[object Number]'</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">'[object RegExp]'</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">'[object String]'</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">'[object Symbol]'</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的集中类型中，我们简单将他们分为两类：</p>
<ul>
<li>可以继续遍历的类型</li>
<li>不可以继续遍历的类型</li>
</ul>
<p>我们分别为它们做不同的拷贝。</p>
<h3 id="可继续遍历的类型"><a href="#可继续遍历的类型" class="headerlink" title="可继续遍历的类型"></a>可继续遍历的类型</h3><p>上面我们已经考虑的<code>object</code>、<code>array</code>都属于可以继续遍历的类型，因为它们内存都还可以存储其他数据类型的数据，另外还有<code>Map</code>，<code>Set</code>等都是可以继续遍历的类型，这里我们只考虑这四种，如果你有兴趣可以继续探索其他类型。</p>
<p>有序这几种类型还需要继续进行递归，我们首先需要获取它们的初始化数据，例如上面的<code>[]</code>和<code>{}</code>，我们可以通过拿到<code>constructor</code>的方式来通用的获取。</p>
<p>例如：<code>const target = {}</code>就是<code>const target = new Object()</code>的语法糖。另外这种方法还有一个好处：因为我们还使用了原对象的构造方法，所以它可以保留对象原型上的数据，如果直接使用普通的<code>{}</code>，那么原型必然是丢失了的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInit</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ctor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们改写<code>clone</code>函数，对可继续遍历的数据类型进行处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆原始类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">const</span> type = getType(target);</span><br><span class="line">    <span class="keyword">let</span> cloneTarget;</span><br><span class="line">    <span class="keyword">if</span> (deepTag.includes(type)) &#123;</span><br><span class="line">        cloneTarget = getInit(target, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(target);</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆set</span></span><br><span class="line">    <span class="keyword">if</span> (type === setTag) &#123;</span><br><span class="line">        target.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.add(clone(value,map));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆map</span></span><br><span class="line">    <span class="keyword">if</span> (type === mapTag) &#123;</span><br><span class="line">        target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.set(key, clone(value,map));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆对象和数组</span></span><br><span class="line">    <span class="keyword">const</span> keys = type === arrayTag ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line">    forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">            key = value;</span><br><span class="line">        &#125;</span><br><span class="line">        cloneTarget[key] = clone(target[key], map);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们执行测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    empty: <span class="literal">null</span>,</span><br><span class="line">    map,</span><br><span class="line">    <span class="keyword">set</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://i.loli.net/2019/09/01/dQ7hGjYirkRlN3s.jpg" alt></p>
<p>没有问题，里大功告成又进一步，下面我们继续处理其他类型：</p>
<h3 id="不可继续遍历的类型"><a href="#不可继续遍历的类型" class="headerlink" title="不可继续遍历的类型"></a>不可继续遍历的类型</h3><p>其他剩余的类型我们把它们统一归类成不可处理的数据类型，我们依次进行处理：</p>
<p><code>Bool</code>、<code>Number</code>、<code>String</code>、<code>String</code>、<code>Date</code>、<code>Error</code>这几种类型我们都可以直接用构造函数和原始数据创建一个新对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneOtherType</span>(<span class="params">targe, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = targe.constructor;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> boolTag:</span><br><span class="line">        <span class="keyword">case</span> numberTag:</span><br><span class="line">        <span class="keyword">case</span> stringTag:</span><br><span class="line">        <span class="keyword">case</span> errorTag:</span><br><span class="line">        <span class="keyword">case</span> dateTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ctor(targe);</span><br><span class="line">        <span class="keyword">case</span> regexpTag:</span><br><span class="line">            <span class="keyword">return</span> cloneReg(targe);</span><br><span class="line">        <span class="keyword">case</span> symbolTag:</span><br><span class="line">            <span class="keyword">return</span> cloneSymbol(targe);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>克隆<code>Symbol</code>类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">targe</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(targe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">克隆正则：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneReg</span>(<span class="params">targe</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class="line">    result.lastIndex = targe.lastIndex;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上还有很多数据类型我这里没有写到，有兴趣的话可以继续探索实现一下。</p>
<p>能写到这里，面试官已经看到了你考虑问题的严谨性，你对变量和类型的理解，对<code>JS API</code>的熟练程度，相信面试官已经开始对你刮目相看了。</p>
<h3 id="克隆函数"><a href="#克隆函数" class="headerlink" title="克隆函数"></a>克隆函数</h3><p>最后，我把克隆函数单独拎出来了，实际上克隆函数是没有实际应用场景的，两个对象使用一个在内存中处于同一个地址的函数也是没有任何问题的，我特意看了下<code>lodash</code>对函数的处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value == <span class="string">'function'</span></span><br><span class="line"><span class="keyword">if</span> (isFunc || !cloneableTags[tag]) &#123;</span><br><span class="line">       <span class="keyword">return</span> object ? value : &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见这里如果发现是函数的话就会直接返回了，没有做特殊的处理，但是我发现不少面试官还是热衷于问这个问题的，而且据我了解能写出来的少之又少。。。</p>
<p>实际上这个方法并没有什么难度，主要就是考察你对基础的掌握扎实不扎实。</p>
<p>首先，我们可以通过<code>prototype</code>来区分下箭头函数和普通函数，箭头函数是没有<code>prototype</code>的。</p>
<p>我们可以直接使用<code>eval</code>和函数字符串来重新生成一个箭头函数，注意这种方法是不适用于普通函数的。</p>
<p>我们可以使用正则来处理普通函数：</p>
<p>分别使用正则取出函数体和函数参数，然后使用<code>new Function ([arg1[, arg2[, ...argN]],] functionBody)</code>构造函数重新构造一个新的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneFunction</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">    <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">    <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">    <span class="keyword">if</span> (func.prototype) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'普通函数'</span>);</span><br><span class="line">        <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">        <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">        <span class="keyword">if</span> (body) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'匹配到函数体：'</span>, body[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (param) &#123;</span><br><span class="line">                <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">','</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'匹配到参数：'</span>, paramArr);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(funcString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们再来执行测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line">map.set(<span class="string">'ConardLi'</span>, <span class="string">'code秘密花园'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add('ConardLi');</span><br><span class="line"><span class="keyword">set</span>.add('code秘密花园');</span><br><span class="line"></span><br><span class="line">const target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    empty: <span class="literal">null</span>,</span><br><span class="line">    map,</span><br><span class="line">    <span class="keyword">set</span>,</span><br><span class="line">    bool: new Boolean(true),</span><br><span class="line">    num: new Number(2),</span><br><span class="line">    str: new String(2),</span><br><span class="line">    symbol: Object(Symbol(1)),</span><br><span class="line">    date: new Date(),</span><br><span class="line">    reg: /\d+/,</span><br><span class="line">    error: new Error(),</span><br><span class="line">    func1: () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'code秘密花园'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://i.loli.net/2019/09/01/3tsUZR561FYOuQc.jpg" alt></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>为了更好的阅读，我们用一张图来展示上面所有的代码：</p>
<p><img src="https://i.loli.net/2019/08/30/9lfDPCXBagE8rQY.jpg" alt></p>
<p>可见，一个小小的深拷贝还是隐藏了很多的知识点的。</p>
<p>千万不要以最低的要求来要求自己，如果你只是为了应付面试中的一个题目，那么你可能只会去准备上面最简陋的深拷贝的方法。</p>
<p>但是面试官考察你的目的是全方位的考察你的思维能力，如果你写出上面的代码，可以体现你多方位的能力：</p>
<ul>
<li>基本实现<ul>
<li>递归能力</li>
</ul>
</li>
<li>循环引用<ul>
<li>考虑问题的全面性</li>
<li>理解weakmap的真正意义</li>
</ul>
</li>
<li>多种类型<ul>
<li>考虑问题的严谨性</li>
<li>创建各种引用类型的方法，JS API的熟练程度</li>
<li>准确的判断数据类型，对数据类型的理解程度</li>
</ul>
</li>
<li>通用遍历：<ul>
<li>写代码可以考虑性能优化</li>
<li>了解集中遍历的效率</li>
<li>代码抽象能力</li>
</ul>
</li>
<li>拷贝函数：<ul>
<li>箭头函数和普通函数的区别</li>
<li>正则表达式熟练程度</li>
</ul>
</li>
</ul>
<p>看吧，一个小小的深拷贝能考察你这么多的能力，如果面试官看到这样的代码，怎么能够不惊艳呢？</p>
<p>其实面试官出的所有题目你都可以用这样的思路去考虑。不要为了应付面试而去背一些代码，这样在有经验的面试官面前会都会暴露出来。你写的每一段代码都要经过深思熟虑，为什么要这样用，还能怎么优化…这样才能给面试官展现一个最好的你。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank" rel="noopener">WeakMap</a></li>
<li><a href="https://lodash.com/" target="_blank" rel="noopener">lodash</a></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望看完本篇文章能对你有如下帮助：</p>
<ul>
<li>理解深浅拷贝的真正意义</li>
<li>能整我深拷贝的各个要点，对问题进行深入分析</li>
<li>可以手写一个比较完整的深拷贝</li>
</ul>
<p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端适配总结（二）应用篇</title>
    <url>/2019/05/27/2019-05-27-Programing-JavaScript-moblie-develop-2/</url>
    <content><![CDATA[<h2 id="五、1px问题"><a href="#五、1px问题" class="headerlink" title="五、1px问题"></a>五、1px问题</h2><p>为了适配各种屏幕，我们写代码时一般使用设备独立像素来对页面进行布局。</p>
<p>而在设备像素比大于<code>1</code>的屏幕上，我们写的<code>1px</code>实际上是被多个物理像素渲染，这就会出现<code>1px</code>在有些屏幕上看起来很粗的现象。</p>
<h3 id="5-1-border-image"><a href="#5-1-border-image" class="headerlink" title="5.1 border-image"></a>5.1 border-image</h3><p>基于<code>media</code>查询判断不同的设备像素比给定不同的<code>border-image</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">         <span class="attribute">border-bottom</span>: none;</span><br><span class="line">         <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span>;</span><br><span class="line">         <span class="attribute">border-image</span>: <span class="built_in">url</span>(../img/1pxline.png) <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> stretch;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-background-image"><a href="#5-2-background-image" class="headerlink" title="5.2 background-image"></a>5.2 background-image</h3><p>和<code>border-image</code>类似，准备一张符合条件的边框背景图，模拟在背景上。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">         <span class="attribute">background</span>: <span class="built_in">url</span>(../img/1pxline.png) repeat-x left bottom;</span><br><span class="line">         <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">1px</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面两种都需要单独准备图片，而且圆角不是很好处理，但是可以应对大部分场景。</p>
<a id="more"></a>
<h3 id="5-3-伪类-transform"><a href="#5-3-伪类-transform" class="headerlink" title="5.3 伪类 + transform"></a>5.3 伪类 + transform</h3><p>基于<code>media</code>查询判断不同的设备像素比对线条进行缩放：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">   <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">   <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0%</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">         <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(0.5);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">3</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">         <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(0.33);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这种方式可以满足各种场景，如果需要满足圆角，只需要给伪类也加上<code>border-radius</code>即可。</p>
<h3 id="5-4-svg"><a href="#5-4-svg" class="headerlink" title="5.4 svg"></a>5.4 svg</h3><p>上面我们<code>border-image</code>和<code>background-image</code>都可以模拟<code>1px</code>边框，但是使用的都是位图，还需要外部引入。</p>
<p>借助<code>PostCSS</code>的<code>postcss-write-svg</code>我们能直接使用<code>border-image</code>和<code>background-image</code>创建<code>svg</code>的<code>1px</code>边框：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">svg</span> border_1px &#123; </span><br><span class="line">  <span class="selector-tag">height</span>: 2<span class="selector-tag">px</span>; </span><br><span class="line">  @<span class="keyword">rect</span> &#123; </span><br><span class="line">    <span class="selector-tag">fill</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--color</span>, <span class="selector-tag">black</span>); </span><br><span class="line">    <span class="selector-tag">width</span>: 100%; </span><br><span class="line">    <span class="selector-tag">height</span>: 50%; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"><span class="selector-class">.example</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid transparent; <span class="attribute">border-image</span>: <span class="built_in">svg</span>(border_1px param(--color #00b1ff)) <span class="number">2</span> <span class="number">2</span> stretch; &#125;</span><br></pre></td></tr></table></figure>
<p>编译后：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid transparent; <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' height='2px'%3E%3Crect fill='%2300b1ff' width='100%25' height='50%25'/%3E%3C/svg%3E"</span>) <span class="number">2</span> <span class="number">2</span> stretch; &#125;</span><br></pre></td></tr></table></figure>
<p>上面的方案是大漠在他的文章中推荐使用的，基本可以满足所有场景，而且不需要外部引入，这是我个人比较喜欢的一种方案。</p>
<h3 id="5-5-设置viewport"><a href="#5-5-设置viewport" class="headerlink" title="5.5 设置viewport"></a>5.5 设置viewport</h3><p>通过设置缩放，让<code>CSS</code>像素等于真正的物理像素。</p>
<p>例如：当设备像素比为<code>3</code>时，我们将页面缩放<code>1/3</code>倍，这时<code>1px</code>等于一个真正的屏幕像素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="keyword">const</span> viewport = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>);</span><br><span class="line"><span class="keyword">if</span> (!viewport) &#123;</span><br><span class="line">    viewport = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>);</span><br><span class="line">    viewport.setAttribute(<span class="string">'name'</span>, <span class="string">'viewport'</span>);</span><br><span class="line">    <span class="built_in">window</span>.document.head.appendChild(viewport);</span><br><span class="line">&#125;</span><br><span class="line">viewport.setAttribute(<span class="string">'content'</span>, <span class="string">'width=device-width,user-scalable=no,initial-scale='</span> + scale + <span class="string">',maximum-scale='</span> + scale + <span class="string">',minimum-scale='</span> + scale);</span><br></pre></td></tr></table></figure>
<p>实际上，上面这种方案是早先<code>flexible</code>采用的方案。</p>
<p>当然，这样做是要付出代价的，这意味着你页面上所有的布局都要按照物理像素来写。这显然是不现实的，这时，我们可以借助<code>flexible</code>或<code>vw、vh</code>来帮助我们进行适配。</p>
<h2 id="六、移动端适配方案"><a href="#六、移动端适配方案" class="headerlink" title="六、移动端适配方案"></a>六、移动端适配方案</h2><p>尽管我们可以使用设备独立像素来保证各个设备在不同手机上显示的效果类似，但这并不能保证它们显示完全一致，我们需要一种方案来让设计稿得到更完美的适配。</p>
<h3 id="6-1-flexible方案"><a href="#6-1-flexible方案" class="headerlink" title="6.1 flexible方案"></a>6.1 flexible方案</h3><p><code>flexible</code>方案是阿里早期开源的一个移动端适配解决方案，引用<code>flexible</code>后，我们在页面上统一使用<code>rem</code>来布局。</p>
<p>它的核心代码非常简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set 1rem = viewWidth / 10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRemUnit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rem = docEl.clientWidth / <span class="number">10</span></span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">'px'</span></span><br><span class="line">&#125;</span><br><span class="line">setRemUnit();</span><br></pre></td></tr></table></figure>
<p><code>rem</code> 是相对于<code>html</code>节点的<code>font-size</code>来做计算的。</p>
<p>我们通过设置<code>document.documentElement.style.fontSize</code>就可以统一整个页面的布局标准。</p>
<p>上面的代码中，将<code>html</code>节点的<code>font-size</code>设置为页面<code>clientWidth</code>(布局视口)的<code>1/10</code>，即<code>1rem</code>就等于页面布局视口的<code>1/10</code>，这就意味着我们后面使用的<code>rem</code>都是按照页面比例来计算的。</p>
<p>这时，我们只需要将<code>UI</code>出的图转换为<code>rem</code>即可。</p>
<p>以<code>iPhone6</code>为例：布局视口为<code>375px</code>，则<code>1rem = 37.5px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 37.5 = 2rem</code>。</p>
<p>当然，每个布局都要计算非常繁琐，我们可以借助<code>PostCSS</code>的<code>px2rem</code>插件来帮助我们完成这个过程。</p>
<p>下面的代码可以保证在页面大小变化时，布局可以自适应，当触发了<code>window</code>的<code>resize</code>和<code>pageShow</code>事件之后自动调整<code>html</code>的<code>fontSize</code>大小。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// reset rem unit on page resize</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, setRemUnit)<span class="built_in">window</span>.addEventListener(<span class="string">'pageshow'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">      setRemUnit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>由于<code>viewport</code>单位得到众多浏览器的兼容，上面这种方案现在已经被官方弃用：</p>
<blockquote>
<p>lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。</p>
</blockquote>
<p>下面我们来看看现在最流行的<code>vh、vw</code>方案。</p>
<h3 id="6-2-vh、vw方案"><a href="#6-2-vh、vw方案" class="headerlink" title="6.2 vh、vw方案"></a>6.2 vh、vw方案</h3><p><code>vh、vw</code>方案即将视觉视口宽度 <code>window.innerWidth</code>和视觉视口高度 <code>window.innerHeight</code> 等分为 100 份。</p>
<p>上面的<code>flexible</code>方案就是模仿这种方案，因为早些时候<code>vw</code>还没有得到很好的兼容。</p>
<ul>
<li><code>vw(Viewport&#39;s width)</code>：<code>1vw</code>等于视觉视口的<code>1%</code></li>
<li><code>vh(Viewport&#39;s height)</code> :<code>1vh</code> 为视觉视口高度的<code>1%</code></li>
<li><code>vmin</code> :  <code>vw</code> 和 <code>vh</code> 中的较小值</li>
<li><code>vmax</code> : 选取 <code>vw</code> 和 <code>vh</code> 中的较大值</li>
</ul>
<p><img src="https://i.loli.net/2019/05/17/5cddf1f0e18bb53584.png" alt></p>
<p>如果视觉视口为<code>375px</code>，那么<code>1vw = 3.75px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 3.75 = 20vw</code>。</p>
<p>这里的比例关系我们也不用自己换算，我们可以使用<code>PostCSS</code>的 <code>postcss-px-to-viewport</code> 插件帮我们完成这个过程。写代码时，我们只需要根据<code>UI</code>给的设计图写<code>px</code>单位即可。</p>
<p>当然，没有一种方案是十全十美的，<code>vw</code>同样有一定的缺陷：</p>
<ul>
<li><code>px</code>转换成<code>vw</code>不一定能完全整除，因此有一定的像素差。</li>
<li>比如当容器使用<code>vw</code>，<code>margin</code>采用<code>px</code>时，很容易造成整体宽度超过<code>100vw</code>，从而影响布局效果。当然我们也是可以避免的，例如使用<code>padding</code>代替<code>margin</code>，结合<code>calc()</code>函数使用等等…</li>
</ul>
<h2 id="七、适配iPhoneX"><a href="#七、适配iPhoneX" class="headerlink" title="七、适配iPhoneX"></a>七、适配iPhoneX</h2><p><code>iPhoneX</code>的出现将手机的颜值带上了一个新的高度，它取消了物理按键，改成了底部的小黑条，但是这样的改动给开发者适配移动端又增加了难度。</p>
<h3 id="7-1-安全区域"><a href="#7-1-安全区域" class="headerlink" title="7.1 安全区域"></a>7.1 安全区域</h3><p>在<code>iPhoneX</code>发布后，许多厂商相继推出了具有边缘屏幕的手机。</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf1e78a7c870328.png" alt></p>
<p>这些手机和普通手机在外观上无外乎做了三个改动：圆角（<code>corners</code>）、刘海（<code>sensor housing</code>）和小黑条（<code>Home Indicator</code>）。为了适配这些手机，安全区域这个概念变诞生了：安全区域就是一个不受上面三个效果的可视窗口范围。</p>
<p>为了保证页面的显示效果，我们必须把页面限制在安全范围内，但是不影响整体效果。</p>
<h3 id="7-2-viewport-fit"><a href="#7-2-viewport-fit" class="headerlink" title="7.2 viewport-fit"></a>7.2 viewport-fit</h3><p><code>viewport-fit</code>是专门为了适配<code>iPhoneX</code>而诞生的一个属性，它用于限制网页如何在安全区域内进行展示。</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf1a74a74578018.png" alt></p>
<p><code>contain</code>: 可视窗口完全包含网页内容</p>
<p><code>cover</code>：网页内容完全覆盖可视窗口</p>
<p>默认情况下或者设置为<code>auto</code>和<code>contain</code>效果相同。</p>
<h3 id="7-3-env、constant"><a href="#7-3-env、constant" class="headerlink" title="7.3 env、constant"></a>7.3 env、constant</h3><p><img src="https://i.loli.net/2019/05/17/5cddf1b63010c69640.png" alt></p>
<p>我们需要将顶部和底部合理的摆放在安全区域内，<code>iOS11</code>新增了两个<code>CSS</code>函数<code>env、constant</code>，用于设定安全区域与边界的距离。</p>
<p>函数内部可以是四个常量：</p>
<ul>
<li><code>safe-area-inset-left</code>：安全区域距离左边边界距离</li>
<li><code>safe-area-inset-right</code>：安全区域距离右边边界距离</li>
<li><code>safe-area-inset-top</code>：安全区域距离顶部边界距离</li>
<li><code>safe-area-inset-bottom</code>：安全区域距离底部边界距离</li>
</ul>
<p>注意：我们必须指定<code>viweport-fit</code>后才能使用这两个函数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"viewport-fit=cover"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>constant</code>在<code>iOS &lt; 11.2</code>的版本中生效，<code>env</code>在<code>iOS &gt;= 11.2</code>的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用底部固定导航栏时，我们要为他们设置<code>padding</code>值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八、横屏适配"><a href="#八、横屏适配" class="headerlink" title="八、横屏适配"></a>八、横屏适配</h2><p><img src="https://i.loli.net/2019/05/17/5cddf20178d8c32612.png" alt></p>
<p>很多视口我们要对横屏和竖屏显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式：</p>
<h3 id="8-1-JavaScript检测横屏"><a href="#8-1-JavaScript检测横屏" class="headerlink" title="8.1 JavaScript检测横屏"></a>8.1 JavaScript检测横屏</h3><p><code>window.orientation</code>:获取屏幕旋转方向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.orientation === <span class="number">180</span> || <span class="built_in">window</span>.orientation === <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// 正常方向或屏幕旋转180度</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'竖屏'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.orientation === <span class="number">90</span> || <span class="built_in">window</span>.orientation === <span class="number">-90</span> )&#123; </span><br><span class="line">       <span class="comment">// 屏幕顺时钟旋转90度或屏幕逆时针旋转90度</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'横屏'</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="8-2-CSS检测横屏"><a href="#8-2-CSS检测横屏" class="headerlink" title="8.2 CSS检测横屏"></a>8.2 CSS检测横屏</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@media screen and (orientation: portrait) &#123;</span><br><span class="line">  <span class="comment">/*竖屏...*/</span></span><br><span class="line">&#125; </span><br><span class="line">@media screen and (orientation: landscape) &#123;</span><br><span class="line">  <span class="comment">/*横屏...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="九、图片模糊问题"><a href="#九、图片模糊问题" class="headerlink" title="九、图片模糊问题"></a>九、图片模糊问题</h2><h3 id="9-1-产生原因"><a href="#9-1-产生原因" class="headerlink" title="9.1 产生原因"></a>9.1 产生原因</h3><p>我们平时使用的图片大多数都属于位图（<code>png、jpg...</code>），位图由一个个像素点构成的，每个像素都具有特定的位置和颜色值：</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf1ea88e2190952.png" alt></p>
<p>理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果。</p>
<p>而在<code>dpr &gt; 1</code>的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确的分配上对应位图像素的颜色，只能取近似值，所以相同的图片在<code>dpr &gt; 1</code>的屏幕上就会模糊:</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf1ebd33ce27972.jpg" alt></p>
<h3 id="9-2-解决方案"><a href="#9-2-解决方案" class="headerlink" title="9.2 解决方案"></a>9.2 解决方案</h3><p>为了保证图片质量，我们应该尽可能让一个屏幕像素来渲染一个图片像素，所以，针对不同<code>DPR</code>的屏幕，我们需要展示不同分辨率的图片。</p>
<p>如：在<code>dpr=2</code>的屏幕上展示两倍图<code>(@2x)</code>，在<code>dpr=3</code>的屏幕上展示三倍图<code>(@3x)</code>。</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf1ee82d2b57483.png" alt></p>
<h3 id="9-3-media查询"><a href="#9-3-media查询" class="headerlink" title="9.3 media查询"></a>9.3 media查询</h3><p>使用<code>media</code>查询判断不同的设备像素比来显示不同精度的图片：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span>&#123;</span><br><span class="line">     <span class="attribute">background-image</span>: <span class="built_in">url</span>(conardLi_1x.png);</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.avatar</span>&#123;</span><br><span class="line">         <span class="attribute">background-image</span>: <span class="built_in">url</span>(conardLi_2x.png);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">3</span>)&#123;</span><br><span class="line">     <span class="selector-class">.avatar</span>&#123;</span><br><span class="line">         <span class="attribute">background-image</span>: <span class="built_in">url</span>(conardLi_3x.png);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只适用于背景图</p>
</blockquote>
<h3 id="9-4-image-set"><a href="#9-4-image-set" class="headerlink" title="9.4 image-set"></a>9.4 image-set</h3><p>使用<code>image-set</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">-webkit-image-set</span>( <span class="string">"conardLi_1x.png"</span> 1x, <span class="string">"conardLi_2x.png"</span> 2x );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只适用于背景图</p>
</blockquote>
<h3 id="9-5-srcset"><a href="#9-5-srcset" class="headerlink" title="9.5 srcset"></a>9.5 srcset</h3><p>使用<code>img</code>标签的<code>srcset</code>属性，浏览器会自动根据像素密度匹配最佳显示图片：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"conardLi_1x.png"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">srcset</span>=<span class="string">" conardLi_2x.png 2x, conardLi_3x.png 3x"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="9-6-JavaScript拼接图片url"><a href="#9-6-JavaScript拼接图片url" class="headerlink" title="9.6 JavaScript拼接图片url"></a>9.6 JavaScript拼接图片url</h3><p>使用<code>window.devicePixelRatio</code>获取设备像素比，遍历所有图片，替换图片地址：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="keyword">const</span> images =  <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>);</span><br><span class="line">images.forEach(<span class="function">(<span class="params">img</span>)=&gt;</span>&#123;</span><br><span class="line">  img.src.replace(<span class="string">"."</span>, <span class="string">`@<span class="subst">$&#123;dpr&#125;</span>x.`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="9-7-使用svg"><a href="#9-7-使用svg" class="headerlink" title="9.7 使用svg"></a>9.7 使用svg</h3><p><code>SVG</code>的全称是可缩放矢量图（<code>Scalable Vector Graphics</code>）。不同于位图的基于像素，<code>SVG</code> 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf1f59b24a71558.png" alt></p>
<p>除了我们手动在代码中绘制<code>svg</code>，我们还可以像使用位图一样使用<code>svg</code>图片：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"conardLi.svg"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">"data:image/svg+xml;base64,[data]"</span>&gt;</span><br><span class="line"></span><br><span class="line">.avatar &#123;</span><br><span class="line">  background: url(conardLi.svg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.w3cplus.com/css/vw-for-layout.html" target="_blank" rel="noopener">https://www.w3cplus.com/css/vw-for-layout.html</a></li>
<li><a href="https://aotu.io/notes/2017/11/27/iphonex/index.html" target="_blank" rel="noopener">https://aotu.io/notes/2017/11/27/iphonex/index.html</a></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p>
<ul>
<li>理清移动端适配常用概念</li>
<li>理解移动端适配问题产生的原理，至少掌握一种解决方案</li>
</ul>
<p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端适配总结（一）原理篇</title>
    <url>/2019/05/22/2019-05-22-Programing-JavaScript-moblie-develop-1/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>移动端适配，是我们在开发中经常会遇到的，这里面可能会遇到非常多的问题：</p>
<ul>
<li><code>1px</code>问题</li>
<li><code>UI</code>图完美适配方案</li>
<li><code>iPhoneX</code>适配方案</li>
<li>横屏适配</li>
<li>高清屏图片模糊问题</li>
<li>…</li>
</ul>
<p>上面这些问题可能我们在开发中已经知道如何解决，但是问题产生的原理，以及解决方案的原理可能会模糊不清。在解决这些问题的过程中，我们往往会遇到非常多的概念：像素、分辨率、<code>PPI</code>、<code>DPI</code>、<code>DP</code>、<code>DIP</code>、<code>DPR</code>、视口等等，你真的能分清这些概念的意义吗？</p>
<p>本文将从移动端适配的基础概念出发，探究移动端适配各种问题的解决方案和实现原理。</p>
<h2 id="一、英寸"><a href="#一、英寸" class="headerlink" title="一、英寸"></a>一、英寸</h2><p>一般用英寸描述屏幕的物理大小，如电脑显示器的<code>17</code>、<code>22</code>，手机显示器的<code>4.8</code>、<code>5.7</code>等使用的单位都是英寸。</p>
<p>需要注意，上面的尺寸都是屏幕对角线的长度：</p>
<p><img src="https://i.loli.net/2019/05/17/5cddefa632f3247082.png" alt></p>
<p>英寸(<code>inch</code>,缩写为<code>in</code>)在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。</p>
<p>英寸和厘米的换算：<code>1英寸 = 2.54 厘米</code></p>
<h2 id="二、分辨率"><a href="#二、分辨率" class="headerlink" title="二、分辨率"></a>二、分辨率</h2><h3 id="2-1-像素"><a href="#2-1-像素" class="headerlink" title="2.1 像素"></a>2.1 像素</h3><p>像素即一个小方块，它具有特定的位置和颜色。</p>
<p>图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。</p>
<p>像素可以作为图片或电子屏幕的最小组成单位。</p>
<p>下面我们使用<code>sketch</code>打开一张图片：</p>
<p><img src="https://i.loli.net/2019/05/17/5cddefd18987943848.png" alt></p>
<p>将这些图片放大即可看到这些像素点：</p>
<p><img src="https://i.loli.net/2019/05/17/5cddefb8d84ab76156.png" alt></p>
<a id="more"></a>
<p>通常我们所说的分辨率有两种，屏幕分辨率和图像分辨率。</p>
<h3 id="2-2-屏幕分辨率"><a href="#2-2-屏幕分辨率" class="headerlink" title="2.2 屏幕分辨率"></a>2.2 屏幕分辨率</h3><p>屏幕分辨率指一个屏幕具体由多少个像素点组成。</p>
<p>下面是<code>apple</code>的官网上对手机分辨率的描述：</p>
<p><img src="https://i.loli.net/2019/05/17/5cddefb520e2929179.png" alt></p>
<p><code>iPhone XS Max</code> 和 <code>iPhone SE</code>的分辨率分别为<code>2688 x 1242</code>和<code>1136 x 640</code>。这表示手机分别在垂直和水平上所具有的像素点数。</p>
<p>当然分辨率高不代表屏幕就清晰，屏幕的清晰程度还与尺寸有关。</p>
<h3 id="2-3-图像分辨率"><a href="#2-3-图像分辨率" class="headerlink" title="2.3 图像分辨率"></a>2.3 图像分辨率</h3><p>我们通常说的<code>图片分辨率</code>其实是指图片含有的<code>像素数</code>，比如一张图片的分辨率为<code>800 x 400</code>。这表示图片分别在垂直和水平上所具有的像素点数为<code>800</code>和<code>400</code>。</p>
<p>同一尺寸的图片，分辨率越高，图片越清晰。</p>
<p><img src="https://i.loli.net/2019/05/17/5cddefb19aeaa99756.png" alt></p>
<h3 id="2-4-PPI"><a href="#2-4-PPI" class="headerlink" title="2.4 PPI"></a>2.4 PPI</h3><p><code>PPI(Pixel Per Inch)</code>：每英寸包括的像素数。</p>
<p><code>PPI</code>可以用于描述屏幕的清晰度以及一张图片的质量。</p>
<p>使用<code>PPI</code>描述图片时，<code>PPI</code>越高，图片质量越高，使用<code>PPI</code>描述屏幕时，<code>PPI</code>越高，屏幕越清晰。</p>
<p>在上面描述手机分辨率的图片中，我们可以看到：<code>iPhone XS Max</code> 和 <code>iPhone SE</code>的<code>PPI</code>分别为<code>458</code>和<code>326</code>，这足以证明前者的屏幕更清晰。</p>
<p>由于手机尺寸为手机对角线的长度，我们通常使用如下的方法计算<code>PPI</code>:</p>
<script type="math/tex; mode=display">\frac{\sqrt{水平像素点数^2+垂直像素点数^2}}{尺寸}</script><p><code>iPhone 6</code>的<code>PPI</code>为 $ \frac{\sqrt{1334^2+750^2}}{4.7}=325.6$，那它每英寸约含有<code>326</code>个物理像素点。</p>
<h3 id="2-5-DPI"><a href="#2-5-DPI" class="headerlink" title="2.5 DPI"></a>2.5 DPI</h3><p><code>DPI(Dot Per Inch)</code>：即每英寸包括的点数。</p>
<p>这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点也可以是打印机的墨点。</p>
<p>平时你可能会看到使用<code>DPI</code>来描述图片和屏幕，这时的<code>DPI</code>应该和<code>PPI</code>是等价的，<code>DPI</code>最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。</p>
<p>一张图片在屏幕上显示时，它的像素点数是规则排列的，每个像素点都有特定的位置和颜色。</p>
<p>当使用打印机进行打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是<code>DPI</code>所描述的：打印点的密度。</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf09abd86b34406.png" alt></p>
<p>在上面的图像中我们可以清晰的看到，打印机是如何使用墨点来打印一张图像。</p>
<p>所以，打印机的<code>DPI</code>越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。</p>
<h2 id="三、设备独立像素"><a href="#三、设备独立像素" class="headerlink" title="三、设备独立像素"></a>三、设备独立像素</h2><p>实际上，上面我们描述的像素都是<code>物理像素</code>，即设备上真实的物理单元。</p>
<p>下面我们来看看<code>设备独立像素</code>究竟是如何产生的：</p>
<p>智能手机发展非常之快，在几年之前，我们还用着分辨率非常低的手机，比如下面左侧的白色手机，它的分辨率是<code>320x480</code>，我们可以在上面浏览正常的文字、图片等等。</p>
<p>但是，随着科技的发展，低分辨率的手机已经不能满足我们的需求了。很快，更高分辨率的屏幕诞生了，比如下面的黑色手机，它的分辨率是<code>640x940</code>，正好是白色手机的两倍。</p>
<p>理论上来讲，在白色手机上相同大小的图片和文字，在黑色手机上会被缩放一倍，因为它的分辨率提高了一倍。这样，岂不是后面出现更高分辨率的手机，页面元素会变得越来越小吗？</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf09f48f0a33102.png" alt></p>
<p>然而，事实并不是这样的，我们现在使用的智能手机，不管分辨率多高，他们所展示的界面比例都是基本类似的。乔布斯在<code>iPhone4</code>的发布会上首次提出了<code>Retina Display</code>(视网膜屏幕)的概念，它正是解决了上面的问题，这也使它成为一款跨时代的手机。</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf0897062b36552.png" alt></p>
<p>在<code>iPhone4</code>使用的视网膜屏幕中，把<code>2x2</code>个像素当<code>1</code>个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变。</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf09af318944420.png" alt></p>
<p>如果黑色手机使用了视网膜屏幕的技术，那么显示结果应该是下面的情况，比如列表的宽度为<code>300</code>个像素，那么在一条水平线上，白色手机会用<code>300</code>个物理像素去渲染它，而黑色手机实际上会用<code>600</code>个物理像素去渲染它。</p>
<p>我们必须用一种单位来同时告诉不同分辨率的手机，它们在界面上显示元素的大小是多少，这个单位就是设备独立像素(<code>Device Independent Pixels</code>)简称<code>DIP</code>或<code>DP</code>。上面我们说，列表的宽度为<code>300</code>个像素，实际上我们可以说：列表的宽度为<code>300</code>个设备独立像素。</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf08cd614e72602.png" alt></p>
<p>打开<code>chrome</code>的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如<code>iPhone X</code>显示的尺寸是<code>375x812</code>，实际<code>iPhone X</code>的分辨率会比这高很多，这里显示的就是设备独立像素。</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf0955ea4541111.png" alt></p>
<h3 id="3-1-设备像素比"><a href="#3-1-设备像素比" class="headerlink" title="3.1 设备像素比"></a>3.1 设备像素比</h3><p>设备像素比<code>device pixel ratio</code>简称<code>dpr</code>，即物理像素和设备独立像素的比值。</p>
<p>在<code>web</code>中，浏览器为我们提供了<code>window.devicePixelRatio</code>来帮助我们获取<code>dpr</code>。</p>
<p>在<code>css</code>中，可以使用媒体查询<code>min-device-pixel-ratio</code>，区分<code>dpr</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> (-webkit-min-device-pixel-ratio: <span class="number">2</span>), (min-device-pixel-ratio: <span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>React Native</code>中，我们也可以使用<code>PixelRatio.get()</code>来获取<code>DPR</code>。</p>
<p>当然，上面的规则也有例外，<code>iPhone 6、7、8 Plus</code>的实际物理像素是<code>1080 x 1920</code>，在开发者工具中我们可以看到：它的设备独立像素是<code>414 x 736</code>，设备像素比为<code>3</code>，设备独立像素和设备像素比的乘积并不等于<code>1080 x 1920</code>，而是等于<code>1242 x 2208</code>。</p>
<p>实际上，手机会自动把<code>1242 x 2208</code>个像素点塞进<code>1080 * 1920</code>个物理像素点来渲染，我们不用关心这个过程，而<code>1242 x 2208</code>被称为屏幕的<code>设计像素</code>。我们开发过程中也是以这个<code>设计像素</code>为准。</p>
<p>实际上，从苹果提出视网膜屏幕开始，才出现设备像素比这个概念，因为在这之前，移动设备都是直接使用物理像素来进行展示。</p>
<p>紧接着，<code>Android</code>同样使用了其他的技术方案来实现<code>DPR</code>大于<code>1</code>的屏幕，不过原理是类似的。由于<code>Android</code>屏幕尺寸非常多、分辨率高低跨度非常大，不像苹果只有它自己的几款固定设备、尺寸。所以，为了保证各种设备的显示效果，<code>Android</code>按照设备的像素密度将设备分成了几个区间：</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf152a707694983.png" alt></p>
<p>当然，所有的<code>Android</code>设备不一定严格按照上面的分辨率，每个类型可能对应几种不同分辨率，所以，每个<code>Android</code>手机都能根据给定的区间范围，确定自己的<code>DPR</code>，从而拥有类似的显示。当然，仅仅是类似，由于各个设备的尺寸、分辨率上的差异，设备独立像素也不会完全相等，所以各种<code>Android</code>设备仍然不能做到在展示上完全相等。</p>
<h3 id="3-2-移动端开发"><a href="#3-2-移动端开发" class="headerlink" title="3.2 移动端开发"></a>3.2 移动端开发</h3><p>在<code>iOS</code>、<code>Android</code>和<code>React Native</code>开发中样式单位其实都使用的是设备独立像素。</p>
<p><code>iOS</code>的尺寸单位为<code>pt</code>，<code>Android</code>的尺寸单位为<code>dp</code>，<code>React Native</code>中没有指定明确的单位，它们其实都是设备独立像素<code>dp</code>。</p>
<p>在使用<code>React Native</code>开发<code>App</code>时，<code>UI</code>给我们的原型图一般是基于<code>iphone6</code>的像素给定的。</p>
<p>为了适配所有机型，我们在写样式时需要把物理像素转换为设备独立像素：例如：如果给定一个元素的高度为<code>200px</code>(这里的<code>px</code>指物理像素，非<code>CSS</code>像素)，<code>iphone6</code>的设备像素比为<code>2</code>，我们给定的<code>height</code>应为<code>200px/2=100dp</code>。</p>
<p>当然，最好的是，你可以和设计沟通好，所有的<code>UI</code>图都按照设备独立像素来出。</p>
<p>我们还可以在代码(<code>React Native</code>)中进行<code>px</code>和<code>dp</code>的转换：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PixelRatio &#125; <span class="keyword">from</span> <span class="string">"react-native"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dpr = PixelRatio.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * px转换为dp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pxConvertTodp</span>(<span class="params">px</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> px / dpr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp转换为px</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dpConvertTopx</span>(<span class="params">dp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PixelRatio.getPixelSizeForLayoutSize(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-WEB-端开发"><a href="#3-3-WEB-端开发" class="headerlink" title="3.3 WEB 端开发"></a>3.3 WEB 端开发</h3><p>在写<code>CSS</code>时，我们用到最多的单位是<code>px</code>，即<code>CSS像素</code>，当页面缩放比例为<code>100%</code>时，一个<code>CSS像素</code>等于一个设备独立像素。</p>
<p>但是<code>CSS像素</code>是很容易被改变的，当用户对浏览器进行了放大，<code>CSS像素</code>会被放大，这时一个<code>CSS像素</code>会跨越更多的物理像素。</p>
<p><code>页面的缩放系数 = CSS像素 / 设备独立像素</code>。</p>
<h3 id="3-4-关于屏幕"><a href="#3-4-关于屏幕" class="headerlink" title="3.4 关于屏幕"></a>3.4 关于屏幕</h3><p>这里多说两句<code>Retina</code>屏幕，因为我在很多文章中看到对<code>Retina</code>屏幕的误解。</p>
<p><code>Retina</code>屏幕只是苹果提出的一个营销术语：</p>
<blockquote>
<p>在普通的使用距离下，人的肉眼无法分辨单个的像素点。</p>
</blockquote>
<p>为什么强调<code>普通的使用距离下</code>呢？我们来看一下它的计算公式：</p>
<script type="math/tex; mode=display">a=2arctan(h/2d)</script><p><code>a</code>代表人眼视角，<code>h</code>代表像素间距，<code>d</code>代表肉眼与屏幕的距离，符合以上条件的屏幕可以使肉眼看不见单个物理像素点。</p>
<p>它不能单纯的表达分辨率和<code>PPI</code>，只能一种表达视觉效果。</p>
<p>让多个物理像素渲染一个独立像素只是<code>Retina</code>屏幕为了达到效果而使用的一种技术。而不是所有<code>DPR &gt; 1</code>的屏幕就是<code>Retina</code>屏幕。</p>
<p>比如：给你一块超大尺寸的屏幕，即使它的<code>PPI</code>很高，<code>DPR</code>也很高，在近距离你也能看清它的像素点，这就不算<code>Retina</code>屏幕。</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf1510035720584.jpg" alt></p>
<p>我们经常见到用<code>K</code>和<code>P</code>这个单位来形容屏幕：</p>
<p><code>P</code>代表的就是屏幕纵向的像素个数，<code>1080P</code>即纵向有<code>1080</code>个像素，分辨率为<code>1920X1080</code>的屏幕就属于<code>1080P</code>屏幕。</p>
<p>我们平时所说的高清屏其实就是屏幕的物理分辨率达到或超过<code>1920X1080</code>的屏幕。</p>
<p><code>K</code>代表屏幕横向有几个<code>1024</code>个像素，一般来讲横向像素超过<code>2048</code>就属于<code>2K</code>屏，横向像素超过<code>4096</code>就属于<code>4K</code>屏。</p>
<h2 id="四、视口"><a href="#四、视口" class="headerlink" title="四、视口"></a>四、视口</h2><p>视口(<code>viewport</code>)代表当前可见的计算机图形区域。在<code>Web</code>浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的<code>UI</code>， 菜单栏等——即指你正在浏览的文档的那一部分。</p>
<p>一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。</p>
<h3 id="4-1-布局视口"><a href="#4-1-布局视口" class="headerlink" title="4.1 布局视口"></a>4.1 布局视口</h3><p><img src="https://i.loli.net/2019/05/17/5cddf1581489419627.png" alt></p>
<p>布局视口(<code>layout viewport</code>)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。</p>
<p>所以，布局视口是网页布局的基准窗口，在<code>PC</code>浏览器上，布局视口就等于当前浏览器的窗口大小（不包括<code>borders</code> 、<code>margins</code>、滚动条）。</p>
<p>在移动端，布局视口被赋予一个默认值，大部分为<code>980px</code>，这保证<code>PC</code>的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。</p>
<p>我们可以通过调用<code>document.documentElement.clientWidth / clientHeight</code>来获取布局视口大小。</p>
<h3 id="4-2-视觉视口"><a href="#4-2-视觉视口" class="headerlink" title="4.2 视觉视口"></a>4.2 视觉视口</h3><p><img src="https://i.loli.net/2019/05/17/5cddf1554295a45164.png" alt></p>
<p>视觉视口(<code>visual viewport</code>)：用户通过屏幕真实看到的区域。</p>
<p>视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。</p>
<p>当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小。</p>
<p>例如：用户将浏览器窗口放大了<code>200%</code>，这时浏览器窗口中的<code>CSS像素</code>会随着视觉视口的放大而放大，这时一个<code>CSS</code>像素会跨越更多的物理像素。</p>
<p>所以，布局视口会限制你的<code>CSS</code>布局而视觉视口决定用户具体能看到什么。</p>
<p>我们可以通过调用<code>window.innerWidth / innerHeight</code>来获取视觉视口大小。</p>
<h3 id="4-3-理想视口"><a href="#4-3-理想视口" class="headerlink" title="4.3 理想视口"></a>4.3 理想视口</h3><p><img src="https://i.loli.net/2019/05/17/5cddf0955ea4541111.png" alt></p>
<p>布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(<code>ideal viewport</code>)就诞生了：网站页面在移动端展示的理想大小。</p>
<p>如上图，我们在描述设备独立像素时曾使用过这张图，在浏览器调试移动端时页面上给定的像素大小就是理想视口大小，它的单位正是设备独立像素。</p>
<p>上面在介绍<code>CSS像素时</code>曾经提到<code>页面的缩放系数 = CSS像素 / 设备独立像素</code>，实际上说<code>页面的缩放系数 = 理想视口宽度 / 视觉视口宽度</code>更为准确。</p>
<p>所以，当页面缩放比例为<code>100%</code>时，<code>CSS像素 = 设备独立像素</code>，<code>理想视口 = 视觉视口</code>。</p>
<p>我们可以通过调用<code>screen.width / height</code>来获取理想视口大小。</p>
<h3 id="4-4-Meta-viewport"><a href="#4-4-Meta-viewport" class="headerlink" title="4.4 Meta viewport"></a>4.4 Meta viewport</h3><p><code>&lt;meta&gt;</code> 元素表示那些不能由其它<code>HTML</code>元相关元素之一表示的任何元数据信息，它可以告诉浏览器如何解析页面。</p>
<p>我们可以借助<code>&lt;meta&gt;</code>元素的<code>viewport</code>来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面是<code>viewport</code>的一个配置，我们来看看它们的具体含义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>Value</code></th>
<th>可能值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>width</code></td>
<td>正整数或<code>device-width</code></td>
<td>以<code>pixels</code>（像素）为单位， 定义布局视口的宽度。</td>
</tr>
<tr>
<td><code>height</code></td>
<td>正整数或<code>device-height</code></td>
<td>以<code>pixels</code>（像素）为单位， 定义布局视口的高度。</td>
</tr>
<tr>
<td><code>initial-scale</code></td>
<td><code>0.0 - 10.0</code></td>
<td>定义页面初始缩放比率。</td>
</tr>
<tr>
<td><code>minimum-scale</code></td>
<td><code>0.0 - 10.0</code></td>
<td>定义缩放的最小值；必须小于或等于<code>maximum-scale</code>的值。</td>
</tr>
<tr>
<td><code>maximum-scale</code></td>
<td><code>0.0 - 10.0</code></td>
<td>定义缩放的最大值；必须大于或等于<code>minimum-scale</code>的值。</td>
</tr>
<tr>
<td><code>user-scalable</code></td>
<td>一个布尔值（<code>yes</code>或者<code>no</code>）</td>
<td>如果设置为 <code>no</code>，用户将不能放大或缩小网页。默认值为 yes。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-5-移动端适配"><a href="#4-5-移动端适配" class="headerlink" title="4.5 移动端适配"></a>4.5 移动端适配</h3><p>为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。</p>
<p><code>device-width</code>就等于理想视口的宽度，所以设置<code>width=device-width</code>就相当于让布局视口等于理想视口。</p>
<p>由于<code>initial-scale = 理想视口宽度 / 视觉视口宽度</code>，所以我们设置<code>initial-scale=1;</code>就相当于让视觉视口等于理想视口。</p>
<p>这时，1 个<code>CSS</code>像素就等于 1 个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。</p>
<h3 id="4-6-缩放"><a href="#4-6-缩放" class="headerlink" title="4.6 缩放"></a>4.6 缩放</h3><p>上面提到<code>width</code>可以决定布局视口的宽度，实际上它并不是布局视口的唯一决定性因素，设置<code>initial-scale</code>也有肯能影响到布局视口，因为布局视口宽度取的是<code>width</code>和视觉视口宽度的最大值。</p>
<p>例如：若手机的理想视口宽度为<code>400px</code>，设置<code>width=device-width</code>，<code>initial-scale=2</code>，此时<code>视觉视口宽度 = 理想视口宽度 / initial-scale</code>即<code>200px</code>，布局视口取两者最大值即<code>device-width</code> <code>400px</code>。</p>
<p>若设置<code>width=device-width</code>，<code>initial-scale=0.5</code>，此时<code>视觉视口宽度 = 理想视口宽度 / initial-scale</code>即<code>800px</code>，布局视口取两者最大值即<code>800px</code>。</p>
<h3 id="4-7-获取浏览器大小"><a href="#4-7-获取浏览器大小" class="headerlink" title="4.7 获取浏览器大小"></a>4.7 获取浏览器大小</h3><p>浏览器为我们提供的获取窗口大小的<code>API</code>有很多，下面我们再来对比一下：</p>
<p><img src="https://i.loli.net/2019/05/17/5cddf1b5bc92295065.png" alt></p>
<ul>
<li><code>window.innerHeight</code>：获取浏览器视觉视口高度（包括垂直滚动条）。</li>
<li><code>window.outerHeight</code>：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。</li>
<li><code>window.screen.Height</code>：获取获屏幕取理想视口高度，这个数值是固定的，<code>设备的分辨率/设备像素比</code></li>
<li><code>window.screen.availHeight</code>：浏览器窗口可用的高度。</li>
<li><code>document.documentElement.clientHeight</code>：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。</li>
<li><code>document.documentElement.offsetHeight</code>：包括内边距、滚动条、边框和外边距。</li>
<li><code>document.documentElement.scrollHeight</code>：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与<code>clientHeight</code>相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。</li>
</ul>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>用JS开发桌面应用（五）终篇</title>
    <url>/2019/05/17/2019-05-17-Programing-JavaScript-use-js-develop-desk-app-5/</url>
    <content><![CDATA[<h2 id="十一、扩展能力"><a href="#十一、扩展能力" class="headerlink" title="十一、扩展能力"></a>十一、扩展能力</h2><p><img src="http://www.conardli.top/img/electron/el_4_iot.jpg" alt></p>
<p>在很多情况下，你的应用程序要和外部设备进行交互，一般情况下厂商会为你提供硬件设备的开发包，这些开发包基本上都是通过<code>C++</code> 编写，在使用<code>electron</code>开发的情况下，我们并不具备直接调用<code>C++</code>代码的能力，我们可以利用<code>node-ffi</code>来实现这一功能。</p>
<p><code>node-ffi</code>提供了一组强大的工具，用于在<code>Node.js</code>环境中使用纯<code>JavaScript</code>调用动态链接库接口。它可以用来为库构建接口绑定，而不需要使用任何<code>C++</code>代码。</p>
<blockquote>
<p>注意<code>node-ffi</code>并不能直接调用<code>C++</code>代码，你需要将<code>C++</code>代码编译为动态链接库：在 <code>Windows</code>下是 <code>Dll</code> ，在 <code>Mac OS</code>下是 <code>dylib</code> <code>，Linux</code> 是 <code>so</code> 。</p>
<p><code>node-ffi</code> 加载 <code>Library</code>是有限制的，只能处理 <code>C</code>风格的 <code>Library</code>。 </p>
</blockquote>
<p>下面是一个简单的实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ffi = <span class="built_in">require</span>(<span class="string">'ffi'</span>);</span><br><span class="line"><span class="keyword">const</span> ref = <span class="built_in">require</span>(<span class="string">'ref'</span>);</span><br><span class="line"><span class="keyword">const</span> SHORT_CODE = ref.refType(<span class="string">'short'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DLL = <span class="keyword">new</span> ffi.Library(<span class="string">'test.dll'</span>, &#123;</span><br><span class="line">    Test_CPP_Method: [<span class="string">'int'</span>, [<span class="string">'string'</span>,SHORT_CODE]], </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">testCppMethod(str: <span class="built_in">String</span>, <span class="attr">num</span>: number): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result: any = DLL.Test_CPP_Method(str, num);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'调用失败～'</span>,error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.testCppMethod(<span class="string">'ConardLi'</span>,<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>上面的代码中，我们用<code>ffi</code>包装<code>C++</code>接口生成的动态链接库<code>test.dll</code>，并使用<code>ref</code>进行一些类型映射。</p>
<p>使用<code>JavaScript</code>调用这些映射方法时，推荐使用<code>TypeScript</code>来约定参数类型，因为弱类型的<code>JavaScript</code>在调用强类型语言的接口时可能会带来意想不到的风险。</p>
<p>借助这一能力，前端开发工程师也可以在<code>IOT</code>领域一展身手了😎～</p>
<h2 id="十二、环境选择"><a href="#十二、环境选择" class="headerlink" title="十二、环境选择"></a>十二、环境选择</h2><p>一般情况下，我们的应用程序可能运行在多套环境下（<code>production</code>、<code>beta</code>、<code>uat</code>、<code>moke</code>、<code>development</code>…），不同的开发环境可能对应不同的后端接口或者其他配置，我们可以在客户端程序中内置一个简单的环境选择功能来帮助我们更高效的开发。</p>
<p><img src="http://www.conardli.top/img/electron/el_14_env.png" alt></p>
<p>具体策略如下：</p>
<p><img src="http://www.conardli.top/img/electron/el_15_env.png" alt></p>
<ul>
<li>在开发环境中，我们直接进入环境选择页面，读取到选择的环境后进行响应的重定向操作</li>
<li>在菜单保留环境选择入口，以便在开发过程中切换</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> envList = [<span class="string">"moke"</span>, <span class="string">"beta"</span>, <span class="string">"development"</span>, <span class="string">"production"</span>];</span><br><span class="line">exports.envList = envList;</span><br><span class="line"><span class="keyword">const</span> urlBeta = <span class="string">'https://wwww.xxx-beta.com'</span>;</span><br><span class="line"><span class="keyword">const</span> urlDev = <span class="string">'https://wwww.xxx-dev.com'</span>;</span><br><span class="line"><span class="keyword">const</span> urlProp = <span class="string">'https://wwww.xxx-prop.com'</span>;</span><br><span class="line"><span class="keyword">const</span> urlMoke = <span class="string">'https://wwww.xxx-moke.com'</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(path.resolve(global.__dirname, <span class="string">'package.json'</span>));</span><br><span class="line"><span class="keyword">const</span> build = pkg[<span class="string">'build-config'</span>];</span><br><span class="line">exports.handleEnv = &#123;</span><br><span class="line">  build,</span><br><span class="line">  currentEnv: <span class="string">'moke'</span>,</span><br><span class="line">  setEnv: <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentEnv = env</span><br><span class="line">  &#125;,</span><br><span class="line">  getUrl: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'env:'</span>, build.env);</span><br><span class="line">    <span class="keyword">if</span> (build.env === <span class="string">'production'</span> || <span class="keyword">this</span>.currentEnv === <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlProp;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.currentEnv === <span class="string">'moke'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlMoke;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.currentEnv === <span class="string">'development'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlDev;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.currentEnv === <span class="string">"beta"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlBeta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isDebugger: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build.env === <span class="string">'development'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十三、打包"><a href="#十三、打包" class="headerlink" title="十三、打包"></a>十三、打包</h2><p>最后也是最重要的一步，将写好的代码打包成可运行的<code>.app</code>或<code>.exe</code>可执行文件。</p>
<p>这里我把打包氛围两部分来做，渲染进程打包和主进程打包。</p>
<h3 id="13-1-渲染进程打包和升级"><a href="#13-1-渲染进程打包和升级" class="headerlink" title="13.1 渲染进程打包和升级"></a>13.1 渲染进程打包和升级</h3><p>一般情况下，我们的大部分业务逻辑代码是在渲染进程完成的，在大部分情况下我们仅仅需要对渲染进程进行更新和升级而不需要改动主进程代码，我们渲染进程的打包实际上和一般的<code>web</code>项目打包没有太大差别，使用<code>webpack</code>打包即可。</p>
<p>这里我说说渲染进程单独打包的好处：</p>
<p>打包完成的<code>html</code>和<code>js</code>文件，我们一般要上传到我们的前端静态资源服务器下，然后告知服务端我们的渲染进程有代码更新，这里可以说成渲染进程单独的升级。</p>
<p>注意，和壳的升级不同，渲染进程的升级仅仅是静态资源服务器上<code>html</code>和<code>js</code>文件的更新，而不需要重新下载更新客户端，这样我们每次启动程序的时候检测到离线包有更新，即可直接刷新读取最新版本的静态资源文件，即使在程序运行过程中要强制更新，我们的程序只需要强制刷新页面读取最新的静态资源即可，这样的升级对用户是非常友好的。</p>
<p>这里注意，一旦我们这样配置，就意味着渲染进程和主进程打包升级的完全分离，我们在启动主窗口时读取的文件就不应该再是本地文件，而是打包完成后放在静态资源服务器的文件。</p>
<p>为了方便开发，这里我们可以区分本地和线上加载不同的文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVersion</span> (<span class="params">mac,current</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 根据设备mac和当前版本获取最新版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (build.env === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> version = getVersion (mac,current);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'https://www.xxxserver.html/electron-react/index_'</span>+version+<span class="string">'.html'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url.format(&#123;</span><br><span class="line">    protocol: <span class="string">'file:'</span>,</span><br><span class="line">    pathname: path.join(__dirname, <span class="string">'env/environment.html'</span>),</span><br><span class="line">    slashes: <span class="literal">true</span>,</span><br><span class="line">    query: &#123; <span class="attr">debugger</span>: build.env === <span class="string">"development"</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的<code>webpack</code>配置这里就不再贴出。</p>
<p>这里需要注意，在开发环境下我们可以结合<code>webpack</code>的<code>devServer</code>和<code>electron</code>命令来启动<code>app</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: <span class="string">'./assets/'</span>,</span><br><span class="line">  historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  port: PORT,</span><br><span class="line">  noInfo: <span class="literal">false</span>,</span><br><span class="line">  stats: &#123;</span><br><span class="line">    colors: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    spawn(</span><br><span class="line">      <span class="string">'electron'</span>,</span><br><span class="line">      [<span class="string">'.'</span>],</span><br><span class="line">      &#123;</span><br><span class="line">        shell: <span class="literal">true</span>,</span><br><span class="line">        stdio: <span class="string">'inherit'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      .on(<span class="string">'close'</span>, () =&gt; process.exit(<span class="number">0</span>))</span><br><span class="line">      .on(<span class="string">'error'</span>, e =&gt; <span class="built_in">console</span>.error(e));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,<span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<h3 id="13-2-主进程打包"><a href="#13-2-主进程打包" class="headerlink" title="13.2 主进程打包"></a>13.2 主进程打包</h3><p> 主进程，即将整个程序打包成可运行的客户端程序，常用的打包方案一般有两种，<code>electron-packager</code>和<code>electron-builder</code>。</p>
<p> <code>electron-packager</code>在打包配置上我觉得有些繁琐，而且它只能将应用直接打包为可执行程序。</p>
<p> 这里我推荐使用<code>electron-builder</code>，它不仅拥有方便的配置 <code>protocol</code> 的功能、内置的 <code>Auto Update</code>、简单的配置 <code>package.json</code> 便能完成整个打包工作，用户体验非常不错。而且<code>electron-builder</code>不仅能直接将应用打包成<code>exe app</code>等可执行程序，还能打包成<code>msi dmg</code>等安装包格式。</p>
<p> 你可以在<code>package.json</code>方便的进行各种配置：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"build"</span>: &#123;</span><br><span class="line">  <span class="string">"productName"</span>: <span class="string">"electron-react"</span>, <span class="comment">// app中文名称</span></span><br><span class="line">  <span class="string">"appId"</span>: <span class="string">"electron-react"</span>,<span class="comment">// app标识</span></span><br><span class="line">  <span class="string">"directories"</span>: &#123; <span class="comment">// 打包后输出的文件夹</span></span><br><span class="line">    <span class="string">"buildResources"</span>: <span class="string">"resources"</span>,</span><br><span class="line">    <span class="string">"output"</span>: <span class="string">"dist/"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"files"</span>: [ <span class="comment">// 打包后依然保留的源文件</span></span><br><span class="line">    <span class="string">"main_process/"</span>,</span><br><span class="line">    <span class="string">"render_process/"</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"mac"</span>: &#123; <span class="comment">// mac打包配置</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"dmg"</span>,</span><br><span class="line">    <span class="string">"icon"</span>: <span class="string">"icon.ico"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"win"</span>: &#123; <span class="comment">// windows打包配置</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"nsis"</span>,</span><br><span class="line">    <span class="string">"icon"</span>: <span class="string">"icon.ico"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"dmg"</span>: &#123; <span class="comment">// dmg文件打包配置</span></span><br><span class="line">    <span class="string">"artifactName"</span>: <span class="string">"electron_react.dmg"</span>,</span><br><span class="line">    <span class="string">"contents"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="string">"path"</span>: <span class="string">"/Applications"</span>,</span><br><span class="line">        <span class="string">"x"</span>: <span class="number">410</span>,</span><br><span class="line">        <span class="string">"y"</span>: <span class="number">150</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"file"</span>,</span><br><span class="line">        <span class="string">"x"</span>: <span class="number">130</span>,</span><br><span class="line">        <span class="string">"y"</span>: <span class="number">150</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"nsis"</span>: &#123; <span class="comment">// nsis文件打包配置</span></span><br><span class="line">    <span class="string">"oneClick"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"allowToChangeInstallationDirectory"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"shortcutName"</span>: <span class="string">"electron-react"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 执行<code>electron-builder</code>打包命令时，可指定参数进行打包。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">--mac, -m, -o, --macos   macOS打包</span><br><span class="line">--linux, -l              Linux打包</span><br><span class="line">--win, -w, --windows     Windows打包</span><br><span class="line">--mwl                    同时为macOS，Windows和Linux打包</span><br><span class="line">--x64                    x64 (<span class="number">64</span>位安装包)</span><br><span class="line">--ia32                   ia32(<span class="number">32</span>位安装包)</span><br></pre></td></tr></table></figure>
<p> 关于主进程的更新你可以使用<code>electron-builder</code>自带的<code>Auto Update</code>模块，在<code>electron-react</code>也实现了手动更新的模块。</p>
<h3 id="13-3-打包优化"><a href="#13-3-打包优化" class="headerlink" title="13.3 打包优化"></a>13.3 打包优化</h3><p><code>electron-builder</code>打包出来的<code>App</code>要比相同功能的原生客户端应用体积大很多，即使是空的应用，体积也要在<code>100mb</code>以上。原因有很多：</p>
<p>第一点；为了达到跨平台的效果，每个<code>Electron</code>应用都包含了整个<code>V8</code>引擎和<code>Chromium</code>内核。</p>
<p>第二点：打包时会将整个<code>node_modules</code>打包进去，大家都知道一个应用的<code>node_module</code>体积是非常庞大的，这也是使得<code>Electron</code>应用打包后的体积较大的原因。</p>
<p>第一点我们无法改变，我们可以从第二点对应用体积进行优化：<code>Electron</code>在打包时只会将<code>denpendencies</code>的依赖打包进去，而不会将 <code>devDependencies</code> 中的依赖进行打包。所以我们应尽可能的减少<code>denpendencies</code>中的依赖。在上面的进程中，我们使用<code>webpack</code>对渲染进程进行打包，所以渲染进程的依赖全部都可以移入<code>devDependencies</code>。</p>
<p>另外，我们还可以使用双<code>packajson.json</code>的方式来进行优化，把只在开发环境中使用到的依赖放在整个项目的根目录的<code>package.json</code>下，将与平台相关的或者运行时需要的依赖装在<code>app</code>目录下。具体详见<a href="https://www.electron.build/tutorials/two-package-structure" target="_blank" rel="noopener">two-package-structure</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://electronjs.org/docs" target="_blank" rel="noopener">https://electronjs.org/docs</a></li>
<li><a href="http://jlord.us/essential-electron/" target="_blank" rel="noopener">http://jlord.us/essential-electron/</a></li>
<li><a href="https://imweb.io/topic/5b9f500cc2ec8e6772f34d79" target="_blank" rel="noopener">https://imweb.io/topic/5b9f500cc2ec8e6772f34d79</a></li>
<li><a href="https://www.jianshu.com/p/1ece6fd7a80c" target="_blank" rel="noopener">https://www.jianshu.com/p/1ece6fd7a80c</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/52991793" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52991793</a></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p>
<ul>
<li>了解<code>Electron</code>的基本运行原理</li>
<li>掌握<code>Electron</code>开发的核心基础知识</li>
<li>了解<code>Electron</code>关于弹框、打印、保护、打包等功能的基本使用</li>
</ul>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>用JS开发桌面应用（四）程序保护</title>
    <url>/2019/05/13/2019-05-13-Programing-JavaScript-use-js-develop-desk-app-4/</url>
    <content><![CDATA[<h2 id="十、程序保护"><a href="#十、程序保护" class="headerlink" title="十、程序保护"></a>十、程序保护</h2><p><a href="https://segmentfault.com/a/1190000007503495" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007503495</a></p>
<p><img src="http://www.conardli.top/img/electron/el_22_protect.gif" alt></p>
<h3 id="10-1-崩溃"><a href="#10-1-崩溃" class="headerlink" title="10.1 崩溃"></a>10.1 崩溃</h3><p>崩溃监控是每个客户端程序必备的保护功能，当程序崩溃时我们一般期望做到两件事：</p>
<ul>
<li>1.上传崩溃日志，及时报警</li>
<li>2.监控程序崩溃，提示用户重启程序</li>
</ul>
<p><code>electron</code>为我们提供给了<code>crashReporter</code>来帮助我们记录崩溃日志，我们可以通过<code>crashReporter.start</code>来创建一个崩溃报告器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; crashReporter &#125; = <span class="built_in">require</span>(<span class="string">"electron"</span>);</span><br><span class="line">crashReporter.start(&#123;</span><br><span class="line">  productName: <span class="string">"YourName"</span>,</span><br><span class="line">  companyName: <span class="string">"YourCompany"</span>,</span><br><span class="line">  submitURL: <span class="string">"https://your-domain.com/url-to-submit"</span>,</span><br><span class="line">  uploadToServer: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当程序发生崩溃时，崩溃报日志将被储存在临时文件夹中名为<code>YourName Crashes</code>的文件文件夹中。<code>submitURL</code>用于指定你的崩溃日志上传服务器。 在启动崩溃报告器之前，您可以通过调用<code>app.setPath(&#39;temp&#39;, &#39;my/custom/temp&#39;)</code>API 来自定义这些临时文件的保存路径。你还可以通过<code>crashReporter.getLastCrashReport()</code>来获取上次崩溃报告的日期和<code>ID</code>。</p>
<p>我们可以通过<code>webContents</code>的<code>crashed</code>来监听渲染进程的崩溃，另外经测试有些主进程的崩溃也会触发该事件。所以我们可以根据主<code>window</code>是否被销毁来判断进行不同的重启逻辑，下面使整个崩溃监控的逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserWindow, crashReporter, dialog &#125; <span class="keyword">from</span> <span class="string">"electron"</span>;</span><br><span class="line"><span class="comment">// 开启进程崩溃记录</span></span><br><span class="line">crashReporter.start(&#123;</span><br><span class="line">  productName: <span class="string">"electron-react"</span>,</span><br><span class="line">  companyName: <span class="string">"ConardLi"</span>,</span><br><span class="line">  submitURL: <span class="string">"http://xxx.com"</span>, <span class="comment">// 上传崩溃日志的接口</span></span><br><span class="line">  uploadToServer: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reloadWindow</span>(<span class="params">mainWin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mainWin.isDestroyed()) &#123;</span><br><span class="line">    app.relaunch();</span><br><span class="line">    app.exit(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 销毁其他窗口</span></span><br><span class="line">    BrowserWindow.getAllWindows().forEach(<span class="function"><span class="params">w</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (w.id !== mainWin.id) w.destroy();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">      type: <span class="string">"info"</span>,</span><br><span class="line">      title: <span class="string">"渲染器进程崩溃"</span>,</span><br><span class="line">      message: <span class="string">"这个进程已经崩溃."</span>,</span><br><span class="line">      buttons: [<span class="string">"重载"</span>, <span class="string">"关闭"</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">    dialog.showMessageBox(options, index =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) mainWin.reload();</span><br><span class="line">      <span class="keyword">else</span> mainWin.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mainWindow = BrowserWindow.fromId(global.mainId);</span><br><span class="line">  mainWindow.webContents.on(<span class="string">"crashed"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> errorMessage = crashReporter.getLastCrashReport();</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"程序崩溃了！"</span>, errorMessage); <span class="comment">// 可单独上传日志</span></span><br><span class="line">    reloadWindow(mainWindow);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="10-2-最小化到托盘"><a href="#10-2-最小化到托盘" class="headerlink" title="10.2 最小化到托盘"></a>10.2 最小化到托盘</h3><p>有的时候我们并不想让用户通过点关闭按钮的时候就关闭程序，而是把程序最小化到托盘，在托盘上做真正的退出操作。</p>
<p>首先要监听窗口的关闭事件，阻止用户关闭操作的默认行为，将窗口隐藏。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkQuit</span>(<span class="params">mainWindow, event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    type: <span class="string">"info"</span>,</span><br><span class="line">    title: <span class="string">"关闭确认"</span>,</span><br><span class="line">    message: <span class="string">"确认要最小化程序到托盘吗？"</span>,</span><br><span class="line">    buttons: [<span class="string">"确认"</span>, <span class="string">"关闭程序"</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  dialog.showMessageBox(options, index =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">      mainWindow.hide();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mainWindow = <span class="literal">null</span>;</span><br><span class="line">      app.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleQuit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mainWindow = BrowserWindow.fromId(global.mainId);</span><br><span class="line">  mainWindow.on(<span class="string">"close"</span>, event =&gt; &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    checkQuit(mainWindow, event);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时程序就再也找不到了，任务托盘中也没有我们的程序，所以我们要先创建好任务托盘，并做好事件监听。</p>
<blockquote>
<p>windows 平台使用<code>ico</code>文件可以达到更好的效果</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createTray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mainWindow = BrowserWindow.fromId(global.mainId);</span><br><span class="line">  <span class="keyword">const</span> iconName = process.platform === <span class="string">"win32"</span> ? <span class="string">"icon.ico"</span> : <span class="string">"icon.png"</span>;</span><br><span class="line">  tray = <span class="keyword">new</span> Tray(path.join(global.__dirname, iconName));</span><br><span class="line">  <span class="keyword">const</span> contextMenu = Menu.buildFromTemplate([</span><br><span class="line">    &#123;</span><br><span class="line">      label: <span class="string">"显示主界面"</span>,</span><br><span class="line">      click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        mainWindow.show();</span><br><span class="line">        mainWindow.setSkipTaskbar(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      label: <span class="string">"退出"</span>,</span><br><span class="line">      click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        mainWindow.destroy();</span><br><span class="line">        app.quit();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  tray.setToolTip(<span class="string">"electron-react"</span>);</span><br><span class="line">  tray.setContextMenu(contextMenu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>用JS开发桌面应用（三）打印篇</title>
    <url>/2019/05/09/2019-05-09-Programing-JavaScript-use-js-develop-desk-app-3/</url>
    <content><![CDATA[<h2 id="九、打印"><a href="#九、打印" class="headerlink" title="九、打印"></a>九、打印</h2><p>很多情况下程序中使用的打印都是用户无感知的。并且想要灵活的控制打印内容，往往需要借助打印机给我们提供的<code>api</code>再进行开发，这种开发方式非常繁琐，并且开发难度较大。第一次在业务中用到<code>Electron</code>其实就是用到它的打印功能，这里就多介绍一些。</p>
<p><code>Electron</code>提供的打印api可以非常灵活的控制打印设置的显示，并且可以通过html来书写打印内容。<code>Electron</code>提供了两种方式进行打印，一种是直接调用打印机打印，一种是打印到<code>pdf</code>。</p>
<p>并且有两种对象可以调用打印：</p>
<ul>
<li>通过<code>window</code>的<code>webcontent</code>对象，使用此种方式需要单独开出一个打印的窗口，可以将该窗口隐藏，但是通信调用相对复杂。</li>
<li>使用页面的<code>webview</code>元素调用打印，可以将<code>webview</code>隐藏在调用的页面中，通信方式比较简单。</li>
</ul>
<p>上面两种方式同时拥有<code>print</code>和<code>printToPdf</code>方法。</p>
<p><img src="http://www.conardli.top/img/electron/el_23_print.gif" alt></p>
<h3 id="9-1-调用系统打印"><a href="#9-1-调用系统打印" class="headerlink" title="9.1 调用系统打印"></a>9.1 调用系统打印</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contents.print([options], [callback])；</span><br></pre></td></tr></table></figure>
<p>打印配置(options)中只有简单的三个配置：</p>
<ul>
<li><code>silent</code>：打印时是否不展示打印配置（是否静默打印）</li>
<li><code>printBackground</code>：是否打印背景</li>
<li><code>deviceName</code>：打印机设备名称</li>
</ul>
<p>首先要将我们使用的打印机名称配置好，并且要在调用打印前首先要判断打印机是否可用。</p>
<p>使用<code>webContents</code>的<code>getPrinters</code>方法可获取当前设备已经配置的打印机列表，注意配置过不是可用，只是在此设备上安装过驱动。</p>
<p>通过<code>getPrinters</code>获取到的打印机对象：<a href="https://electronjs.org/docs/api/structures/printer-info" target="_blank" rel="noopener">https://electronjs.org/docs/api/structures/printer-info</a></p>
<p>我们这里只管关心两个，<code>name</code>和<code>status</code>，<code>status</code>为<code>0</code>时表示打印机可用。</p>
<p><code>print</code>的第二个参数<code>callback</code>是用于判断打印任务是否发出的回调，而不是打印任务完成后的回调。所以一般打印任务发出，回调函数即会调用并返回参数<code>true</code>。这个回调并不能判断打印是否真的成功了。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.state.curretnPrinter) &#123;</span><br><span class="line">  mainWindow.webContents.print(&#123;</span><br><span class="line">    silent: silent, <span class="attr">printBackground</span>: <span class="literal">true</span>, <span class="attr">deviceName</span>: <span class="keyword">this</span>.state.curretnPrinter</span><br><span class="line">  &#125;, () =&gt; &#123; &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  remote.dialog.showErrorBox(<span class="string">'错误'</span>, <span class="string">'请先选择一个打印机！'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-2-打印到PDF"><a href="#9-2-打印到PDF" class="headerlink" title="9.2 打印到PDF"></a>9.2 打印到PDF</h3><p><code>printToPdf</code>的用法基本和<code>print</code>相同，但是<code>print</code>的配置项非常少，而<code>printToPdf</code>则扩展了很多属性。这里翻了一下源码发现还有很多没有被贴进api的，大概有三十几个包括可以对打印的margin，打印页眉页脚等进行配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contents.printToPDF(options, callback)</span><br></pre></td></tr></table></figure>
<p><code>callback</code>函数在打印失败或打印成功后调用，可获取打印失败信息或包含<code>PDF</code>数据的缓冲区。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pdfPath = path.join(os.tmpdir(), <span class="string">'webviewPrint.pdf'</span>);</span><br><span class="line"><span class="keyword">const</span> webview = <span class="built_in">document</span>.getElementById(<span class="string">'printWebview'</span>);</span><br><span class="line"><span class="keyword">const</span> renderHtml = <span class="string">'我是被临时插入webview的内容...'</span>;</span><br><span class="line">webview.executeJavaScript(<span class="string">'document.documentElement.innerHTML =`'</span> + renderHtml + <span class="string">'`;'</span>);</span><br><span class="line">webview.printToPDF(&#123;&#125;, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err, data);</span><br><span class="line">  fs.writeFile(pdfPath, data, (error) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">    shell.openExternal(<span class="string">`file://<span class="subst">$&#123;pdfPath&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">webviewPdfPath</span>: pdfPath &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个例子中的打印是使用<code>webview</code>完成的，通过调用<code>executeJavaScript</code>方法可动态向<code>webview</code>插入打印内容。</p>
</blockquote>
<h3 id="9-3-两种打印方案的选择"><a href="#9-3-两种打印方案的选择" class="headerlink" title="9.3 两种打印方案的选择"></a>9.3 两种打印方案的选择</h3><p>上面提到，使用<code>webview</code>和<code>webcontent</code>都可以调用打印功能，使用<code>webcontent</code>打印，首先要有一个打印窗口，这个窗口不能随时打印随时创建，比较耗费性能。可以将它在程序运行时启动好，并做好事件监听。</p>
<p>此过程需和调用打印的进行做好通信，大致过程如下：</p>
<p><img src="http://www.conardli.top/img/electron/el_24_print.png" alt></p>
<p>可见通信非常繁琐，使用<code>webview</code>进行打印可实现同样的效果但是通信方式会变得简单，因为渲染进程和<code>webview</code>通信不需要经过主进程，通过如下方式即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webview = <span class="built_in">document</span>.querySelector(<span class="string">'webview'</span>)</span><br><span class="line">webview.addEventListener(<span class="string">'ipc-message'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.channel)</span><br><span class="line">&#125;)</span><br><span class="line">webview.send(<span class="string">'ping'</span>)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line">ipcRenderer.on(<span class="string">'ping'</span>, () =&gt; &#123;</span><br><span class="line">  ipcRenderer.sendToHost(<span class="string">'pong'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="9-4-打印功能封装"><a href="#9-4-打印功能封装" class="headerlink" title="9.4 打印功能封装"></a>9.4 打印功能封装</h3><p>下面是几个针对常用打印功能的工具函数封装。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取系统打印机列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getPrinters</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> printers = [];</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> contents = remote.getCurrentWindow().webContents;</span><br><span class="line">    printers = contents.getPrinters();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'getPrintersError'</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> printers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取系统默认打印机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getDefaultPrinter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getPrinters().find(<span class="function"><span class="params">element</span> =&gt;</span> element.isDefault);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测是否安装了某个打印驱动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">checkDriver</span>(<span class="params">driverMame</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getPrinters().find(<span class="function"><span class="params">element</span> =&gt;</span> (element.options[<span class="string">"printer-make-and-model"</span>] || <span class="string">''</span>).includes(driverMame));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据打印机名称获取打印机对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getPrinterByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getPrinters().find(<span class="function"><span class="params">element</span> =&gt;</span> element.name === name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p>
<ul>
<li>了解<code>Electron</code>的基本运行原理</li>
<li>掌握<code>Electron</code>开发的核心基础知识</li>
<li>了解<code>Electron</code>关于弹框、打印、保护、打包等功能的基本使用</li>
</ul>
<p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>用JS开发桌面应用（二）- 应用篇</title>
    <url>/2019/05/06/2019-05-06-Programing-JavaScript-use-js-develop-desk-app-2/</url>
    <content><![CDATA[<h2 id="五、窗口"><a href="#五、窗口" class="headerlink" title="五、窗口"></a>五、窗口</h2><h3 id="5-1-BrowserWindow"><a href="#5-1-BrowserWindow" class="headerlink" title="5.1 BrowserWindow"></a>5.1 BrowserWindow</h3><p>主进程模块<code>BrowserWindow</code>用于创建和控制浏览器窗口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  width: <span class="number">1000</span>,</span><br><span class="line">  height: <span class="number">800</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line">mainWindow.loadURL(<span class="string">"http://www.conardli.top/"</span>);</span><br></pre></td></tr></table></figure>
<p>你可以在<a href="https://electronjs.org/docs/api/browser-window#new-browserwindowoptions" target="_blank" rel="noopener">这里</a>查看它所有的构造参数。</p>
<p><img src="http://www.conardli.top/img/electron/el_13_window.gif" alt></p>
<h3 id="5-2-无框窗口"><a href="#5-2-无框窗口" class="headerlink" title="5.2 无框窗口"></a>5.2 无框窗口</h3><blockquote>
<p>无框窗口是没有镶边的窗口，窗口的部分（如工具栏）不属于网页的一部分。</p>
</blockquote>
<p>在<code>BrowserWindow</code>的构造参数中，将<code>frame</code>设置为<code>false</code>可以指定窗口为无边框窗口，将工具栏隐藏后，就会产生两个问题：</p>
<ul>
<li>1.窗口控制按钮（最小化、全屏、关闭按钮）会被隐藏</li>
<li>2.无法拖拽移动窗口</li>
</ul>
<p>可以通过指定<code>titleBarStyle</code>选项来再将工具栏按钮显示出来，将其设置为<code>hidden</code>表示返回一个隐藏标题栏的全尺寸内容窗口，在左上角仍然有标准的窗口控制按钮。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  width: <span class="number">200</span>,</span><br><span class="line">  height: <span class="number">200</span>,</span><br><span class="line">  titleBarStyle: <span class="string">"hidden"</span>,</span><br><span class="line">  frame: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="5-3-窗口拖拽"><a href="#5-3-窗口拖拽" class="headerlink" title="5.3 窗口拖拽"></a>5.3 窗口拖拽</h3><p>默认情况下, 无边框窗口是不可拖拽的。我们可以在界面中通过<code>CSS</code>属性<code>-webkit-app-region: drag</code>手动制定拖拽区域。</p>
<p>在无框窗口中, 拖动行为可能与选择文本冲突，可以通过设定<code>-webkit-user-select: none;</code>禁用文本选择：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-webkit-app-region</span>: drag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相反的，在可拖拽区域内部设置 <code>-webkit-app-region: no-drag</code>则可以指定特定不可拖拽区域。</p>
</blockquote>
<h3 id="5-4-透明窗口"><a href="#5-4-透明窗口" class="headerlink" title="5.4 透明窗口"></a>5.4 透明窗口</h3><p>通过将<code>transparent</code>选项设置为<code>true</code>, 还可以使无框窗口透明:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  transparent: <span class="literal">true</span>,</span><br><span class="line">  frame: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="5-5-Webview"><a href="#5-5-Webview" class="headerlink" title="5.5 Webview"></a>5.5 Webview</h3><p>使用 <code>webview</code> 标签在<code>Electron</code> 应用中嵌入 “外来” 内容。外来内容包含在 <code>webview</code> 容器中。 应用中的嵌入页面可以控制外来内容的布局和重绘。</p>
<p>与 <code>iframe</code> 不同, <code>webview</code> 在与应用程序不同的进程中运行。它与您的网页没有相同的权限, 应用程序和嵌入内容之间的所有交互都将是异步的。</p>
<h2 id="六、对话框"><a href="#六、对话框" class="headerlink" title="六、对话框"></a>六、对话框</h2><p><code>dialog</code> 模块提供了<code>api</code>来展示原生的系统对话框，例如打开文件框，<code>alert</code>框，所以<code>web</code>应用可以给用户带来跟系统应用相同的体验。</p>
<blockquote>
<p>注意：dialog 是主进程模块，想要在渲染进程调用可以使用 remote</p>
</blockquote>
<p><img src="http://www.conardli.top/img/electron/el_16_dialog.gif" alt></p>
<h3 id="6-1-错误提示"><a href="#6-1-错误提示" class="headerlink" title="6.1 错误提示"></a>6.1 错误提示</h3><p><code>dialog.showErrorBox</code>用于显示一个显示错误消息的模态对话框。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">remote.dialog.showErrorBox(<span class="string">"错误"</span>, <span class="string">"这是一个错误弹框！"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="6-2-对话框"><a href="#6-2-对话框" class="headerlink" title="6.2 对话框"></a>6.2 对话框</h3><p><code>dialog.showErrorBox</code>用于调用系统对话框，可以为指定几种不同的类型： “<code>none</code>“, “<code>info</code>“, “<code>error</code>“, “<code>question</code>“ 或者 “<code>warning</code>“。</p>
<blockquote>
<p>在 Windows 上, “question” 与”info”显示相同的图标, 除非你使用了 “icon” 选项设置图标。 在 macOS 上, “warning” 和 “error” 显示相同的警告图标</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">remote.dialog.showMessageBox(</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">"info"</span>,</span><br><span class="line">    title: <span class="string">"提示信息"</span>,</span><br><span class="line">    message: <span class="string">"这是一个对话弹框！"</span>,</span><br><span class="line">    buttons: [<span class="string">"确定"</span>, <span class="string">"取消"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  index =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      dialogMessage: <span class="string">`【你点击了<span class="subst">$&#123;index ? <span class="string">"取消"</span> : <span class="string">"确定"</span>&#125;</span>！！】`</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="6-3-文件框"><a href="#6-3-文件框" class="headerlink" title="6.3 文件框"></a>6.3 文件框</h3><p><code>dialog.showOpenDialog</code>用于打开或选择系统目录。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">remote.dialog.showOpenDialog(</span><br><span class="line">  &#123;</span><br><span class="line">    properties: [<span class="string">"openDirectory"</span>, <span class="string">"openFile"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  data =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">filePath</span>: <span class="string">`【选择路径：<span class="subst">$&#123;data[<span class="number">0</span>]&#125;</span>】 `</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="6-4-信息框"><a href="#6-4-信息框" class="headerlink" title="6.4 信息框"></a>6.4 信息框</h3><p>这里推荐直接使用<code>HTML5 API</code>，它只能在渲染器进程中使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">"信息框标题"</span>,</span><br><span class="line">  body: <span class="string">"我是一条信息～～～"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> myNotification = <span class="keyword">new</span> <span class="built_in">window</span>.Notification(options.title, options);</span><br><span class="line">myNotification.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">message</span>: <span class="string">"【你点击了信息框！！】"</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="七、系统"><a href="#七、系统" class="headerlink" title="七、系统"></a>七、系统</h2><h3 id="7-1-获取系统信息"><a href="#7-1-获取系统信息" class="headerlink" title="7.1 获取系统信息"></a>7.1 获取系统信息</h3><p><img src="http://www.conardli.top/img/electron/el_17_sys.png" alt></p>
<p>通过<code>remote</code>获取到主进程的<code>process</code>对象，可以获取到当前应用的各个版本信息：</p>
<ul>
<li><code>process.versions.electron</code>：<code>electron</code>版本信息</li>
<li><code>process.versions.chrome</code>：<code>chrome</code>版本信息</li>
<li><code>process.versions.node</code>：<code>node</code>版本信息</li>
<li><code>process.versions.v8</code>：<code>v8</code>版本信息</li>
</ul>
<p>获取当前应用根目录：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">remote.app.getAppPath();</span><br></pre></td></tr></table></figure>
<p>使用<code>node</code>的<code>os</code>模块获取当前系统根目录：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">os.homedir();</span><br></pre></td></tr></table></figure>
<h3 id="7-2-复制粘贴"><a href="#7-2-复制粘贴" class="headerlink" title="7.2 复制粘贴"></a>7.2 复制粘贴</h3><p><img src="http://www.conardli.top/img/electron/el_18_clipboard.gif" alt></p>
<p><code>Electron</code>提供的<code>clipboard</code>在渲染进程和主进程都可使用，用于在系统剪贴板上执行复制和粘贴操作。</p>
<p>以纯文本的形式写入剪贴板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">clipboard.writeText(text[, type])</span><br></pre></td></tr></table></figure>
<p>以纯文本的形式获取剪贴板的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">clipboard.readText([type]);</span><br></pre></td></tr></table></figure>
<h3 id="7-3-截图"><a href="#7-3-截图" class="headerlink" title="7.3 截图"></a>7.3 截图</h3><p><code>desktopCapturer</code>用于从桌面捕获音频和视频的媒体源的信息。它只能在渲染进程中被调用。</p>
<p><img src="http://www.conardli.top/img/electron/el_19_cap.gif" alt></p>
<p>下面的代码是一个获取屏幕截图并保存的实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getImg = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">imgMsg</span>: <span class="string">"正在截取屏幕..."</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> thumbSize = <span class="keyword">this</span>.determineScreenShotSize();</span><br><span class="line">  <span class="keyword">let</span> options = &#123; <span class="attr">types</span>: [<span class="string">"screen"</span>], <span class="attr">thumbnailSize</span>: thumbSize &#125;;</span><br><span class="line">  desktopCapturer.getSources(options, (error, sources) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="built_in">console</span>.log(error);</span><br><span class="line">    sources.forEach(<span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (source.name === <span class="string">"Entire screen"</span> || source.name === <span class="string">"Screen 1"</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> screenshotPath = path.join(os.tmpdir(), <span class="string">"screenshot.png"</span>);</span><br><span class="line">        fs.writeFile(screenshotPath, source.thumbnail.toPNG(), error =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="built_in">console</span>.log(error);</span><br><span class="line">          shell.openExternal(<span class="string">`file://<span class="subst">$&#123;screenshotPath&#125;</span>`</span>);</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123; <span class="attr">imgMsg</span>: <span class="string">`截图保存到: <span class="subst">$&#123;screenshotPath&#125;</span>`</span> &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">determineScreenShotSize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> screenSize = screen.getPrimaryDisplay().workAreaSize;</span><br><span class="line">  <span class="keyword">const</span> maxDimension = <span class="built_in">Math</span>.max(screenSize.width, screenSize.height);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    width: maxDimension * <span class="built_in">window</span>.devicePixelRatio,</span><br><span class="line">    height: maxDimension * <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="八、菜单"><a href="#八、菜单" class="headerlink" title="八、菜单"></a>八、菜单</h2><p>应用程序的菜单可以帮助我们快捷的到达某一功能，而不借助客户端的界面资源，一般菜单分为两种：</p>
<ul>
<li>应用程序菜单：位于应用程序顶部，在全局范围内都能使用</li>
<li>上下文菜单：可自定义任意页面显示，自定义调用，如右键菜单</li>
</ul>
<p><code>Electron</code>为我们提供了<code>Menu</code>模块用于创建本机应用程序菜单和上下文菜单，它是一个主进程模块。</p>
<p>你可以通过<code>Menu</code>的静态方法<code>buildFromTemplate(template)</code>，使用自定义菜单模版来构造一个菜单对象。</p>
<p><code>template</code>是一个<code>MenuItem</code>的数组，我们来看看<code>MenuItem</code>的几个重要参数：</p>
<ul>
<li><code>label</code>：菜单显示的文字</li>
<li><code>click</code>：点击菜单后的事件处理函数</li>
<li><code>role</code>：系统预定义的菜单，例如<code>copy</code>(复制)、<code>paste</code>(粘贴)、<code>minimize</code>(最小化)…</li>
<li><code>enabled</code>：指示是否启用该项目，此属性可以动态更改</li>
<li><code>submenu</code>：子菜单，也是一个<code>MenuItem</code>的数组</li>
</ul>
<blockquote>
<p>推荐：最好指定 role 与标准角色相匹配的任何菜单项，而不是尝试手动实现 click 函数中的行为。内置 role 行为将提供最佳的本地体验。</p>
</blockquote>
<p>下面的实例是一个简单的额菜单<code>template</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> template = [</span><br><span class="line">  &#123;</span><br><span class="line">    label: <span class="string">"文件"</span>,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123;</span><br><span class="line">        label: <span class="string">"新建文件"</span>,</span><br><span class="line">        click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          dialog.showMessageBox(&#123;</span><br><span class="line">            type: <span class="string">"info"</span>,</span><br><span class="line">            message: <span class="string">"嘿!"</span>,</span><br><span class="line">            detail: <span class="string">"你点击了新建文件！"</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    label: <span class="string">"编辑"</span>,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123;</span><br><span class="line">        label: <span class="string">"剪切"</span>,</span><br><span class="line">        role: <span class="string">"cut"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        label: <span class="string">"复制"</span>,</span><br><span class="line">        role: <span class="string">"copy"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        label: <span class="string">"粘贴"</span>,</span><br><span class="line">        role: <span class="string">"paste"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    label: <span class="string">"最小化"</span>,</span><br><span class="line">    role: <span class="string">"minimize"</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h3 id="8-1-应用程序菜单"><a href="#8-1-应用程序菜单" class="headerlink" title="8.1 应用程序菜单"></a>8.1 应用程序菜单</h3><p>使用<code>Menu</code>的静态方法<code>setApplicationMenu</code>，可创建一个应用程序菜单，在 <code>Windows</code> 和 <code>Linux</code> 上，<code>menu</code>将被设置为每个窗口的顶层菜单。</p>
<blockquote>
<p>注意：必须在模块 ready 事件后调用此 API app。</p>
</blockquote>
<p>我们可以根据应用程序不同的的生命周期，不同的系统对菜单做不同的处理。</p>
<p><img src="http://www.conardli.top/img/electron/el_20_menu.png" alt></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.on(<span class="string">"ready"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> menu = Menu.buildFromTemplate(template);</span><br><span class="line">  Menu.setApplicationMenu(menu);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">"browser-window-created"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reopenMenuItem = findReopenMenuItem();</span><br><span class="line">  <span class="keyword">if</span> (reopenMenuItem) reopenMenuItem.enabled = <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">"window-all-closed"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reopenMenuItem = findReopenMenuItem();</span><br><span class="line">  <span class="keyword">if</span> (reopenMenuItem) reopenMenuItem.enabled = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.platform === <span class="string">"win32"</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> helpMenu = template[template.length - <span class="number">1</span>].submenu;</span><br><span class="line">  addUpdateMenuItems(helpMenu, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-上下文菜单"><a href="#8-2-上下文菜单" class="headerlink" title="8.2 上下文菜单"></a>8.2 上下文菜单</h3><p>使用<code>Menu</code>的实例方法<code>menu.popup</code>可自定义弹出上下文菜单。</p>
<p><img src="http://www.conardli.top/img/electron/el_21_memu.gif" alt></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = Menu.buildFromTemplate(template);</span><br><span class="line"><span class="built_in">document</span></span><br><span class="line">  .getElementById(<span class="string">"menuDemoContainer"</span>)</span><br><span class="line">  .addEventListener(<span class="string">"contextmenu"</span>, e =&gt; &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    m.popup(&#123; <span class="attr">window</span>: remote.getCurrentWindow() &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="8-3-快捷键"><a href="#8-3-快捷键" class="headerlink" title="8.3 快捷键"></a>8.3 快捷键</h3><p>在菜单选项中，我们可以指定一个<code>accelerator</code>属性来指定操作的快捷键：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  label: <span class="string">'最小化'</span>,</span><br><span class="line">  accelerator: <span class="string">'CmdOrCtrl+M'</span>,</span><br><span class="line">  role: <span class="string">'minimize'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，我们还可以使用<code>globalShortcut</code>来注册全局快捷键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalShortcut.register(<span class="string">"CommandOrControl+N"</span>, () =&gt; &#123;</span><br><span class="line">  dialog.showMessageBox(&#123;</span><br><span class="line">    type: <span class="string">"info"</span>,</span><br><span class="line">    message: <span class="string">"嘿!"</span>,</span><br><span class="line">    detail: <span class="string">"你触发了手动注册的快捷键."</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CommandOrControl 代表在 macOS 上为 Command 键，以及在 Linux 和 Windows 上为 Control 键。</p>
</blockquote>
<p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>用JS开发桌面应用（一）原理篇</title>
    <url>/2019/05/04/2019-05-04-Programing-JavaScript-use-js-develop-desk-app-1/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>使用<code>Electron</code>开发客户端程序已经有一段时间了，整体感觉还是非常不错的，其中也遇到了一些坑点，本文旨在从【运行原理】到【实际应用】对<code>Electron</code>进行一次系统性的总结。【多图，长文预警～】</p>
<p>另外<code>electron-react</code>还可作为使用<code>Electron + React + Mobx + Webpack</code>技术栈的脚手架工程。</p>
<h2 id="一、桌面应用程序"><a href="#一、桌面应用程序" class="headerlink" title="一、桌面应用程序"></a>一、桌面应用程序</h2><p><img src="http://www.conardli.top/img/electron/el_1_app.jpg" alt></p>
<blockquote>
<p>桌面应用程序，又称为 GUI 程序（Graphical User Interface），但是和 GUI 程序也有一些区别。桌面应用程序 将 GUI 程序从 GUI 具体为“桌面”，使冷冰冰的像块木头一样的电脑概念更具有 人性化，更生动和富有活力。</p>
</blockquote>
<p>我们电脑上使用的各种客户端程序都属于桌面应用程序，近年来<code>WEB</code>和移动端的兴起让桌面程序渐渐暗淡，但是在某些日常功能或者行业应用中桌面应用程序仍然是必不可少的。</p>
<p>传统的桌面应用开发方式，一般是下面两种：</p>
<h3 id="1-1-原生开发"><a href="#1-1-原生开发" class="headerlink" title="1.1 原生开发"></a>1.1 原生开发</h3><p>直接将语言编译成可执行文件，直接调用系统<code>API</code>，完成 UI 绘制等。这类开发技术，有着较高的运行效率，但一般来说，开发速度较慢，技术要求较高，例如：</p>
<ul>
<li>使用<code>C++ / MFC</code>开发<code>Windows</code>应用</li>
<li>使用<code>Objective-C</code>开发<code>MAC</code>应用</li>
</ul>
<h3 id="1-2-托管平台"><a href="#1-2-托管平台" class="headerlink" title="1.2 托管平台"></a>1.2 托管平台</h3><p>一开始就有本地开发和 UI 开发。一次编译后，得到中间文件，通过平台或虚机完成二次加载编译或解释运行。运行效率低于原生编译，但平台优化后，其效率也是比较可观的。就开发速度方面，比原生编译技术要快一些。例如：</p>
<ul>
<li>使用<code>C# / .NET Framework</code>(只能开发<code>Windows应用</code>)</li>
<li><code>Java / Swing</code></li>
</ul>
<p>不过，上面两种对前端开发人员太不友好了，基本是前端人员不会设计的领域，但是在这个【大前端 😅】的时代，前端开发者正在想方设法涉足各个领域，使用<code>WEB</code>技术开发客户端的方式横空出世。</p>
<h3 id="1-3-WEB-开发"><a href="#1-3-WEB-开发" class="headerlink" title="1.3 WEB 开发"></a>1.3 WEB 开发</h3><p>使用<code>WEB</code>技术进行开发，利用浏览器引擎完成<code>UI</code>渲染，利用<code>Node.js</code>实现服务器端<code>JS</code>编程并可以调用系统<code>API</code>，可以把它想像成一个套了一个客户端外壳的<code>WEB</code>应用。</p>
<p>在界面上，<code>WEB</code>的强大生态为<code>UI</code>带来了无限可能，并且开发、维护成本相对较低，有<code>WEB</code>开发经验的前端开发者很容易上手进行开发。</p>
<p>本文就来着重介绍使用<code>WEB</code>技术开发客户端程序的技术之一【<code>electron</code>】</p>
<h2 id="二、Electron"><a href="#二、Electron" class="headerlink" title="二、Electron"></a>二、Electron</h2><p><img src="http://www.conardli.top/img/electron/el_2_electron.jpg" alt></p>
<p><code>Electron</code>是由<code>Github</code>开发，用<code>HTML，CSS</code>和<code>JavaScript</code>来构建跨平台桌面应用程序的一个开源库。 <code>Electron</code>通过将<code>Chromium</code>和<code>Node.js</code>合并到同一个运行时环境中，并将其打包为<code>Mac，Windows</code>和<code>Linux</code>系统下的应用来实现这一目的。</p>
<p><a href="https://electronjs.org/docs" target="_blank" rel="noopener">https://electronjs.org/docs</a></p>
<p><a href="https://juejin.im/post/5c67619351882562276c3162#heading-5" target="_blank" rel="noopener">https://juejin.im/post/5c67619351882562276c3162#heading-5</a></p>
<h3 id="2-1-使用-Electron-开发的理由："><a href="#2-1-使用-Electron-开发的理由：" class="headerlink" title="2.1 使用 Electron 开发的理由："></a>2.1 使用 Electron 开发的理由：</h3><ul>
<li>1.使用具有强大生态的<code>Web</code>技术进行开发，开发成本低，可扩展性强，更炫酷的<code>UI</code></li>
<li>2.跨平台，一套代码可打包为<code>Windows、Linux、Mac</code>三套软件，且编译快速</li>
<li>3.可直接在现有<code>Web</code>应用上进行扩展，提供浏览器不具备的能力</li>
<li>4.你是一个前端 👨‍</li>
</ul>
<p>当然，我们也要认清它的缺点：性能比原生桌面应用要低，最终打包后的安装包和其他文件都比较大。</p>
<a id="more"></a>
<h3 id="2-2-开发体验"><a href="#2-2-开发体验" class="headerlink" title="2.2 开发体验"></a>2.2 开发体验</h3><p><strong>兼容性</strong></p>
<p>虽然你还在用<code>WEB</code>技术进行开发，但是你不用再考虑兼容性问题了，你只需要关心你当前使用<code>Electron</code>的版本对应<code>Chrome</code>的版本，一般情况下它已经足够新来让你使用最新的<code>API</code>和语法了，你还可以手动升级<code>Chrome</code>版本。同样的，你也不用考虑不同浏览器带了的样式和代码兼容问题。</p>
<p><strong>Node 环境</strong></p>
<p>这可能是很多前端开发者曾经梦想过的功能，在<code>WEB</code>界面中使用<code>Node.js</code>提供的强大<code>API</code>，这意味着你在<code>WEB</code>页面直接可以操作文件，调用系统<code>API</code>，甚至操作数据库。当然，除了完整的<code>Node API</code>，你还可以使用额外的几十万个<code>npm</code>模块。</p>
<p><strong>跨域</strong></p>
<p>你可以直接使用<code>Node</code>提供的<code>request</code>模块进行网络请求，这意味着你无需再被跨域所困扰。</p>
<p><strong>强大的扩展性</strong></p>
<p>借助<code>node-ffi</code>，为应用程序提供强大的扩展性（后面的章节会详细介绍）。</p>
<h3 id="2-3-谁在用-Electron"><a href="#2-3-谁在用-Electron" class="headerlink" title="2.3 谁在用 Electron"></a>2.3 谁在用 Electron</h3><p><img src="http://www.conardli.top/img/electron/el_6_apps.png" alt></p>
<p>现在市面上已经有非常多的应用在使用<code>electron</code>进行开发了，包括我们熟悉的<code>VS Code</code>客户端、<code>GitHub</code>客户端、<code>Atom</code>客户端等等。印象很深的，去年迅雷在发布迅雷 X<code>10.1</code>时的文案：</p>
<blockquote>
<p>从迅雷 X 10.1 版本开始，我们采用 Electron 软件框架完全重写了迅雷主界面。使用新框架的迅雷 X 可以完美支持 2K、4K 等高清显示屏，界面中的文字渲染也更加清晰锐利。从技术层面来说，新框架的界面绘制、事件处理等方面比老框架更加灵活高效，因此界面的流畅度也显著优于老框架的迅雷。至于具体提升有多大？您一试便知。</p>
</blockquote>
<p>你可以打开<code>VS Code</code>，点击【帮助】【切换开发人员工具】来<code>VS Code</code>客户端的界面。</p>
<p><img src="http://www.conardli.top/img/electron/el_5_vscode.png" alt></p>
<h2 id="三、Electron-运行原理"><a href="#三、Electron-运行原理" class="headerlink" title="三、Electron 运行原理"></a>三、Electron 运行原理</h2><p><img src="http://www.conardli.top/img/electron/el_3_composition.png" alt></p>
<p><code>Electron</code> 结合了 <code>Chromium</code>、<code>Node.js</code> 和用于调用操作系统本地功能的<code>API</code>。</p>
<h3 id="3-1-Chromium"><a href="#3-1-Chromium" class="headerlink" title="3.1 Chromium"></a>3.1 Chromium</h3><p><code>Chromium</code>是<code>Google</code>为发展<code>Chrome</code>浏览器而启动的开源项目，<code>Chromium</code>相当于<code>Chrome</code>的工程版或称实验版，新功能会率先在<code>Chromium</code>上实现，待验证后才会应用在<code>Chrome</code>上，故<code>Chrome</code>的功能会相对落后但较稳定。</p>
<p><code>Chromium</code>为<code>Electron</code>提供强大的<code>UI</code>能力，可以在不考虑兼容性的情况下开发界面。</p>
<h3 id="3-2-Node-js"><a href="#3-2-Node-js" class="headerlink" title="3.2 Node.js"></a>3.2 Node.js</h3><p><code>Node.js</code>是一个让<code>JavaScript</code>运行在服务端的开发平台，<code>Node</code>使用事件驱动，非阻塞<code>I/O</code>模型而得以轻量和高效。</p>
<p>单单靠<code>Chromium</code>是不能具备直接操作原生<code>GUI</code>能力的，<code>Electron</code>内集成了<code>Nodejs</code>，这让其在开发界面的同时也有了操作系统底层<code>API</code>的能力，<code>Nodejs</code> 中常用的 <code>Path、fs、Crypto</code> 等模块在 <code>Electron</code> 可以直接使用。</p>
<h3 id="3-3-系统-API"><a href="#3-3-系统-API" class="headerlink" title="3.3 系统 API"></a>3.3 系统 API</h3><p>为了提供原生系统的<code>GUI</code>支持，<code>Electron</code>内置了原生应用程序接口，对调用一些系统功能，如调用系统通知、打开系统文件夹提供支持。</p>
<p>在开发模式上，<code>Electron</code>在调用系统<code>API</code>和绘制界面上是分离开发的，下面我们来看看<code>Electron</code>关于进程如何划分。</p>
<h3 id="3-4-主进程"><a href="#3-4-主进程" class="headerlink" title="3.4 主进程"></a>3.4 主进程</h3><p><code>Electron</code>区分了两种进程：主进程和渲染进程，两者各自负责自己的职能。</p>
<p><img src="http://www.conardli.top/img/electron/el_7_process.png" alt></p>
<p><code>Electron</code> 运行<code>package.json</code>的 <code>main</code> 脚本的进程被称为主进程。一个 <code>Electron</code> 应用总是有且只有一个主进程。</p>
<p><strong>职责:</strong></p>
<ul>
<li>创建渲染进程（可多个）</li>
<li>控制了应用生命周期（启动、退出<code>APP</code>以及对<code>APP</code>做一些事件监听）</li>
<li>调用系统底层功能、调用原生资源</li>
</ul>
<p><strong>可调用的 API:</strong></p>
<ul>
<li><code>Node.js API</code></li>
<li><code>Electron</code>提供的主进程<code>API</code>（包括一些系统功能和<code>Electron</code>附加功能）</li>
</ul>
<h3 id="3-5-渲染进程"><a href="#3-5-渲染进程" class="headerlink" title="3.5 渲染进程"></a>3.5 渲染进程</h3><p>由于 <code>Electron</code> 使用了 <code>Chromium</code> 来展示 <code>web</code> 页面，所以 <code>Chromium</code> 的多进程架构也被使用到。 每个<code>Electron</code> 中的 <code>web</code>页面运行在它自己的渲染进程中。</p>
<blockquote>
<p>主进程使用 BrowserWindow 实例创建页面。 每个 BrowserWindow 实例都在自己的渲染进程里运行页面。 当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被终止。</p>
</blockquote>
<p>你可以把渲染进程想像成一个浏览器窗口，它能存在多个并且相互独立，不过和浏览器不同的是，它能调用<code>Node API</code>。</p>
<p><strong>职责:</strong></p>
<ul>
<li>用<code>HTML</code>和<code>CSS</code>渲染界面</li>
<li>用<code>JavaScript</code>做一些界面交互</li>
</ul>
<p><strong>可调用的 API:</strong></p>
<ul>
<li><code>DOM API</code></li>
<li><code>Node.js API</code></li>
<li><code>Electron</code>提供的渲染进程<code>API</code></li>
</ul>
<h2 id="四、Electron-基础"><a href="#四、Electron-基础" class="headerlink" title="四、Electron 基础"></a>四、Electron 基础</h2><h3 id="4-1-Electron-API"><a href="#4-1-Electron-API" class="headerlink" title="4.1 Electron API"></a>4.1 Electron API</h3><p>在上面的章节我们提到，渲染进和主进程分别可调用的<code>Electron API</code>。所有<code>Electron</code>的<code>API</code>都被指派给一种进程类型。 许多<code>API</code>只能被用于主进程中，有些<code>API</code>又只能被用于渲染进程，又有一些主进程和渲染进程中都可以使用。</p>
<p>你可以通过如下方式获取<code>Electron API</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BrowserWindow, ... &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br></pre></td></tr></table></figure>
<p>下面是一些常用的<code>Electron API</code>：</p>
<p><img src="http://www.conardli.top/img/electron/el_8_api.png" alt></p>
<p>在后面的章节我们会选择其中常用的模块进行详细介绍。</p>
<h3 id="4-2-使用-Node-js-的-API"><a href="#4-2-使用-Node-js-的-API" class="headerlink" title="4.2 使用 Node.js 的 API"></a>4.2 使用 Node.js 的 API</h3><p><img src="http://www.conardli.top/img/electron/el_9_node.png" alt></p>
<p>你可以同时在<code>Electron</code>的主进程和渲染进程使用<code>Node.js API</code>，)所有在<code>Node.js</code>可以使用的<code>API</code>，在<code>Electron</code>中同样可以使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shell &#125; <span class="keyword">from</span> <span class="string">"electron"</span>;</span><br><span class="line"><span class="keyword">import</span> os <span class="keyword">from</span> <span class="string">"os"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  shell.showItemInFolder(os.homedir());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有一个非常重要的提示: 原生 Node.js 模块 (即指，需要编译源码过后才能被使用的模块) 需要在编译后才能和 Electron 一起使用。</p>
</blockquote>
<h3 id="4-3-进程通信"><a href="#4-3-进程通信" class="headerlink" title="4.3 进程通信"></a>4.3 进程通信</h3><p>主进程和渲染进程虽然拥有不同的职责，然是他们也需要相互协作，互相通讯。</p>
<blockquote>
<p>例如：在<code>web</code>页面管理原生<code>GUI</code>资源是很危险的，会很容易泄露资源。所以在<code>web</code>页面，不允许直接调用原生<code>GUI</code>相关的<code>API</code>。渲染进程如果想要进行原生的<code>GUI</code>操作，就必须和主进程通讯，请求主进程来完成这些操作。</p>
</blockquote>
<p><img src="http://www.conardli.top/img/electron/el_10_ipc.gif" alt></p>
<h3 id="4-4-渲染进程向主进程通信"><a href="#4-4-渲染进程向主进程通信" class="headerlink" title="4.4 渲染进程向主进程通信"></a>4.4 渲染进程向主进程通信</h3><p><code>ipcRenderer</code> 是一个 <code>EventEmitter</code> 的实例。 你可以使用它提供的一些方法从渲染进程发送同步或异步的消息到主进程。 也可以接收主进程回复的消息。</p>
<p>在渲染进程引入<code>ipcRenderer</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ipcRenderer &#125; <span class="keyword">from</span> <span class="string">"electron"</span>;</span><br></pre></td></tr></table></figure>
<p>异步发送：</p>
<p>通过 <code>channel</code> 发送同步消息到主进程，可以携带任意参数。</p>
<blockquote>
<p>在内部，参数会被序列化为 <code>JSON</code>，因此参数对象上的函数和原型链不会被发送。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ipcRenderer.send(<span class="string">"sync-render"</span>, <span class="string">"我是来自渲染进程的异步消息"</span>);</span><br></pre></td></tr></table></figure>
<p>同步发送：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = ipcRenderer.sendSync(<span class="string">"async-render"</span>, <span class="string">"我是来自渲染进程的同步消息"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 发送同步消息将会阻塞整个渲染进程，直到收到主进程的响应。</p>
</blockquote>
<p>主进程监听消息：</p>
<p><code>ipcMain</code>模块是<code>EventEmitter</code>类的一个实例。 当在主进程中使用时，它处理从渲染器进程（网页）发送出来的异步和同步信息。 从渲染器进程发送的消息将被发送到该模块。</p>
<p><code>ipcMain.on</code>：监听 <code>channel</code>，当接收到新的消息时 <code>listener</code> 会以 <code>listener(event, args...)</code> 的形式被调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ipcMain.on(<span class="string">"sync-render"</span>, (event, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="4-5-主进程向渲染进程通信"><a href="#4-5-主进程向渲染进程通信" class="headerlink" title="4.5 主进程向渲染进程通信"></a>4.5 主进程向渲染进程通信</h3><p><a href="https://imweb.io/topic/5b13a663d4c96b9b1b4c4e9c" target="_blank" rel="noopener">https://imweb.io/topic/5b13a663d4c96b9b1b4c4e9c</a></p>
<p>在主进程中可以通过<code>BrowserWindow</code>的<code>webContents</code>向渲染进程发送消息，所以，在发送消息前你必须先找到对应渲染进程的<code>BrowserWindow</code>对象。：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mainWindow = BrowserWindow.fromId(global.mainId);</span><br><span class="line">mainWindow.webContents.send(<span class="string">"main-msg"</span>, <span class="string">`ConardLi]`</span>);</span><br></pre></td></tr></table></figure>
<p>根据消息来源发送：</p>
<p>在<code>ipcMain</code>接受消息的回调函数中，通过第一个参数<code>event</code>的属性<code>sender</code>可以拿到消息来源渲染进程的<code>webContents</code>对象，我们可以直接用此对象回应消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ipcMain.on(<span class="string">"sync-render"</span>, (event, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  event.sender.send(<span class="string">"main-msg"</span>, <span class="string">"主进程收到了渲染进程的【异步】消息！"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>渲染进程监听：</p>
<p><code>ipcRenderer.on</code>:监听 <code>channel</code>, 当新消息到达，将通过<code>listener(event, args...)</code>调用 <code>listener</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ipcRenderer.on(<span class="string">"main-msg"</span>, (event, msg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="4-6-通信原理"><a href="#4-6-通信原理" class="headerlink" title="4.6 通信原理"></a>4.6 通信原理</h3><p><code>ipcMain</code> 和 <code>ipcRenderer</code> 都是 <code>EventEmitter</code> 类的一个实例。<code>EventEmitter</code> 类是 <code>NodeJS</code> 事件的基础，它由 <code>NodeJS</code> 中的 <code>events</code> 模块导出。</p>
<p><code>EventEmitter</code> 的核心就是事件触发与事件监听器功能的封装。它实现了事件模型需要的接口， 包括 <code>addListener，removeListener</code>, <code>emit</code> 及其它工具方法. 同原生 <code>JavaScript</code> 事件类似， 采用了发布/订阅(观察者)的方式， 使用内部 <code>_events</code> 列表来记录注册的事件处理器。</p>
<p>我们通过 <code>ipcMain</code>和<code>ipcRenderer</code> 的 <code>on、send</code> 进行监听和发送消息都是 <code>EventEmitter</code> 定义的相关接口。</p>
<h3 id="4-7-remote"><a href="#4-7-remote" class="headerlink" title="4.7 remote"></a>4.7 remote</h3><p><code>remote</code> 模块为渲染进程（web 页面）和主进程通信（<code>IPC</code>）提供了一种简单方法。 使用 <code>remote</code> 模块, 你可以调用 <code>main</code> 进程对象的方法, 而不必显式发送进程间消息, 类似于 <code>Java</code> 的 <code>RMI</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; remote &#125; <span class="keyword">from</span> <span class="string">"electron"</span>;</span><br><span class="line"></span><br><span class="line">remote.dialog.showErrorBox(<span class="string">"主进程才有的dialog模块"</span>, <span class="string">"我是使用remote调用的"</span>);</span><br></pre></td></tr></table></figure>
<p><img src="http://www.conardli.top/img/electron/el_11_remote.gif" alt></p>
<p>但实际上，我们在调用远程对象的方法、函数或者通过远程构造函数创建一个新的对象，实际上都是在发送一个同步的进程间消息。</p>
<p>在上面通过 <code>remote</code> 模块调用 <code>dialog</code> 的例子里。我们在渲染进程中创建的 <code>dialog</code> 对象其实并不在我们的渲染进程中，它只是让主进程创建了一个 <code>dialog</code> 对象，并返回了这个相对应的远程对象给了渲染进程。</p>
<h3 id="4-8-渲染进程间通信"><a href="#4-8-渲染进程间通信" class="headerlink" title="4.8 渲染进程间通信"></a>4.8 渲染进程间通信</h3><p><code>Electron</code>并没有提供渲染进程之间相互通信的方式，我们可以在主进程中建立一个消息中转站。</p>
<p>渲染进程之间通信首先发送消息到主进程，主进程的中转站接受到消息后根据条件进行分发。</p>
<h3 id="4-9-渲染进程数据共享"><a href="#4-9-渲染进程数据共享" class="headerlink" title="4.9 渲染进程数据共享"></a>4.9 渲染进程数据共享</h3><p>在两个渲染进程间共享数据最简单的方法是使用浏览器中已经实现的<code>HTML5 API</code>。 其中比较好的方案是用<code>Storage API</code>， <code>localStorage，sessionStorage</code> 或者 <code>IndexedDB。</code></p>
<p>就像在浏览器中使用一样，这种存储相当于在应用程序中永久存储了一部分数据。有时你并不需要这样的存储，只需要在当前应用程序的生命周期内进行一些数据的共享。这时你可以用 <code>Electron</code> 内的 <code>IPC</code> 机制实现。</p>
<p>将数据存在主进程的某个全局变量中，然后在多个渲染进程中使用 <code>remote</code> 模块来访问它。</p>
<p><img src="http://www.conardli.top/img/electron/el_12_global.gif" alt></p>
<p>在主进程中初始化全局变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">global.mainId = ...;</span><br><span class="line">global.device = &#123;...&#125;;</span><br><span class="line">global.__dirname = __dirname;</span><br><span class="line">global.myField = &#123; <span class="attr">name</span>: <span class="string">'ConardLi'</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>在渲染进程中读取：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ipcRenderer, remote &#125; <span class="keyword">from</span> <span class="string">"electron"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; getGlobal &#125; = remote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mainId = getGlobal(<span class="string">"mainId"</span>);</span><br><span class="line"><span class="keyword">const</span> dirname = getGlobal(<span class="string">"__dirname"</span>);</span><br><span class="line"><span class="keyword">const</span> deviecMac = getGlobal(<span class="string">"device"</span>).mac;</span><br></pre></td></tr></table></figure>
<p>在渲染进程中改变：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getGlobal(<span class="string">"myField"</span>).name = <span class="string">"code秘密花园"</span>;</span><br></pre></td></tr></table></figure>
<p>多个渲染进程共享同一个主进程的全局变量，这样即可达到渲染进程数据共享和传递的效果。</p>
<p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>《张扬的日生活》 写在专题开始前</title>
    <url>/2019/02/23/2019-02-23-Life-JianShu-ZY-intro-1/</url>
    <content><![CDATA[<p>有感于生活，最近准备新开一个专题，主要描述来源于生活并高于生活的日常生活。</p>
<p>既然是来源于日常生活，那就免不了柴米油盐，免不了柴米油盐，免不了蒜皮小事，免不了流水账。</p>
<p>篇幅不会太长，每篇 600 字左右吧。不会有太多的写作技法，只是最基本的白描，不带任何感情色彩的白描。</p>
<p>先简单对几个重要人物做个脸谱化的设定，后续提到新人物的时候再进行补充说明。</p>
<p>张扬：85 后，已婚。在一家小公司做程序员，公交车上下班，偶尔加班。</p>
<p>李强：张扬现工作中的小组长。</p>
<p>马琦：张扬前公司的同事。</p>
<a id="more"></a>
<p>万玉：张扬的妻子。90 年，在一家小公司做程序员，离家较远，公交车上下班。</p>
<p>张一中：张扬爸，60 后，之前是农民，现在帮忙带小孩。</p>
<p>刘英：张扬妈，60 后，之前是农民，现在在家带弟弟张明家的小孩。</p>
<p>张明：张扬的弟弟，90 后，已婚。外出打工，一个小孩留在老家由刘英照顾。</p>
<p>张冲：<code>张扬</code>和<code>妻子万玉</code>的孩子。19 个月男宝宝。</p>
<p>这个系列预计更新 100 篇左右，希望自己能坚持下去。</p>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>简书</category>
        <category>张扬的日生活</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>简书</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析虚拟DOM的渲染原理和特性</title>
    <url>/2019/01/22/2019-01-22-Programing-JavaScript-DOM-Intro/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><code>React</code>的虚拟<code>DOM</code>和<code>Diff</code>算法是<code>React</code>的非常重要的核心特性，这部分源码也非常复杂，理解这部分知识的原理对更深入的掌握<code>React</code>是非常必要的。</p>
<p>本来想将虚拟<code>DOM</code>和<code>Diff</code>算法放到一篇文章，写完虚拟<code>DOM</code>发现文章已经很长了，所以本篇只分析虚拟<code>DOM</code>。</p>
<p>本篇文章从源码出发，分析虚拟<code>DOM</code>的核心渲染原理（首次渲染），以及<code>React</code>对它做的性能优化点。</p>
<p>说实话<code>React</code>源码真的很难读 😅，如果本篇文章帮助到了你，那么请给个赞 👍 支持一下吧。</p>
<h2 id="开发中的常见问题"><a href="#开发中的常见问题" class="headerlink" title="开发中的常见问题"></a>开发中的常见问题</h2><ul>
<li>为何必须引用<code>React</code></li>
<li>自定义的<code>React</code>组件为何必须大写</li>
<li><code>React</code>如何防止<code>XSS</code></li>
<li><code>React</code>的<code>Diff</code>算法和其他的<code>Diff</code>算法有何区别</li>
<li><code>key</code>在<code>React</code>中的作用</li>
<li>如何写出高性能的<code>React</code>组件</li>
</ul>
<p>如果你对上面几个问题还存在疑问，说明你对<code>React</code>的虚拟<code>DOM</code>以及<code>Diff</code>算法实现原理还有所欠缺，那么请好好阅读本篇文章吧。</p>
<p>首先我们来看看到底什么是虚拟<code>DOM</code>:</p>
<h2 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h2><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/虚拟dom.png" alt="image"></p>
<p>在原生的<code>JavaScript</code>程序中，我们直接对<code>DOM</code>进行创建和更改，而<code>DOM</code>元素通过我们监听的事件和我们的应用程序进行通讯。</p>
<p>而<code>React</code>会先将你的代码转换成一个<code>JavaScript</code>对象，然后这个<code>JavaScript</code>对象再转换成真实<code>DOM</code>。这个<code>JavaScript</code>对象就是所谓的虚拟<code>DOM</code>。</p>
<p>比如下面一段<code>html</code>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello ConardLi<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在<code>React</code>可能存储为这样的<code>JS</code>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VitrualDom = &#123;</span><br><span class="line">  type: <span class="string">"div"</span>,</span><br><span class="line">  props: &#123; <span class="attr">class</span>: <span class="string">"title"</span> &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">"span"</span>,</span><br><span class="line">      children: <span class="string">"Hello ConardLi"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">"ul"</span>,</span><br><span class="line">      children: [</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">"ul"</span>, <span class="attr">children</span>: <span class="string">"苹果"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">"ul"</span>, <span class="attr">children</span>: <span class="string">"橘子"</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们需要创建或更新元素时，<code>React</code>首先会让这个<code>VitrualDom</code>对象进行创建和更改，然后再将<code>VitrualDom</code>对象渲染成真实<code>DOM</code>；</p>
<p>当我们需要对<code>DOM</code>进行事件监听时，首先对<code>VitrualDom</code>进行事件监听，<code>VitrualDom</code>会代理原生的<code>DOM</code>事件从而做出响应。</p>
<h2 id="为何使用虚拟-DOM"><a href="#为何使用虚拟-DOM" class="headerlink" title="为何使用虚拟 DOM"></a>为何使用虚拟 DOM</h2><p><code>React</code>为何采用<code>VitrualDom</code>这种方案呢？</p>
<h3 id="提高开发效率"><a href="#提高开发效率" class="headerlink" title="提高开发效率"></a>提高开发效率</h3><p>使用<code>JavaScript</code>，我们在编写应用程序时的关注点在于如何更新<code>DOM</code>。</p>
<p>使用<code>React</code>，你只需要告诉<code>React</code>你想让视图处于什么状态，<code>React</code>则通过<code>VitrualDom</code>确保<code>DOM</code>与该状态相匹配。你不必自己去完成属性操作、事件处理、<code>DOM</code>更新，<code>React</code>会替你完成这一切。</p>
<p>这让我们更关注我们的业务逻辑而非<code>DOM</code>操作，这一点即可大大提升我们的开发效率。</p>
<h3 id="关于提升性能"><a href="#关于提升性能" class="headerlink" title="关于提升性能"></a>关于提升性能</h3><p>很多文章说<code>VitrualDom</code>可以提升性能，这一说法实际上是很片面的。</p>
<p>直接操作<code>DOM</code>是非常耗费性能的，这一点毋庸置疑。但是<code>React</code>使用<code>VitrualDom</code>也是无法避免操作<code>DOM</code>的。</p>
<p>如果是首次渲染，<code>VitrualDom</code>不具有任何优势，甚至它要进行更多的计算，消耗更多的内存。</p>
<p><code>VitrualDom</code>的优势在于<code>React</code>的<code>Diff</code>算法和批处理策略，<code>React</code>在页面更新之前，提前计算好了如何进行更新和渲染<code>DOM</code>。实际上，这个计算过程我们在直接操作<code>DOM</code>时，也是可以自己判断和实现的，但是一定会耗费非常多的精力和时间，而且往往我们自己做的是不如<code>React</code>好的。所以，在这个过程中<code>React</code>帮助我们”提升了性能”。</p>
<p>所以，我更倾向于说，<code>VitrualDom</code>帮助我们提高了开发效率，在重复渲染时它帮助我们计算如何更高效的更新，而不是它比<code>DOM</code>操作更快。</p>
<p>如果您对本部分的分析有什么不同见解，欢迎在评论区拍砖。</p>
<h3 id="跨浏览器兼容"><a href="#跨浏览器兼容" class="headerlink" title="跨浏览器兼容"></a>跨浏览器兼容</h3><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/diff3.jpg" alt="image"></p>
<p><code>React</code>基于<code>VitrualDom</code>自己实现了一套自己的事件机制，自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，抹平了各个浏览器的事件兼容性问题。</p>
<h3 id="跨平台兼容"><a href="#跨平台兼容" class="headerlink" title="跨平台兼容"></a>跨平台兼容</h3><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/rn.png" alt="image"></p>
<p><code>VitrualDom</code>为<code>React</code>带来了跨平台渲染的能力。以<code>React Native</code>为例子。<code>React</code>根据<code>VitrualDom</code>画出相应平台的<code>ui</code>层，只不过不同平台画的姿势不同而已。</p>
<h2 id="虚拟-DOM-实现原理"><a href="#虚拟-DOM-实现原理" class="headerlink" title="虚拟 DOM 实现原理"></a>虚拟 DOM 实现原理</h2><p>如果你不想看繁杂的源码，或者现在没有足够时间，可以跳过这一章，直接 👇<a href="#虚拟DOM原理、特性总结">虚拟 DOM 原理总结</a></p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/虚拟dom2.png" alt="image"></p>
<p>在上面的图上我们继续进行扩展，按照图中的流程，我们依次来分析虚拟<code>DOM</code>的实现原理。</p>
<h3 id="JSX-和-createElement"><a href="#JSX-和-createElement" class="headerlink" title="JSX 和 createElement"></a>JSX 和 createElement</h3><p>我们在实现一个<code>React</code>组件时可以选择两种编码方式，第一种是使用<code>JSX</code>编写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello ConardLi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种是直接使用<code>React.createElement</code>编写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="string">`Hello ConardLi`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，上面两种写法是等价的，<code>JSX</code>只是为 <code>React.createElement(component, props, ...children)</code>方法提供的语法糖。也就是说所有的<code>JSX</code>代码最后都会转换成<code>React.createElement(...)</code>，<code>Babel</code>帮助我们完成了这个转换的过程。</p>
<p>如下面的<code>JSX</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;img src=<span class="string">"avatar.png"</span> className=<span class="string">"profile"</span> /&gt;</span><br><span class="line">  &lt;Hello /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>将会被<code>Babel</code>转换为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">"div"</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  React.createElement(<span class="string">"img"</span>, &#123;</span><br><span class="line">    src: <span class="string">"avatar.png"</span>,</span><br><span class="line">    className: <span class="string">"profile"</span></span><br><span class="line">  &#125;),</span><br><span class="line">  React.createElement(Hello, <span class="literal">null</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意，<code>babel</code>在编译时会判断<code>JSX</code>中组件的首字母，当首字母为小写时，其被认定为原生<code>DOM</code>标签，<code>createElement</code>的第一个变量被编译为字符串；当首字母为大写时，其被认定为自定义组件，<code>createElement</code>的第一个变量被编译为对象；</p>
<p>另外，由于<code>JSX</code>提前要被<code>Babel</code>编译，所以<code>JSX</code>是不能在运行时动态选择类型的，比如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Story</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Wrong! JSX type can't be an expression.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">components[props.storyType]</span> <span class="attr">story</span>=<span class="string">&#123;props.story&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>需要变成下面的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Story</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Correct! JSX type can be a capitalized variable.</span></span><br><span class="line">  <span class="keyword">const</span> SpecificStory = components[props.storyType];</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SpecificStory</span> <span class="attr">story</span>=<span class="string">&#123;props.story&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>所以，使用<code>JSX</code>你需要安装<code>Babel</code>插件<code>babel-plugin-transform-react-jsx</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"transform-react-jsx"</span>, &#123;</span><br><span class="line">            <span class="string">"pragma"</span>: <span class="string">"React.createElement"</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建虚拟-DOM"><a href="#创建虚拟-DOM" class="headerlink" title="创建虚拟 DOM"></a>创建虚拟 DOM</h3><p>下面我们来看看虚拟<code>DOM</code>的真实模样，将下面的<code>JSX</code>代码在控制台打印出来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello ConardLi<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/diff2.png" alt="image"></p>
<p>这个结构和我们上面自己描绘的结构很像，那么<code>React</code>是如何将我们的代码转换成这个结构的呢，下面我们来看看<code>createElement</code>函数的具体实现（文中的源码经过精简）。</p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/vdom1.png" alt="image"></p>
<p><code>createElement</code>函数内部做的操作很简单，将<code>props</code>和子元素进行处理后返回一个<code>ReactElement</code>对象，下面我们来逐一分析：</p>
<p><strong>(1).处理 props：</strong></p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/vdom2.png" alt="image"></p>
<ul>
<li>1.将特殊属性<code>ref</code>、<code>key</code>从<code>config</code>中取出并赋值</li>
<li>2.将特殊属性<code>self</code>、<code>source</code>从<code>config</code>中取出并赋值</li>
<li>3.将除特殊属性的其他属性取出并赋值给<code>props</code></li>
</ul>
<p>后面的文章会详细介绍这些特殊属性的作用。</p>
<p><strong>(2).获取子元素</strong></p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/vdom3.png" alt="image"></p>
<ul>
<li>1.获取子元素的个数 —— 第二个参数后面的所有参数</li>
<li>2.若只有一个子元素，赋值给<code>props.children</code></li>
<li>3.若有多个子元素，将子元素填充为一个数组赋值给<code>props.children</code></li>
</ul>
<p><strong>(3).处理默认 props</strong></p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/vdom4.png" alt="image"></p>
<ul>
<li>将组件的静态属性<code>defaultProps</code>定义的默认<code>props</code>进行赋值</li>
</ul>
<p><strong>ReactElement</strong></p>
<p><code>ReactElement</code>将传入的几个属性进行组合，并返回。</p>
<ul>
<li><code>type</code>：元素的类型，可以是原生 html 类型（字符串），或者自定义组件（函数或<code>class</code>）</li>
<li><code>key</code>：组件的唯一标识，用于<code>Diff</code>算法，下面会详细介绍</li>
<li><code>ref</code>：用于访问原生<code>dom</code>节点</li>
<li><code>props</code>：传入组件的<code>props</code></li>
<li><code>owner</code>：当前正在构建的<code>Component</code>所属的<code>Component</code></li>
</ul>
<p><code>$$typeof</code>：一个我们不常见到的属性，它被赋值为<code>REACT_ELEMENT_TYPE</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> REACT_ELEMENT_TYPE =</span><br><span class="line">  (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="built_in">Symbol</span>.for &amp;&amp; <span class="built_in">Symbol</span>.for(<span class="string">"react.element"</span>)) ||</span><br><span class="line">  <span class="number">0xeac7</span>;</span><br></pre></td></tr></table></figure>
<p>可见，<code>$$typeof</code>是一个<code>Symbol</code>类型的变量，这个变量可以防止<code>XSS</code>。</p>
<p>如果你的服务器有一个漏洞，允许用户存储任意<code>JSON</code>对象， 而客户端代码需要一个字符串，这可能会成为一个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSON</span></span><br><span class="line"><span class="keyword">let</span> expectedTextButGotJSON = &#123;</span><br><span class="line">  type: <span class="string">"div"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    dangerouslySetInnerHTML: &#123;</span><br><span class="line">      __html: <span class="string">"/* put your exploit here */"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> message = &#123; <span class="attr">text</span>: expectedTextButGotJSON &#125;;</span><br><span class="line">&lt;p&gt;&#123;message.text&#125;&lt;<span class="regexp">/p&gt;;</span></span><br></pre></td></tr></table></figure>
<p><code>JSON</code>中不能存储<code>Symbol</code>类型的变量。</p>
<p><code>ReactElement.isValidElement</code>函数用来判断一个<code>React</code>组件是否是有效的，下面是它的具体实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="keyword">typeof</span> object === <span class="string">"object"</span> &amp;&amp;</span><br><span class="line">    object !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可见<code>React</code>渲染时会把没有<code>$$typeof</code>标识，以及规则校验不通过的组件过滤掉。</p>
<p>当你的环境不支持<code>Symbol</code>时，<code>$$typeof</code>被赋值为<code>0xeac7</code>，至于为什么，<code>React</code>开发者给出了答案：</p>
<blockquote>
<p><code>0xeac7</code>看起来有点像<code>React</code>。</p>
</blockquote>
<p><code>self</code>、<code>source</code>只有在非生产环境才会被加入对象中。</p>
<ul>
<li><code>self</code>指定当前位于哪个组件实例。</li>
<li><code>_source</code>指定调试代码来自的文件(<code>fileName</code>)和代码行数(<code>lineNumber</code>)。</li>
</ul>
<h3 id="虚拟-DOM-转换为真实-DOM"><a href="#虚拟-DOM-转换为真实-DOM" class="headerlink" title="虚拟 DOM 转换为真实 DOM"></a>虚拟 DOM 转换为真实 DOM</h3><p>上面我们分析了代码转换成了虚拟<code>DOM</code>的过程，下面来看一下<code>React</code>如何将虚拟<code>DOM</code>转换成真实<code>DOM</code>。</p>
<p>本部分逻辑较复杂，我们先用流程图梳理一下整个过程，整个过程大概可分为四步：</p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/diff4.png" alt="image"></p>
<p><strong>过程 1：初始参数处理</strong></p>
<p>在编写好我们的<code>React</code>组件后，我们需要调用<code>ReactDOM.render(element, container[, callback])</code>将组件进行渲染。</p>
<p><code>render</code>函数内部实际调用了<code>_renderSubtreeIntoContainer</code>，我们来看看它的具体实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">nextElement, container, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ReactMount._renderSubtreeIntoContainer(<span class="literal">null</span>, nextElement, container, callback);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/vdom6.png" alt="image"></p>
<ul>
<li>1.将当前组件使用<code>TopLevelWrapper</code>进行包裹</li>
</ul>
<p><code>TopLevelWrapper</code>只一个空壳，它为你需要挂载的组件提供了一个<code>rootID</code>属性，并在<code>render</code>函数中返回该组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">TopLevelWrapper.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props.child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ReactDOM.render</code>函数的第一个参数可以是原生<code>DOM</code>也可以是<code>React</code>组件，包裹一层<code>TopLevelWrapper</code>可以在后面的渲染中将它们进行统一处理，而不用关心是否原生。</p>
<ul>
<li>2.判断根结点下是否已经渲染过元素，如果已经渲染过，判断执行更新或者卸载操作</li>
<li>3.处理<code>shouldReuseMarkup</code>变量，该变量表示是否需要重新标记元素</li>
<li>4.调用将上面处理好的参数传入<code>_renderNewRootComponent</code>，渲染完成后调用<code>callback</code>。</li>
</ul>
<p>在<code>_renderNewRootComponent</code>中调用<code>instantiateReactComponent</code>对我们传入的组件进行分类包装：</p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/vdom7.png" alt="image"></p>
<p>根据组件的类型，<code>React</code>根据原组件创建了下面四大类组件，对组件进行分类渲染：</p>
<ul>
<li><code>ReactDOMEmptyComponent</code>:空组件</li>
<li><code>ReactDOMTextComponent</code>:文本</li>
<li><code>ReactDOMComponent</code>:原生<code>DOM</code></li>
<li><code>ReactCompositeComponent</code>:自定义<code>React</code>组件</li>
</ul>
<p>他们都具备以下三个方法：</p>
<ul>
<li><code>construct</code>:用来接收<code>ReactElement</code>进行初始化。</li>
<li><code>mountComponent</code>:用来生成<code>ReactElement</code>对应的真实<code>DOM</code>或<code>DOMLazyTree</code>。</li>
<li><code>unmountComponent</code>:卸载<code>DOM</code>节点，解绑事件。</li>
</ul>
<p>具体是如何渲染我们在过程 3 中进行分析。</p>
<p><strong>过程 2：批处理、事务调用</strong></p>
<p>在<code>_renderNewRootComponent</code>中使用<code>ReactUpdates.batchedUpdates</code>调用<code>batchedMountComponentIntoNode</code>进行批处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactUpdates.batchedUpdates(</span><br><span class="line">  batchedMountComponentIntoNode,</span><br><span class="line">  componentInstance,</span><br><span class="line">  container,</span><br><span class="line">  shouldReuseMarkup,</span><br><span class="line">  context</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在<code>batchedMountComponentIntoNode</code>中，使用<code>transaction.perform</code>调用<code>mountComponentIntoNode</code>让其基于事务机制进行调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">transaction.perform(</span><br><span class="line">  mountComponentIntoNode,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  componentInstance,</span><br><span class="line">  container,</span><br><span class="line">  transaction,</span><br><span class="line">  shouldReuseMarkup,</span><br><span class="line">  context</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>关于批处理事务，在我前面的分析<a href="https://juejin.im/post/5c71050ef265da2db27938b5" target="_blank" rel="noopener">setState 执行机制</a>中有更多介绍。</p>
<p><strong>过程 3：生成 html</strong></p>
<p>在<code>mountComponentIntoNode</code>函数中调用<code>ReactReconciler.mountComponent</code>生成原生<code>DOM</code>节点。</p>
<p><code>mountComponent</code>内部实际上是调用了过程 1 生成的四种对象的<code>mountComponent</code>方法。首先来看一下<code>ReactDOMComponent</code>：</p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/diff5.png" alt="image"></p>
<ul>
<li>1.对特殊<code>DOM</code>标签、<code>props</code>进行处理。</li>
<li>2.根据标签类型创建<code>DOM</code>节点。</li>
<li>3.调用<code>_updateDOMProperties</code>将<code>props</code>插入到<code>DOM</code>节点，<code>_updateDOMProperties</code>也可用于<code>props Diff</code>，第一个参数为上次渲染的<code>props</code>，第二个参数为当前<code>props</code>，若第一个参数为空，则为首次创建。</li>
<li>4.生成一个<code>DOMLazyTree</code>对象并调用<code>_createInitialChildren</code>将孩子节点渲染到上面。</li>
</ul>
<p>那么为什么不直接生成一个<code>DOM</code>节点而是要创建一个<code>DOMLazyTree</code>呢？我们先来看看<code>_createInitialChildren</code>做了什么：</p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/vdom9.png" alt="image"></p>
<p>判断当前节点的<code>dangerouslySetInnerHTML</code>属性、孩子节点是否为文本和其他节点分别调用<code>DOMLazyTree</code>的<code>queueHTML</code>、<code>queueText</code>、<code>queueChild</code>。</p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/vdom10.png" alt="image"></p>
<p>可以发现：<code>DOMLazyTree</code>实际上是一个包裹对象，<code>node</code>属性中存储了真实的<code>DOM</code>节点，<code>children</code>、<code>html</code>、<code>text</code>分别存储孩子、html 节点和文本节点。</p>
<p>它提供了几个方法用于插入孩子、<code>html</code>以及文本节点，这些插入都是有条件限制的，当<code>enableLazy</code>属性为<code>true</code>时，这些孩子、<code>html</code>以及文本节点会被插入到<code>DOMLazyTree</code>对象中，当其为<code>false</code>时会插入到真实<code>DOM</code>节点中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> enableLazy =</span><br><span class="line">  (<span class="keyword">typeof</span> <span class="built_in">document</span> !== <span class="string">"undefined"</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">document</span>.documentMode === <span class="string">"number"</span>) ||</span><br><span class="line">  (<span class="keyword">typeof</span> navigator !== <span class="string">"undefined"</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> navigator.userAgent === <span class="string">"string"</span> &amp;&amp;</span><br><span class="line">    /\bEdge\/\d/.test(navigator.userAgent));</span><br></pre></td></tr></table></figure>
<p>可见：<code>enableLazy</code>是一个变量，当前浏览器是<code>IE</code>或<code>Edge</code>时为<code>true</code>。</p>
<p>在<code>IE（8-11）</code>和<code>Edge</code>浏览器中，一个一个插入无子孙的节点，效率要远高于插入一整个序列化完整的节点树。</p>
<p>所以<code>lazyTree</code>主要解决的是在<code>IE（8-11）</code>和<code>Edge</code>浏览器中插入节点的效率问题，在后面的过程 4 我们会分析到：若当前是<code>IE</code>或<code>Edge</code>，则需要递归插入<code>DOMLazyTree</code>中缓存的子节点，其他浏览器只需要插入一次当前节点，因为他们的孩子已经被渲染好了，而不用担心效率问题。</p>
<p>下面来看一下<code>ReactCompositeComponent</code>，由于代码非常多这里就不再贴这个模块的代码，其内部主要做了以下几步：</p>
<ul>
<li>处理<code>props</code>、<code>contex</code>等变量，调用构造函数创建组件实例</li>
<li>判断是否为无状态组件，处理<code>state</code></li>
<li>调用<code>performInitialMount</code>生命周期，处理子节点，获取<code>markup</code>。</li>
<li>调用<code>componentDidMount</code>生命周期</li>
</ul>
<p>在<code>performInitialMount</code>函数中，首先调用了<code>componentWillMount</code>生命周期，由于自定义的<code>React</code>组件并不是一个真实的 DOM，所以在函数中又调用了孩子节点的<code>mountComponent</code>。这也是一个递归的过程，当所有孩子节点渲染完成后，返回<code>markup</code>并调用<code>componentDidMount</code>。</p>
<p><strong>过程 4：渲染 html</strong></p>
<p>在<code>mountComponentIntoNode</code>函数中调用将上一步生成的<code>markup</code>插入<code>container</code>容器。</p>
<p>在首次渲染时，<code>_mountImageIntoNode</code>会清空<code>container</code>的子节点后调用<code>DOMLazyTree.insertTreeBefore</code>：</p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/vdom5.png" alt="image"></p>
<p>判断是否为<code>fragment</code>节点或者<code>&lt;object&gt;</code>插件：</p>
<ul>
<li><p>如果是以上两种，首先调用<code>insertTreeChildren</code>将此节点的孩子节点渲染到当前节点上，再将渲染完的节点插入到<code>html</code></p>
</li>
<li><p>如果是其他节点，先将节点插入到插入到<code>html</code>，再调用<code>insertTreeChildren</code>将孩子节点插入到<code>html</code>。</p>
</li>
<li><p>若当前不是<code>IE</code>或<code>Edge</code>，则不需要再递归插入子节点，只需要插入一次当前节点。</p>
</li>
</ul>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/vdom8.png" alt="image"></p>
<ul>
<li>判断不是<code>IE</code>或<code>bEdge</code>时<code>return</code></li>
<li>若<code>children</code>不为空，递归<code>insertTreeBefore</code>进行插入</li>
<li>渲染 html 节点</li>
<li>渲染文本节点</li>
</ul>
<h3 id="原生-DOM-事件代理"><a href="#原生-DOM-事件代理" class="headerlink" title="原生 DOM 事件代理"></a>原生 DOM 事件代理</h3><p>有关虚拟<code>DOM</code>的事件机制，我曾专门写过一篇文章，有兴趣可以 👇<a href="https://juejin.im/post/5c7df2e7f265da2d8a55d49d" target="_blank" rel="noopener">【React 深入】React 事件机制</a></p>
<h2 id="虚拟-DOM-原理、特性总结"><a href="#虚拟-DOM-原理、特性总结" class="headerlink" title="虚拟 DOM 原理、特性总结"></a>虚拟 DOM 原理、特性总结</h2><h3 id="React-组件的渲染流程"><a href="#React-组件的渲染流程" class="headerlink" title="React 组件的渲染流程"></a>React 组件的渲染流程</h3><ul>
<li><p>使用<code>React.createElement</code>或<code>JSX</code>编写<code>React</code>组件，实际上所有的<code>JSX</code>代码最后都会转换成<code>React.createElement(...)</code>，<code>Babel</code>帮助我们完成了这个转换的过程。</p>
</li>
<li><p><code>createElement</code>函数对<code>key</code>和<code>ref</code>等特殊的<code>props</code>进行处理，并获取<code>defaultProps</code>对默认<code>props</code>进行赋值，并且对传入的孩子节点进行处理，最终构造成一个<code>ReactElement</code>对象（所谓的虚拟<code>DOM</code>）。</p>
</li>
<li><p><code>ReactDOM.render</code>将生成好的虚拟<code>DOM</code>渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实<code>DOM</code>。</p>
</li>
</ul>
<h3 id="虚拟-DOM-的组成"><a href="#虚拟-DOM-的组成" class="headerlink" title="虚拟 DOM 的组成"></a>虚拟 DOM 的组成</h3><p>即<code>ReactElement</code>element 对象，我们的组件最终会被渲染成下面的结构：</p>
<ul>
<li><code>type</code>：元素的类型，可以是原生 html 类型（字符串），或者自定义组件（函数或<code>class</code>）</li>
<li><code>key</code>：组件的唯一标识，用于<code>Diff</code>算法，下面会详细介绍</li>
<li><code>ref</code>：用于访问原生<code>dom</code>节点</li>
<li><code>props</code>：传入组件的<code>props</code>，<code>chidren</code>是<code>props</code>中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点）</li>
<li><code>owner</code>：当前正在构建的<code>Component</code>所属的<code>Component</code></li>
<li><code>self</code>：（非生产环境）指定当前位于哪个组件实例</li>
<li><code>_source</code>：（非生产环境）指定调试代码来自的文件(<code>fileName</code>)和代码行数(<code>lineNumber</code>)</li>
</ul>
<h3 id="防止-XSS"><a href="#防止-XSS" class="headerlink" title="防止 XSS"></a>防止 XSS</h3><p><code>ReactElement</code>对象还有一个<code>$$typeof</code>属性，它是一个<code>Symbol</code>类型的变量<code>Symbol.for(&#39;react.element&#39;)</code>，当环境不支持<code>Symbol</code>时，<code>$$typeof</code>被赋值为<code>0xeac7</code>。</p>
<p>这个变量可以防止<code>XSS</code>。如果你的服务器有一个漏洞，允许用户存储任意<code>JSON</code>对象， 而客户端代码需要一个字符串，这可能为你的应用程序带来风险。<code>JSON</code>中不能存储<code>Symbol</code>类型的变量，而<code>React</code>渲染时会把没有<code>$$typeof</code>标识的组件过滤掉。</p>
<h3 id="批处理和事务"><a href="#批处理和事务" class="headerlink" title="批处理和事务"></a>批处理和事务</h3><p><code>React</code>在渲染虚拟<code>DOM</code>时应用了批处理以及事务机制，以提高渲染性能。</p>
<p>关于批处理以及事务机制，在我之前的文章<a href="https://juejin.im/post/5c71050ef265da2db27938b5" target="_blank" rel="noopener">【React 深入】setState 的执行机制</a>中有详细介绍。</p>
<h3 id="针对性的性能优化"><a href="#针对性的性能优化" class="headerlink" title="针对性的性能优化"></a>针对性的性能优化</h3><p>在<code>IE（8-11）</code>和<code>Edge</code>浏览器中，一个一个插入无子孙的节点，效率要远高于插入一整个序列化完整的节点树。</p>
<p><code>React</code>通过<code>lazyTree</code>，在<code>IE（8-11）</code>和<code>Edge</code>中进行单个节点依次渲染节点，而在其他浏览器中则首先将整个大的<code>DOM</code>结构构建好，然后再整体插入容器。</p>
<p>并且，在单独渲染节点时，<code>React</code>还考虑了<code>fragment</code>等特殊节点，这些节点则不会一个一个插入渲染。</p>
<h3 id="虚拟-DOM-事件机制"><a href="#虚拟-DOM-事件机制" class="headerlink" title="虚拟 DOM 事件机制"></a>虚拟 DOM 事件机制</h3><p><code>React</code>自己实现了一套事件机制，其将所有绑定在虚拟<code>DOM</code>上的事件映射到真正的<code>DOM</code>事件，并将所有的事件都代理到<code>document</code>上，自己模拟了事件冒泡和捕获的过程，并且进行统一的事件分发。</p>
<p><code>React</code>自己构造了合成事件对象<code>SyntheticEvent</code>，这是一个跨浏览器原生事件包装器。 它具有与浏览器原生事件相同的接口，包括<code>stopPropagation()</code>和<code>preventDefault()</code>等等，在所有浏览器中他们工作方式都相同。这抹平了各个浏览器的事件兼容性问题。</p>
<p>上面只分析虚拟<code>DOM</code>首次渲染的原理和过程，当然这并不包括虚拟 <code>DOM</code>进行 <code>Diff</code>的过程，下一篇文章我们再来详细探讨。</p>
<p>关于开篇提的几个问题，我们在下篇文章中进行统一回答。</p>
<h2 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h2><p>文中如有错误，欢迎在评论区指正，或者您对文章的排版，阅读体验有什么好的建议，欢迎在评论区指出，谢谢阅读。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>setState的执行机制</title>
    <url>/2019/01/19/2019-01-19-Programing-JavaScript-setState-run-flow/</url>
    <content><![CDATA[<h2 id="一-几个开发中经常会遇到的问题"><a href="#一-几个开发中经常会遇到的问题" class="headerlink" title="一.几个开发中经常会遇到的问题"></a>一.几个开发中经常会遇到的问题</h2><p>以下几个问题是我们在实际开发中经常会遇到的场景，下面用几个简单的示例代码来还原一下。</p>
<h4 id="1-setState-是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以"><a href="#1-setState-是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以" class="headerlink" title="1.setState 是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以?"></a>1.setState 是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以?</h4><p>1.1 钩子函数和 React 合成事件中的<code>setState</code></p>
<p>现在有两个组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'parent componentDidMount'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;SetState2&gt;<span class="xml"><span class="tag">&lt;/<span class="name">SetState2</span>&gt;</span></span></span><br><span class="line">      &lt;SetState&gt;<span class="xml"><span class="tag">&lt;/<span class="name">SetState</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>组件内部放入同样的代码，并在<code>Setstate1</code>中的<code>componentDidMount</code>中放入一段同步延时代码，打印延时时间：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">componentWillUpdate() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'SetState调用setState'</span>);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    index: <span class="keyword">this</span>.state.index + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'state'</span>, <span class="keyword">this</span>.state.index);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'SetState调用setState'</span>);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    index: <span class="keyword">this</span>.state.index + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'state'</span>, <span class="keyword">this</span>.state.index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是执行结果：<br><a id="more"></a><br><img src="https://user-gold-cdn.xitu.io/2019/2/23/169197bbda942d55?w=332&amp;h=337&amp;f=png&amp;s=37749" alt="image"></p>
<p>说明：</p>
<ul>
<li>1.调用<code>setState</code>不会立即更新</li>
<li>2.所有组件使用的是同一套更新机制，当所有组件<code>didmount</code>后，父组件<code>didmount</code>，然后执行更新</li>
<li><p>3.更新时会把每个组件的更新合并，每个组件只会触发一次更新的生命周期。</p>
<p>1.2 异步函数和原生事件中的<code>setstate</code>？</p>
</li>
</ul>
<p>在<code>setTimeout</code>中调用<code>setState</code>（例子和在浏览器原生事件以及接口回调中执行效果相同）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;调用setState&apos;);</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      index: this.state.index + 1</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(&apos;state&apos;, this.state.index);</span><br><span class="line">    console.log(&apos;调用setState&apos;);</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      index: this.state.index + 1</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(&apos;state&apos;, this.state.index);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/23/169197bbda86af04?w=244&amp;h=219&amp;f=png&amp;s=20237" alt="image"></p>
<p>说明：</p>
<ul>
<li>1.在父组件<code>didmount</code>后执行</li>
<li>2.调用<code>setState</code>同步更新</li>
</ul>
<h4 id="2-为什么有时连续两次setState只有一次生效？"><a href="#2-为什么有时连续两次setState只有一次生效？" class="headerlink" title="2.为什么有时连续两次setState只有一次生效？"></a>2.为什么有时连续两次<code>setState</code>只有一次生效？</h4><p>分别执行以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span> &#125;, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span> &#125;, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">preState</span>) =&gt;</span> <span class="function">(<span class="params">&#123; index: preState.index + <span class="number">1</span> &#125;</span>), <span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> <span class="function">(<span class="params">&#123; index: preState.index + <span class="number">1</span> &#125;</span>), <span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>1.直接传递对象的<code>setstate</code>会被合并成一次</li>
<li>2.使用函数传递<code>state</code>不会被合并</li>
</ul>
<h2 id="二-setState-执行过程"><a href="#二-setState-执行过程" class="headerlink" title="二.setState 执行过程"></a>二.setState 执行过程</h2><p>由于源码比较复杂，就不贴在这里了，有兴趣的可以去<code>github</code>上<code>clone</code>一份然后按照下面的流程图去走一遍。</p>
<h3 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1.流程图"></a>1.流程图</h3><p><img src="https://user-gold-cdn.xitu.io/2019/2/23/169197bbdc7ae14e?w=982&amp;h=2387&amp;f=png&amp;s=147606" alt="setState"></p>
<ul>
<li><code>partialState</code>：<code>setState</code>传入的第一个参数，对象或函数</li>
<li><code>_pendingStateQueue</code>：当前组件等待执行更新的<code>state</code>队列</li>
<li><code>isBatchingUpdates</code>：react 用于标识当前是否处于批量更新状态，所有组件公用</li>
<li><code>dirtyComponent</code>：当前所有处于待更新状态的组件队列</li>
<li><code>transcation</code>：react 的事务机制，在被事务调用的方法外包装 n 个<code>waper</code>对象，并一次执行：<code>waper.init</code>、被调用方法、<code>waper.close</code></li>
<li><code>FLUSH_BATCHED_UPDATES</code>：用于执行更新的<code>waper</code>，只有一个<code>close</code>方法</li>
</ul>
<h3 id="2-执行过程"><a href="#2-执行过程" class="headerlink" title="2.执行过程"></a>2.执行过程</h3><p>对照上面流程图的文字说明，大概可分为以下几步：</p>
<ul>
<li>1.将 setState 传入的<code>partialState</code>参数存储在当前组件实例的 state 暂存队列中。</li>
<li>2.判断当前 React 是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。</li>
<li>3.如果未处于批量更新状态，将批量更新状态标识设置为 true，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。</li>
<li>4.调用事务的<code>waper</code>方法，遍历待更新组件队列依次执行更新。</li>
<li>5.执行生命周期<code>componentWillReceiveProps</code>。</li>
<li>6.将组件的 state 暂存队列中的<code>state</code>进行合并，获得最终要更新的 state 对象，并将队列置为空。</li>
<li>7.执行生命周期<code>componentShouldUpdate</code>，根据返回值判断是否要继续更新。</li>
<li>8.执行生命周期<code>componentWillUpdate</code>。</li>
<li>9.执行真正的更新，<code>render</code>。</li>
<li>10.执行生命周期<code>componentDidUpdate</code>。</li>
</ul>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h2><h3 id="1-钩子函数和合成事件中："><a href="#1-钩子函数和合成事件中：" class="headerlink" title="1.钩子函数和合成事件中："></a>1.钩子函数和合成事件中：</h3><p>在<code>react</code>的生命周期和合成事件中，<code>react</code>仍然处于他的更新机制中，这时<code>isBranchUpdate</code>为 true。</p>
<p>按照上述过程，这时无论调用多少次<code>setState</code>，都会不会执行更新，而是将要更新的<code>state</code>存入<code>_pendingStateQueue</code>，将要更新的组件存入<code>dirtyComponent</code>。</p>
<p>当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件<code>didmount</code>后会将<code>isBranchUpdate</code>设置为 false。这时将执行之前累积的<code>setState</code>。</p>
<h3 id="2-异步函数和原生事件中"><a href="#2-异步函数和原生事件中" class="headerlink" title="2.异步函数和原生事件中"></a>2.异步函数和原生事件中</h3><p>由执行机制看，<code>setState</code>本身并不是异步的，而是如果在调用<code>setState</code>时，如果<code>react</code>正处于更新过程，当前更新会被暂存，等上一次更新执行后在执行，这个过程给人一种异步的假象。</p>
<p>在生命周期，根据 JS 的异步机制，会将异步函数先暂存，等所有同步代码执行完毕后在执行，这时上一次更新过程已经执行完毕，<code>isBranchUpdate</code>被设置为 false，根据上面的流程，这时再调用<code>setState</code>即可立即执行更新，拿到更新结果。</p>
<h3 id="3-partialState合并机制"><a href="#3-partialState合并机制" class="headerlink" title="3.partialState合并机制"></a>3.<code>partialState</code>合并机制</h3><p>我们看下流程中<code>_processPendingState</code>的代码，这个函数是用来合并<code>state</code>暂存队列的，最后返回一个合并后的<code>state</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">_processPendingState: <span class="function"><span class="keyword">function</span> (<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="keyword">this</span>._pendingStateQueue;</span><br><span class="line">  <span class="keyword">var</span> replace = <span class="keyword">this</span>._pendingReplaceState;</span><br><span class="line">  <span class="keyword">this</span>._pendingReplaceState = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>._pendingStateQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!queue) &#123;</span><br><span class="line">    <span class="keyword">return</span> inst.state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (replace &amp;&amp; queue.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> queue[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> nextState = _assign(&#123;&#125;, replace ? queue[<span class="number">0</span>] : inst.state);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = replace ? <span class="number">1</span> : <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> partial = queue[i];</span><br><span class="line">    _assign(nextState, <span class="keyword">typeof</span> partial === <span class="string">'function'</span> ? partial.call(inst, nextState, props, context) : partial);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nextState;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>我们只需要关注下面  这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_assign(</span><br><span class="line">  nextState,</span><br><span class="line">  <span class="keyword">typeof</span> partial === <span class="string">"function"</span></span><br><span class="line">    ? partial.call(inst, nextState, props, context)</span><br><span class="line">    : partial</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果传入的是对象，很明显会被合并成一次：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">  nextState,</span><br><span class="line">  &#123; <span class="attr">index</span>: state.index + <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">index</span>: state.index + <span class="number">1</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果传入的是函数，函数的参数 preState 是前一次合并后的结果，所以计算结果是准确的。</p>
<h3 id="4-componentDidMount-调用-setstate"><a href="#4-componentDidMount-调用-setstate" class="headerlink" title="4.componentDidMount 调用 setstate"></a>4.componentDidMount 调用 setstate</h3><blockquote>
<p>在 componentDidMount()中，你 可以立即调用 setState()。它将会触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了在此情况下即使 render()将会调用两次，用户也不会看到中间状态。谨慎使用这一模式，因为它常导致性能问题。在大多数情况下，你可以 在 constructor()中使用赋值初始状态来代替。然而，有些情况下必须这样，比如像模态框和工具提示框。这时，你需要先测量这些 DOM 节点，才能渲染依赖尺寸或者位置的某些东西。</p>
</blockquote>
<p>以上是官方文档的说明，不推荐直接在<code>componentDidMount</code>直接调用<code>setState</code>，由上面的分析：<code>componentDidMount</code>本身处于一次更新中，我们又调用了一次<code>setState</code>，就会在未来再进行一次<code>render</code>，造成不必要的性能浪费，大多数情况可以设置初始值来搞定。</p>
<p>当然在<code>componentDidMount</code>我们可以调用接口，再回调中去修改<code>state</code>，这是正确的做法。</p>
<p>当 state 初始值依赖 dom 属性时，在<code>componentDidMount</code>中<code>setState</code>是无法避免的。</p>
<h3 id="5-componentWillUpdate、componentDidUpdate"><a href="#5-componentWillUpdate、componentDidUpdate" class="headerlink" title="5.componentWillUpdate、componentDidUpdate"></a>5.componentWillUpdate、componentDidUpdate</h3><p>这两个生命周期中不能调用<code>setState</code>。</p>
<p>由上面的流程图很容易发现，在它们里面调用<code>setState</code>会造成死循环，导致程序崩溃。</p>
<h3 id="6-推荐使用方式"><a href="#6-推荐使用方式" class="headerlink" title="6.推荐使用方式"></a>6.推荐使用方式</h3><p>在调用<code>setState</code>时使用函数传递<code>state</code>值，在回调函数中获取最新更新后的<code>state</code>。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-01-11-Programing-React-event-handler</title>
    <url>/2019/01/11/2019-01-11-Programing-JavaScript-event-handler/</url>
    <content><![CDATA[<h2 id="关于-React-事件的疑问"><a href="#关于-React-事件的疑问" class="headerlink" title="关于 React 事件的疑问"></a>关于 React 事件的疑问</h2><ul>
<li><p>1.为什么要手动绑定<code>this</code></p>
</li>
<li><p>2.<code>React</code>事件和原生事件有什么区别</p>
</li>
<li><p>3.<code>React</code>事件和原生事件的执行顺序，可以混用吗</p>
</li>
<li><p>4.<code>React</code>事件如何解决跨浏览器兼容</p>
</li>
<li><p>5.什么是合成事件</p>
</li>
</ul>
<p>下面是我阅读过源码后，将所有的执行流程总结出来的流程图，不会贴代码，如果你想阅读代码看看具体是如何实现的，可以根据流程图去源码里寻找。</p>
<h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/事件注册.png" alt="image"></p>
<ul>
<li>组件装载 / 更新。</li>
<li>通过<code>lastProps</code>、<code>nextProps</code>判断是否新增、删除事件分别调用事件注册、卸载方法。</li>
<li>调用<code>EventPluginHub</code>的<code>enqueuePutListener</code>进行事件存储</li>
<li>获取<code>document</code>对象。</li>
<li>根据事件名称（如<code>onClick</code>、<code>onCaptureClick</code>）判断是进行冒泡还是捕获。</li>
<li>判断是否存在<code>addEventListener</code>方法，否则使用<code>attachEvent</code>（兼容 IE）。</li>
<li>给<code>document</code>注册原生事件回调为<code>dispatchEvent</code>（统一的事件分发机制）。</li>
</ul>
<h2 id="事件存储"><a href="#事件存储" class="headerlink" title="事件存储"></a>事件存储</h2><a id="more"></a>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/事件存储.png" alt="image"></p>
<ul>
<li><code>EventPluginHub</code>负责管理 React 合成事件的<code>callback</code>，它将<code>callback</code>存储在<code>listenerBank</code>中，另外还存储了负责合成事件的<code>Plugin</code>。</li>
<li><code>EventPluginHub</code>的<code>putListener</code>方法是向存储容器中增加一个 listener。</li>
<li>获取绑定事件的元素的唯一标识<code>key</code>。</li>
<li>将<code>callback</code>根据事件类型，元素的唯一标识<code>key</code>存储在<code>listenerBank</code>中。</li>
<li><code>listenerBank</code>的结构是：<code>listenerBank[registrationName][key]</code>。</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    onClick:&#123;</span><br><span class="line">        nodeid1:()=&gt;&#123;...&#125;</span><br><span class="line">        nodeid2:()=&gt;&#123;...&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onChange:&#123;</span><br><span class="line">        nodeid3:()=&gt;&#123;...&#125;</span><br><span class="line">        nodeid4:()=&gt;&#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件触发-执行"><a href="#事件触发-执行" class="headerlink" title="事件触发 / 执行"></a>事件触发 / 执行</h2><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/事件触发.png" alt="image"></p>
<p>这里的事件执行利用了<code>React</code>的批处理机制，在前一篇的【React 深入】setState 执行机制中已经分析过，这里不再多加分析。</p>
<ul>
<li>触发<code>document</code>注册原生事件的回调<code>dispatchEvent</code></li>
<li>获取到触发这个事件最深一级的元素</li>
</ul>
<p>例如下面的代码：首先会获取到<code>this.child</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div onClick=&#123;<span class="keyword">this</span>.parentClick&#125; ref=&#123;ref =&gt; (<span class="keyword">this</span>.parent = ref)&#125;&gt;</span><br><span class="line">  &lt;div onClick=&#123;<span class="keyword">this</span>.childClick&#125; ref=&#123;ref =&gt; (<span class="keyword">this</span>.child = ref)&#125;&gt;</span><br><span class="line">    test</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历这个元素的所有父元素，依次对每一级元素进行处理。</li>
<li>构造合成事件。</li>
<li>将每一级的合成事件存储在<code>eventQueue</code>事件队列中。</li>
<li>遍历<code>eventQueue</code>。</li>
<li>通过<code>isPropagationStopped</code>判断当前事件是否执行了阻止冒泡方法。</li>
<li>如果阻止了冒泡，停止遍历，否则通过<code>executeDispatch</code>执行合成事件。</li>
<li>释放处理完成的事件。</li>
</ul>
<p><code>react</code>在自己的合成事件中重写了<code>stopPropagation</code>方法，将<code>isPropagationStopped</code>设置为<code>true</code>，然后在遍历每一级事件的过程中根据此遍历判断是否继续执行。这就是<code>react</code>自己实现的冒泡机制。</p>
<h2 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h2><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/合成事件.png" alt="image"></p>
<ul>
<li>调用<code>EventPluginHub</code>的<code>extractEvents</code>方法。</li>
<li>循环所有类型的<code>EventPlugin</code>（用来处理不同事件的工具方法）。</li>
<li>在每个<code>EventPlugin</code>中根据不同的事件类型，返回不同的事件池。</li>
<li>在事件池中取出合成事件，如果事件池是空的，那么创建一个新的。</li>
<li>根据元素<code>nodeid</code>(唯一标识<code>key</code>)和事件类型从<code>listenerBink</code>中取出回调函数</li>
<li>返回带有合成事件参数的回调函数</li>
</ul>
<h3 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h3><p>将上面的四个流程串联起来。</p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/react事件机制.png" alt="image"></p>
<h2 id="为什么要手动绑定-this"><a href="#为什么要手动绑定-this" class="headerlink" title="为什么要手动绑定 this"></a>为什么要手动绑定 this</h2><p>通过事件触发过程的分析，<code>dispatchEvent</code>调用了<code>invokeGuardedCallback</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeGuardedCallback</span>(<span class="params">name, func, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    func(a);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (caughtError === <span class="literal">null</span>) &#123;</span><br><span class="line">      caughtError = x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，回调函数是直接调用调用的，并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的<code>this</code>是<code>undefined</code>。</p>
<p>这里可以使用实验性的<a href="https://babeljs.io/docs/en/babel-plugin-proposal-class-properties" target="_blank" rel="noopener">属性初始化语法</a> ，也就是直接在组件声明箭头函数。箭头函数不会创建自己的<code>this</code>，它只会从自己的作用域链的上一层继承<code>this</code>。因此这样我们在<code>React</code>事件中获取到的就是组件本身了。</p>
<h2 id="和原生事件有什么区别"><a href="#和原生事件有什么区别" class="headerlink" title="和原生事件有什么区别"></a>和原生事件有什么区别</h2><ul>
<li><p><code>React</code> 事件使用驼峰命名，而不是全部小写。</p>
</li>
<li><p>通过 <code>JSX</code> , 你传递一个函数作为事件处理程序，而不是一个字符串。</p>
</li>
</ul>
<p>例如，<code>HTML</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"activateLasers()"</span>&gt;Activate Lasers&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>React</code> 中略有不同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;Activate Lasers&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>另一个区别是，在 React 中你不能通过返回<code>false</code> 来阻止默认行为。必须明确调用 <code>preventDefault</code>。</p>
<p>由上面执行机制我们可以得出：<code>React</code>自己实现了一套事件机制，自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，并且抹平了各个浏览器的兼容性问题。</p>
<h2 id="React事件和原生事件的执行顺序"><a href="#React事件和原生事件的执行顺序" class="headerlink" title="React事件和原生事件的执行顺序"></a><code>React</code>事件和原生事件的执行顺序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.parent.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dom parent'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.child.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dom child'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'document'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">childClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'react child'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'react parent'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div onClick=&#123;<span class="keyword">this</span>.parentClick&#125; ref=&#123;ref =&gt; <span class="keyword">this</span>.parent = ref&#125;&gt;</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.childClick&#125; ref=&#123;ref =&gt; <span class="keyword">this</span>.child = ref&#125;&gt;</span><br><span class="line">        test</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/reactEvent1.png" alt="image"></p>
<p>由上面的流程我们可以理解：</p>
<ul>
<li><code>react</code>的所有事件都挂载在<code>document</code>中</li>
<li>当真实 dom 触发后冒泡到<code>document</code>后才会对<code>react</code>事件进行处理</li>
<li>所以原生的事件会先执行</li>
<li>然后执行<code>react</code>合成事件</li>
<li>最后执行真正在<code>document</code>上挂载的事件</li>
</ul>
<h1 id="react-事件和原生事件可以混用吗？"><a href="#react-事件和原生事件可以混用吗？" class="headerlink" title="react 事件和原生事件可以混用吗？"></a>react 事件和原生事件可以混用吗？</h1><p><code>react</code>事件和原生事件最好不要混用。</p>
<p>原生事件中如果执行了<code>stopPropagation</code>方法，则会导致其他<code>react</code>事件失效。因为所有元素的事件将无法冒泡到<code>document</code>上。</p>
<p>由上面的执行机制不难得出，所有的 react 事件都将无法被注册。</p>
<h2 id="合成事件、浏览器兼容"><a href="#合成事件、浏览器兼容" class="headerlink" title="合成事件、浏览器兼容"></a>合成事件、浏览器兼容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function handleClick(e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  console.log(&apos;The link was clicked.&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里， <code>e</code> 是一个合成的事件。 <code>React</code> 根据<a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener"> W3C </a>规范 定义了这个合成事件，所以你不需要担心跨浏览器的兼容性问题。</p>
</blockquote>
<p>事件处理程序将传递 <code>SyntheticEvent</code> 的实例，这是一个跨浏览器原生事件包装器。 它具有与浏览器原生事件相同的接口，包括<code>stopPropagation()</code> 和 <code>preventDefault()</code> ，在所有浏览器中他们工作方式都相同。</p>
<p>每个<code>SyntheticEvent</code>对象都具有以下属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">boolean bubbles</span><br><span class="line">boolean cancelable</span><br><span class="line">DOMEventTarget currentTarget</span><br><span class="line">boolean defaultPrevented</span><br><span class="line">number eventPhase</span><br><span class="line">boolean isTrusted</span><br><span class="line">DOMEvent nativeEvent</span><br><span class="line"><span class="keyword">void</span> preventDefault()</span><br><span class="line">boolean isDefaultPrevented()</span><br><span class="line"><span class="keyword">void</span> stopPropagation()</span><br><span class="line">boolean isPropagationStopped()</span><br><span class="line">DOMEventTarget target</span><br><span class="line">number timeStamp</span><br><span class="line">string type</span><br></pre></td></tr></table></figure>
<p><code>React</code>合成的<code>SyntheticEvent</code>采用了事件池，这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。</p>
<p>另外，不管在什么浏览器环境下，浏览器会将该事件类型统一创建为合成事件，从而达到了浏览器兼容的目的。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2>]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-高级-使用MongoDB</title>
    <url>/2018/11/03/2018-11-03_Programing-Python-Advanced-use-mongoDB/</url>
    <content><![CDATA[<hr>
<h2 id="Python使用MongoDB"><a href="#Python使用MongoDB" class="headerlink" title="Python使用MongoDB"></a>Python使用MongoDB</h2><p>MongoDB相对于传统的关系型数据库，可以存储JSON数据，非常适合存储数据抓取返回的JSON数据。<br>今天主要学习的是使用Python连接MongoDB，并进行增删改查的操作。</p>
<blockquote>
<p>MongoDB 的安装及使用，请参照官方文档。<br><a href="https://api.mongodb.com/python/current/installation.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/installation.html</a></p>
</blockquote>
<p>在连接MongoDB前 首先要安装的是Python包：PyMongo，包的安装非常的简单。<br>只需执行 <code>pip install pymongo</code> 即可使用。</p>
<h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>在安装完PyMongo以后，使用Python连接MongoDB变得异常简单。具体方式为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"> </span><br><span class="line">client = MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br></pre></td></tr></table></figure><br>或使用如下方式：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"> </span><br><span class="line">client = MongoClient(<span class="string">'mongodb://localhost:27017'</span>)</span><br></pre></td></tr></table></figure><br>如果连接含有账号密码等，请参考：<br><a href="https://api.mongodb.com/python/current/api/pymongo/mongo_client.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/api/pymongo/mongo_client.html</a></p>
<a id="more"></a>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>连接数据库的操作也非常的简单，最为重要的是，在你连接数据库之前无需先创建数据库，如果数据库存在则直接连接，如果数据库不存在则会创建新的库。具体方式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">db = client.pymongo_test</span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">db = client[<span class="string">'pymongo_test'</span>]</span><br></pre></td></tr></table></figure>
<p>以上两种方式任选一种即可。</p>
<h3 id="Collection概念"><a href="#Collection概念" class="headerlink" title="Collection概念"></a>Collection概念</h3><p>在MongoDB中存在一个Collection的概念，我将其理解为命名空间，类似其他数据库中Scheme的概念，Collection可以理解为一些表的集合。Collection可以使用也可以不使用，具体看你是否要给库下的表分类。相关的操作：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法一：</span></span><br><span class="line">collection = db.test_collection</span><br><span class="line"><span class="comment">#方法二</span></span><br><span class="line">collection = db[<span class="string">'test-collection'</span>]</span><br></pre></td></tr></table></figure><br>需要知晓的是，collection的创建是在第一张表创建时才会创建。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入数据的方式的凡是非常的简单，最长使用的方法是，<code>insert_one()</code>和<code>inert_many()</code>方法，从字面上就可以看出来一个是插入一条数据，另外一个是插入多条数据，示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"> </span><br><span class="line">client = MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br><span class="line">db = client.testdb</span><br><span class="line">posts = db.posts</span><br><span class="line"> </span><br><span class="line">post_1 = &#123;</span><br><span class="line">    <span class="string">'title'</span>: <span class="string">'Python and MongoDB'</span>,</span><br><span class="line">    <span class="string">'content'</span>: <span class="string">'PyMongo is fun'</span>,</span><br><span class="line">    <span class="string">'author'</span>: <span class="string">'saul'</span></span><br><span class="line">&#125;</span><br><span class="line">post_2 = &#123;</span><br><span class="line">    <span class="string">'title'</span>: <span class="string">'Virtual Environments'</span>,</span><br><span class="line">    <span class="string">'content'</span>: <span class="string">'Use virtual environments'</span>,</span><br><span class="line">    <span class="string">'author'</span>: <span class="string">'Scott'</span></span><br><span class="line">&#125;</span><br><span class="line">post_3 = &#123;</span><br><span class="line">    <span class="string">'title'</span>: <span class="string">'Learning Python'</span>,</span><br><span class="line">    <span class="string">'content'</span>: <span class="string">'Learn Python, it is easy'</span>,</span><br><span class="line">    <span class="string">'author'</span>: <span class="string">'Bill'</span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">#每次插入一条数据</span></span><br><span class="line">posts.insert_one(post_1)</span><br><span class="line">posts.insert_one(post_2)</span><br><span class="line">posts.insert_one(post_3)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#一次插入多条数据</span></span><br><span class="line">posts.insert_many([post_1, post_2, post_3])</span><br></pre></td></tr></table></figure></p>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>和插入数据一样，查询数据的时候，提供查询一条或多条数据的方法，方法分别为<code>find_one()</code>和<code>find()</code>。示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询一条数据</span></span><br><span class="line">bills_post = posts.find_one(&#123;<span class="string">'author'</span>: <span class="string">'Bill'</span>&#125;)</span><br><span class="line">print(bills_post)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查询多条数据</span></span><br><span class="line">scotts_posts = posts.find(&#123;<span class="string">'author'</span>: <span class="string">'Scott'</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> post <span class="keyword">in</span> scotts_posts:</span><br><span class="line">    print(post)</span><br></pre></td></tr></table></figure><br>另外，查询多条时，可以设定返回的数量或其他限定条件：<br><a href="https://api.mongodb.com/python/current/api/pymongo/collection.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/api/pymongo/collection.html</a></p>
<p>另外条件中如需支持类似的关系数据库中的WHERE条件，需要使用特定的关键词。示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = datetime.datetime(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">for</span> post <span class="keyword">in</span> posts.find(&#123;<span class="string">"date"</span>: &#123;<span class="string">"$lt"</span>: d&#125;&#125;).sort(<span class="string">"author"</span>):</span><br><span class="line">    pprint.pprint(post)</span><br></pre></td></tr></table></figure></p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除数据同样非常的简单，主要用到的方法为：<code>delete_one()</code>和<code>delete_many()</code>。</p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>更新数据的主要方法是，<code>update_one()</code>和<code>update_many()</code>，除此之外，还有一个<code>replace_one()</code>方法用来替换，由于用的不多，具体看文档。</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>pyMongo还支持创建索引，可以进一步提升查询的性能，示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = db.profiles.create_index([(<span class="string">'user_id'</span>, pymongo.ASCENDING)],unique=<span class="literal">True</span>)</span><br><span class="line">sorted(list(db.profiles.index_information()))</span><br></pre></td></tr></table></figure>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://api.mongodb.com/python/current/tutorial.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/tutorial.html</a><br><a href="https://docs.mongodb.com/manual/indexes/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/indexes/</a></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
        <category>高级技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程技术</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-高级-Numpy简介</title>
    <url>/2018/10/08/2019-10-08-Programing-Python-Advanded-Numpy-intro/</url>
    <content><![CDATA[<hr>
<h2 id="Numpy-是什么？"><a href="#Numpy-是什么？" class="headerlink" title="Numpy 是什么？"></a><code>Numpy</code> 是什么？</h2><p><code>Numpy</code> 是 Python 中科学计算的核心库。它提供了一个高性能的多维数组对象，以及用于处理这些数组的工具。</p>
<blockquote>
<p>如果您已经熟悉 <code>MATLAB</code> ，那么您可能会发现本教程对 <code>Numpy</code> 入门非常有用。</p>
</blockquote>
<p>它主要包含下面内容：</p>
<ul>
<li>一个强大的N维数组对象</li>
<li>复杂的（广播）功能</li>
<li>用于集成<code>C / C ++</code> 和 <code>Fortran</code> 代码的工具</li>
<li>提供了丰富的的线性代数，傅里叶变换和随机数等功能</li>
</ul>
<p>除了科学计算用途外，<code>NumPy</code> 还可以用作通用数据的高效多维容器。可以定义任意数据类型。这使 <code>NumPy</code> 能够无缝快速地与各种数据库集成。特别在人工智能领域， <code>Numpy</code> 已经是不可或缺的基础库了。</p>
<h2 id="Numpy-安装"><a href="#Numpy-安装" class="headerlink" title="Numpy 安装"></a>Numpy 安装</h2><p>安装 Numpy 最快的方式是通过 pip 安装，通过下面的命令进行安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure>
<p>然后按下回车键，系统将会自动安装 Numpy 及 Numpy 引用的包。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-8e598c43a1848784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Numpy 安装"></p>
<a id="more"></a>
<h2 id="Numpy-Array"><a href="#Numpy-Array" class="headerlink" title="Numpy Array"></a>Numpy Array</h2><p><code>Array</code> 是一个数值的矩阵, 所有的数值有相同类型，网格的大小由一对非负整数组成的的数值对唯一确定。<br><code>Array</code> 维数是阵列的秩;<br><code>Array</code> 的形状是一个整数元组，给出了每个维度的数组大小。</p>
<p>我们可以从嵌套的 <code>Python</code> 列表初始化 <code>numpy</code> 数组，并使用方括号访问元素：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一维矩阵</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])                </span><br><span class="line">print(type(a))                            </span><br><span class="line"><span class="comment"># Prints "&lt;class 'numpy.ndarray'&gt;"</span></span><br><span class="line"></span><br><span class="line">print(a.shape)                           </span><br><span class="line"><span class="comment"># Prints "(3,)"</span></span><br><span class="line"></span><br><span class="line">print(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])                  </span><br><span class="line"><span class="comment"># Prints "1 2 3"</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 改变矩阵中的一个值</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                                   </span><br><span class="line">print(a)                                     </span><br><span class="line"><span class="comment"># Prints "[5, 2, 3]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建二维矩阵</span></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])    </span><br><span class="line">print(b.shape)                          </span><br><span class="line"><span class="comment"># Prints "(2, 3)"</span></span><br><span class="line"></span><br><span class="line">print(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])     </span><br><span class="line"><span class="comment"># Prints "1 2 4"</span></span><br></pre></td></tr></table></figure><br><code>Numpy</code> 模块内部也提供了许多创建 <code>array</code> 的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全 `0` 矩阵</span></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">2</span>))                               </span><br><span class="line">print(a)                                                </span><br><span class="line"><span class="comment"># Prints "[[ 0.  0.]                                                            </span></span><br><span class="line"><span class="comment">#          [ 0.  0.]]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全 `1` 矩阵</span></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))                              </span><br><span class="line">print(b)                                                </span><br><span class="line"><span class="comment"># Prints "[[ 1.  1.]]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建常数矩阵</span></span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">7</span>)  </span><br><span class="line">print(c)                                                </span><br><span class="line"><span class="comment"># Prints "[[ 7.  7.]                                                           </span></span><br><span class="line"><span class="comment">#          [ 7.  7.]]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 2 x 2 单位矩阵</span></span><br><span class="line">d = np.eye(<span class="number">2</span>)         </span><br><span class="line">print(d)                                               </span><br><span class="line"><span class="comment"># Prints "[[ 1.  0.]</span></span><br><span class="line"><span class="comment">#          [ 0.  1.]]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an array filled with random values</span></span><br><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>)) </span><br><span class="line">print(e)                     </span><br><span class="line"><span class="comment"># Might print "[[ 0.91923167  0.08484941]</span></span><br><span class="line"><span class="comment">#               [ 0.68726234  0.84629387]]"</span></span><br></pre></td></tr></table></figure>
<h2 id="Array-索引"><a href="#Array-索引" class="headerlink" title="Array 索引"></a>Array 索引</h2><p><code>Numpy</code> 提供了大量的内建函数来快速操作 <code>array</code> 对象。</p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>如果有 Python <code>list</code> 的经验，对切片的操作就不会感到陌生。<code>Numpy</code> 也提供了切片的功能。但是有一点需要特别注意：<br><code>Numpy Array</code> 可能是多维的，因此必须为数组的每个维指定一个切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建3行4列的二维数组</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用切片来拉出由前2行和第1列和第2列组成的子阵列;</span></span><br><span class="line"><span class="comment"># b是以下形状数组（2,2）：</span></span><br><span class="line"><span class="comment"># [[2 3]</span></span><br><span class="line"><span class="comment">#  [6 7]]</span></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组的切片是对相同数据的视图，因此修改它将修改原始数组。</span></span><br><span class="line">print(a[<span class="number">0</span>, <span class="number">1</span>])   </span><br><span class="line"><span class="comment"># Prints "2"</span></span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">88</span>     </span><br><span class="line"><span class="comment"># b[0, 1] 和 a[0, 1] 有相同的数据</span></span><br><span class="line"></span><br><span class="line">print(a[<span class="number">0</span>, <span class="number">1</span>])   </span><br><span class="line"><span class="comment"># Prints "88"</span></span><br></pre></td></tr></table></figure>
<h2 id="Array-数据类型"><a href="#Array-数据类型" class="headerlink" title="Array 数据类型"></a>Array 数据类型</h2><p>每个 <code>numpy</code> 数组都是相同类型元素的集合。<br><code>Numpy</code> 提供了一组可用于构造数组的大量数值数据类型。<br><code>Numpy</code>尝试在创建数组时猜测数据类型，但构造数组的函数通常还包含一个可选参数来显式指定数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 自动选择类型</span></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])   </span><br><span class="line">print(x.dtype)</span><br><span class="line"><span class="comment"># Prints "int64"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 自动选择类型</span></span><br><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])   </span><br><span class="line">print(x.dtype)             </span><br><span class="line"><span class="comment"># Prints "float64"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 numpy 指定类型</span></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.int64)   </span><br><span class="line">print(x.dtype)                         </span><br><span class="line"><span class="comment"># Prints "int64"</span></span><br></pre></td></tr></table></figure>
<h2 id="Array-运算"><a href="#Array-运算" class="headerlink" title="Array 运算"></a>Array 运算</h2><p>基本的数学函数在数组上按元素运行，既可以作为运算符重载，也可以作为 <code>numpy</code> 模块中的函数。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素和，两种方式都会产生新的array 对象</span></span><br><span class="line"><span class="comment"># [[ 6.0  8.0]</span></span><br><span class="line"><span class="comment">#  [10.0 12.0]]</span></span><br><span class="line">print(x + y)</span><br><span class="line">print(np.add(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素差，两种方式都会产生新的array 对象</span></span><br><span class="line"><span class="comment"># [[-4.0 -4.0]</span></span><br><span class="line"><span class="comment">#  [-4.0 -4.0]]</span></span><br><span class="line">print(x - y)</span><br><span class="line">print(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素相乘，两种方式都会产生新的array 对象</span></span><br><span class="line"><span class="comment"># [[ 5.0 12.0]</span></span><br><span class="line"><span class="comment">#  [21.0 32.0]]</span></span><br><span class="line">print(x * y)</span><br><span class="line">print(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素相除，两种方式都会产生新的array 对象</span></span><br><span class="line"><span class="comment"># [[ 0.2         0.33333333]</span></span><br><span class="line"><span class="comment">#  [ 0.42857143  0.5       ]]</span></span><br><span class="line">print(x / y)</span><br><span class="line">print(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素的平方根，产生新的array 对象</span></span><br><span class="line"><span class="comment"># [[ 1.          1.41421356]</span></span><br><span class="line"><span class="comment">#  [ 1.73205081  2.        ]]</span></span><br><span class="line">print(np.sqrt(x))</span><br></pre></td></tr></table></figure></p>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p><code>Numpy</code> 的广播是一种强大的机制，允许 <code>numpy</code> 对象在执行算术运算时使用不同形状的数组。</p>
<p>我们经常有一个较小的数组和一个更大的数组，我们希望多次使用较小的数组来对较大的数组执行某些操作。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将向量v添加到矩阵x的每一行，将结果存储在矩阵y中</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.empty_like(x)   <span class="comment"># 创建一个与x形状相同的空矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加向量v到矩阵x的每一行，</span></span><br><span class="line"><span class="comment"># 显式循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now y is the following</span></span><br><span class="line"><span class="comment"># [[ 2  2  4]</span></span><br><span class="line"><span class="comment">#  [ 5  5  7]</span></span><br><span class="line"><span class="comment">#  [ 8  8 10]</span></span><br><span class="line"><span class="comment">#  [11 11 13]]</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><br>用一张图来理解这个过程：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-aa668e5f268cad36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="广播示意图"></p>
<blockquote>
<p>广播的功能，在机器学习中有大量的应用。</p>
</blockquote>
<p>广播通常会使您的代码更简洁，更快速，因此应该尽可能地使用它。</p>
<h2 id="基于-Numpy-提供高级功能的第三方库"><a href="#基于-Numpy-提供高级功能的第三方库" class="headerlink" title="基于 Numpy 提供高级功能的第三方库"></a>基于 <code>Numpy</code> 提供高级功能的第三方库</h2><p><code>Numpy</code> 提供了一个高性能的多维数组和基本工具来计算和操作这些数组。 很多的第三方库基于 <code>numpy</code> 提供的功能，定制化了很多新的功能，下面挑取一部分进行简介。</p>
<h3 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h3><p><code>Scipy</code> 在<code>numpy</code> 为基础，提供了大量在<code>numpy</code> 数组上运行的函数，适用于不同类型的科学和工程应用程序。<br><code>SciPy</code> 提供了一些处理图像的基本功能。</p>
<p>例如，它具有将图像从磁盘读取到<code>numpy</code> 数组，将<code>numpy</code> 数组作为图像写入磁盘以及调整图像大小的功能。</p>
<p>这是一个展示这些功能的简单示例<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread, imsave, imresize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取本地的图片文件到 numpy array</span></span><br><span class="line">img = imread(<span class="string">'temp/cat.jpg'</span>)</span><br><span class="line">print(img.dtype, img.shape)  </span><br><span class="line"><span class="comment"># Prints "uint8 (400, 248, 3)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以通过用不同的标量常数列出图片的参数。</span></span><br><span class="line"><span class="comment"># 图像具有形状（400,248,3）;</span></span><br><span class="line"><span class="comment"># 我们将它乘以形状一维的数组[1,0.95,9.9]; </span></span><br><span class="line"><span class="comment"># `numpy` 广播机制意味着它保持红色通道不变，并将绿色和蓝色通道分别乘以0.95和0.9。</span></span><br><span class="line">img_tinted = img * [<span class="number">1</span>, <span class="number">0.95</span>, <span class="number">0.9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时将图片的size 调整为 300 x 300</span></span><br><span class="line">img_tinted = imresize(img_tinted, (<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将修改后图片写进本地文件</span></span><br><span class="line">imsave(<span class="string">'temp/cat_tinted.jpg'</span>, img_tinted)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-753b621c16d0cb1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片效果图"></p>
<blockquote>
<p>更多的例子请到 <a href="https://scipy.org/" target="_blank" rel="noopener">https://scipy.org/</a></p>
</blockquote>
<h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a><code>Matplotlib</code></h3><p><code>Matplotlib</code> 是一个绘图库。</p>
<p>本节简要介绍matplotlib.pyplot模块，该模块提供了类似于MATLAB的绘图系统。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在正弦曲线上输入点的x和y坐标</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 matplotlib 显示绘制的图形</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须呼叫 plt.show() 才能显示图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-70f55db08e85606a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sin(x)"></p>
<p>一个同时显示 sin(x) 和 cos(x) 的例子<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the x and y coordinates for points on sine and cosine curves</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the points using matplotlib</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.xlabel(<span class="string">'x axis label'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y axis label'</span>)</span><br><span class="line">plt.title(<span class="string">'Sine and Cosine'</span>)</span><br><span class="line">plt.legend([<span class="string">'Sine'</span>, <span class="string">'Cosine'</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-f14b67657dfde644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sin VS. cos"></p>
<blockquote>
<p>更多的例子请到 <a href="https://matplotlib.org/" target="_blank" rel="noopener">https://matplotlib.org/</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
        <category>高级技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程技术</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-高级-聊一聊 Flask 的 jsonify</title>
    <url>/2018/07/07/2018-07-07_Programing-Python-Advanced-jsonify-in-Flask/</url>
    <content><![CDATA[<p>首先我们来看一段 Python 代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 python_mastery 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/python_mastery'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 pythonml 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/pythonml'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: tasks&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>在这段代码里面，我们看到了今天的主角 <code>jsonify</code>。</p>
<p>Flask 框架里，可以用 <code>jsonify</code> 返回 json 数据，但是为什么不用 <code>Python</code> 自带的 <code>json</code> 模块返回 JSON 数据呢？</p>
<a id="more"></a>
<hr>
<h2 id="其实是一样"><a href="#其实是一样" class="headerlink" title="其实是一样"></a>其实是一样</h2><p>其实，<code>jsonify</code> 在处理数据过程中，对数据做 JSON 序列化处理时，用的是 <code>itsdangerous</code> 模块里的 JSON ，让我们看一下，这个模块里的 JSON 是如何引入的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> simplejson <span class="keyword">as</span> json</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> json</span><br></pre></td></tr></table></figure>
<p>它会先尝试引入<code>simplejson</code>，如果没有安装这个模块，则引入 Python 原生模。</p>
<p>在Flask框架中，引入过程如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> json <span class="keyword">as</span> _json</span><br></pre></td></tr></table></figure>
<p>对于数据的序列化处理，用的正是 <code>_json</code>.</p>
<hr>
<h2 id="Content-Type-的差别"><a href="#Content-Type-的差别" class="headerlink" title="Content-Type 的差别"></a>Content-Type 的差别</h2><p>前面讲到，<code>jsonify</code> 和 <code>json</code> 是殊途同归，那么为什么要费周折绕这么一圈呢?</p>
<p>肯定存在一个合理的原因让 <code>jsonify</code>存在的有意义。</p>
<p>这个原因就是 <code>Content-Type</code></p>
<p>看下面两段代码</p>
<p><strong>第一段代码</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##  jsonify</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/json')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json</span><span class="params">()</span>:</span></span><br><span class="line">    data = &#123;<span class="string">'name'</span>: <span class="string">'lilei'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(data)</span><br><span class="line"></span><br><span class="line">app.run(host=<span class="string">"0.0.0.0"</span>, port=<span class="number">9877</span>)</span><br></pre></td></tr></table></figure></p>
<p>在浏览器里输入<a href="http://127.0.0.1:9877/json," target="_blank" rel="noopener">http://127.0.0.1:9877/json</a>， 得到的结果是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"age"</span>:<span class="number">30</span>,<span class="string">"name"</span>:<span class="string">"lilei"</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二段代码：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## json</span><br><span class="line">import json</span><br><span class="line">from flask import Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/json&apos;)</span><br><span class="line">def test_json():</span><br><span class="line">    data = &#123;&apos;name&apos;: &apos;lilei&apos;, &apos;age&apos;: 30&#125;</span><br><span class="line">    return json.dumps(data)</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;, port=9877)</span><br></pre></td></tr></table></figure></p>
<p>在浏览器里输入<a href="http://127.0.0.1:9877/json," target="_blank" rel="noopener">http://127.0.0.1:9877/json</a>， 得到的结果是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>: <span class="string">"lilei"</span>, <span class="string">"age"</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>
<p>从内容上看，两种方法没有区别。<br>但是使用  <code>jsonify</code> 时，返回的 <code>http response</code>  的 <code>Content-Type</code> 是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>
<p>而使用json.dumps时，Content-Type则是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure>
<p>既然返回的是 json 数据，那么自然要指明 <code>Content-Type</code> 是 <code>application/json</code> ， 这样做是符合 HTTP 协议的规定的，这就是使用 <code>jsonify</code> 的原因之一。</p>
<hr>
<h2 id="减小数据量"><a href="#减小数据量" class="headerlink" title="减小数据量"></a>减小数据量</h2><p>使用 <code>jsonify</code> 除了让返回的 `http response符合 HTTP 协议，同时也对数据做了压缩处理，让数据体积更小。</p>
<p>仔细比较上面两种方法返回的数据，虽然内容相同，但 <code>jsonify</code> 返回的数据，每个 <code>key-value</code> 对之间的逗号，和每个 <code>key</code> 与 <code>value</code> 之间的冒号后面都是没有空格的，而 <code>json.dumps</code> 返回的数据里，却在逗号和冒号后面存在空格，因此即便内容相同，<code>jsonify</code> 返回的数据体积更小，更节省流量。</p>
<p>其实，<code>json.dumps</code> 也可以将这些不必要的空格去掉，看下面的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">'name'</span>: <span class="string">'lilei'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">print(json.dumps(data, separators=(<span class="string">','</span>, <span class="string">':'</span>)))</span><br><span class="line">print(json.dumps(data))</span><br></pre></td></tr></table></figure>
<p>输出结果为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;lilei&quot;,&quot;age&quot;:30&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;lilei&quot;, &quot;age&quot;: 30&#125;</span><br></pre></td></tr></table></figure></p>
<p>只需要在 <code>dumps</code> 参数里指定   <code>separators</code> 即可，其实在 <code>jsonify</code> 里就是这么干的。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
        <category>高级技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程技术</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot Web 应用加速</title>
    <url>/2018/04/29/2018-04-29-Programing-Java-Spring-Boot-App-speeded-up/</url>
    <content><![CDATA[<h1 id="Spring-Boot-Web-应用加速"><a href="#Spring-Boot-Web-应用加速" class="headerlink" title="Spring Boot Web 应用加速"></a>Spring Boot Web 应用加速</h1><p>默认情况下，Spring Boot Web 应用会装配一些功能组件 Bean。</p>
<p>在大多数 Web 应用场景下，可以选择性地关闭一下自动装配的Spring 组件 Bean，以达到提升性能的目的。</p>
<h2 id="配置项优化"><a href="#配置项优化" class="headerlink" title="配置项优化"></a>配置项优化</h2><h3 id="Spring-Boot-Web-应用加速-完整配置项"><a href="#Spring-Boot-Web-应用加速-完整配置项" class="headerlink" title="Spring Boot Web 应用加速 完整配置项"></a>Spring Boot Web 应用加速 完整配置项</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.add-application-context-header</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">spring.mvc.formcontent.putfilter.enabled</span> = <span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<h3 id="配置项汇总"><a href="#配置项汇总" class="headerlink" title="配置项汇总"></a>配置项汇总</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration,\</span></span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="关闭-Web-请求跟踪-自动装配"><a href="#关闭-Web-请求跟踪-自动装配" class="headerlink" title="关闭 Web 请求跟踪 自动装配"></a>关闭 Web 请求跟踪 自动装配</h3><h4 id="org-springframework-boot-actuate-autoconfigure-TraceWebFilterAutoConfiguration"><a href="#org-springframework-boot-actuate-autoconfigure-TraceWebFilterAutoConfiguration" class="headerlink" title="org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration"></a><code>org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration</code></h4><p>顾名思义，该自动装配用跟踪 Web 请求，通过Servlet Filter <code>org.springframework.boot.actuate.trace.WebRequestTraceFilter</code> 记录请求的信息（如：请求方法、请求头以及请求路径等），其计算的过程存在一定的开销，使用场景罕见，故可选择关闭。</p>
<ul>
<li>配置项</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<h4 id="org-springframework-boot-actuate-autoconfigure-TraceRepositoryAutoConfiguration"><a href="#org-springframework-boot-actuate-autoconfigure-TraceRepositoryAutoConfiguration" class="headerlink" title="org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration"></a><code>org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration</code></h4><p>当<code>org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration</code>关闭后，其请求信息存储介质<code>org.springframework.boot.actuate.trace.TraceRepository</code>没有存在的必要，故可选择关闭。</p>
<ul>
<li>配置项</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭-Web-请求结果指标-自动装配"><a href="#关闭-Web-请求结果指标-自动装配" class="headerlink" title="关闭 Web 请求结果指标 自动装配"></a>关闭 Web 请求结果指标 自动装配</h3><h4 id="org-springframework-boot-actuate-autoconfigure-MetricFilterAutoConfiguration"><a href="#org-springframework-boot-actuate-autoconfigure-MetricFilterAutoConfiguration" class="headerlink" title="org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration"></a><code>org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</code></h4><p>该组件将自动装配<code>org.springframework.boot.actuate.autoconfigure.MetricsFilter</code>，该 Filter</p>
<p>主要记录Web 请求结果指标（如：相应状态码、请求方法执行时间等），该信息一定程度上与反向代理服务器（nginx）功能重叠，故可选择关闭。</p>
<ul>
<li>配置项</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<h3 id="可关闭-Servlet-Web-组件"><a href="#可关闭-Servlet-Web-组件" class="headerlink" title="可关闭 Servlet Web 组件"></a>可关闭 Servlet Web 组件</h3><h4 id="org-springframework-web-filter-HttpPutFormContentFilter"><a href="#org-springframework-web-filter-HttpPutFormContentFilter" class="headerlink" title="org.springframework.web.filter.HttpPutFormContentFilter"></a><code>org.springframework.web.filter.HttpPutFormContentFilter</code></h4><ul>
<li>引入版本</li>
</ul>
<p><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 由 Spring<br>Framework 3.1 版本引入，分发在 <code>org.springframework:spring-web</code> 中。</p>
<ul>
<li>使用场景</li>
</ul>
<p>通常 Web 场景中，浏览器通过 HTTP <code>GET</code> 或者 <code>POST</code> 请求 提交 Form 数据，而非浏览<br>器客户端（如应用程序）可能通过 HTTP <code>PUT</code> 请求来实现。</p>
<p>当 HTTP 请求头<code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 时<br>，Form 数据被 encoded。而 Servlet 规范中， <code>ServletRequest.getParameter*()</code><br>方法仅对 HTTP <code>POST</code> 方法支持请求参数的获取，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> intetfacce ServletRequest &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name);</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故 以上方法无法支持 HTTP <code>PUT</code> 或 HTTP <code>PATCH</code> 请求方法（请求头<code>Content-Type</code><br>为<code>application/x-www-form-urlencoded</code>）。</p>
<p><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 正是这种场景的解<br>决方案。</p>
<p>Spring Boot 默认场景下，将<br><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 被<br><code>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration</code> 自动<br>装配，以下为 Spring Boot 1.4.1.RELEASE 以及更好版本定义（可能存在一定的差异）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span>, <span class="title">WebMvcConfigurerAdapter</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">WebMvcConfigurationSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureOrder</span>(<span class="title">Ordered</span>.<span class="title">HIGHEST_PRECEDENCE</span> + 10)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HttpPutFormContentFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.mvc.formcontent.putfilter"</span>, name = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderedHttpPutFormContentFilter <span class="title">httpPutFormContentFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderedHttpPutFormContentFilter();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，<code>org.springframework.web.filter.HttpPutFormContentFilter</code> 在绝大<br>多数 Web 使用场景下为非必须组件。</p>
<ul>
<li>配置项</li>
</ul>
<p>如果应用依赖 Spring Boot 版本 为 1.4.1.RELEASE 以及更高的版本，可通过如下配置，<br>进行将 <code>org.springframework.web.filter.HttpPutFormContentFilter</code> 关闭：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.formcontent.putfilter.enabled</span> = <span class="string">false</span></span><br></pre></td></tr></table></figure>
<h4 id="org-springframework-web-filter-HiddenHttpMethodFilter"><a href="#org-springframework-web-filter-HiddenHttpMethodFilter" class="headerlink" title="org.springframework.web.filter.HiddenHttpMethodFilter"></a><code>org.springframework.web.filter.HiddenHttpMethodFilter</code></h4><ul>
<li>引入版本</li>
</ul>
<p><code>org.springframework.web.filter.HiddenHttpMethodFilter</code> 由 Spring<br>Framework 3.0 版本引入，分发在 <code>org.springframework:spring-web</code> 中。</p>
<ul>
<li>使用场景</li>
</ul>
<p>当 Web 服务端同一资源（URL）提供了多请求方法的实现，例如 URI ：/update 提供了<br>HTTP <code>POST</code> 以及 HTTP <code>PUT</code> 实现），通常 Web 场景中，浏览器仅支持 HTTP <code>GET</code><br>或者 <code>POST</code> 请求方法，这样的话，浏览器无法发起 HTTP <code>PUT</code> 请求。</p>
<p>为了浏览器可以消费 HTTP <code>PUT</code> 资源， 需要在服务端将 HTTP <code>POST</code> 转化成<br>HTTP <code>PUT</code> 请求，为了解决这类问题，Spring 引入<br><code>org.springframework.web.filter.HiddenHttpMethodFilter</code> Web 组件。</p>
<p>当浏览器 发起 HTTP <code>POST</code> 请求时，可通过增加请求参数（默认参数名称：”_method”）<br>的方式，进行HTTP 请求方法切换，<br><code>org.springframework.web.filter.HiddenHttpMethodFilter</code> 获取参数”_method”<br>值后，将参数值作为 <code>HttpServletRequest#getMethod()</code>的返回值，给后续 <code>Servlet</code><br>实现使用。</p>
<p>出于通用性的考虑，<code>org.springframework.web.filter.HiddenHttpMethodFilter</code><br>通过调用 <code>#setMethodParam(String)</code> 方法，来修改转换请求方法的参数名称。</p>
<p>Spring Boot 默认场景下，将<br><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 被<br><code>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration</code> 自动<br>装配，以下为 Spring Boot 1.4.1.RELEASE 以及更好版本定义（可能存在一定的差异）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span>, <span class="title">WebMvcConfigurerAdapter</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">WebMvcConfigurationSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureOrder</span>(<span class="title">Ordered</span>.<span class="title">HIGHEST_PRECEDENCE</span> + 10)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>,	<span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HiddenHttpMethodFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">OrderedHiddenHttpMethodFilter</span> <span class="title">hiddenHttpMethodFilter</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，<code>org.springframework.web.filter.HiddenHttpMethodFilter</code> 也是特殊<br>场景下所需，故可以关闭之。</p>
<ul>
<li>配置项</li>
</ul>
<p>按目前最新的 Spring Boot 1.5.2.RELEASE 版本中实现，也没有提供类似<br><code>spring.mvc.formcontent.putfilter.enabled</code> 这样的配置项关闭，无法关闭。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Java</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Gradle实用技巧-批量控制生成的APK文件名</title>
    <url>/2018/03/17/2018-03-16-Programing-Android-bulk-generate-apks/</url>
    <content><![CDATA[<p>在讲批量修改APK文件名之前，我们讲一下关于Android Gradle插件集成的Task任务问题。普通的Java工程比较简单，因为它有一个有限的任务集合，而且它的属性或者方法都是Java Gradle插件添加的，比较固定，而且我们访问任务以及任务里的方法和属性都比较方便，比如classes这个编译Java源代码的任务，我们通过project.tasks.classes就可以访问它，非常快捷。</p>
<p>但是对于Android工程，就不行了，Android工程相对与Java工程来说，要复杂的多，因为它有很多相同的任务，这些任务的名字都是通过Build Types和Product Flavors 生成的，是动态的创建和生成的，而且时机比较靠后，如果你还像原来一样在某个闭包里通过project.tasks获取一个任务，会提示找不到该任务，因为还没有生成。</p>
<p>既然要修改生成的Apk文件名，那么我们就要修改Android Gradle打包的输出，为了解决上面提到的问题（不限于此），android对象为我们提供了2个属性：</p>
<ul>
<li>applicationVariants (仅仅适用于Android应用Gradle插件)</li>
<li>libraryVariants (仅仅适用于Android库Gradle插件)</li>
<li>testVariants (以上两种Gradle插件都使用)</li>
</ul>
<p>以上三个属性返回的都是DomainObjectSet对象集合，里面元素分别是ApplicationVariant、LibraryVariant和TestVariant。这三个元素直译来看是变体，通俗的讲他们就是Android构建的产物，比如ApplicationVariant可以代表google渠道的release包，也可以代表dev开发用的debug包，我们上面提到了，他们基于Build Types和Product Flavors生成的产物。</p>
<p>特别注意的是，访问以上这三种集合都会触发创建所有的任务，这意味着访问这些集合后无须重新配置就会产生，也就是说假如我们通过访问这些集合，修改生成Apk的输出文件名，那么就会自动的触发创建所有任务，此时我们修改后的新的Apk文件名就会起作用，达到可我们修改Apk文件名的目的，因为这些是一个集合，包含我们所有生成的产物，所以我们只需要进行迭代，就可以达到我们批量修改Apk文件名的目的。</p>
<p>com.android.build.gradle.AppExtension中的getApplicationVariants方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the list of Application variants. Since the collections is built after evaluation, it</span></span><br><span class="line"><span class="comment"> * should be used with Gradle's &lt;code&gt;all&lt;/code&gt; iterator to process future items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DomainObjectSet&lt;ApplicationVariant&gt; <span class="title">getApplicationVariants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationVariantList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们给出一个批量修改Apk文件名的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">23</span></span><br><span class="line">    buildToolsVersion <span class="string">"23.0.1"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.youdaily.app"</span></span><br><span class="line">        minSdkVersion <span class="number">14</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">            zipAlignEnabled <span class="keyword">true</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    productFlavors </span>&#123;</span><br><span class="line">        google &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        variant.outputs.each &#123; output -&gt;</span><br><span class="line">            <span class="keyword">if</span> (output.outputFile != <span class="keyword">null</span> &amp;&amp; output.outputFile.name.endsWith(<span class="string">'.apk'</span>)</span><br><span class="line">                    &amp;&amp;<span class="string">'release'</span>.equals(variant.buildType.name)) &#123;</span><br><span class="line">                def flavorName = variant.flavorName.startsWith(<span class="string">"_"</span>) ? variant.flavorName.substring(<span class="number">1</span>) : variant.flavorName</span><br><span class="line">                def apkFile = <span class="keyword">new</span> File(</span><br><span class="line">                        output.outputFile.getParent(),</span><br><span class="line">                        <span class="string">"App_$&#123;flavorName&#125;_v$&#123;variant.versionName&#125;_$&#123;buildTime()&#125;.apk"</span>)</span><br><span class="line">                output.outputFile = apkFile</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">buildTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    def date = <span class="keyword">new</span> Date()</span><br><span class="line">    def formattedDate = date.format(<span class="string">'yyyyMMdd'</span>)</span><br><span class="line">    <span class="keyword">return</span> formattedDate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>applicationVariants是一个DomainObjectCollection集合，我们可以通过all方法进行遍历，遍历的每一个variant都是一个生成的产物，针对示例，共有googleRelease和googleDebug两个产物，所以遍历的variant共有googleRelease和googleDebug。</p>
<p>applicationVariants中的variant都是ApplicationVariant，通过查看源代码，可以看到它有一个outputs作为它的输出，每一个ApplicationVariant至少有一个输出，也可以有多个，所以这里的outputs属性是一个List集合，我们再遍历它，如果它的名字是以.apk结尾的话那么就是我们要修改的apk名字了，然后我们就可以根据需求，修改成我们想要的名字。</p>
<p>我这里修改的是以项目名<em>渠道名_v版本名称</em>构建日期.apk格式生成的文件名，这样通过文件名就可以了解该apk的基本信息，比如什么渠道，什么版本，什么时候构建的等等，最后生成的示例apk名字为App_google_v1.0_20170217.apk，大家可以运行测试一下，注意buildTime这个我们自定义的返回日期格式的方法。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Android</category>
        <category>系统工具</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>Android</tag>
        <tag>Gradle</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Gradle实用技巧-自动生成版本信息</title>
    <url>/2018/03/13/2018-03-13-Programing-Android-auto-generate-version-code/</url>
    <content><![CDATA[<p>每一个 App 都会有一个版本号，这样用户就知道自己安装的应用是哪个版本，是不是最新版，有了问题，也可以找客服报上自己的版本，让客服有针对性的帮用户解决问题。</p>
<p>一般的版本有三部分构成：major.minor.patch，第一个是主版本号，第二个是副版本号，第三位补丁号，这种我们常见的见识 1.0.0 这样的，当然也有两位的 1.0，对应 major.minor，这里我们以三位为例。</p>
<p>原始的版本信息配置方式<br>最开始的时候我们都是配置在 build 文件里的，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">compileSdkVersion <span class="number">23</span></span><br><span class="line">buildToolsVersion <span class="string">"23.0.1"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.youdaily.app"</span></span><br><span class="line">        minSdkVersion <span class="number">14</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0.0"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这种方式我们直接写在 versionName 的后面，比较直观。但是这种方式有个很大的问题就是修改不方便，特别当我们的 build 文件中有很多代码时，不容易找，而且修改容易出错，代码版本管理时也容易产生冲突。</p>
<h2 id="使用-Gradle-模块化的机制剥离版本信息"><a href="#使用-Gradle-模块化的机制剥离版本信息" class="headerlink" title="使用 Gradle 模块化的机制剥离版本信息"></a>使用 Gradle 模块化的机制剥离版本信息</h2><p>既然最原始的方式，修改不方便，那么我们可不可以把版本号的配置单独的抽取出来的，放在单独的文件里，供 build 引用，就像我们在 Android 里，单独新建一个存放常量的 Java 类一样，供其他类调用，幸运的是，android 是支持基于文件的模块化的，它就是 apply from。</p>
<p>这和应用一个 Gradle 是一样的，我们不光可以应用一个插件，也可以把另一个 gradle 文件引用进来。我们新建一个 version.gradle 文件，用于专门存放我们的版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">version.gradle</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    appVersionCode =<span class="number">1</span></span><br><span class="line">    appVersionName = <span class="string">"1.0.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ext{}块表明我们要为当前 project 创建扩展属性，以供其他脚本引用，他就像我们 java 里的变量一样。创建好之后，我们在 build.gradle 中引用它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">build.gradle</span><br><span class="line"></span><br><span class="line">apply from: <span class="string">'version.gradle'</span></span><br><span class="line">android &#123;</span><br><span class="line">compileSdkVersion <span class="number">23</span></span><br><span class="line">buildToolsVersion <span class="string">"23.0.1"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.youdaily.app"</span></span><br><span class="line">        minSdkVersion <span class="number">14</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span></span><br><span class="line">        versionCode appVersionCode</span><br><span class="line">        versionName appVersionName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从示例中可以看到，我们先使用 apply from 加载我们的 version.gradle 脚本文件，这样它里面定义的扩展属性就可以使用了。然后我们为 versionCode 和 versionName 配置我们定义好的属性变量。</p>
<p>这种方式，我们每次只用修改 version.gradle 里的版本号就好了，方便，容易，也比较清晰，在团队协作的过程中，大家看到这个文件，就能猜测出来它大概是做什么的，而且只会负责发版的人才会修改这样文件，代码冲突少。</p>
<h2 id="从-git-的-tag-中获取版本号"><a href="#从-git-的-tag-中获取版本号" class="headerlink" title="从 git 的 tag 中获取版本号"></a>从 git 的 tag 中获取版本号</h2><p>一般 Jenkins 打包发布的时候，我们都会从我们已经打好的一个 tag 打包发布，而 tag 的名字一般就是我们的版本名称，这时候我们就可以动态的获取我们的 tag 名称作为我们应用的名称，可能你用的不是 git 版本控制系统，但是大同小异，这里以 git 为例。</p>
<p>想获取当前的 tag 名称，在 git 下非常简单，使用如下命令即可，前提是你已经打了 tag。</p>
<p>git describe —abbrev=0 —tags<br>知道了命令，那么我们如何在 gradle 中动态获取呢，这就需要 gradle 的 exec 了，gradle 为我们提供了执行 shell 命令非常简便的方法，这就是 Exec，它是一个 Task 任务，我们可以创建一个继承 Exec 的任务来执行我们的 shell 命令，但是比较麻烦，还好 Gradle 已经为我们想到了这个问题，为我们在 Project 对象里提供了 exec 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ExecResult <span class="title">exec</span><span class="params">(Closure closure)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ExecResult <span class="title">exec</span><span class="params">(Action&lt;? <span class="keyword">super</span> ExecSpec&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其参数接受闭包和 Action 两种方式，一般我们都是采用闭包的方式，其闭包的配置是通过 ExecSpec 对象来配置的，我们从源代码的文档中也可以看到说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecSpec</span> <span class="keyword">extends</span> <span class="title">BaseExecSpec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCommandLine</span><span class="params">(Object... args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCommandLine</span><span class="params">(Iterable&lt;?&gt; args)</span></span>;</span><br><span class="line">    <span class="function">ExecSpec <span class="title">commandLine</span><span class="params">(Object... args)</span></span>;</span><br><span class="line">    <span class="function">ExecSpec <span class="title">commandLine</span><span class="params">(Iterable&lt;?&gt; args)</span></span>;</span><br><span class="line">    <span class="function">ExecSpec <span class="title">args</span><span class="params">(Object... args)</span></span>;</span><br><span class="line">    <span class="function">ExecSpec <span class="title">args</span><span class="params">(Iterable&lt;?&gt; args)</span></span>;</span><br><span class="line">    <span class="function">ExecSpec <span class="title">setArgs</span><span class="params">(Iterable&lt;?&gt; args)</span></span>;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getArgs</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 ExecSpec 源代码中我们可以看出，Project 的 exec 方法的闭包可以有 commandLine 属性、commandLine 方法、args 属性以及 args 方法等配置供我们使用，我们这里只需要 commandLine 方法就可以达到目的了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从 git tag 中获取应用的版本名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> git tag 的名称</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">def <span class="title">getAppVersionName</span><span class="params">()</span></span>&#123;</span><br><span class="line">  def stdout = <span class="keyword">new</span> ByteArrayOutputStream()</span><br><span class="line">  exec &#123;</span><br><span class="line">  commandLine <span class="string">'git'</span>,<span class="string">'describe'</span>,<span class="string">'--abbrev=0'</span>,<span class="string">'--tags'</span></span><br><span class="line">  standardOutput = stdout</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stdout.toString()</span><br><span class="line">  &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt; 以上示例定义了一个 getAppVersionName 方法来获取我们的 tag 名称，exec 执行后的输出可以用 standardOutput 获得，它是 BaseExecSpec 的一个属性，ExecSpec 继承了 BaseExecSpec,所以我们可以在 exec&#123;&#125;闭包中使用。</span><br><span class="line"></span><br><span class="line">通过该方法我们获取了 git tag 的名称后，就可以把它作为我们应用的版本名称了，使用非常简单，只用把我们的 versionName 配置成这个方法就好了，刚刚我们演示的时候是一个名为 appVersionName 的扩展属性。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">android &#123;</span><br><span class="line">compileSdkVersion <span class="number">23</span></span><br><span class="line">buildToolsVersion <span class="string">"23.0.1"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.youdaily.app"</span></span><br><span class="line">        minSdkVersion <span class="number">14</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span></span><br><span class="line">        versionCode appVersionCode</span><br><span class="line">        <span class="function">versionName <span class="title">getAppVersionName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>以上我们通过 git tag 动态获取了版本名称，那么版本号我们如何动态获取呢？版本号作为我们内部开发的标识，主要用于控制应用进行生成，一般它是+1 递增的，每一次发版，其值就+1，而每一次发版我们就会打一个 tag，tag 的数量也会增加 1 个，和我们版本号的递增逻辑是符合的，那么我们是不是可以把 git tag 的数量作为我们的版本号呢？答案是肯定的，这样打包发版之前，我们只需打个 tag，tag 数量+1，版本号也会跟着+1，达到了我们的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以 git tag 的数量作为其版本号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> tag 的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">def <span class="title">getAppVersionCode</span><span class="params">()</span></span>&#123;</span><br><span class="line"> def stdout = <span class="keyword">new</span> ByteArrayOutputStream()</span><br><span class="line"> exec &#123;</span><br><span class="line"> commandLine <span class="string">'git'</span>,<span class="string">'tag'</span>,<span class="string">'--list'</span></span><br><span class="line"> standardOutput = stdout</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> stdout.toString().split(<span class="string">"\n"</span>).size()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上示例我们定义一个 getAppVersionCode 方法来获取 git tag 的数量，用于我们的版本号，然后我们在 defaultConfig 里使用这个方法即可，替换掉我们的 appVersionCode 变量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">compileSdkVersion <span class="number">23</span></span><br><span class="line">buildToolsVersion <span class="string">"23.0.1"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.youdaily.app"</span></span><br><span class="line">        minSdkVersion <span class="number">14</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span></span><br><span class="line">        <span class="function">versionCode <span class="title">getAppVersionCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        versionName <span class="title">getAppVersionName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>大功告成，这样我们在发版打包之前，只需要打一个 tag，然后 Android Gradle 打包的时候就会自动帮我们生成应用的版本名称和版本号，非常方便，再也不用为维护应用的版本信息担心了，这也是我们使用 Gradle 构建的灵活之处，如果使用 Ant，会麻烦的多，有兴趣的同学可以思考一下。</p>
<h2 id="从属性文件中动态获取和递增版本信息"><a href="#从属性文件中动态获取和递增版本信息" class="headerlink" title="从属性文件中动态获取和递增版本信息"></a>从属性文件中动态获取和递增版本信息</h2><p>其实上一小结已经可以满足我们大部分的情况了，如果大家不想用，或者想自己更灵活的控制版本信息，可以采用 Properties 属性文件的方式，这里我不给出示例代码了，仅给出思路，以供参考。</p>
<p>大致思路如下：</p>
<ul>
<li>在项目目录下新建一个 version.properties 的属性文件。<br>-把版本名称分成三部分 major.minor.patch，版本号分成一部分 number，然后在 version.properties 中新增四个 KV 键值对，其 key 就是我们上面分好的 major，minor，patch 以及 number，value 是对应的值。</li>
<li>然后在 build.gradle 里新建两个方法，用于读取该属性文件，获取对应 Key 的值，然后把 major.minor.patch 这三个 key 拼接成版本名称，number 用于版本号。</li>
<li>以上就达到了获取版本信息的目的，获取使用之后，我们还要更新我们存放在 version.properties 文件中的信息，这样就可以达到版本自增的目的，以供下次使用。</li>
<li>在更新版本名称三部分的时候，你可以自定义自己的逻辑，是逢 10 高位+1 呢，还是其他算法，都可以自己灵活定义。</li>
<li>使用版本信息，更新 version.properties 文件的时机，记得 doLast 这个方法。</li>
<li>记得不会在自己运行调试的时候让你的版本信息自增哦，如何控制呢？就是要区分是真正的打包发版，还是平时的调试、测试，有很多办法来区分的。</li>
</ul>
<p>动态获取生成版本信息的思路都大同小异，只是信息来源不一样，比如 git tag，比如 version 配置等等，你自己的业务项目中还可以从其他更多的渠道来生成，这也是因为 gradle 的灵活，我们才可以随心所欲的做到这么多。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Android</category>
        <category>系统工具</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>Android</tag>
        <tag>Gradle</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Gradle实用技巧-隐藏Android签名文件和密钥信息</title>
    <url>/2018/03/10/2018-03-10-Programing-Android-hide-signer-file/</url>
    <content><![CDATA[<h2 id="什么是Gradle"><a href="#什么是Gradle" class="headerlink" title="什么是Gradle"></a>什么是Gradle</h2><p>Gradle是一款非常优秀的构建系统工具，它使用可以配置的DSL语言描述构建流程，同时允许我们使用原生的Java和Groovy编码的方式进行构建，所以相比Ant、Maven这些非常灵活。</p>
<p>在Gradle中，大部分的构建都是通过Gradle的插件来完成的，插件是Gradle非常好的一个设计，Gradle提供了一个核心可以扩展的平台，然后通过插件来扩展Gradle的能力，灵活方便。</p>
<p>Gradle本身提供了非常多的插件，比如java，war，scala等，可以满足我们的绝大多数需求。如果内置的插件不能满足需求，可以使用第三方开发的插件，甚至自己开发可以满足自己需求的插件。</p>
<p>Gradle官网：<code>https://gradle.org/</code><br>Gradle文档：<code>https://gradle.org/docs</code><br>Gradle插件：<code>https://plugins.gradle.org/</code></p>
<a id="more"></a>
<h2 id="什么是Android-Gradle"><a href="#什么是Android-Gradle" class="headerlink" title="什么是Android Gradle"></a>什么是Android Gradle</h2><p>刚开始我们做Android开发的时候，采用的是Eclipse+Ant的构建方式，后来Android团队打算采用基于IDEA的Android Studio的时候，采用了Gradle进行构建，为了能和Android Studio进行无缝整合，Android团队开发了Android Gradle这个Gradle的第三方插件，用于Android的开发构建。使用Android Gradle，我们可以更好的：</p>
<ul>
<li>代码和资源的复用</li>
<li>很方便的创建App的衍生版本</li>
<li>可以满足自定义、扩展，而且非常容易</li>
</ul>
<p>当然不能少的，可以和Android Studio无缝整合<br>Android团队开发了三个Android Gradle插件，但是他们都属于一套代码库。这三个插件名字分别为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.android.application</span><br><span class="line">com.android.library</span><br><span class="line">com.android.library</span><br></pre></td></tr></table></figure>
<p>从名字上看，其实他们分别对应我们Android的 Android App开发，Android Lib库开发以及Android Test测试工程的开发。</p>
<p>使用这三个插件也非常容易，和Gradle使用其它插件的方式一样，因为这是一个非内置自带的，第三方插件，所以我们首先得声明classpath的依赖，才可以使用，和jdk的classpath很像。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.2.3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们配置里仓库为jcenter，这样当我们配置依赖的时候，gradle就会去这个仓库里寻找我们的依赖。</p>
<p>然后我们在dependencies{}配置里我们需要的是Android Gradle2.2.3版本的插件。</p>
<p>buildscript{}这部分配置可以写到根工程的build.gradle脚本文件中，这样所有的子工程就不用重复配置了。 </p>
<p>以上配置好之后，我们就可以应用我们的Android Gradle插件了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">23</span></span><br><span class="line">    buildToolsVersion <span class="string">"23.0.1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>android{}</code> 是Android插件提供的一个扩展类型，可以让我们自定义Android Gradle工程。<br><code>compileSdkVersion</code> 是编译所依赖的Android SDK的版本，这里是API Level；buildToolsVersion是构建该Android工程所以的构建工具的版本。</p>
<p>以上应用的是一个App工程插件，应用Android Library插件和Android Test插件也类似的，只需要换成相应的id即可。</p>
<h2 id="隐藏Android签名文件和密钥信息"><a href="#隐藏Android签名文件和密钥信息" class="headerlink" title="隐藏Android签名文件和密钥信息"></a>隐藏Android签名文件和密钥信息</h2><p>很多团队一开始的成立的时候，十来个人，三五条枪，就开始创业了，每个组基本上就一个人，扛起所有。开始的时候，大家都不知道这款产品是否可以成功，所以也都没想那么多，只能小步快跑，快速迭代，占领市场，抢占用户，这才是最重要的。</p>
<p>随着产品越做越好，团队越来越大，组内成员越来越多，就开始注重团队协作，编码规范，性能安全，团队建设等等，因为只有做到这些，整个团队的工作效率和产出才能更高，才能有团队的威力，越到最后靠的是团队，而不是一个人。</p>
<p>以前我们都是把App的签名证书和相关密钥放在项目中，托管在git上，这样做非常方便，可以直接访问打包，并且借助git这个代码管理平台维护管理。但是签名信息这个是我们应用非常重要的信息，属于公司重要的资源，所以我们要做到分级管理，保证安全，这也是公司保密措施的一部分，所以基于此，签名信息需要隐藏，但是又可以让大家都可以使用这个签名打包。</p>
<p>签名信息既然不能放在项目中，那么就需要有个地方存放他们，既然不能在每个开发者的电脑上，那就只能放到构建的服务器上，所以要实现这个，你还得有自己的专门用于打包发版的服务器，我们把签名文件和密钥信息放到服务器上，在打包的时候去读取即可，下面我们以使用环境变量的方式为例，当然还有更多方式，比如配置文件等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">23</span></span><br><span class="line">    buildToolsVersion <span class="string">"23.0.1"</span></span><br><span class="line"></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        def appStoreFile = System.getenv(<span class="string">"STORE_FILE"</span>)</span><br><span class="line">        def appStorePassword = System.getenv(<span class="string">"STORE_PASSWORD"</span>)</span><br><span class="line">        def appKeyAlias = System.getenv(<span class="string">"KEY_ALIAS"</span>)</span><br><span class="line">        def appKeyPassword = System.getenv(<span class="string">"KEY_PASSWORD"</span>)</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="function">storeFile <span class="title">file</span><span class="params">(appStoreFile)</span></span></span><br><span class="line"><span class="function">            storePassword appStorePassword</span></span><br><span class="line"><span class="function">            keyAlias appKeyAlias</span></span><br><span class="line"><span class="function">            keyPassword appKeyPassword</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    buildTypes </span>&#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在打包的机器上配置以上环境变量即可，window和linux的方式不一样，关于配置环境变量这一块的知识，大家可以自行google一下。</p>
<p>如果你是使用Jenkins这类CI打包，以Jenkins，它的配置里就可以指定Jenkins使用的环境变量，这样我们就不用区分linux和window了，只需要在Jenkins里配置即可。</p>
<p>以上配置好之后，我们就可以进行打包使用了，签名信息也做了隐藏，看到这里，相信大家也意识到了一个问题，那就是每个开发者电脑上并没有如上的环境变量配置，因为签名信息对他们是隐藏的，那么他们如何进行打包测试呢？这就需要我们两个一个debug签名上场了，我们直接使用android自己提供的debug签名即可，因为我们需要的是签名，保证可以生成App测试（非debug调试）即可，比如给测试。</p>
<p>首先我们要从我们自己的电脑目录上提取出来Android自带的debug签名，一般在你的<br>${HOME}/.android/目录下，找到后拷贝到我们的工程目录下，其次找到他们的签名信息，比如密码，key等，这是公开的，我们可以参考Android文档。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">23</span></span><br><span class="line">    buildToolsVersion <span class="string">"23.0.1"</span></span><br><span class="line"></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        def appStoreFile = System.getenv(<span class="string">"STORE_FILE"</span>)</span><br><span class="line">        def appStorePassword = System.getenv(<span class="string">"STORE_PASSWORD"</span>)</span><br><span class="line">        def appKeyAlias = System.getenv(<span class="string">"KEY_ALIAS"</span>)</span><br><span class="line">        def appKeyPassword = System.getenv(<span class="string">"KEY_PASSWORD"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当不能从环境变量里获取到签名信息的时候，就使用项目中带的debug签名</span></span><br><span class="line">        <span class="keyword">if</span>(!appStoreFile||!appStorePassword||!appKeyAlias||!appKeyPassword)&#123;</span><br><span class="line">            appStoreFile = <span class="string">"debug.keystore"</span></span><br><span class="line">            appStorePassword = <span class="string">"android"</span></span><br><span class="line">            appKeyAlias = <span class="string">"androiddebugkey"</span></span><br><span class="line">            appKeyPassword = <span class="string">"android"</span></span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="function">storeFile <span class="title">file</span><span class="params">(appStoreFile)</span></span></span><br><span class="line"><span class="function">            storePassword appStorePassword</span></span><br><span class="line"><span class="function">            keyAlias appKeyAlias</span></span><br><span class="line"><span class="function">            keyPassword appKeyPassword</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>关键的逻辑就是在signingConfigs中加了判断代码，如果签名信息四要素中的任何一个没有获取到，就使用默认的签名信息，这样当我们在打包服务器进行打包的时候就会使用正式发布的签名，因为我们已经在服务器上配置了签名信息的环境变量；当每个开发者自己生成Release包的时候，因为本机没有配置，就使用默认的签名。</p>
<p>假如有的开发者有时候也需要使用正式发布的签名打正式的包，用于升级测试等目的，也是可以做到的，比如Jenkins，给每个开发者开放一个账号，他们自己新建个Job就可以打正式的包了，打了之后可以在生成的构建里下载。</p>
<p>这里要隐藏我们的签名信息，既能保证签名信息的安全性，又可以进行正式的打包，其中的关键点是一个专有的打包服务器，如果你们公司还没有的话，赶紧试试吧，好处多多，从这个小技巧也可以看到Gradle的灵活性，我们和编写Java代码一样编写我们的构建打包流程。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Android</category>
        <category>系统工具</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>Android</tag>
        <tag>Gradle</tag>
        <tag>高级技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo 注解驱动</title>
    <url>/2017/11/28/2017-12-28-Programing-Java-Dubbo-Annotation-Driven/</url>
    <content><![CDATA[<h1 id="Dubbo-注解驱动（Annotation-Driven）"><a href="#Dubbo-注解驱动（Annotation-Driven）" class="headerlink" title="Dubbo 注解驱动（Annotation-Driven）"></a>Dubbo 注解驱动（Annotation-Driven）</h1><h2 id="注解驱动（Annotation-Driven）"><a href="#注解驱动（Annotation-Driven）" class="headerlink" title="注解驱动（Annotation-Driven）"></a>注解驱动（Annotation-Driven）</h2><h3 id="DubboComponentScan"><a href="#DubboComponentScan" class="headerlink" title="@DubboComponentScan"></a><code>@DubboComponentScan</code></h3><h4 id="起始版本：-2-5-7"><a href="#起始版本：-2-5-7" class="headerlink" title="起始版本： 2.5.7"></a>起始版本： <code>2.5.7</code></h4><h4 id="lt-dubbo-annotation-gt-历史遗留问题"><a href="#lt-dubbo-annotation-gt-历史遗留问题" class="headerlink" title="&lt;dubbo:annotation&gt;历史遗留问题"></a><code>&lt;dubbo:annotation&gt;</code>历史遗留问题</h4><h5 id="1-注解支持不充分"><a href="#1-注解支持不充分" class="headerlink" title="1. 注解支持不充分"></a>1. 注解支持不充分</h5><p>在 Dubbo <code>2.5.7</code>之前的版本 ，Dubbo 提供了两个核心注解 <code>@Service</code> 以及 <code>@Reference</code>，分别用于 Dubbo 服务提供和 Dubbo 服务引用。</p>
<p>其中，<code>@Service</code> 作为 XML 元素 <code>&lt;dubbo:service&gt;</code>的替代注解，与 Spring Framework <code>@org.springframework.stereotype.Service</code> 类似，用于服务提供方 Dubbo 服务暴露。与之相对应的<code>@Reference</code>，则是替代<code>&lt;dubbo:reference</code> 元素，类似于 Spring 中的 <code>@Autowired</code>。</p>
<p><code>2.5.7</code> 之前的 Dubbo，与早期的 Spring Framework 2.5 存在类似的不足，即注解支持不够充分。注解需要和 XML 配置文件配合使用，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"annotation-provider"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"127.0.0.1:4548"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.alibaba.dubbo.config.spring.annotation.provider"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="2-Service-Bean-不支持-Spring-AOP"><a href="#2-Service-Bean-不支持-Spring-AOP" class="headerlink" title="2. @Service Bean 不支持 Spring AOP"></a>2. <code>@Service</code> Bean 不支持 Spring AOP</h5><p>同时，使用 <code>&lt;dubbo:annotation&gt;</code> 方式扫描后的 Dubbo <code>@Service</code> ，在 Spring 代理方面存在问题，如 GitHub 上的 issue <a href="https://github.com/alibaba/dubbo/issues/794：" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/794：</a></p>
<blockquote>
<p>关于 dubbo @Service 注解生成 ServiceBean 时, interface 获取成 spring 的代理对象的 bug</p>
<blockquote>
<p>在项目里， 我使用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@com</span>.alibaba.dubbo.config.annotation.Service</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SUserJpushServiceImp</span></span></span><br></pre></td></tr></table></figure>
<p>的形式， 来暴露服务。但是在发布服务的时候， interface class 是通过<br><code>serviceConfig.setInterface(bean.getClass().getInterfaces()[0]);</code><br>的形式获取， 刚好， 我的 service 都使用了@Transactional 注解， 对象被代理了。所以获取到的 interface 是 Spring 的代理接口…</p>
</blockquote>
</blockquote>
<p>不少热心的小伙伴不仅发现这个历史遗留问题，而且提出了一些修复方案。同时，为了更好地适配 Spring 生命周期以及将 Dubbo 完全向注解驱动编程模型过渡，因此，引入了全新 Dubbo 组件扫描注解 - <code>@DubboComponentScan</code>。</p>
<blockquote>
<p>注： <code>&lt;dubbo:annotation&gt;</code> Spring AOP 问题将在 <code>2.5.9</code> 中修复：<a href="https://github.com/alibaba/dubbo/issues/1125" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/1125</a></p>
</blockquote>
<h5 id="3-Reference-不支持字段继承性"><a href="#3-Reference-不支持字段继承性" class="headerlink" title="3. @Reference 不支持字段继承性"></a>3. @Reference 不支持字段继承性</h5><p>假设有一个 Spring Bean <code>AnnotationAction</code> 直接通过字段<code>annotationService</code> 标记 <code>@Reference</code> 引用 <code>AnnotationService</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.examples.annotation.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.examples.annotation.api.AnnotationService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"annotationAction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>AnnotationAction</code> 被 XML 元素 <code>&lt;dubbo:annotation&gt;</code> 扫描后：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.alibaba.dubbo.examples.annotation.action"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>字段 <code>annotationService</code> 能够引用到 <code>AnnotationService</code>，执行 <code>doSayHello</code> 方法能够正常返回。</p>
<p>如果将字段<code>annotationService</code> 抽取到<code>AnnotationAction</code> 的父类<code>BaseAction</code> 后，<code>AnnotationService</code> 无法再被引用，改造如下所示：</p>
<p><code>AnnotationAction.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"annotationAction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAction</span> <span class="keyword">extends</span> <span class="title">BaseAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAnnotationService().sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BaseAction.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AnnotationService <span class="title">getAnnotationService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造后，再次执行 <code>doSayHello</code> 方法，<code>NullPointerException</code> 将会被抛出。说明<code>&lt;dubbo:annotation&gt;</code> 并不支持<code>@Reference</code> 字段继承性。</p>
<p>了解了历史问题，集合整体愿景，下面介绍<code>@DubboComponentScan</code> 的设计原则。</p>
<h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>Spring Framework 3.1 引入了新 Annotation - <code>@ComponentScan</code> ， 完全替代了 XML 元素 <code>&lt;context:component-scan&gt;</code> 。同样， <code>@DubboComponentScan</code> 作为 Dubbo <code>2.5.7</code> 新增的 Annotation，也是 XML 元素 <code>&lt;dubbo:annotation&gt;</code> 的替代方案。</p>
<p>在命名上（类名以及属性方法），为了简化使用和关联记忆，Dubbo 组件扫描 Annotation <code>@DubboComponentScan</code>，借鉴了 Spring Boot 1.3 引入的 <code>@ServletComponentScan</code>。定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DubboComponentScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise annotation</span></span><br><span class="line"><span class="comment">     * declarations e.g.: &#123;<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>("org.my.pkg")&#125; instead of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>(basePackages="org.my.pkg")&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base packages to scan for annotated <span class="doctag">@Service</span> classes. &#123;<span class="doctag">@link</span> #value()&#125; is an</span></span><br><span class="line"><span class="comment">     * alias for (and mutually exclusive with) this attribute.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Use &#123;<span class="doctag">@link</span> #basePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment">     * package names.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment">     * scan for annotated <span class="doctag">@Service</span> classes. The package of each class specified will be</span></span><br><span class="line"><span class="comment">     * scanned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> classes from the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>basePackages()</code> 和 <code>value()</code> 均能支持占位符（placeholder）指定的包名</p>
</blockquote>
<p>在职责上，<code>@DubboComponentScan</code> 相对于 Spring Boot <code>@ServletComponentScan</code> 更为繁重，原因在于处理 Dubbo <code>@Service</code> 类暴露 Dubbo 服务外，还有帮助 Spring Bean <code>@Reference</code>字段或者方法注入 Dubbo 服务代理。</p>
<p>在场景上，Spring Framework <code>@ComponentScan</code> 组件扫描逻辑更为复杂。而在 <code>@DubboComponentScan</code> 只需关注 <code>@Service</code> 和 <code>@Reference</code> 处理。</p>
<p>在功能上， <code>@DubboComponentScan</code> 不但需要提供完整 Spring AOP 支持的能力，而且还得具备<code>@Reference</code> 字段可继承性的能力。</p>
<p>了解基本设计原则后，下面通过完整的示例，简介<code>@DubboComponentScan</code> 使用方法以及注意事项。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>后续通过服务提供方（<code>@Serivce</code>）以及服务消费方（<code>@Reference</code>）两部分来介绍<code>@DubboComponentScan</code> 使用方法。</p>
<p>假设，服务提供方和服务消费分均依赖服务接口<code>DemoService</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="服务提供方（-Serivce）"><a href="#服务提供方（-Serivce）" class="headerlink" title="服务提供方（@Serivce）"></a>服务提供方（<code>@Serivce</code>）</h5><h6 id="实现-DemoService"><a href="#实现-DemoService" class="headerlink" title="实现 DemoService"></a>实现 <code>DemoService</code></h6><p>服务提供方实现<code>DemoService</code> - <code>AnnotationDemoService</code> ，同时标注 Dubbo <code>@Service</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation &#123;<span class="doctag">@link</span> DemoService&#125; 实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello , "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="服务提供方-Annotation-配置"><a href="#服务提供方-Annotation-配置" class="headerlink" title="服务提供方 Annotation 配置"></a>服务提供方 Annotation 配置</h6><p>将 <code>AnnotationDemoService</code> 暴露成 Dubbo 服务，需要依赖 Spring Bean：<code>AplicationConfig</code>、<code>ProtocolConfig</code> 以及 <code>RegistryConfig</code> 。这三个 Spring Bean 过去可通过 XML 文件方式组装 Spring Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当前应用信息配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-annotation-provider"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 连接注册中心配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"my-registry"</span> <span class="attr">address</span>=<span class="string">"N/A"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"12345"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上装配方式不予推荐，推荐使用 Annotation 配置，因此可以换成 Spring <code>@Configuration</code> Bean 的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProtocolConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供方配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span>(<span class="string">"com.alibaba.dubbo.demo.provider"</span>) <span class="comment">// 扫描 Dubbo 组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前应用配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dubbo-annotation-provider"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-annotation-provider"</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"my-registry"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setAddress(<span class="string">"N/A"</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dubbo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">        protocolConfig.setName(<span class="string">"dubbo"</span>);</span><br><span class="line">        protocolConfig.setPort(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">return</span> protocolConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="服务提供方引导类"><a href="#服务提供方引导类" class="headerlink" title="服务提供方引导类"></a>服务提供方引导类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.bootstrap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ProviderConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供方引导类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册配置 Bean</span></span><br><span class="line">        context.register(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 启动上下文</span></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 获取 DemoService Bean</span></span><br><span class="line">        DemoService demoService = context.getBean(DemoService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行 sayHello 方法</span></span><br><span class="line">        String message = demoService.sayHello(<span class="string">"World"</span>);</span><br><span class="line">        <span class="comment">// 控制台输出信息</span></span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ProviderBootstrap</code> 启动并执行后，控制输出与预期一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello , World</span><br></pre></td></tr></table></figure>
<p>以上直接结果说明 <code>@DubboComponentScan(&quot;com.alibaba.dubbo.demo.provider&quot;)</code> 扫描后，标注 Dubbo <code>@Service</code> 的 <code>AnnotationDemoService</code> 被注册成 Spring Bean，可从 Spring ApplicationContext 自由获取。</p>
<h5 id="服务消费方（-Reference）"><a href="#服务消费方（-Reference）" class="headerlink" title="服务消费方（@Reference）"></a>服务消费方（<code>@Reference</code>）</h5><h6 id="服务-DemoService"><a href="#服务-DemoService" class="headerlink" title="服务 DemoService"></a>服务 <code>DemoService</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation 驱动 &#123;<span class="doctag">@link</span> DemoService&#125; 消费方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoServiceConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span>(url = <span class="string">"dubbo://127.0.0.1:12345"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHell</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="服务消费方-Annotation-配置"><a href="#服务消费方-Annotation-配置" class="headerlink" title="服务消费方 Annotation 配置"></a>服务消费方 Annotation 配置</h6><p>与服务提供方配置类似，服务消费方也许 Dubbo 相关配置 Bean - <code>ConsumerConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.consumer.AnnotationDemoServiceConsumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务消费方配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前应用配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-annotation-consumer"</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setAddress(<span class="string">"N/A"</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 AnnotationDemoServiceConsumer，<span class="doctag">@DubboComponentScan</span> 将处理其中 <span class="doctag">@Reference</span> 字段。</span></span><br><span class="line"><span class="comment">     * 如果 AnnotationDemoServiceConsumer 非 Spring Bean 的话，</span></span><br><span class="line"><span class="comment">     * 即使 <span class="doctag">@DubboComponentScan</span> 指定 package 也不会进行处理，与 Spring <span class="doctag">@Autowired</span> 同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnotationDemoServiceConsumer <span class="title">annotationDemoServiceConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationDemoServiceConsumer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="服务消费方引导类"><a href="#服务消费方引导类" class="headerlink" title="服务消费方引导类"></a>服务消费方引导类</h6><p>服务消费方需要先引导服务提供方，下面的实例将会启动两个 Spring 应用上下文，首先引导服务提供方 Spring 应用上下文，同时，需要复用前面 Annotation 配置 <code>ProviderConfiguration</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动服务提供方上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startProviderContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Annotation 配置上下文</span></span><br><span class="line">    AnnotationConfigApplicationContext providerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    <span class="comment">// 注册配置 Bean</span></span><br><span class="line">    providerContext.register(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 启动服务提供方上下文</span></span><br><span class="line">    providerContext.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后引导服务消费方 Spring 应用上下文：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动并且返回服务消费方上下文</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> AnnotationConfigApplicationContext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext <span class="title">startConsumerContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务消费方 Annotation 配置上下文</span></span><br><span class="line">    AnnotationConfigApplicationContext consumerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    <span class="comment">// 注册服务消费方配置 Bean</span></span><br><span class="line">    consumerContext.register(ConsumerConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 启动服务消费方上下文</span></span><br><span class="line">    consumerContext.refresh();</span><br><span class="line">    <span class="comment">// 返回服务消费方 Annotation 配置上下文</span></span><br><span class="line">    <span class="keyword">return</span> consumerContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的引导类实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.bootstrap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ConsumerConfiguration;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ProviderConfiguration;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.consumer.AnnotationDemoServiceConsumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务消费端引导类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动服务提供方上下文</span></span><br><span class="line">        startProviderContext();</span><br><span class="line">        <span class="comment">// 启动并且返回服务消费方上下文</span></span><br><span class="line">        ApplicationContext consumerContext = startConsumerContext();</span><br><span class="line">        <span class="comment">// 获取 AnnotationDemoServiceConsumer Bean</span></span><br><span class="line">        AnnotationDemoServiceConsumer consumer = consumerContext.getBean(AnnotationDemoServiceConsumer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行 doSayHello 方法</span></span><br><span class="line">        String message = consumer.doSayHello(<span class="string">"World"</span>);</span><br><span class="line">        <span class="comment">// 输出执行结果</span></span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动并且返回服务消费方上下文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AnnotationConfigApplicationContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext <span class="title">startConsumerContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务消费方 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext consumerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册服务消费方配置 Bean</span></span><br><span class="line">        consumerContext.register(ConsumerConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 启动服务消费方上下文</span></span><br><span class="line">        consumerContext.refresh();</span><br><span class="line">        <span class="comment">// 返回服务消费方 Annotation 配置上下文</span></span><br><span class="line">        <span class="keyword">return</span> consumerContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务提供方上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startProviderContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext providerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册配置 Bean</span></span><br><span class="line">        providerContext.register(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 启动服务提供方上下文</span></span><br><span class="line">        providerContext.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>ConsumerBootstrap</code>结果，仍然符合期望，<code>AnnotationDemoServiceConsumer</code> 输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello , World</span><br></pre></td></tr></table></figure>
<h4 id="Spring-AOP-支持"><a href="#Spring-AOP-支持" class="headerlink" title="Spring AOP 支持"></a>Spring AOP 支持</h4><p>前面提到 <code>&lt;dubbo:annotation&gt;</code> 注册 Dubbo <code>@Service</code> 组件后，在 Spring AOP 支持方面存在问题。事务作为 Spring AOP 的功能扩展，自然也会在 <code>&lt;dubbo:annotation&gt;</code>中不支持。</p>
<p><code>@DubboComponentScan</code> 针对以上问题，实现了对 Spring AOP 是完全兼容。将上述服务提供方 Annotation 配置做出一定的调整，标注<code>@EnableTransactionManagement</code> 以及自定义实现<code>PlatformTransactionManager</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span>(<span class="string">"com.alibaba.dubbo.demo.provider"</span>) <span class="comment">// 扫描 Dubbo 组件</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 激活事务管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略其他配置 Bean 定义</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义事务管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PlatformTransactionManager() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"get transaction ..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SimpleTransactionStatus();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"commit transaction ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"rollback transaction ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时调整 <code>AnnotationDemoService</code> - 增加<code>@Transactional</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略实现，保持不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行<code>ConsumerBootstrap</code> , 观察控制台输出内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get transaction ...</span><br><span class="line">commit transaction ...</span><br><span class="line">Hello , World</span><br></pre></td></tr></table></figure>
<p>输入内容中多处了两行，说明自定义 <code>PlatformTransactionManager</code> <code>getTransaction(TransactionDefinition)</code> 以及 <code>commit(TransactionStatus)</code> 方法被执行，进而说明 <code>AnnotationDemoService</code> 的<code>sayHello(String)</code> 方法执行时，事务也伴随执行。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><code>ConsumerConfiguration</code> 上的 <code>@DubboComponentScan</code> 并没有指定 <code>basePackages</code> 扫描，这种情况会将<code>ConsumerConfiguration</code> 当做 <code>basePackageClasses</code> ，即扫描<code>ConsumerConfiguration</code> 所属的 package <code>com.alibaba.dubbo.demo.config</code> 以及子 package。由于当前示例中，不存在标注 Dubbo <code>@Service</code>的类，因此在运行时日志（如果开启的话）会输出警告信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARN :  [DUBBO] No Spring Bean annotating Dubbo&apos;s @Service was found in Spring BeanFactory, dubbo version: 2.0.0, current host: 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>以上信息大可不必担忧，因为 <code>@DubboComponentScan</code> 除了扫描 Dubbo <code>@Service</code> 组件以外，还将处理 <code>@Reference</code>字段注入。然而读者特别关注<code>@Reference</code>字段注入的规则。</p>
<p>以上实现为例，<code>AnnotationDemoServiceConsumer</code> 必须申明为 Spring <code>@Bean</code> 或者 <code>@Component</code>（或者其派生注解），否则 <code>@DubboComponentScan</code> 不会主动将标注 <code>@Reference</code>字段所在的声明类提成为 Spring Bean，换句话说，如果 <code>@Reference</code>字段所在的声明类不是 Spring Bean 的话， <code>@DubboComponentScan</code> 不会处理<code>@Reference</code>注入，其原理与 Spring <code>@Autowired</code> 一致。</p>
<p>以上使用不当可能会导致相关问题，如 GitHub 上曾有小伙伴提问：<a href="https://github.com/alibaba/dubbo/issues/825" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/825</a></p>
<blockquote>
<p><strong>li362692680</strong> 提问：</p>
<blockquote>
<p>@DubboComponentScan 注解在消费端扫描包时扫描的是 @Service 注解？？不是@Reference 注解？？<br>启动时报<br>DubboComponentScanRegistrar-85]-[main]-[INFO] 0 annotated @Service Components { [] }</p>
</blockquote>
<p>笔者(<strong>mercyblitz</strong>)回复：</p>
<blockquote>
<p><code>@Reference</code> 类似于 <code>@Autowired</code> 一样，首先其申明的类必须被 Spring 上下文当做一个 Bean，因此，Dubbo 并没有直接将 <code>@Reference</code> 字段所在的类提升成 Bean。</p>
<p>综上所述，这并不是一个问题，而是用法不当！</p>
</blockquote>
</blockquote>
<h4 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h4><p>最新发布的 Dubbo <code>2.5.8</code> 中，<code>@DubboComponentScan</code> 在以下特殊场景下存在 Spring <code>@Service</code> 不兼容情况：</p>
<blockquote>
<p>假设有两个服务实现类 <code>A</code> 和 <code>B</code>，同时存放在<code>com.acme</code> 包下：</p>
<ul>
<li><code>A</code> 标注 Dubbo <code>@Service</code></li>
<li><code>B</code> 标注 Dubbo <code>@Service</code> 和 Spring <code>@Service</code></li>
</ul>
<p>当 Spring <code>@ComponentScan</code> 先扫描<code>com.acme</code> 包时，<code>B</code> 被当做 Spring Bean 的候选类。随后，<code>@DubboComponentScan</code> 也扫描相同的包。当应用启动时，<code>A</code> 和 <code>B</code> 虽然都是 Spring Bean，可仅 <code>A</code> 能够暴露 Dubbo 服务，<code>B</code> 则丢失。</p>
</blockquote>
<p>问题版本：<code>2.5.7</code>、<code>2.5.8</code></p>
<p>问题详情：<a href="https://github.com/alibaba/dubbo/issues/1120" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/1120</a></p>
<p>修复版本：<code>2.5.9</code>（下个版本）</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Java</category>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Java</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础-日期和时间</title>
    <url>/2017/11/22/2017-11-22_Programing-Python-Basic-date-time-intro/</url>
    <content><![CDATA[<hr>
<p>Python程序可以通过多种方式来处理日期和时间。<br>日期格式之间的转换是计算机的一个共同核心。Python的时间和日历模块能够帮助我们跟踪的日期和时间。</p>
<h2 id="什么是刻度？"><a href="#什么是刻度？" class="headerlink" title="什么是刻度？"></a>什么是刻度？</h2><p>时间间隔以秒为单位的浮点数。特别是在时间瞬间在自1970年1月1日(纪元)12点的表示。</p>
<p>在Python提供一个流行时间 time 模块，提供时间的的 函数功能，并可转换表示。函数 <code>time.time()</code>返回当前系统时间，从1970年1月1日12点起来的秒数。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time;  <span class="comment"># This is required to include time module.</span></span><br><span class="line"></span><br><span class="line">ticks = time.time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Number of ticks since 12:00am, January 1, 1970:"</span>, ticks)</span><br></pre></td></tr></table></figure>
<p>将产生一个结果，如下 -<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Number of ticks since <span class="number">12</span>:<span class="number">00</span>am, January <span class="number">1</span>, <span class="number">1970</span>: <span class="number">1568018748.2947338</span></span><br></pre></td></tr></table></figure></p>
<p>日期计算使用刻度线是很容易做到的。<br>然而，新纪元日期之前不能以这种形式表示。在未来的一个日期也不能表示这种方式, 分界点是在某个时候，在 UNIX和Windows上为 2038年。</p>
<a id="more"></a>
<h2 id="什么是TimeTuple？"><a href="#什么是TimeTuple？" class="headerlink" title="什么是TimeTuple？"></a>什么是TimeTuple？</h2><p>Python时间的函数处理时间9个数字的元组，如下图所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>字段</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4-digit year</td>
<td>2019</td>
</tr>
<tr>
<td>1</td>
<td>Month</td>
<td>1 to 12</td>
</tr>
<tr>
<td>2</td>
<td>Day</td>
<td>1 to 31</td>
</tr>
<tr>
<td>3</td>
<td>Hour</td>
<td>0 to 23</td>
</tr>
<tr>
<td>4</td>
<td>Minute</td>
<td>0 to 59</td>
</tr>
<tr>
<td>5</td>
<td>Second</td>
<td>0 to 61 (60 or 61 are leap-seconds)</td>
</tr>
<tr>
<td>6</td>
<td>Day of Week</td>
<td>0 to 6 (0 is Monday)</td>
</tr>
<tr>
<td>7</td>
<td>Day of year</td>
<td>1 to 366 (Julian day)</td>
</tr>
<tr>
<td>8</td>
<td>Daylight savings</td>
<td>-1, 0, 1, -1 means library determines DST</td>
</tr>
</tbody>
</table>
</div>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (time.localtime())</span><br></pre></td></tr></table></figure>
<p>这将产生一个结果如下 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.struct_time(tm_year=<span class="number">2019</span>, tm_mon=<span class="number">9</span>, tm_mday=<span class="number">9</span>, tm_hour=<span class="number">10</span>, tm_min=<span class="number">51</span>, tm_sec=<span class="number">9</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">252</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>上述元组相当于struct_time结构。这种结构具有以下属性 -</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>属性</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>tm_year</td>
<td>2019</td>
</tr>
<tr>
<td>1</td>
<td>tm_mon</td>
<td>1 to 12</td>
</tr>
<tr>
<td>2</td>
<td>tm_mday</td>
<td>1 to 31</td>
</tr>
<tr>
<td>3</td>
<td>tm_hour</td>
<td>1 to 23</td>
</tr>
<tr>
<td>4</td>
<td>tm_min</td>
<td>1 to 59</td>
</tr>
<tr>
<td>5</td>
<td>tm_sec</td>
<td>0 to 61 (60 or 61 are leap-seconds)</td>
</tr>
<tr>
<td>6</td>
<td>tm_wday</td>
<td>0 to 6 (0 is Monday)</td>
</tr>
<tr>
<td>7</td>
<td>tm_yday</td>
<td>1 to 366 (Julian day)</td>
</tr>
<tr>
<td>8</td>
<td>tm_isdst</td>
<td>-1, 0, 1, -1 means library determines DST</td>
</tr>
</tbody>
</table>
</div>
<h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><p>划时代浮点值从秒时刻转换生成为时间元组，浮点值传递给一个函数返回时间的元组并带上所有九个项目无效(例如，本地时间)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">localtime = time.localtime(time.time())</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Local current time :"</span>, localtime)</span><br></pre></td></tr></table></figure>
<p>这将产生以下结果，这可能会在任何其他像样形式被格式化.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Local current time : time.struct_time(tm_year=<span class="number">2019</span>, tm_mon=<span class="number">9</span>, tm_mday=<span class="number">9</span>, tm_hour=<span class="number">16</span>, tm_min=<span class="number">51</span>, tm_sec=<span class="number">9</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">252</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="获取格式化时间"><a href="#获取格式化时间" class="headerlink" title="获取格式化时间"></a>获取格式化时间</h2><p>可以在格式化任何时候按您的要求，但用来获得时间可读格式的简单方法是asctime() -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">localtime = time.asctime( time.localtime(time.time()) )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Local current time :"</span>, localtime)</span><br></pre></td></tr></table></figure>
<p>这将产生以下结果<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Local current time : Mon Sep  <span class="number">9</span> <span class="number">16</span>:<span class="number">57</span>:<span class="number">48</span> <span class="number">2019</span></span><br></pre></td></tr></table></figure></p>
<h2 id="获取一个月份的日历"><a href="#获取一个月份的日历" class="headerlink" title="获取一个月份的日历"></a>获取一个月份的日历</h2><p>日历模块提供各种各样年度和月度的日历方法。在这里，我们将打印给定月份(2008年1月)的日历 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"></span><br><span class="line">cal = calendar.month(<span class="number">2019</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Here is the calendar:"</span>)</span><br><span class="line"><span class="keyword">print</span> (cal)</span><br></pre></td></tr></table></figure>
<p>这将产生以下结果 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Here <span class="keyword">is</span> the calendar:</span><br><span class="line">   February <span class="number">2019</span></span><br><span class="line">Mo Tu We Th Fr Sa Su</span><br><span class="line">             <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span></span><br><span class="line"><span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span></span><br></pre></td></tr></table></figure>
<h3 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h3><p>Python提供一个流行时间模块，为时间和表示之间转换提供了相应函数。<br>这里是所有可用方法的列表<br>|序号|函数|描述|<br>|—-|—-|—-|<br>|1|time.altzone |如果定义则在当地的DST时区偏移，在UTC西部秒数。这是负值，如果当地的MST时区是UTC以东 (在西欧，包括英国).只使用这个，如果白天不为零。|<br>|2|time.asctime([tupletime]) |接受时间元组，并返回一个可读24个字符的字符串，如 ‘Tue Dec 11 18:07:14 2008’.|<br>|3|time.clock( ) |返回当前CPU时间为几秒钟的浮点数。要测量计算成本的不同的方法，time.clock()的值比time.time更有用。|<br>|4|time.ctime([secs])|类似 asctime(localtime(secs))和不带参数的 ctime()函数|<br>|5|time.gmtime([secs]) |接受从新纪元用秒表示瞬间和返回用UTC表示时间元组t。注: t.tm_isdst 总是为 0|<br>|6|time.localtime([secs]) |接受从新纪元用秒表示瞬间和返回本地时间的时间元组t(t.tm_isdst 为 0 或 1, 根据DST是否通过局部规则适用于时刻秒)|<br>|7|time.mktime(tupletime) |接受表示为本地时间的时间元组并返回从新纪元以秒表示瞬间的一个浮点值|<br>|8|time.sleep(secs) |线程暂停secs秒调用|<br>|9|time.strftime(fmt[,tupletime]) |接受表示为本地时间的时间元组瞬间，并返回表示由字符串指定 fmt 瞬间的字符串 |<br>|10|time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’) |解析 str 按照格式字符串格式化并返回时间元组格式的时间|<br>|11|time.time( ) |返回当前时刻，从新纪元以来的秒的浮点数|<br>|12|time.tzset() |通过重置库例程使用时间转换规则。 环境变量TZ指定如何做到这一点 |下列是时间模块提供两个重要属性：</p>
<p>下列是时间模块提供两个重要属性：<br>|序号|属性及说明|<br>|—-|—-|<br>|1|time.timezone |属性time.timezone是在本地时区以UTC的秒偏移量(不包括DST) |<br>|2|time.tzname |属性time.tzname是一对区域设置相关的字符串|</p>
<h2 id="calendar-日历模块"><a href="#calendar-日历模块" class="headerlink" title="calendar 日历模块"></a>calendar 日历模块</h2><p>calendar 模块提供日历相关的功能，包括函数用来打印给定月份或年份文本日历。默认情况下，日历采用星期一作为一周的第一天，周日是最后一个。如要改变这种情况，调用calendar.setfirstweekday()函数。这里是 calendar 模块可用的函数列表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>calendar.calendar(year,w=2,l=1,c=6)</td>
<td>返回一个多行字符串使用格式化成用c空格分隔的三列逐年的日历</td>
</tr>
<tr>
<td>2</td>
<td>calendar.firstweekday( )</td>
<td>返回每周工作日开始的当前设置。默认情况下，当日历被首次导入是0，这意味着星期一</td>
</tr>
<tr>
<td>3</td>
<td>calendar.isleap(year)</td>
<td>如果 year 是闰年返回True;否则为false</td>
</tr>
<tr>
<td>4</td>
<td>calendar.leapdays(y1,y2)</td>
<td>返回跨越润年在范围内(y1,y2)的总数</td>
</tr>
<tr>
<td>5</td>
<td>calendar.month(year,month,w=2,l=1)</td>
<td>返回一个多行字符串以及逐年月月份的日历，每周一行加上两个标题行。</td>
</tr>
<tr>
<td>6</td>
<td>calendar.monthcalendar(year,month)</td>
<td>返回列表的列表整数。</td>
</tr>
<tr>
<td>7</td>
<td>calendar.monthrange(year,month)</td>
<td>返回两个整数。</td>
</tr>
<tr>
<td>8</td>
<td>calendar.prcal(year,w=2,l=1,c=6)</td>
<td>类似打印 calendar.calendar(year,w,l,c).</td>
</tr>
<tr>
<td>9</td>
<td>calendar.prmonth(year,month,w=2,l=1)</td>
<td>类似打印 calendar.month(year,month,w,l).</td>
</tr>
<tr>
<td>10</td>
<td>calendar.setfirstweekday(weekday)</td>
<td>设定每个星期的第一天工作日代码。工作日代码是0(星期一)至6(星期日)</td>
</tr>
<tr>
<td>11</td>
<td>calendar.timegm(tupletime)</td>
<td>time.gmtime反转：接受时间元组形式的时刻，并返回同一时刻作为自新纪元以来秒的浮点数</td>
</tr>
<tr>
<td>12</td>
<td>calendar.weekday(year,month,day)</td>
<td>返回给定日期是星期几代码。 工作日代码是0(星期一)至60(星期日);月数是1(1月)到12(12月)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="其它模块和功能："><a href="#其它模块和功能：" class="headerlink" title="其它模块和功能："></a>其它模块和功能：</h2><p>如果你有兴趣，那么在这里你会发现其他重要的模块和功能的列表，包括在Python日期和时间的使用：</p>
<p>datetime模块<br><a href="https://docs.python.org/3/library/datetime.html#module-datetime" target="_blank" rel="noopener">https://docs.python.org/3/library/datetime.html#module-datetime</a></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础-常用术语对照表</title>
    <url>/2017/11/19/2017-11-19_Programing-Python-Basic-Common-Terms-table/</url>
    <content><![CDATA[<hr>
<p>下面内容主要摘抄自<code>python</code> 官网，<a href="https://docs.python.org/3.7/glossary.html#glossary" target="_blank" rel="noopener">https://docs.python.org/3.7/glossary.html#glossary</a>，部分内容有删减。</p>
<h3 id="2to3"><a href="#2to3" class="headerlink" title="2to3"></a>2to3</h3><p>一个将 <code>Python</code> 2.x 代码转换为 <code>Python</code> 3.x 代码的工具，能够处理大部分通过解析源码并遍历解析树可检测到的不兼容问题。</p>
<p>2to3 包含在标准库中，模块名为 lib2to3；并提供一个独立入口点 Tools/scripts/2to3。参见 2to3 - 自动将 <code>Python</code> 2 代码转为 <code>Python</code> 3 代码。</p>
<p>因为官方将在2020年不再支持 <code>Python</code> 2.x, 在遇到没有<code>Python</code> 2.X 版本 的code 的时候，可以尝试使用这个工具将代码转化成Python 的版本。</p>
<h3 id="abstract-base-class-—-抽象基类"><a href="#abstract-base-class-—-抽象基类" class="headerlink" title="abstract base class — 抽象基类"></a>abstract base class — 抽象基类</h3><p>抽象基类简称 ABC，是对 duck-typing 的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如 hasattr() 显得过于笨拙或有微妙错误（例如使用 魔术方法）。ABC 引入了虚拟子类，这种类并非继承自其他类，但却仍能被 isinstance() 和 issubclass() 所认可；详见 abc 模块文档。<code>Python</code> 自带许多内置的 ABC 用于实现数据结构（在 collections.abc 模块中）、数字（在 numbers 模块中）、流（在 io 模块中）、导入查找器和加载器（在 importlib.abc 模块中）。你可以使用 abc 模块来创建自己的 ABC。</p>
<h3 id="argument-—-参数"><a href="#argument-—-参数" class="headerlink" title="argument — 参数"></a>argument — 参数</h3><p>在调用函数时传给 function （或 method ）的值。参数分为两种：</p>
<ul>
<li>关键字参数: 在函数调用中前面带有标识符（例如 name=）或者作为包含在前面带有 ** 的字典里的值传入。<br>  举例来说，3 和 5 在以下对 complex() 的调用中均属于关键字参数:  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">complex(real=<span class="number">3</span>, imag=<span class="number">5</span>)</span><br><span class="line">complex(**&#123;<span class="string">'real'</span>: <span class="number">3</span>, <span class="string">'imag'</span>: <span class="number">5</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>位置参数: 不属于关键字参数的参数。位置参数可出现于参数列表的开头以及/或者作为前面带有 * 的 iterable 里的元素被传入。<br>  举例来说，3 和 5 在以下调用中均属于位置参数:  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">complex(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">complex(*(<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
参数会被赋值给函数体中对应的局部变量。有关赋值规则参见 调用 一节。根据语法，任何表达式都可用来表示一个参数；最终算出的值会被赋给对应的局部变量。</li>
</ul>
<p>另参见 parameter 术语表条目，常见问题中 参数与形参的区别 以及 PEP 362。</p>
<a id="more"></a>
<h3 id="asynchronous-context-manager-—-异步上下文管理器"><a href="#asynchronous-context-manager-—-异步上下文管理器" class="headerlink" title="asynchronous context manager — 异步上下文管理器"></a>asynchronous context manager — 异步上下文管理器</h3><p>此种对象通过定义 <strong>aenter</strong>() 和 <strong>aexit</strong>() 方法来对 async with 语句中的环境进行控制。由 PEP 492 引入。</p>
<h3 id="asynchronous-generator-—-异步生成器"><a href="#asynchronous-generator-—-异步生成器" class="headerlink" title="asynchronous generator — 异步生成器"></a>asynchronous generator — 异步生成器</h3><p>返回值为 asynchronous generator iterator 的函数。它与使用 async def 定义的协程函数很相似，不同之处在于它包含 yield 表达式以产生一系列可在 async for 循环中使用的值。</p>
<p>此术语通常是指异步生成器函数，但在某些情况下则可能是指 异步生成器迭代器。如果需要清楚表达具体含义，请使用全称以避免歧义。</p>
<p>一个异步生成器函数可能包含 await 表达式或者 async for 以及 async with 语句。</p>
<h3 id="attribute-—-属性"><a href="#attribute-—-属性" class="headerlink" title="attribute — 属性"></a>attribute — 属性</h3><p>关联到一个对象的值，可以使用点号表达式通过其名称来引用。例如，如果一个对象 o 具有一个属性 a，就可以用 o.a 来引用它。</p>
<h3 id="BDFL"><a href="#BDFL" class="headerlink" title="BDFL"></a>BDFL</h3><p>“终身仁慈独裁者”的英文缩写，即 Guido van Rossum，<code>Python</code> 的创造者。</p>
<h3 id="binary-file-—-二进制文件"><a href="#binary-file-—-二进制文件" class="headerlink" title="binary file — 二进制文件"></a>binary file — 二进制文件</h3><p>file object 能够读写 字节类对象。二进制文件的例子包括以二进制模式（’rb’, ‘wb’ or ‘rb+’）打开的文件、sys.stdin.buffer、sys.stdout.buffer 以及 io.BytesIO 和 gzip.GzipFile 的实例。</p>
<p>另请参见 text file 了解能够读写 str 对象的文件对象。</p>
<h3 id="bytes-like-object-—-字节类对象"><a href="#bytes-like-object-—-字节类对象" class="headerlink" title="bytes-like object — 字节类对象"></a>bytes-like object — 字节类对象</h3><p>支持 缓冲协议 并且能导出 C-contiguous 缓冲的对象。这包括所有 bytes、bytearray 和 array.array 对象，以及许多普通 memoryview 对象。字节类对象可在多种二进制数据操作中使用；这些操作包括压缩、保存为二进制文件以及通过套接字发送等。</p>
<p>某些操作需要可变的二进制数据。这种对象在文档中常被称为“可读写字节类对象”。可变缓冲对象的例子包括 bytearray 以及 bytearray 的 memoryview。其他操作要求二进制数据存放于不可变对象 (“只读字节类对象”)；这种对象的例子包括 bytes 以及 bytes 对象的 memoryview。</p>
<h3 id="bytecode-—-字节码"><a href="#bytecode-—-字节码" class="headerlink" title="bytecode — 字节码"></a>bytecode — 字节码</h3><p><code>Python</code> 源代码会被编译为字节码，即 C<code>Python</code> 解释器中表示 <code>Python</code> 程序的内部代码。字节码还会缓存在 .pyc 文件中，这样第二次执行同一文件时速度更快（可以免去将源码重新编译为字节码）。这种 “中间语言” 运行在根据字节码执行相应机器码的 virtual machine 之上。请注意不同 <code>Python</code> 虚拟机上的字节码不一定通用，也不一定能在不同 <code>Python</code> 版本上兼容。</p>
<h3 id="class-—-类"><a href="#class-—-类" class="headerlink" title="class — 类"></a>class — 类</h3><p>用来创建用户定义对象的模板。类定义通常包含对该类的实例进行操作的方法定义。</p>
<h3 id="class-variable-—-类变量"><a href="#class-variable-—-类变量" class="headerlink" title="class variable — 类变量"></a>class variable — 类变量</h3><p>在类中定义的变量，并且仅限在类的层级上修改 (而不是在类的实例中修改)。</p>
<h3 id="coercion-—-强制类型转换"><a href="#coercion-—-强制类型转换" class="headerlink" title="coercion — 强制类型转换"></a>coercion — 强制类型转换</h3><p>在包含两个相同类型参数的操作中，一种类型的实例隐式地转换为另一种类型。例如，int(3.15) 是将原浮点数转换为整型数 3，但在 3+4.5 中，参数的类型不一致（一个是 int, 一个是 float），两者必须转换为相同类型才能相加，否则将引发 TypeError。如果没有强制类型转换机制，程序员必须将所有可兼容参数归一化为相同类型，例如要写成 float(3)+4.5 而不是 3+4.5。</p>
<p>coroutine — 协程<br>协程是子例程的更一般形式。子例程可以在某一点进入并在另一点退出。协程则可以在许多不同的点上进入、退出和恢复。它们可通过 async def 语句来实现。参见 PEP 492。</p>
<p>coroutine function — 协程函数<br>返回一个 coroutine 对象的函数。协程函数可通过 async def 语句来定义，并可能包含 await、async for 和 async with 关键字。这些特性是由 PEP 492 引入的。</p>
<h3 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h3><p><code>Python</code> 编程语言的规范实现，在 <code>python</code>.org 上发布。<code>CPython</code> 一词用于在必要时将此实现与其他实现例如 <code>Jython</code> 或 <code>IronPython</code> 相区别。</p>
<h3 id="decorator-—-装饰器"><a href="#decorator-—-装饰器" class="headerlink" title="decorator — 装饰器"></a>decorator — 装饰器</h3><p>返回值为另一个函数的函数，通常使用 @wrapper 语法形式来进行函数变换。 装饰器的常见例子包括 classmethod() 和 staticmethod()。</p>
<p>装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(...)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">f = staticmethod(f)</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(...)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>同的样概念也适用于类，但通常较少这样使用。有关装饰器的详情可参见 函数定义 和 类定义 的文档。</p>
<h3 id="dictionary-—-字典"><a href="#dictionary-—-字典" class="headerlink" title="dictionary — 字典"></a>dictionary — 字典</h3><p>一个关联数组，其中的任意键都映射到相应的值。键可以是任何具有 <strong>hash</strong>() 和 <strong>eq</strong>() 方法的对象。在 Perl 语言中称为 hash。</p>
<h3 id="EAFP"><a href="#EAFP" class="headerlink" title="EAFP"></a>EAFP</h3><p>“求原谅比求许可更容易”的英文缩写。这种 <code>Python</code> 常用代码编写风格会假定所需的键或属性存在，并在假定错误时捕获异常。这种简洁快速风格的特点就是大量运用 try 和 except 语句。于其相对的则是所谓 LBYL 风格，常见于 C 等许多其他语言。</p>
<h3 id="expression-—-表达式"><a href="#expression-—-表达式" class="headerlink" title="expression — 表达式"></a>expression — 表达式</h3><p>可以求出某个值的语法单元。 换句话说，一个表达式就是表达元素例如字面值、名称、属性访问、运算符或函数调用的汇总，它们最终都会返回一个值。 与许多其他语言不同，并非所有语言构件都是表达式。 还存在不能被用作表达式的 statement，例如 while。 赋值也是属于语句而非表达式。</p>
<p>extension module — 扩展模块<br>以 C 或 C++ 编写的模块，使用 <code>Python</code> 的 C API 来与语言核心以及用户代码进行交互。</p>
<h3 id="file-object-—-文件对象"><a href="#file-object-—-文件对象" class="headerlink" title="file object — 文件对象"></a>file object — 文件对象</h3><p>对外提供面向文件 API 以使用下层资源的对象（带有 read() 或 write() 这样的方法）。<br>根据其创建方式的不同，文件对象可以处理对真实磁盘文件，对其他类型存储，或是对通讯设备的访问（例如标准输入/输出、内存缓冲区、套接字、管道等等）。<br>文件对象也被称为 <code>文件类对象</code> 或 <code>流</code>。</p>
<p>实际上共有三种类别的文件对象: <code>原始二进制文件</code>, <code>缓冲二进制文件</code> 以及 <code>文本文件</code>。它们的接口定义均在 io 模块中。<br>创建文件对象的规范方式是使用 open() 函数。</p>
<h3 id="floor-division-—-向下取整除法"><a href="#floor-division-—-向下取整除法" class="headerlink" title="floor division — 向下取整除法"></a>floor division — 向下取整除法</h3><p>向下舍入到最接近的整数的数学除法。向下取整除法的运算符是 // 。例如，表达式 11 // 4 的计算结果是 2 ，而与之相反的是浮点数的真正除法返回 2.75 。注意 (-11) // 4 会返回 -3 因为这是 -2.75 向下 舍入得到的结果。见 PEP 238 。</p>
<h3 id="function-—-函数"><a href="#function-—-函数" class="headerlink" title="function — 函数"></a>function — 函数</h3><p>可以向调用者返回某个值的一组语句。还可以向其传入零个或多个 参数 并在函数体执行中被使用。另见 parameter, method 和 函数定义 等节。</p>
<h3 id="future"><a href="#future" class="headerlink" title="future"></a><strong>future</strong></h3><p>一种伪模块，可被程序员用来启用与当前解释器不兼容的新语言特性。</p>
<p>通过导入 <strong>future</strong> 模块并对其中的变量求值，你可以查看新特性何时首次加入语言以及何时成为默认:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> __future__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__future__.division</span><br><span class="line">_Feature((<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="string">'alpha'</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'alpha'</span>, <span class="number">0</span>), <span class="number">8192</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="garbage-collection-—-垃圾回收"><a href="#garbage-collection-—-垃圾回收" class="headerlink" title="garbage collection — 垃圾回收"></a>garbage collection — 垃圾回收</h3><p>释放不再被使用的内存空间的过程。<br><code>Python</code> 是通过引用计数和一个能够检测和打破循环引用的循环垃圾回收器来执行垃圾回收的。<br>可以使用 gc 模块来控制垃圾回收器。</p>
<h3 id="global-interpreter-lock-—-全局解释器锁"><a href="#global-interpreter-lock-—-全局解释器锁" class="headerlink" title="global interpreter lock — 全局解释器锁"></a>global interpreter lock — 全局解释器锁</h3><p>C<code>Python</code> 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 <code>Python</code> bytecode。此机制通过设置对象模型（包括 dict 等重要内置类型）针对并发访问的隐式安全简化了 C<code>Python</code> 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性。</p>
<p>不过，某些标准库或第三方库的扩展模块被设计为在执行计算密集型任务如压缩或哈希时释放 GIL。此外，在执行 I/O 操作时也总是会释放 GIL。</p>
<p>创建一个（以更精细粒度来锁定共享数据的）“自由线程”解释器的努力从未获得成功，因为这会牺牲在普通单处理器情况下的性能。据信克服这种性能问题的措施将导致实现变得更复杂，从而更难以维护。</p>
<h3 id="IDLE"><a href="#IDLE" class="headerlink" title="IDLE"></a>IDLE</h3><p><code>Python</code> 的 IDE，“集成开发与学习环境”的英文缩写。是 <code>Python</code> 标准发行版附带的基本编程器和解释器环境。</p>
<h3 id="import-path-—-导入路径"><a href="#import-path-—-导入路径" class="headerlink" title="import path — 导入路径"></a>import path — 导入路径</h3><p>由多个位置（或 路径条目）组成的列表，会被模块的 path based finder 用来查找导入目标。在导入时，此位置列表通常来自 sys.path，但对次级包来说也可能来自上级包的 <strong>path</strong> 属性。</p>
<h3 id="iterable-—-可迭代对象"><a href="#iterable-—-可迭代对象" class="headerlink" title="iterable — 可迭代对象"></a>iterable — 可迭代对象</h3><p>能够逐一返回其成员项的对象。可迭代对象的例子包括所有序列类型（例如 list、str 和 tuple）以及某些非序列类型例如 dict、文件对象 以及定义了 <strong>iter</strong>() 方法或是实现了 Sequence 语义的 <strong>getitem</strong>() 方法的任意自定义类对象。</p>
<p>可迭代对象被可用于 for 循环以及许多其他需要一个序列的地方（zip()、map() …）。当一个可迭代对象作为参数传给内置函数 iter() 时，它会返回该对象的迭代器。这种迭代器适用于对值集合的一次性遍历。在使用可迭代对象时，你通常不需要调用 iter() 或者自己处理迭代器对象。for 语句会为你自动处理那些操作，创建一个临时的未命名变量用来在循环期间保存迭代器。参见 iterator、sequence 以及 generator。</p>
<h3 id="iterator-—-迭代器"><a href="#iterator-—-迭代器" class="headerlink" title="iterator — 迭代器"></a>iterator — 迭代器</h3><p>用来表示一连串数据流的对象。重复调用迭代器的 <strong>next</strong>() 方法（或将其传给内置函数 next()）将逐个返回流中的项。当没有数据可用时则将引发 StopIteration 异常。到这时迭代器对象中的数据项已耗尽，继续调用其 <strong>next</strong>() 方法只会再次引发 StopIteration 异常。迭代器必须具有 <strong>iter</strong>() 方法用来返回该迭代器对象自身，因此迭代器必定也是可迭代对象，可被用于其他可迭代对象适用的大部分场合。一个显著的例外是那些会多次重复访问迭代项的代码。容器对象（例如 list）在你每次向其传入 iter() 函数或是在 for 循环中使用它时都会产生一个新的迭代器。如果在此情况下你尝试用迭代器则会返回在之前迭代过程中被耗尽的同一迭代器对象，使其看起来就像是一个空容器。</p>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>由一个单独 expression 构成的匿名内联函数，表达式会在调用时被求值。<br>创建 lambda 函数的句法为 <code>lambda [parameters]: expression</code>。</p>
<h3 id="list-—-列表"><a href="#list-—-列表" class="headerlink" title="list — 列表"></a>list — 列表</h3><p><code>Python</code> 内置的一种 sequence。虽然名为列表，但更类似于其他语言中的数组而非链接列表，因为访问元素的时间复杂度为 O(1)。</p>
<h3 id="mapping-—-映射"><a href="#mapping-—-映射" class="headerlink" title="mapping — 映射"></a>mapping — 映射</h3><p>一种支持任意键查找并实现了 Mapping 或 MutableMapping 抽象基类 中所规定方法的容器对象。<br>此类对象的例子包括 <code>dict</code>, c<code>ollections.defaultdict</code>, <code>collections.OrderedDict</code> 以及 <code>collections.Counter</code>。</p>
<h3 id="metaclass-—-元类"><a href="#metaclass-—-元类" class="headerlink" title="metaclass — 元类"></a>metaclass — 元类</h3><p>一种用于创建类的类。类定义包含类名、类字典和基类列表。元类负责接受上述三个参数并创建相应的类。大部分面向对象的编程语言都会提供一个默认实现。<code>Python</code> 的特别之处在于可以创建自定义元类。大部分用户永远不需要这个工具，但当需要出现时，元类可提供强大而优雅的解决方案。它们已被用于记录属性访问日志、添加线程安全性、跟踪对象创建、实现单例，以及其他许多任务。</p>
<h3 id="method-—-方法"><a href="#method-—-方法" class="headerlink" title="method — 方法"></a>method — 方法</h3><p>在类内部定义的函数。如果作为该类的实例的一个属性来调用，方法将会获取实例对象作为其第一个 argument (通常命名为 self)。参见 <code>function</code> 。</p>
<h3 id="module-—-模块"><a href="#module-—-模块" class="headerlink" title="module — 模块"></a>module — 模块</h3><p>此对象是 <code>Python</code> 代码的一种组织单位。各模块具有独立的<code>命名空间</code>，可包含任意 <code>Python</code> 对象。模块可通过 importing 操作被加载到 <code>Python</code> 中。</p>
<p>另见 package。</p>
<h3 id="namespace-—-命名空间"><a href="#namespace-—-命名空间" class="headerlink" title="namespace — 命名空间"></a>namespace — 命名空间</h3><p>命名空间是存放变量的场所。命名空间有局部、全局和内置的，还有对象中的嵌套命名空间（在方法之内）。<br>命名空间通过防止命名冲突来支持模块化。例如，函数 <code>builtins.open</code> 与 <code>os.open()</code> 可通过各自的命名空间来区分。命名空间还通过明确哪个模块实现那个函数来帮助提高可读性和可维护性。<br>例如，<code>`random.seed() 或</code>itertools.islice()` 这种写法明确了这些函数是由 random 与 itertools 模块分别实现的。</p>
<h3 id="namespace-package-—-命名空间包"><a href="#namespace-package-—-命名空间包" class="headerlink" title="namespace package — 命名空间包"></a>namespace package — 命名空间包</h3><p>PEP 420 所引入的一种仅被用作子包的容器的 package，命名空间包可以没有实体表示物，其描述方式与 regular package 不同，因为它们没有 <code>__init__.py</code> 文件。</p>
<p>另可参见 module。</p>
<h3 id="object-—-对象"><a href="#object-—-对象" class="headerlink" title="object — 对象"></a>object — 对象</h3><p>任何具有状态（属性或值）以及预定义行为（方法）的数据。object 也是任何 new-style class 的最顶层基类名。</p>
<h3 id="package-—-包"><a href="#package-—-包" class="headerlink" title="package — 包"></a>package — 包</h3><p>一种可包含子模块或递归地包含子包的 <code>Python</code> module。从技术上说，包是带有 <strong>path</strong> 属性的 <code>Python</code> 模块。</p>
<p>另参见 regular package 和 namespace package。</p>
<h3 id="parameter-—-形参"><a href="#parameter-—-形参" class="headerlink" title="parameter — 形参"></a>parameter — 形参</h3><p>function （或方法）定义中的命名实体，它指定函数可以接受的一个 argument （或在某些情况下，多个实参）。有五种形参：</p>
<ul>
<li>positional-or-keyword：位置或关键字，指定一个可以作为 位置参数 传入也可以作为 关键字参数 传入的实参。<br>  这是默认的形参类型，例如下面的 foo 和 bar:  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(foo, bar=None)</span>:</span> ...</span><br></pre></td></tr></table></figure></li>
<li><p>positional-only：仅限位置，指定一个只能按位置传入的参数。<code>Python</code> 中没有定义仅限位置形参的语法。但是一些内置函数有仅限位置形参（比如 <code>abs()</code>）。</p>
</li>
<li><p>keyword-only：仅限关键字，指定一个只能通过关键字传入的参数。<br>仅限关键字形参可通过在函数定义的形参列表中包含单个可变位置形参或者在多个可变位置形参之前放一个 * 来定义，例如下面的 kw_only1 和 kw_only2:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg, *, kw_only1, kw_only2)</span>:</span> ...</span><br></pre></td></tr></table></figure></li>
<li>var-positional：可变位置，指定可以提供由一个任意数量的位置参数构成的序列（附加在其他形参已接受的位置参数之后）。这种形参可通过在形参名称前加缀 * 来定义。<br>例如下面的 args:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span> ...</span><br></pre></td></tr></table></figure></li>
<li>var-keyword：可变关键字，指定可以提供任意数量的关键字参数（附加在其他形参已接受的关键字参数之后）。这种形参可通过在形参名称前加缀 ** 来定义，例如上面的 kwargs。</li>
</ul>
<p>形参可以同时指定可选和必选参数，也可以为某些可选参数指定默认值。</p>
<h3 id="path-entry-—-路径入口"><a href="#path-entry-—-路径入口" class="headerlink" title="path entry — 路径入口"></a>path entry — 路径入口</h3><p>import path 中的一个单独位置，会被 path based finder 用来查找要导入的模块。</p>
<h3 id="PEP"><a href="#PEP" class="headerlink" title="PEP"></a>PEP</h3><p>“<code>Python</code> 增强提议”的英文缩写。<br>一个 PEP 就是一份设计文档，用来向 <code>Python</code> 社区提供信息，或描述一个 <code>Python</code> 的新增特性及其进度或环境。PEP 应当提供精确的技术规格和所提议特性的原理说明。</p>
<p>PEP 应被作为提出主要新特性建议、收集社区对特定问题反馈以及为必须加入 <code>Python</code> 的设计决策编写文档的首选机制。PEP 的作者有责任在社区内部建立共识，并应将不同意见也记入文档。</p>
<p>参见 PEP 1。</p>
<h3 id="sequence-—-序列"><a href="#sequence-—-序列" class="headerlink" title="sequence — 序列"></a>sequence — 序列</h3><p>一种 iterable，它支持通过 <strong>getitem</strong>() 特殊方法来使用整数索引进行高效的元素访问，并定义了一个返回序列长度的 <strong>len</strong>() 方法。<br>内置的序列类型有 list、str、tuple 和 bytes。注意虽然 dict 也支持   <code>__getitem__()</code> 和 <code>__len__()</code>，但它被认为属于映射而非序列，因为它查找时使用任意的 immutable 键而非整数。</p>
<p>collections.abc.Sequence 抽象基类定义了一个更丰富的接口，它超越了<code>__getitem__()</code> 和<code>__len__()</code>，添加了 <code>count()</code>, <code>index()</code>, <code>__contains__()</code> 和 <code>__reversed__()</code> 。 可以使用 <code>register()</code> 显式注册实现此扩展接口的类型。</p>
<h3 id="slice-—-切片"><a href="#slice-—-切片" class="headerlink" title="slice — 切片"></a>slice — 切片</h3><p>通常只包含了特定 sequence 的一部分的对象。<br>切片是通过使用下标标记来创建的，在 [] 中给出几个以冒号分隔的数字，例如 variable_name[1:3:5]。方括号（下标）标记在内部使用 slice 对象。</p>
<h3 id="statement-—-语句"><a href="#statement-—-语句" class="headerlink" title="statement — 语句"></a>statement — 语句</h3><p>语句是程序段（一个代码“块”）的组成单位。<br>一条语句可以是一个 expression 或某个带有关键字的结构，例如 if、while 或 for。</p>
<h3 id="text-encoding-—-文本编码"><a href="#text-encoding-—-文本编码" class="headerlink" title="text encoding — 文本编码"></a>text encoding — 文本编码</h3><p>用于将Unicode字符串编码为字节串的编码器。</p>
<h3 id="type-—-类型"><a href="#type-—-类型" class="headerlink" title="type — 类型"></a>type — 类型</h3><p>类型决定一个 <code>Python</code> 对象属于什么种类；每个对象都具有一种类型。<br>要知道对象的类型，可以访问它的 <code>__class__</code> 属性，或是通过 type(obj) 来获取。</p>
<p>type hint — 类型提示<br>annotation 为变量、类属性、函数的形参或返回值指定预期的类型。</p>
<p>类型提示属于可选项，<code>Python</code> 不要求提供，但其可对静态类型分析工具起作用，并可协助 IDE 实现代码补全与重构。</p>
<p>全局变量、类属性和函数的类型提示可以使用 typing.get_type_hints() 来访问，但局部变量则不可以。</p>
<p>参见 typing 和 PEP 484，其中有对此功能的详细描述。</p>
<h3 id="universal-newlines-—-通用换行"><a href="#universal-newlines-—-通用换行" class="headerlink" title="universal newlines — 通用换行"></a>universal newlines — 通用换行</h3><p>一种解读文本流的方式，将以下所有符号都识别为行结束标志：Unix 的行结束约定 ‘\n’、Windows 的约定 ‘\r\n’ 以及旧版 Macintosh 的约定 ‘\r’。<br>参见 PEP 278 和 PEP 3116 和 bytes.splitlines() 了解更多用法说明。</p>
<h3 id="virtual-machine-—-虚拟机"><a href="#virtual-machine-—-虚拟机" class="headerlink" title="virtual machine — 虚拟机"></a>virtual machine — 虚拟机</h3><p>一台完全通过软件定义的计算机。<br><code>Python</code> 虚拟机可执行字节码编译器所生成的 bytecode。</p>
<h3 id="Zen-of-Python-—-Python-之禅"><a href="#Zen-of-Python-—-Python-之禅" class="headerlink" title="Zen of Python — Python 之禅"></a>Zen of <code>Python</code> — <code>Python</code> 之禅</h3><p>列出 <code>Python</code> 设计的原则与哲学，有助于理解与使用这种语言。<br>定义在PEP 8 中。<br>每个版本的具体内容，可能会有差。查看当前版本的具体内容可在交互模式提示符中输入 “import this”。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>非科班出身，如何成为程序员？</title>
    <url>/2017/11/16/2017-11-16-Programing-becomer-a-coder-from-others/</url>
    <content><![CDATA[<h2 id="非科班出身，如何成为程序员"><a href="#非科班出身，如何成为程序员" class="headerlink" title="非科班出身，如何成为程序员"></a>非科班出身，如何成为程序员</h2><blockquote>
<p>本文是知乎的一篇回答</p>
</blockquote>
<p>身边有很多非科班出身的程序员，比如 sofish、粽神。当然我也是，所以决定结合自身经历强答一波。</p>
<h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><p>我本科学习的是「生物科学」，大学四年无非就是拿着 eppendorf 的实验枪，在超净台旁养着各种知名或不知名的微生物，有广为人知的「海拉细胞」有很多人没有听过的「毕赤酵母」，每逢寒暑假可能还会去山里或者某个海滨城市实习，在鸟巢旁边装一个微型摄像头，记录下喂食雏鸟的频率，去海边抓一些招潮蟹或者海月水母，也算乐在其中。我很享受大学这段时光，因为毕竟是我儿时的梦想，成为一个生物学家。</p>
<p>毕业后，进入了北京水产科学研究所，主要工作是「养鱼」，每天固定时间给「小西伯利亚鲟」喂点吃的，给鱼缸换水。很不幸…，在一次换水的过程中水龙头我忘关了，结果水沿着鱼缸溢了出来，小鲟鱼也在想「外面的世界那么大，我想去看看」，都顺着鱼缸溢出的水推力，游到了鱼缸外面，等我发现时，这些小生命都散落在鱼缸周围，也不跳了。主任没有批评我把一缸鱼都养死了，但是也再让我去喂鱼了，给了我一份新的差事，通过毕赤酵母来表达出促性腺激素，促进鲟鱼快速性成熟。实验做了大概一年，有一些成果，毕竟在一年中成功过一次。后来觉得愧对这份工作，就跟主任请辞了，主任就介绍了上海的一份工作给我，去欧莱雅研发中心做实验。现在想想主任真是难得的人生导师。</p>
<p>在欧莱雅工作了三年，每天也是重复相同的工作，工作内容只是从以前的养各种微生物变成了养「人造皮肤」，然后再把化妆品涂在人造皮肤上，看看化妆品对皮肤的效果，其实和大学拿老鼠、兔子做实验没什么区别，只是欧洲那边不让在活体上做化妆品实验。在欧莱雅的三年，慢慢消磨了我对「生物科学」的热情，重复的工作让我麻痹了我的思想。我决定做一些改变，那是2014年，我已经27了。</p>
<h3 id="学习编程的动机"><a href="#学习编程的动机" class="headerlink" title="学习编程的动机"></a>学习编程的动机</h3><p>还得从 13 年年底说起，在欧莱雅工作期间，命运多舛，出了一次车祸，右胫腓骨粉碎骨折，当时还是女朋友的老婆放弃了东京的工作回国来照顾我，在床上躺了三四个月，老婆回上海后也找了一份广告公司的工作，做 SEM。到了14年，腿伤基本恢复，我重新回到欧莱雅工作，经历了人生变故（车祸），住院期间把这一生中的生离死别都看完了，开始思考起人生，更加热爱生命。</p>
<a id="more"></a>
<p>老婆是做 SEM 工作的，其中很大一部分工作是做 SEO，也就是搜索引擎优化，文科出生的她（日语系）自然对 HTML标记语言、JS代码感到陌生，学习起来也有些吃苦，在区分 CSS 属性 color 和 background 也会疑惑。出于对她回国照顾我的感恩，以及责任。我从图书馆借了一本书「15天掌握HTML\CSS\JS」，开始学习起前端来，那时候我还不知道有前端这个职业，也不是为了转行做前端，仅仅是想自己学会了，然后帮她解决问题。</p>
<p>也许看了这本书，让我对当时欧莱雅的工作有了更深入的思考，在欧莱雅，我每天工作内容相同，做实验、处理实验数据，写 report。实验之余看看 paper。而学习 HTML\CSS\JS 可以创造不同网站，然后分享给世界各地浏览你网站的人。写网站比做实验似乎更能够给我带来成就感和满足感。于是我决定正式学习 web development，成为一个前端工程师，那是2014年八月，我已经27岁了。</p>
<h3 id="非科班出身怎么学习编程"><a href="#非科班出身怎么学习编程" class="headerlink" title="非科班出身怎么学习编程"></a>非科班出身怎么学习编程</h3><p>才发现，写到这儿才进入正题，正式开始学习编程是在2014年九月，我并没有辞掉当时的工作，我是白天工作，晚上回家学习，周一到周五每天大概学习5~6个小时左右，周末全天学习。我习惯每个月给自己制定一些任务和目标，然后按照自己的目标前进，比如下面是我2014年九月份制定的一些计划：</p>
<blockquote>
<p>九月份：《javascript》高级程序设计 + 慕课网练习（每天保证两小时coding）</p>
<p>十月份：学习 CSS2 和 CSS3，并对 javascript 的学习做个回顾，教材包括《精通CSS》，《javascript DOM编程艺术》，《javascript语言精粹》外加慕课网每天至少两小时coding！</p>
<p>十一月份：学习javascript库，jquery、prototype、html5。主要学习书籍《Javascript模式》、《锋利的jQuery》、《html5程序设计》、photoshop学习。</p>
<p>十二月份：主要任务是设计个人网站，主要书籍《精通javascript》、《编写可维护的Javascript》。</p>
</blockquote>
<p>这儿我并不是向大家推荐学习书籍，以及个人的计划，因为那是 2014 年制定的，可能已经不再适合现在入门学习者了，再者，推荐前端书籍的知乎问题不胜枚举。</p>
<p>周末的时候习惯带个电脑去普陀区图书馆，上海市的图书馆周末也挺多人的，所以不得不很早就去占座，突然又有了回到大学的感觉，关于电脑当时也是下了血本，游说当时还是女朋友的老婆，把他从日本带回来的十几万日元去中国银行换了人民币，然后买了一台 Macbook Pro。</p>
<p>2015年，我决定转行了，做一个前端工程师，那一年工作也忙了，学习的时间少了许多，为了找工作，我用 NodeJs + jQuery 搭建了一个多人博客系统，然后将自己的实现思路和技术栈连同博客地址发到了知乎和 NodeJs 社区，当然也附上了个人简历和邮箱地址，主要想看看以现在的水平，能不能够找到一份前端工作了。</p>
<p>那是15年八月，当时小鱼 sofish，推荐我去饿了么面试（估计是在 Nodejs 社区看到我发的帖子），但是由于知识体系的不健全，面试官可能觉得学习曲线会太陡，最终没有过初试，因为当时我还不知道 Promise，也不懂 Angular，更不会 Loopback。</p>
<p>于是我决定先找一份实习的工作，很幸运一家做 CRM 的公司愿意收留我，开的工资是4.5k，一下回到了刚毕业的水平，但是我很感谢这家公司，它给了我很大的学习空间，因为在这之前，我都是一个人在摸索，自学。甚至不知道真正的前端工程师到底做什么工作，而这家公司给了我机会，给我分配了导师，甚至在入职三个月内不用做任何业务，而是全身心学习。正是这三个月，我构建前自己的前端知识体系，从 JS 基础到 Angular 框架，从 HTML 到 CSS，从 Grunt 到 webpack，从NodeJs 到 Mongodb。在这三个月的学习期间，每天坚持早上九点到公司，晚上十点下班，每天坚持写周报，总结一天的学习，每个月完成一个小项目，三个月期间，自己写了一个所输及所得的 markdown 编辑器，写了一个 CSS selector 的 parser，通过 websocket 做了一个聊天工具。</p>
<p>当然，这三个月我也放弃了很多，因为刚入职，我放弃了和刚结婚老婆去度蜜月，两个人的蜜月，变成了她独自旅游。到现在也感到愧疚，争取明年补上。</p>
<p>三个月后，评级转正，当时的职级是 P5，我感到很欣慰，三个月的努力学习有了回报。和之前边工作边学习的离散学习完全不同，当然全职的效率更高，当然薪资也从4.5k 涨到了12k，说实话，对于刚入门的我，我很满意这薪资了。在这公司我工作了两年，合作和独立完成了几个项目，职级后来也再升了两级。在今年七月，我选择了离开，主要原因还是考虑个人发展，以及对饿了么的眷顾。</p>
<p>对的，我又参加了饿了么的面试，顺利入职饿了么前端工程师，感到很欣慰。好像实现了一个长久的夙愿。</p>
<h3 id="我为什么感到焦虑"><a href="#我为什么感到焦虑" class="headerlink" title="我为什么感到焦虑"></a>我为什么感到焦虑</h3><p>转行后，我无时不感到焦虑，毕竟是一个大龄转行程序员，身边的同事都是九零后甚至九五后，我无时不刻不在想我怎么规划我的职业，怎么做得更好，怎么缩短与科班出身的同事之间的差距。我没有后悔过转行，也没有后悔过那八年生物生涯（大学四年工作四年），毕竟那八年的生物学习，我快乐过，我不完整实现了儿时的梦想。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础-时间控制</title>
    <url>/2017/11/15/2017-11-15_Programing-Python-Basic-flow-control/</url>
    <content><![CDATA[<hr>
<p>这次主要介绍python 的基础流程控制。<br>包括 if 条件语句、for 循环 和 while 循环语句； continue 及 break 的用法等。<br>基本用法与 C 和 Java 差不多，无 switch 语句。</p>
<hr>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>语法：<code>if(...):</code>, 括号内为一表达式，当为<code>True</code>（即成立）时，执行对应的代码段。</p>
<blockquote>
<p>注意:所有条件语句后方都需加冒号 <code>:</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if 语句实例</span></span><br><span class="line"><span class="string">''' 判断用户输入的整数是几位数（暂不考虑用户输入非整数）</span></span><br><span class="line"><span class="string">    为0               输出     It's zero.</span></span><br><span class="line"><span class="string">    个位数             输出     It's a number below 10</span></span><br><span class="line"><span class="string">    两位数             输出     It's a two-digit number</span></span><br><span class="line"><span class="string">    三位数级以上        输出     It's digit is more than two</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">user_input = input(<span class="string">"Please input a number: "</span>)</span><br><span class="line"><span class="comment"># 用户输入的类型为字符串，转换为整数类型</span></span><br><span class="line">n = int(user_input)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span>):</span><br><span class="line">    print(<span class="string">"It's zero."</span>)</span><br><span class="line"><span class="keyword">elif</span> (n&lt;<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">"It's a number below 10"</span>)</span><br><span class="line"><span class="keyword">elif</span> (n&lt;<span class="number">100</span>):</span><br><span class="line">    print(<span class="string">"It's a two-digit number"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"It's digit is more than two"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可能会有零到多个 elif 部分，else 是可选的。</p>
</blockquote>
<p>关键字 “ elif ” 是 “else if ” 的缩写，这个可以有效地避免过深的缩进。<code>if ... elif ... elif ...</code> 序列于替代其它语言中的switch case语句。</p>
<a id="more"></a>
<hr>
<h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><p>Python 中的 <code>for</code> 语句和 C Pascal 中的 有不同。通常的循环可能会由用户来定义迭代步骤和中止条件（如 C ），Python 的 <code>for</code> 语句依据任意序列（链表或字符串）中的子项，按它们在序列中的顺序来进行迭代。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for 语句实例</span></span><br><span class="line">string = <span class="string">"python"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">    <span class="comment"># 字符串处理</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">list = [<span class="string">"l"</span>,<span class="string">"i"</span>,<span class="string">"s"</span>,<span class="string">"t"</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">    <span class="comment"># 列表处理</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># range()函数，range(5) 表示 0 到 4 </span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述示例仅感受下 for 语句的写法。</p>
<hr>
<h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><p><code>while(...)</code> 括号内表达式若为 <code>True</code>，则继续执行代码段；若为<code>False</code>，停止执行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># while语句实例</span></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>需要注意错误代码导致的无限循环，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>):</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="break-、-continue"><a href="#break-、-continue" class="headerlink" title="break 、 continue"></a>break 、 continue</h2><p><code>break</code> 用法和 C 中的类似，直接跳出循环，执行循环后的语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>continue</code> 用法也是从C中借鉴来的，跳出当前循环，并执行下一次循环<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-Basic-dirt_intro</title>
    <url>/2017/11/14/2017-11-14_Programing-Python-Basic-dirt-intro/</url>
    <content><![CDATA[<hr>
<p>每个键是从它的值由冒号(:)，即在项目之间用逗号隔开，整个东西是包含在大括号中。没有任何项目一个空字典只写两个大括号，就像这样：<code>{}</code>.</p>
<p>键在一个字典中是唯一的，而值则可以重复。字典的值可以是任何类型，但键必须是不可变的数据的类型，例如：字符串，数字或元组这样的类型。</p>
<h2 id="访问字典中的值"><a href="#访问字典中的值" class="headerlink" title="访问字典中的值"></a>访问字典中的值</h2><p>要访问字典元素，你可以使用方括号和对应键，以获得其对应的值。下面是一个简单的例子 -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br><span class="line">print(<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br></pre></td></tr></table></figure>
<p>当执行上面的代码，它产生以下结果 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict[<span class="string">'Name'</span>]:  Saul</span><br><span class="line">dict[<span class="string">'Age'</span>]:  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>如果我们试图使用一个键，但这是不字典访问数据项的一部分，我们会得到一个错误如下 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;;</span><br><span class="line">print(<span class="string">"dict['Alice']: "</span>, dict[<span class="string">'Alice'</span>])</span><br></pre></td></tr></table></figure>
<p>当执行上面的代码，它产生以下结果 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict[<span class="string">'Saul'</span>]:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(<span class="string">"dict['Alice']: "</span>, dict[<span class="string">'Alice'</span>])</span><br><span class="line">KeyError: <span class="string">'Alice'</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="更新字典"><a href="#更新字典" class="headerlink" title="更新字典"></a>更新字典</h2><p>可以通过添加新条目或键值对，修改现有条目，或删除现有条目，更新词典的简单例子如下图所示 -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># update existing entry</span></span><br><span class="line">dict[<span class="string">'Age'</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add new entry</span></span><br><span class="line">dict[<span class="string">'School'</span>] = <span class="string">"SPD School"</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dict['School']: "</span>, dict[<span class="string">'School'</span>])</span><br></pre></td></tr></table></figure>
<p>当执行上面的代码，它产生以下结果 -<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict[<span class="string">'Age'</span>]:  <span class="number">8</span></span><br><span class="line">dict[<span class="string">'School'</span>]:  SPD School</span><br></pre></td></tr></table></figure></p>
<h3 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h3><p>可以删除单个字典元素或清除字典的全部内容。也可以在一个单一的操作删除整个词典。</p>
<p>要明确删除整个词典，只要用 del 语句就可以做到。下面是一个简单的例子 -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove entry with key 'Name'</span></span><br><span class="line"><span class="keyword">del</span> dict[<span class="string">'Name'</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all entries in dict</span></span><br><span class="line">dict.clear()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># delete entire dictionary</span></span><br><span class="line"><span class="keyword">del</span> dict         </span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line">print(<span class="string">"dict['School']: "</span>, dict[<span class="string">'School'</span>])</span><br></pre></td></tr></table></figure>
<p>这将产生以下结果。请注意，将引发一个异常，因为执行 del dict 后字典不存在了-<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict[<span class="string">'Age'</span>]:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line">TypeError: <span class="string">'type'</span> object <span class="keyword">is</span> unsubscriptable</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注： del() 方法是在后续部分讨论。</p>
</blockquote>
<h2 id="字典键的属性"><a href="#字典键的属性" class="headerlink" title="字典键的属性"></a>字典键的属性</h2><p>字典的值没有限制。它们可以是任意Python对象，无论是标准的对象或用户定义的对象。但是，键却不能这样使用。</p>
<p>还有要记住字典的键的重要两点 -</p>
<ul>
<li>每个键对应多个条目是不允许的。这意味着重复键是不允许的。当键分配过程中遇到重复，以最后分配的为准。例如 -</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Name'</span>: <span class="string">'Manli'</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br></pre></td></tr></table></figure>
<p>当执行上面的代码，它产生以下结果<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">dict[<span class="string">'Name'</span>]:  Manli</span><br></pre></td></tr></table></figure></p>
<ul>
<li>键必须是不可变的。这意味着可以使用字符串，数字或元组作为字典的键，但是像[‘key’]是不允许的。下面是一个简单的例子：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br></pre></td></tr></table></figure>
<p>当执行上面的代码，它产生以下结果 -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line">TypeError: list objects are unhashable</span><br></pre></td></tr></table></figure>
<h2 id="内置字典函数和方法"><a href="#内置字典函数和方法" class="headerlink" title="内置字典函数和方法"></a>内置字典函数和方法</h2><h3 id="Python包括以下字典函数"><a href="#Python包括以下字典函数" class="headerlink" title="Python包括以下字典函数"></a>Python包括以下字典函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>cmp(dict1, dict2)</td>
<td>比较这两个字典的元素。</td>
</tr>
<tr>
<td>2</td>
<td>len(dict)</td>
<td>计算字典的总长度。这等于字典中的项的数目。</td>
</tr>
<tr>
<td>3</td>
<td>str(dict)</td>
<td>产生字典的可打印字符串表示</td>
</tr>
<tr>
<td>4</td>
<td>type(variable)</td>
<td>返回传递变量的类型。如果传递变量是字典，那么它会返回一个字典类型。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Python中包括以下字典方法"><a href="#Python中包括以下字典方法" class="headerlink" title="Python中包括以下字典方法 -"></a>Python中包括以下字典方法 -</h3><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>dict.clear()</td>
<td>删除字典 dict 中的所有元素</td>
</tr>
<tr>
<td>2</td>
<td>dict.copy()</td>
<td>返回字典 dict 的浅表副本</td>
</tr>
<tr>
<td>3</td>
<td>dict.fromkeys()</td>
<td>使用seq的键和值来设置创建新字典</td>
</tr>
<tr>
<td>4</td>
<td>dict.get(key, default=None)</td>
<td>对于键key，返回其值或default如果键不存在于字典中</td>
</tr>
<tr>
<td>5</td>
<td>dict.has_key(key)</td>
<td>返回true如果在字典dict有存在键key，否则为false</td>
</tr>
<tr>
<td>6</td>
<td>dict.items()</td>
<td>返回 dict (键，值)元组对的列表</td>
</tr>
<tr>
<td>7</td>
<td>dict.keys()</td>
<td>返回字典 dict 的键列表</td>
</tr>
<tr>
<td>8</td>
<td>dict.setdefault(key, default=None)</td>
<td>类似于get()方法，但会设定dict[key]=default，如果键不存在于dict中</td>
</tr>
<tr>
<td>9</td>
<td>dict.update(dict2)</td>
<td>添加字典dict2的键值对到dict</td>
</tr>
<tr>
<td>10</td>
<td>dict.values()</td>
<td>返回字典dict值列表</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础- I/O 简介</title>
    <url>/2017/11/13/2017-11-13_Programing-Python-Basic-IO-intro/</url>
    <content><![CDATA[<p>这里只讲述基本的 I/O 函数，更多函数请参考Python标准文档。</p>
<blockquote>
<p>Python 3.x I/O 标准文档位置  <a href="https://docs.python.org/3/library/io.html" target="_blank" rel="noopener">https://docs.python.org/3/library/io.html</a></p>
</blockquote>
<hr>
<h2 id="打印到屏幕"><a href="#打印到屏幕" class="headerlink" title="打印到屏幕"></a>打印到屏幕</h2><p>最简单的输出方法是用<code>print</code>函数，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></span><br><span class="line">print(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure>
<p>你的标准屏幕上会产生以下结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-e87780fd91230718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hello world"></p>
<h2 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h2><p>Python 3 提供了内置函数从标准输入读入一行文本，默认的标准输入是键盘。</p>
<a id="more"></a>
<h3 id="input-函数"><a href="#input-函数" class="headerlink" title="input 函数"></a>input 函数</h3><p><strong>input([prompt])</strong> 函数，<code>input</code> 可以接收一个Python表达式作为输入，并将运算结果返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></span><br><span class="line"> </span><br><span class="line">str = input(<span class="string">"请输入："</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"你输入的内容是: "</span>, str)</span><br></pre></td></tr></table></figure>
<p>这会产生如下的对应着输入的结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-7aaa0b67137263ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input"></p>
<hr>
<h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>现在，您已经可以向标准输入和输出进行读写。现在，来看看怎么读写实际的数据文件。</p>
<p>Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 <strong>file</strong> 对象做大部分的文件操作。</p>
<h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h3><p>你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file object = open(file_name [, access_mode][, buffering])</span><br></pre></td></tr></table></figure>
<p>各个参数的细节如下：</p>
<ul>
<li>file_name：<br>file_name变量是一个包含了你要访问的文件名称的字符串值。</li>
<li>access_mode：<br>access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li>
<li>buffering:<br>如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。</li>
</ul>
<p>不同模式打开文件的完全列表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>t</td>
<td>文本模式 (默认)。</td>
</tr>
<tr>
<td>x</td>
<td>写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式。</td>
</tr>
<tr>
<td>+</td>
<td>打开一个文件进行更新(可读可写)。</td>
</tr>
<tr>
<td>U</td>
<td>通用换行模式（不推荐）。</td>
</tr>
<tr>
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td>ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody>
</table>
</div>
<p>下图很好的总结了这几种模式：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-e33ee7e59b1f578c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不同模式打开文件"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>r</th>
<th>r+</th>
<th>w</th>
<th>w+</th>
<th>a</th>
<th>a+</th>
</tr>
</thead>
<tbody>
<tr>
<td>读</td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
</tr>
<tr>
<td>写</td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>创建</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>覆盖</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>指针在开始</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>指针在结尾</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="File对象的属性"><a href="#File对象的属性" class="headerlink" title="File对象的属性"></a>File对象的属性</h2><p>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。</p>
<p>以下是和file对象相关的所有属性的列表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>file.closed</td>
<td>返回true如果文件已被关闭，否则返回false。</td>
</tr>
<tr>
<td>file.mode</td>
<td>返回被打开文件的访问模式。</td>
</tr>
<tr>
<td>file.name</td>
<td>返回文件的名称。</td>
</tr>
<tr>
<td>file.softspace</td>
<td>如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td>
</tr>
</tbody>
</table>
</div>
<p>如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"文件名: "</span>, fo.name)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"是否已关闭 : "</span>, fo.closed)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"访问模式 : "</span>, fo.mode)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-6f26e4d45e1aadac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="close 文件"></p>
<h3 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h3><p>File 对象的 close()方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。</p>
<p>当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。</p>
<p>语法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.close()</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"文件名: "</span>, fo.name)</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure></p>
<p>以上实例输出结果：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/34293a3ecaa0cb2f69d381ae0453bbef.png" alt="image.png"></p>
<p>读写文件：</p>
<p>file对象提供了一系列方法，能让我们的文件访问更轻松。来看看如何使用read()和write()方法来读取和写入文件。</p>
<h3 id="write-方法"><a href="#write-方法" class="headerlink" title="write()方法"></a>write()方法</h3><p><code>write()</code>方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。</p>
<p><code>write()</code>方法不会在字符串的结尾添加换行符(‘\n’)：</p>
<p>语法：<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.write(string)</span><br></pre></td></tr></table></figure></p>
<p>在这里，被传递的参数是要写入到已打开文件的内容。</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">fo.write( <span class="string">"www.xiaozhuanlan.com!\nVery good site!\n"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<p>上述方法会创建temp.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.xiaozhuanlan.com!  </span><br><span class="line">Very good site!</span><br></pre></td></tr></table></figure></p>
<h3 id="read-方法"><a href="#read-方法" class="headerlink" title="read()方法"></a>read()方法</h3><p><code>read()</code>方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。</p>
<p>语法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.read([count])</span><br></pre></td></tr></table></figure></p>
<p>在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。</p>
<p>这里我们用到以上创建的 foo.txt 文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">str = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"读取的字符串是 : "</span>, str)</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-bea32e445d75c946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="read file"></p>
<h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><ul>
<li><p>tell()方法<br>告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。</p>
</li>
<li><p>seek（offset [,from]）方法<br>改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。</p>
<p>如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。</p>
</li>
</ul>
<p>例子：</p>
<p>就用我们上面创建的文件temp.txt。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">str = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"读取的字符串是 : "</span>, str</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查找当前位置</span></span><br><span class="line">position = fo.tell()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"当前文件位置 : "</span>, position)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把指针再次重新定位到文件开头</span></span><br><span class="line">position = fo.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">str = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> （<span class="string">"重新读取字符串 : "</span>, str）</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure></p>
<p>以上实例输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-9dfe3cba7f0a9e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="重命名和删除文件"><a href="#重命名和删除文件" class="headerlink" title="重命名和删除文件"></a>重命名和删除文件</h2><p>Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。</p>
<p>要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。</p>
<p>rename()方法：</p>
<p>rename()方法需要两个参数，当前的文件名和新文件名。</p>
<p>语法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rename(current_file_name, new_file_name)</span><br></pre></td></tr></table></figure></p>
<p>例子：</p>
<p>下例将重命名一个已经存在的文件 temp.txt。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重命名文件temp.txt到temp-1.txt。</span></span><br><span class="line">os.rename( <span class="string">"temp.txt"</span>, <span class="string">"temp-1.txt"</span> )</span><br></pre></td></tr></table></figure>
<h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h3><p>你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。</p>
<p>语法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(file_name)</span><br></pre></td></tr></table></figure></p>
<p>例子：</p>
<p>下例将删除一个已经存在的文件temp-1.txt。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除temp-1.txt。</span></span><br><span class="line">os.remove( <span class="string">"temp-1.txt"</span>)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="Python里的目录："><a href="#Python里的目录：" class="headerlink" title="Python里的目录："></a>Python里的目录：</h2><p>所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。</p>
<h3 id="mkdir-方法"><a href="#mkdir-方法" class="headerlink" title="mkdir()方法"></a>mkdir()方法</h3><p>可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。</p>
<p>语法：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.mkdir(<span class="string">"newdir"</span>)</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<p>下例将在当前目录下创建一个新目录test。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建目录test</span></span><br><span class="line">os.mkdir(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="chdir-方法"><a href="#chdir-方法" class="headerlink" title="chdir()方法"></a>chdir()方法</h3><p>可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.chdir(<span class="string">"newdir"</span>)</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<p>下例将进入”test”目录。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建目录test</span></span><br><span class="line">os.chdir(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure></p>
<p>getcwd()方法：</p>
<p>getcwd()方法显示当前的工作目录。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<p>下例给出当前目录：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给出当前的目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br></pre></td></tr></table></figure></p>
<h3 id="rmdir-方法"><a href="#rmdir-方法" class="headerlink" title="rmdir()方法"></a>rmdir()方法</h3><p>rmdir()方法删除目录，目录名称以参数传递。在删除这个目录之前，它的所有内容应该先被清除。</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rmdir()</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<p>以下是删除” test”目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给出当前的目录</span></span><br><span class="line">os.rmdir(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="文件、目录相关的方法"><a href="#文件、目录相关的方法" class="headerlink" title="文件、目录相关的方法"></a>文件、目录相关的方法</h2><p>File 对象和 OS 对象提供了很多文件与目录的操作方法，可以通过点击下面链接查看详情：</p>
<ul>
<li><a href="https://docs.python.org/3/tutorial/inputoutput.html" target="_blank" rel="noopener">File 对象方法</a>: file 对象提供了操作文件的一系列方法。</li>
<li><a href="https://docs.python.org/3/library/os.html" target="_blank" rel="noopener">OS 对象方法</a>: 提供了处理文件及目录的一系列方法。</li>
</ul>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础-`yeild` 关键字使用</title>
    <url>/2017/11/12/2017-11-12_Programing-Python-Basic-use-yield/</url>
    <content><![CDATA[<hr>
<p>大家在阅读 Python 代码时，经常遇到带有 <code>yield</code> 的函数，通常此时我们都需要去想想这个<code>yield</code> 是个什么东西？这一段代码在讲什么事情呢？</p>
<p>那我们这里就来好好讲讲这个 <code>yield</code>。</p>
<p><code>yield</code> 是 Python 设计之初就保留的关键字之一。</p>
<p>在 Python 中被称之为 <code>generator</code>(中文翻译是 <code>“生成器”</code>)，那什么是 <code>generator</code> 呢 ？</p>
<p>我们先抛开 <code>generator</code>，以一个常见的编程题目来展示 <code>yield</code> 的概念。</p>
<hr>
<h2 id="从生成斐波那契数列开始"><a href="#从生成斐波那契数列开始" class="headerlink" title="从生成斐波那契数列开始"></a>从生成斐波那契数列开始</h2><p>斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。</p>
<p>用计算机程序输出斐波那契数列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出斐波那契数列前 N 个数第一版</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">       print(b)</span><br><span class="line">       a, b = b, a + b</span><br><span class="line">       n = n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fab(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>将上面的内容保存为 <code>.py</code> 后缀的文件，然后执行 ，我们可以得到如下输出：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-03a4c82710ec33e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果1"></p>
<p>结果没有问题，但有经验的开发者会指出，直接在 fab 函数中用 print 打印数字会导致该函数可复用性较差，因为 fab 函数返回 None，其他函数无法获得该函数生成的数列。</p>
<p>要提高 fab 函数的可复用性，最好不要直接打印出数列，而是返回一个 List。</p>
<p>以下是 fab 函数改写后的第二个版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出斐波那契数列前 N 个数第二版</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span> </span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> </span><br><span class="line">    L = [] </span><br><span class="line">    <span class="keyword">while</span> n &lt; max: </span><br><span class="line">        L.append(b) </span><br><span class="line">        a, b = b, a + b </span><br><span class="line">        n = n + <span class="number">1</span> </span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
<p>执行 ，我们可以得到如下输出：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-4c63ee7aa08c18ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果2"></p>
<p>改写后的 fab 函数通过返回 List 能满足复用性的要求，但是更有经验的开发者会指出，该函数在运行中占用的内存会随着参数 max 的增大而增大，如果要控制内存占用，最好不要用 List</p>
<p>来保存中间结果，而是通过 iterable 对象来迭代。例如，在 Python 中，<code>range()</code> 不返回 List，而是返回一个 <code>iterable</code>(中文翻译 <code>“可迭代的对象”</code>) 对象。</p>
<p>例如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过 iterable 对象来迭代</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>是在每次迭代中返回下一个数值，内存空间占用很小。</p>
<p>我们可以利用 <code>iterable</code> 的特性，把 fab 函数改写为一个支持 <code>iterable</code> 的 class，以下是第三个版本的 Fab：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出斐波那契数列前 N 个数第三版</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fab</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">       self.max = max</span><br><span class="line">       self.n, self.a, self.b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> self.n &lt; self.max:</span><br><span class="line">           r = self.b</span><br><span class="line">           self.a, self.b = self.b, self.a + self.b</span><br><span class="line">           self.n = self.n + <span class="number">1</span></span><br><span class="line">           <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">raise</span> StopIteration()</span><br><span class="line"><span class="comment"># Fab 类通过 next() 不断返回数列的下一个数，内存占用始终为常数：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> Fab(<span class="number">5</span>):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
<p>执行 ，我们可以得到如下输出：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-6f51a320b6673d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果3"></p>
<p>然而，使用 class 改写的这个版本，代码远远没有第一版的 fab 函数来得简洁。</p>
<p>如果我们想要保持第一版 fab 函数的简洁性，同时又要获得 <code>iterable</code> 的效果，<code>yield</code> 就派上用场了。</p>
<a id="more"></a>
<h2 id="使用-yield-生成斐波那契数列"><a href="#使用-yield-生成斐波那契数列" class="headerlink" title="使用 yield 生成斐波那契数列"></a>使用 <code>yield</code> 生成斐波那契数列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        <span class="comment"># print(b)</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
<p>第四个版本的 fab 和第一版相比，仅仅把 <code>print(b)</code> 改为了 <code>yield b</code> ，就在保持简洁性的同时获得了 <code>iterable</code> 的效果。</p>
<p>那么 <code>yield</code> 到底做了什么呢？</p>
<p>简单地讲，<code>yield</code> 的作用就是把一个函数变成一个 <code>generator</code>，带有 <code>yield</code> 的函数不再是一个普通函数，Python 解释器会将其视为一个 <code>generator</code>。</p>
<p>调用 <code>fab(5)</code> 不会执行 fab 函数，而是返回一个 <code>iterable</code> 对象！</p>
<p>在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 <code>yield b</code> 时，fab 函数就返回一个迭代值，下次迭代时，代码从 <code>yield b</code> 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 <code>yield</code>。</p>
<p>为了精通 <code>yield</code> ,你必须要理解：当你调用这个函数的时候，函数内部的代码并不立马执行 ，这个函数只是返回一个 <code>generator</code> 对象。</p>
<p>函数内的代码只有当你使用 <code>for</code> 进行迭代的时候(也就是 <code>for n in fab(5):</code> 这一句)。</p>
<p>现在到了关键点了！</p>
<p><strong>第一次迭代中你的函数会执行，从开始到达 yield 关键字，然后返回 yield 后的值作为第一次迭代的返回值. 然后，每次执行这个函数都会继续执行你在函数内部定义的那个循环的下一次，再返回那个值，直到没有可以返回的。</strong></p>
<p>如果 <code>generator</code> 内部没有定义 yield 关键字，那么这个 <code>generator</code> 被认为成空的。这种情况可能因为是循环进行没了，或者是没有满足 <code>if/else</code> 条件。</p>
<p>yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值，不仅代码简洁，而且执行流程异常清晰。</p>
<hr>
<h2 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h2><p>要注意区分 fab 和 fab(5)，fab 是一个 <code>generator function</code>，而 fab(5) 是调用 fab 返回的一个 <code>generator</code>，好比类的定义和类的实例的区别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类的定义和类的实例</span></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">print(isinstance(fab, types.GeneratorType))</span><br><span class="line"><span class="comment"># 将输出 False</span></span><br><span class="line">print(isinstance(fab(<span class="number">5</span>), types.GeneratorType))</span><br><span class="line"><span class="comment"># 将输出 True</span></span><br></pre></td></tr></table></figure>
<p>fab 是无法迭代的，而 fab(5) 是可迭代的：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">print(isinstance(fab, Iterable)）</span><br><span class="line"><span class="comment"># 将输出 False</span></span><br><span class="line">print(isinstance(fab(<span class="number">5</span>), Iterable))</span><br><span class="line"><span class="comment"># 将输出 True</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="yield-的实际使用"><a href="#yield-的实际使用" class="headerlink" title="yield 的实际使用"></a><code>yield</code> 的实际使用</h2><p>下面我们通过一个实际的例子来再次回顾下 <code>yield</code> 的用法。</p>
<p>通过 <code>yield</code> 来进行文件读取。如果直接对文件对象调用 <code>read()</code> 方法，会导致不可预测的内存占用。</p>
<p>好的方法是利用固定长度的缓冲区来不断读取文件内容。通过 <code>yield</code>，我们不再需要编写读文件的迭代类，就可以轻松实现文件读取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 yield 读取文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    BLOCK_SIZE = <span class="number">2048</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            block = f.read(BLOCK_SIZE)</span><br><span class="line">            <span class="keyword">if</span> block:</span><br><span class="line">                <span class="keyword">yield</span> block</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>以上内容介绍了 <code>yield</code> 的基本概念和用法。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Programing-Python-Basic-use_random</title>
    <url>/2017/11/11/2017-11-11_Programing-Python-Basic-use-random/</url>
    <content><![CDATA[<h2 id="一-获得-a-b-之间的随机整数"><a href="#一-获得-a-b-之间的随机整数" class="headerlink" title="一 获得[a, b]之间的随机整数"></a>一 获得[a, b]之间的随机整数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(random.randint(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h2 id="二-从一个非空序列中随机挑选一个元素"><a href="#二-从一个非空序列中随机挑选一个元素" class="headerlink" title="二 从一个非空序列中随机挑选一个元素"></a>二 从一个非空序列中随机挑选一个元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(random.choice([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>或<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从0～9中随机取一整数</span></span><br><span class="line">print(random.choice(range(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure></p>
<h2 id="三-按指定基数递增的集合中获取随机数"><a href="#三-按指定基数递增的集合中获取随机数" class="headerlink" title="三 按指定基数递增的集合中获取随机数"></a>三 按指定基数递增的集合中获取随机数</h2><p>基数缺省值为1<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># randrange([start,]stop[,step]) 取不到stop对应的值</span></span><br><span class="line">print(random.randrange(<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="四-随机打乱列表的元素"><a href="#四-随机打乱列表的元素" class="headerlink" title="四 随机打乱列表的元素"></a>四 随机打乱列表的元素</h2><p>就地修改，返回值为None<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">random.shuffle(lst)</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础-PEP 是什么？</title>
    <url>/2017/11/05/2017-11-05_Programing-Python-Basic-what-is-PEP/</url>
    <content><![CDATA[<h2 id="PEP-是什么？"><a href="#PEP-是什么？" class="headerlink" title="PEP 是什么？"></a>PEP 是什么？</h2><p>Python的 PEP 文档是一组不断发展的标准文档，PEP是 <code>Python Enhancement Proposal</code>的首字母缩写。就像TCPIP协议使用RFC来组织起不断发展的通信标准一样，PEP也是类似的用于发展Python的一组文档。</p>
<p>PEP的全称是Python Enhancement Proposals，其中Enhancement是增强改进的意思，Proposals则可译为提案或建议书，所以合起来，比较常见的翻译是 Python 增强提案或 Python 改进建议书。Python 核心开发者主要通过邮件列表讨论问题、提议、计划等，PEP 通常是汇总了多方信息，经过了部分核心开发者 review 和认可，最终形成的正式文档，起到了对外公示的作用。</p>
<p>PEP文档越多，说明 Python 社区越活跃，发展良好。</p>
<h2 id="PEP-的类型"><a href="#PEP-的类型" class="headerlink" title="PEP 的类型"></a>PEP 的类型</h2><p>每个PEP都有对应的类型（PEP Status Key）：</p>
<p>A – Accepted (Standards Track only) or Active proposal 已接受（仅限标准跟踪）或有效提案<br>D – Deferred proposal延期提案<br>F – Final proposal 最终提案<br>P – Provisional proposal 暂定提案<br>R – Rejected proposal 拒绝提案<br>S – Superseded proposal 被取代的提案<br>W – Withdrawn proposal 撤回提案</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-ffd775233a9043a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PEP Status"></p>
<h2 id="几个特殊的PEP"><a href="#几个特殊的PEP" class="headerlink" title="几个特殊的PEP"></a>几个特殊的PEP</h2><h3 id="PEP-0"><a href="#PEP-0" class="headerlink" title="PEP 0"></a>PEP 0</h3><p><a href="https://www.python.org/dev/peps/" target="_blank" rel="noopener">https://www.python.org/dev/peps/</a></p>
<p>这个文档是属于Information类的PEP文档，是所有PEP文档的索引。</p>
<h3 id="PEP-1"><a href="#PEP-1" class="headerlink" title="PEP 1"></a>PEP 1</h3><p><a href="https://www.python.org/dev/peps/pep-0001/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0001/</a></p>
<p>这个文档讲了PEP的目的和指引。</p>
<p>在PEP 1中的开头，就说明了PEP文档分成3个类型：</p>
<ol>
<li>标准，当然是Python语言的标准；</li>
<li>信息类；</li>
<li>过程类，记录Python语言发展过程中的一些信息。</li>
</ol>
<h3 id="PEP-8"><a href="#PEP-8" class="headerlink" title="PEP 8"></a>PEP 8</h3><p><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></p>
<p>PEP 8号文档，是Python官方出的编程规范.</p>
<a id="more"></a>
<h3 id="PEP-20"><a href="#PEP-20" class="headerlink" title="PEP 20"></a>PEP 20</h3><p><a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0020/</a><br>Python 之禅，就是我们在python 解释器中输入</p>
<p>每次Python官方发布新版本，新版本的New Features都有相应的PEP文档支撑，比如3.7.0版本，PEP文档成了Python发展的需求管理工具。如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-4e51d36b3d821fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Python 3.7.0版本关联的PEP"></p>
<p>Python新版本的New Features都有相应的PEP文档支撑</p>
<p>详见：<a href="https://www.python.org/downloads/release/python-370/" target="_blank" rel="noopener">https://www.python.org/downloads/release/python-370/</a></p>
<h3 id="其它需要重点关注的PEP"><a href="#其它需要重点关注的PEP" class="headerlink" title="其它需要重点关注的PEP"></a>其它需要重点关注的PEP</h3><ul>
<li>PEP 7 — Style Guide for C Code，C扩展</li>
<li>PEP 202 — List Comprehensions，列表生成式</li>
<li>PEP 274 — Dict Comprehensions，字典生成式</li>
<li>PEP 234 — Iterators，迭代器</li>
<li>PEP 257 — Docstring Conventions，文档注释规范</li>
<li>PEP 279 — The enumerate() built-in function，enumerate枚举</li>
<li>PEP 282 — A Logging System，日志模块</li>
<li>PEP 285 — Adding a bool type，布尔值</li>
<li>PEP 289 — Generator Expressions，生成器表达式</li>
<li>PEP 318 — Decorators for Functions and Methods，装饰器</li>
<li>PEP 342 — Coroutines via Enhanced Generators，协程</li>
<li>PEP 343 — The “with” Statement，with语句</li>
<li>PEP 380 — Syntax for Delegating to a Subgenerator，yield from语法</li>
<li>PEP 405 — Python Virtual Environments，虚拟环境</li>
<li>PEP 471 — os.scandir() function，遍历目录</li>
<li>PEP 484 — Type Hints，类型约束</li>
<li>PEP 492 — Coroutines with async and await syntax，async/await语法</li>
<li>PEP 498 — Literal String Interpolation Python，字面字符串插值</li>
<li>PEP 525 — Asynchronous Generators，异步生成器</li>
<li>PEP 572 — Assignment Expressions，表达式内赋值</li>
<li>PEP 3105 — Make print a function，print改为函数</li>
<li>PEP 3115 — Metaclasses in Python 3000，元类</li>
<li>PEP 3120 — Using UTF-8 as the default source encoding，默认UTF-8</li>
<li>PEP 3333 — Python Web Server Gateway Interface v1.0.1，Web开发</li>
<li>PEP 8000 — Python Language Governance Proposal Overview，GvR老爹推出决策层后，事关新决策方案</li>
</ul>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 里的变量和作用域</title>
    <url>/2017/10/25/2017-10-15-Programing-JavaScript-Variables-and-scoping-in-ECMAScript-6/</url>
    <content><![CDATA[<p>在本文将有大量的例子介绍在ES6中作用域和变量的使用方法</p>
<h2 id="1-块级作用域的let和const"><a href="#1-块级作用域的let和const" class="headerlink" title="1.块级作用域的let和const"></a>1.块级作用域的let和const</h2><p>让<code>let</code>和<code>const</code>创造块级作用域，他仅仅存在于包裹他们的最内层的块。下面代码演示了使用<code>let</code>修饰的<code>tmp变量</code>仅仅存在于最里层的<code>if</code>申明里。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp); <span class="comment">// tmp未定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比之下，用var申明的变量在函数级作用域</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块级作用域意味着你在函数里只要是两个不同的块，那么变量名称可以重复。（原文为<strong>影子变量</strong>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> foo = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (···) &#123;</span><br><span class="line">        <span class="keyword">let</span> foo = <span class="number">10</span>; <span class="comment">// shadows outer `foo`</span></span><br><span class="line">        <span class="built_in">console</span>.log(foo); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(foo); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-const创建不可变的变量"><a href="#2-const创建不可变的变量" class="headerlink" title="2.const创建不可变的变量"></a>2.<code>const</code>创建不可变的变量</h2><p>由<code>let</code>创建的变量是可变的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">'abc'</span>;</span><br><span class="line">foo = <span class="string">'def'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// def</span></span><br></pre></td></tr></table></figure>
<p><code>const</code>创建变量是不可变的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">'abc'</span>;</span><br><span class="line">foo = <span class="string">'def'</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>const</code>并不影响所赋的值是否可变，如果所赋的值是一个对象，那么并不能保证该对象不变。他只是保存一个对象的引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.prop = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.prop); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">obj = &#123;&#125;; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>如果你想改变量是真正不可变的，那么直接<a href="http://speakingjs.com/es5/ch17.html#freezing_objects" target="_blank" rel="noopener">冻结他的值</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">obj.prop = <span class="number">123</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-循环体内的const"><a href="#2-1-循环体内的const" class="headerlink" title="2.1 循环体内的const"></a>2.1 循环体内的const</h3><p>一旦<code>const</code>变量创建，那么他就不能改变。但这并不意味着你不能重新声明一个新值，比如在循环体内。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> args.entries()) &#123;</span><br><span class="line">        <span class="keyword">const</span> message = index + <span class="string">'. '</span> + elem;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">logArgs(<span class="string">'Hello'</span>, <span class="string">'everyone'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 0. Hello</span></span><br><span class="line"><span class="comment">// 1. everyone</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-什么时候我该使用let，什么时候该使用const？"><a href="#2-2-什么时候我该使用let，什么时候该使用const？" class="headerlink" title="2.2 什么时候我该使用let，什么时候该使用const？"></a>2.2 什么时候我该使用let，什么时候该使用const？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="number">1</span>;</span><br><span class="line">foo++; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>如果你想创建的可变变量为基本类型，则，不能使用const。</p>
<p>不过你可以使用<code>const</code>修饰引用类型的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = [];</span><br><span class="line">bar.push(<span class="string">'abc'</span>); <span class="comment">// array是可变的</span></span><br></pre></td></tr></table></figure>
<p>按照最佳实践，一般会把常量(真正不变的)使用大写来表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EMPTY_ARRAY = <span class="built_in">Object</span>.freeze([]);</span><br></pre></td></tr></table></figure>
<h2 id="3-临时禁区-TDZ"><a href="#3-临时禁区-TDZ" class="headerlink" title="3.临时禁区(TDZ)"></a>3.临时禁区(TDZ)</h2><p>被<code>const</code>和<code>let</code>修饰的变量我叫做它是<code>临时禁区</code> (TDZ)。当进入这个作用域，外界就无法访问这些被修饰的变量知道运行结束。</p>
<p>使用<code>var</code>修饰的变量没有TDZ。</p>
<ul>
<li>当进入有<code>var</code>修饰的变量的作用域中，会在内存中立即创建空间，立即初始化变量，并且设置成<code>undifined</code>。</li>
<li>在执行过程中如遇到赋值关键字则给变量赋值，否则还是为<code>undifined</code>。</li>
</ul>
<p>使用<code>let</code>关键字的拥有TDZ，这意味着它的生命周期如下：</p>
<ul>
<li>当进入有<code>let</code>修饰的变量的作用域中，会在内存中立即创建这个变量，不会初始化这个变量。</li>
<li>获取或设置未初始化的变量会导致引用错误(ReferenceError).</li>
<li>在执行过程中如遇到声明处则初始化且给变量赋值，如果不赋值则为undefined。</li>
</ul>
<p><code>const</code>的机制与<code>let</code>相似，但他必须赋一个值且不能被改变。</p>
<p>在TDZ中，如果获取或者设置一个未初始化会抛出异常。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; <span class="comment">// 一个新的作用域, TDZ 开始</span></span><br><span class="line">    <span class="comment">//tmp未初始化</span></span><br><span class="line">    tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tmp; <span class="comment">// TDZ 结束, `tmp` 被初始化为 `undefined`</span></span><br><span class="line">    <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">    tmp = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面例子演示了TDZ是临时的(基于时间)的而不是基于位置的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (true) &#123; // 一个新的作用域, TDZ 开始</span><br><span class="line">    const func = function () &#123;</span><br><span class="line">        console.log(myVar); // OK!</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 在这里已经进入了TDZ，访问 `myVar` 会导致 ReferenceError</span><br><span class="line"></span><br><span class="line">    let myVar = 3; TDZ 结束</span><br><span class="line">    func(); // called outside TDZ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1TDZ的类型检查"><a href="#3-1TDZ的类型检查" class="headerlink" title="3.1TDZ的类型检查"></a>3.1TDZ的类型检查</h3><p>一个变量不能再TDZ里访问意味着你也不能在该变量使用<code>typeof</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> tmp); <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我不认为这将在实践中是一个问题。因为你不能有条件的给某一个作用域加上<code>let</code>修饰符。事实上你仍然可以使用<code>var</code>修饰符创建全局变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> myVarVariable === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="comment">// `myVarVariable`不存在，则创建它</span></span><br><span class="line">    <span class="built_in">window</span>.myVarVariable = <span class="string">'abc'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-在循环体的头部中使用let修饰符"><a href="#4-在循环体的头部中使用let修饰符" class="headerlink" title="4.在循环体的头部中使用let修饰符"></a>4.在循环体的头部中使用<code>let</code>修饰符</h2><p>在循环体中，你每次迭代重新绑定用<code>let</code>修饰的变量。允许你这样做的循环:<code>for</code>, <code>for-in</code>和<code>for-of</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> myVarVariable === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push(<span class="function"><span class="params">()</span> =&gt;</span> i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(arr.map(<span class="function"><span class="params">x</span> =&gt;</span> x())); <span class="comment">// [0,1,2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比之下，用var声明的循环体中，，每次迭代室友一个单一的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> myVarVariable === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push(<span class="function"><span class="params">()</span> =&gt;</span> i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(arr.map(<span class="function"><span class="params">x</span> =&gt;</span> x())); <span class="comment">// [3,3,3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为每次迭代得到一个新的绑定似乎有些奇怪,但当你使用循环创建函数(例如回调事件处理)它是非常有用。</p>
<h2 id="5-形参"><a href="#5-形参" class="headerlink" title="5.形参"></a>5.形参</h2><h3 id="5-1-形参和局部变量"><a href="#5-1-形参和局部变量" class="headerlink" title="5.1 形参和局部变量"></a>5.1 形参和局部变量</h3><p>如果你声明的变量名正好与形参一致，那么会爆出一个静态错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arg; <span class="comment">// static error: duplicate declaration of `arg`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数里面再嵌套一个块则会避免这个问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> arg; <span class="comment">// 影子参数 `arg`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比之下,用<code>var</code>修饰的与形参同名的变量不会出现错误，表现的形式是覆盖了形参。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg; <span class="comment">// does nothing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> arg; <span class="comment">// does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-默认形参与TDZ"><a href="#5-2-默认形参与TDZ" class="headerlink" title="5.2 默认形参与TDZ"></a>5.2 默认形参与TDZ</h3><p>如果形参有默认值,他们被当做一个序列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OK: 声明之后访问x</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=<span class="number">1</span>, y=x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// [1,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常，在YDZ里试图访问y</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x=y, y=<span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-默认形参与TDZ"><a href="#5-3-默认形参与TDZ" class="headerlink" title="5.3 默认形参与TDZ"></a>5.3 默认形参与TDZ</h3><p>形参默认值的范围是独立于body的作用域(前者围绕后者)。这意味着“inside”定义的方法或函数参数的默认值不知道body的局部变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OK: 在x已经声明后y访问x</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=<span class="number">1</span>, y=x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// [1,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常: `x` 试图在TDZ访问 `y`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x=y, y=<span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<h2 id="6-全局对象"><a href="#6-全局对象" class="headerlink" title="6.全局对象"></a>6.全局对象</h2><p>JS中的全局对象(浏览器是<code>windows</code>，Node.js是global)的bug比特性还要多，尤其在性能这一块，这也就是不奇怪ES6有以下描述：</p>
<ul>
<li>全局对象的属性都是全局变量。在全局范围,<code>var</code> 和 <code>function</code> 声明创建这些属性</li>
<li>是全局变量但不是全局对象的属性。在全局范围,<code>let</code> 和 <code>const</code>, <code>Class</code> 声明创建这些属性</li>
</ul>
<h2 id="7-函数的声明和类的声明"><a href="#7-函数的声明和类的声明" class="headerlink" title="7.函数的声明和类的声明"></a>7.函数的声明和类的声明</h2><p>函数声明：</p>
<ul>
<li>块级作用域，像<code>let</code></li>
<li>在全局对象创建属性(在全局范围),像var。 </li>
<li>声明提升：独立的一个函数声明中提到它的范围,它总是创建之初的范围</li>
</ul>
<p>下面代码解释了声明提升</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="comment">// Enter a new scope</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(foo()); <span class="comment">// OK, due to hoisting</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类的声明：</p>
<ul>
<li>块级作用域</li>
<li>不会再全局对象上创建属性</li>
<li>不会声明提升</li>
</ul>
<p>类不升起可能令人惊讶,因为他们创建函数。这种行为的理由是,他们继承条款定义的值通过表达式,表达式必须在适当的时间执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="comment">// 进入新的作用域</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> identity = <span class="function"><span class="params">x</span> =&gt;</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这儿是`MyClass`的TDZ</span></span><br><span class="line">    <span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass(); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意 `extends`</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">identity</span>(<span class="title">Object</span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-扩展阅读"><a href="#8-扩展阅读" class="headerlink" title="8.扩展阅读"></a>8.扩展阅读</h2><p>1.<a href="http://www.2ality.com/2014/08/es6-today.html" target="_blank" rel="noopener">Using ECMAScript 6 today</a></p>
<p>2.<a href="http://www.2ality.com/2015/01/es6-destructuring.html" target="_blank" rel="noopener">Destructuring and parameter handling in ECMAScript 6</a></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>你需要知道的块级作用域 - let</title>
    <url>/2017/10/14/2017-10-14-Programing-JavaScript-what-you-need-to-know-about-block-scope-let/</url>
    <content><![CDATA[<p>变量声明在任何语言中都是非常基础的东西，理解变量在作用域下如何工作是非常重要的事情。</p>
<p>在大多数语言中，如 <code>Python</code>，他有两个作用域:局部 和 全局。如下，变量定义在代码开头部分则为全局变量，在函数里面声明变量则为局部变量。</p>
<p>JavaScript也很相似，看以下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line">x = <span class="number">1</span> <span class="comment"># 全局变量</span></span><br><span class="line">y = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    s = a + b <span class="comment"># 局部变量</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = a + b;  <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以C语言为基础而衍生出来的语言(JavaScript, PHP)一般是块级作用域，但JavaScript却不是，当你在一个函数体内声明一个变量，他会在父级或者全局来寻找这个变量，这种行为叫做<code>变量提升</code>，与其他语言不同，JavaScript会在<code>for循环</code>外面使用这些变量。</p>
<a id="more"></a>
<p>看下面这个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// current i</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// last i</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，i竟然可以在循环外面被访问到！这在其他语言是不可思议的！这是很常见的问题，但JS程序员不见得都会关注它。</p>
<h2 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h2><p>let在ES6中出现是为了<code>代替</code>var。是的，我们的想法是在未来停用<code>var</code>，现在就停止时不切实际的，因为有很多网站都还在用它。</p>
<p>使用<code>let</code>会像和其他语言大道预期的效果</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>  (foo) &#123;</span><br><span class="line">    <span class="keyword">let</span> bar = <span class="string">'baz'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(bar); <span class="comment">// outputs 'baz'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar doesn't exist"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你想看到的,<code>let</code>会解决在for循环变量的问题。</p>
<h2 id="现在的支持"><a href="#现在的支持" class="headerlink" title="现在的支持"></a>现在的支持</h2><p>你现在就可以使用let</p>
<p>查看 Kangax 的ES6 支持表格 &gt; <a href="http://kangax.github.io/compat-table/es6/#" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es6/#</a>.<br>let已经在z最新的现代浏览器有所支持( &gt;= IE 11)和<a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a>编译器</p>
<p>你可以在火狐开发者工具中试试</p>
<p><img src="http://es6rocks.com/img/let.gif" alt="es6 let"></p>
<p>注： Michał Gołębiowski 指出在各个浏览器的规范不一样，使用时可能会出现bug。在当前还未正式流行开，这种情况可能会持续到2015年中旬。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>声明变量虽然简单,但在JavaScript语言中会让初学者头痛的。<br><code>let</code>声明变量更直观,符合基于c的语言.</p>
<p>var应该停止使用,只有这样，没有变量提示的<code>let</code>才能正在运用到未来。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 箭头函数和它的作用域</title>
    <url>/2017/10/13/2017-10-13-Programing-JavaScript-arrow-functions-and-their-scope/</url>
    <content><![CDATA[<p>在ES6很多很棒的新特性中, 箭头函数 (或者大箭头函数)就是其中值得关注的一个! 它不仅仅是很棒很酷, 它很好的利用了作用域, 快捷方便的在现在使用以前我们用的技术, 减少了很多代码……但是如果你不了解箭头函数原理的话可能就有点难以理解. 所以,让我们来看下箭头函数, 就是现在!</p>
<h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>你可以自己去学习和尝试下, 你可以简单的把示例程序代码复制到你的浏览器控制台下. 现在, 推荐使用Firefox(22+)开发者工具, Firefox(22+)开发者工具现在支持箭头函数,你也可以使用谷歌浏览器. 如果你使用谷歌浏览器, 你必须要做下列两件事:</p>
<ul>
<li>- 在谷歌浏览器中地址栏中输入：”about:flags”, 找到 “使用体验性Javascript”选项，开启使用。</li>
<li>- 在函数的开头加上”use strict”,然后再在你的谷歌浏览中测试箭头函数吧(提示：请用谷歌浏览器v38,我当时就是被浏览器版本坑了):</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="comment">// use arrow functions here</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>幸运的是后面会有越来越多的浏览器支持ES6特性. 现在你完成了所有准备工作, 让我们继续深入它吧!</p>
<a id="more"></a>
<h2 id="一个新话题"><a href="#一个新话题" class="headerlink" title="一个新话题"></a>一个新话题</h2><p>最近大家在讨论关于ES6的一个话题：关于箭头函数, 像这样:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">=&gt;</span><br></pre></td></tr></table></figure>
<h2 id="新的语法"><a href="#新的语法" class="headerlink" title="新的语法"></a>新的语法</h2><p>随着讨论产生了一个新的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">param =&gt; expression</span><br></pre></td></tr></table></figure>
<p>新增的语法是作用在变量上, 可以在表达式中申明多个变量, 下面是箭头函数的使用模式:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  一个参数对应一个表达式</span></span><br><span class="line">param =&gt; expression;<span class="comment">// 例如 x =&gt; x+2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个参数对应一个表达式</span></span><br><span class="line">(param [, param]) =&gt; expression; <span class="comment">//例如 (x,y) =&gt; (x + y);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个参数对应多个表示式</span></span><br><span class="line">param =&gt; &#123;statements;&#125; <span class="comment">//例如 x = &gt; &#123; x++; return x;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  多个参数对应多个表达式</span></span><br><span class="line">([param] [, param]) =&gt; &#123;statements&#125; <span class="comment">// 例如 (x,y) =&gt; &#123; x++;y++;return x*y;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表达式里没有参数</span></span><br><span class="line">() =&gt; expression; <span class="comment">//例如var flag = (() =&gt; 2)(); flag等于2</span></span><br><span class="line"></span><br><span class="line">() =&gt; &#123;statements;&#125; <span class="comment">//例如 var flag = (() =&gt; &#123;return 1;&#125;)(); flag就等于1</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//传入一个表达式，返回一个对象</span></span><br><span class="line">([param]) =&gt; (&#123; <span class="attr">key</span>: value &#125;);</span><br><span class="line"><span class="comment">//例如  var fuc = (x) =&gt; (&#123;key:x&#125;)</span></span><br><span class="line">        <span class="keyword">var</span> object = fuc(<span class="number">1</span>);</span><br><span class="line">        alert(object);<span class="comment">//&#123;key:1&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="箭头函数是怎么实现的"><a href="#箭头函数是怎么实现的" class="headerlink" title="箭头函数是怎么实现的"></a>箭头函数是怎么实现的</h2><p>我们可以把一个普通函数转换成用箭头函数来实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前函数</span></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> param.split(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用箭头函数实现</span></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="params">param</span> =&gt;</span> param.split(<span class="string">" "</span>);</span><br></pre></td></tr></table></figure>
<p>从上面的例子中我们可以看出箭头函数的语法实际上是返回了一个新的函数, 这个函数有函数体和参数</p>
<p>因此, 我们可以这样调用刚才我们创建的函数:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func(<span class="string">"Felipe Moura"</span>); <span class="comment">// returns ["Felipe", "Moura"]</span></span><br></pre></td></tr></table></figure>
<h2 id="立即执行函数-IIFE"><a href="#立即执行函数-IIFE" class="headerlink" title="立即执行函数(IIFE)"></a>立即执行函数(IIFE)</h2><p>你能在立即执行函数里使用箭头函数，例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">( <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span> )( <span class="number">3</span> ); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>这行代码产生了一个临时函数，这个函数有一个形参<code>x</code>，函数的返回值为<code>x*2</code>,之后系统会马上执行这个临时函数, 将<code>3</code>赋值给形参<code>x</code>.</p>
<p>下面的例子描述了临时函数体里有多行代码的情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">( <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    x = x * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;)( <span class="number">3</span>, <span class="string">"A"</span> ); <span class="comment">// "6A"</span></span><br></pre></td></tr></table></figure>
<h2 id="相关思考"><a href="#相关思考" class="headerlink" title="相关思考"></a>相关思考</h2><p>思考下面的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们列出了一些常见的问题：</p>
<p><strong>- 箭头函数创建的临时函数的<code>arguments</code>是我们预料的那样工作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p><strong>- <code>typeof</code>和<code>instanceof</code>函数也能正常检查临时函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> func; <span class="comment">// function</span></span><br><span class="line">func.constructor == <span class="built_in">Function</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>- 把箭头函数放在括号内是无效的</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  有效的常规语法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    x= x * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125; (<span class="number">3</span>, <span class="string">"B"</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效的箭头函数语法</span></span><br><span class="line">( <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    x= x * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125; ( <span class="number">3</span>, <span class="string">"A"</span> ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是可以这样写就是有效的了：</span></span><br><span class="line">( <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line">	x= x * <span class="number">2</span>;<span class="keyword">return</span> x + y;</span><br><span class="line">&#125; )( <span class="number">3</span>,<span class="string">"A"</span> );<span class="comment">//立即执行函数</span></span><br></pre></td></tr></table></figure>
<p><strong>- 尽管箭头函数会产生一个临时函数，但是这个临时函数不是一个构造函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> instance= <span class="keyword">new</span> func(); <span class="comment">// TypeError: func is not a constructor</span></span><br></pre></td></tr></table></figure>
<p><strong>- 同样也没有原型对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.prototype; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>这个箭头函数的作用域和其他函数有一些不同,如果不是严格模式，<code>this</code>关键字就是指向<code>window</code>，严格模式就是<code>undefined</code>，在构造函数里的<code>this</code>指向的是当前对象实例,如果this在一个对象的函数内则<code>this</code>指向的是这个对象，<code>this</code>有可能指向的是一个<code>dom元素</code>，例如当我们添加事件监听函数时,可能这个<code>this</code>的指向不是很直接，其实<code>this</code>（不止是<code>this</code>变量）变量的指向是根据一个规则来判断的：作用域流。下面我将演示<code>this</code>在事件监听函数和在对象函数内出现的情况： </p>
<p>在事件监听函数中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// the HTMLBodyElement itself</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在构造函数里：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fullName;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        fullName = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jon = <span class="keyword">new</span> Person();</span><br><span class="line">jon.setName(<span class="string">"Jon Doe"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(jon.getName()); <span class="comment">// "Jon Doe"</span></span><br><span class="line"><span class="comment">//注：this关键字这里就不解释了，大家自己google,badu吧。</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果我们让Person.setName函数返回Person对象本身，我们就可以这样用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jon.setName(<span class="string">"Jon Doe"</span>)</span><br><span class="line">   .getName(); <span class="comment">// "Jon Doe"</span></span><br></pre></td></tr></table></figure>
<p>在一个对象里:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    foo: <span class="string">"bar"</span>,</span><br><span class="line">    getIt: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( obj.getIt() ); <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure>
<p>但是当执行流(比如使用了setTimeout)和作用域变了的时候，this也会变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = data.name || <span class="string">"Jon Doe"</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = data.age&gt;=<span class="number">0</span> ? data.age : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">", "</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log( <span class="keyword">this</span> );</span><br><span class="line">        &#125;, <span class="number">100</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mary = <span class="keyword">new</span> Student(&#123;</span><br><span class="line">    name: <span class="string">"Mary Lou"</span>,</span><br><span class="line">    age: <span class="number">13</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( mary.getInfo() ); <span class="comment">// "Mary Lou, 13"</span></span><br><span class="line">mary.sayHi();</span><br><span class="line"><span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p>当<code>setTimeout</code>函数改变了执行流的情况时，<code>this</code>的指向会变成全局对象,或者是在严格模式下就是<code>undefine</code>,这样在<code>setTimeout</code>函数里面我们使用其他的变量去指向<code>this</code>对象，比如<code>self</code>，<code>that</code>,当然不管你用什么变量，你首先应该在setTimeout访问之前，给<code>self</code>，<code>that</code>赋值，或者使用<code>bind</code>方法不然这些变量就是undefined。</p>
<p>这是后就是箭头函数登场的时候了，它可以保持作用域，this的指向就不会变了。</p>
<p>让我们看下上文<strong>起先</strong>的例子，在这里我们使用箭头函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = data.name || <span class="string">"Jon Doe"</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = data.age&gt;=<span class="number">0</span> ? data.age : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">", "</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123; </span><br><span class="line">        	<span class="comment">// the only difference is here</span></span><br><span class="line">            <span class="built_in">console</span>.log( <span class="keyword">this</span> );</span><br><span class="line">        &#125;, <span class="number">100</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mary = <span class="keyword">new</span> Student(&#123;</span><br><span class="line">    name: <span class="string">"Mary Lou"</span>,</span><br><span class="line">    age: <span class="number">13</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( mary.getInfo() ); <span class="comment">// "Mary Lou, 13"</span></span><br><span class="line">mary.sayHi();</span><br><span class="line"><span class="comment">// Object &#123; name: "Mary Lou", age: 13, ... &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>分析：在sayHi函数中，我们使用了箭头函数，当前作用域是在student对象的一个方法中，箭头函数生成的临时函数的作用域也就是student对象的sayHi函数的作用域。所以即使我们在setTimeout调用了箭头函数生成的临时函数，这个临时函数中的this也是正确的指向。</p>
</blockquote>
<h2 id="有趣和有用的使用"><a href="#有趣和有用的使用" class="headerlink" title="有趣和有用的使用"></a>有趣和有用的使用</h2><p>创建一个函数很容易，我们可以利用它可以保持作用域的特征：</p>
<p>例如我们可以这么使用：Array.forEach()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="params">vowel</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(vowel);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分析：在forEach里箭头函数会创建并返回一个临时函数 tempFun,这个tempFun你可以想象成这样的：function(vowel){ console.log(vowel);}但是Array.forEach函数会怎么去处理传入的tempFunc呢？在forEach函数里会这样调用它：tempFunc.call(this,value);所有我们看到函数的正确执行效果。</p>
</blockquote>
<p>map里使用箭头函数，这里我就不分析函数执行过程了。。。。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>];</span><br><span class="line">arr.map(<span class="function"><span class="params">vowel</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> vowel.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [ "A", "E", "I", "O", "U" ]</span></span><br></pre></td></tr></table></figure>
<p>费布拉奇数列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n * factorial (n<span class="number">-1</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">6</span>); <span class="comment">// 720</span></span><br></pre></td></tr></table></figure>
<p>我们也可以用在Array.sort方法里：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>];</span><br><span class="line">arr.sort( <span class="function">(<span class="params">a, b</span>)=&gt;</span> a &lt; b? <span class="number">1</span>: <span class="number">-1</span> );</span><br></pre></td></tr></table></figure>
<p>也可以在事件监听函数里使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, event=&gt;<span class="built_in">console</span>.log(event, <span class="keyword">this</span>)); <span class="comment">// EventObject, BodyElement</span></span><br></pre></td></tr></table></figure>
<h2 id="推荐的链接"><a href="#推荐的链接" class="headerlink" title="推荐的链接"></a>推荐的链接</h2><p>下面列出了一系列有用的链接，大家可以去看一看</p>
<ul>
<li>- <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">Arrow Functions in MDN Documentation</a></li>
<li>- <a href="http://tc39wiki.calculist.org/es6/arrow-functions/" target="_blank" rel="noopener">TC39 Wiki about Arrow Function</a></li>
<li>- <a href="https://github.com/esnext" target="_blank" rel="noopener">ESNext</a></li>
<li>- <a href="https://github.com/addyosmani/es6-tools" target="_blank" rel="noopener">ES6 Tools</a></li>
<li>- <a href="https://www.npmjs.org/package/grunt-es6-transpiler" target="_blank" rel="noopener">Grunt ES6 Transpiler</a></li>
<li>- <a href="http://www.es6fiddle.net/" target="_blank" rel="noopener">ES6 Fiddle</a></li>
<li>- <a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">ES6 Compatibility Table</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尽管大家可能会认为使用箭头函数会降低你代码的可读性，但是由于它对作用域的特殊处理，它能让我们能很好的处理this的指向问题。箭头函数加上let关键字的使用，将会让我们javascript代码上一个层次！尽量多使用箭头函数，你可以再你的浏览器测试你写的箭头函数代码，大家可以再评论区留下你对箭头函数的想法和使用方案！我希望大家能享受这篇文章，就像你会不就的将来享受箭头函数带给你的快乐.</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux 框架简介</title>
    <url>/2017/10/09/2017-10-09-Programing-JavaScript-Redux-intro/</url>
    <content><![CDATA[<h2 id="redux简介"><a href="#redux简介" class="headerlink" title="redux简介"></a>redux简介</h2><p>Redux 是一个改变状态(state)的模型，这个模型通过一个单向操作的方式来改变状态。现在网上教程一言不合上来就是 Redux + React 的综合运用，经常搞的人一脸懵逼。其实 Redux 和 React 完全解耦，并不是 Redux 非得和 React结合才能使用，而只是 React 结合 Redux 会事半功倍。本系列主要也讲得这个。</p>
<p>对于日益复杂的 Javascript 应用来说，Javascript 需要管理非常多的 state。包括本地尚未持久化到数据库的数据、UI状态等等，而且这些状态有可能是相互关联的，一个状态的改变可能会引起另外一个状态的变化，如果用命令式编程将会变得异常复杂以及难以维护。Redux 作为一个专门关联 state 的框架应用而生，而这种单向数据流的思想也让 Redux 成为一个现代框架。</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/3db24afe31e7218b4ac6cc74497204250b2f5f3a" alt="redux介绍"></p>
<a id="more"></a>
<h3 id="redux三大原则"><a href="#redux三大原则" class="headerlink" title="redux三大原则"></a>redux三大原则</h3><p>Redux 有三大原则：</p>
<ul>
<li>单一数据源</li>
<li>state 只读</li>
<li>只用纯函数来修改</li>
</ul>
<h3 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h3><p>整个应用的 state 都是保存在一个对象树中，而且这个对象树存在唯一一个 store。这个 store 我们通过<code>redux.createStore创建</code>，通过以下代码获取：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.getState()</span><br><span class="line"><span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### state 只读</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">改变 state 只能通过 dispatch 一个 action 才能修改。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">action 其实就是一个简单对象，其中type是必填项，以便 区分是哪一个 action。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'ALL'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为了方便给 action 传递数据，一般来说我们会把上边参数对象封装成方法。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> create = <span class="function">(<span class="params">item</span>)=&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		type: <span class="string">'CREATE'</span>,</span><br><span class="line">		item</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即便在小的功能也得这样修改 state。比如实现表单的双向绑定。我们给一个input绑定一个在<code>onChange</code>事件，然后在<code>onChange</code>里拿到当前的 value，dispactch 一个 action 通知 reducer 改变给当前 dom 绑定的state(根据props传递)，这样才能实现双向绑定。</p>
<h3 id="使用纯函数来执行修改"><a href="#使用纯函数来执行修改" class="headerlink" title="使用纯函数来执行修改"></a>使用纯函数来执行修改</h3><p>何为纯函数？简单来说就是函数的输出完全由输入所决定，运行过程不依赖于系统的状态和上下文环境，运行过程不改变它作用域之外的环境状态。详情可以参考月影的：<a href="https://www.h5jun.com/post/higher-order-function-play-with-pure-function.html" target="_blank" rel="noopener">高阶函数对系统的“提纯”</a></p>
<p>这个纯函数在 Redux 里叫做 Reducer，它接收先前的 state 和 action，并返回一个新的 state，由于它是纯函数，所以它的结果是可预测的，这样为编写单元测试创造了条件。</p>
<h3 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h3><p>介绍完三大原则，我们认清了redux的三个非常重要的组成部分：</p>
<ul>
<li>action</li>
<li>reducer</li>
<li>store</li>
</ul>
<p>action 通知 reducer 修改 state，store 管理 state。非常简单。介绍一个非常简单的demo：</p>
<p>运行环境： node v6.1.0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> redux = <span class="built_in">require</span>(<span class="string">'redux'</span>);</span><br><span class="line"><span class="keyword">const</span> createStore = redux.createStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ActionType = &#123;</span><br><span class="line">	ADD: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们引入 Redux后，编写一个简单的常量类，这个类里存储着一些不同的类型。注意一般会使用字符串来区分，为了避免出现无意义的字符串，我们使用 ES6 的 <code>Symbol</code>。</p>
<p>我们定义一个元素初始状态的 state：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> initState = &#123;</span><br><span class="line">	products: []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，我们就可以写一个 action，比如新增产品</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addProducts = <span class="function">(<span class="params">product</span>)=&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		type: ActionType.ADD,</span><br><span class="line">		product</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在需要一个 reducer 来改变我们的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getProducts = (state=initState, action) =&gt; &#123;</span><br><span class="line">	switch(action.type) &#123;</span><br><span class="line">		case ActionType.ADD : </span><br><span class="line">			return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">				products: state.products.concat(action.product)</span><br><span class="line">			&#125;);</span><br><span class="line">		default : </span><br><span class="line">			return state;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将 reducer 放入 store 中进行测试</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> store = createStore(getProducts);</span><br><span class="line"><span class="built_in">console</span>.log(store.getState());</span><br><span class="line"></span><br><span class="line">store.dispatch(addProducts(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(store.getState());</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">products</span>: [] &#125;</span><br><span class="line">&#123; <span class="attr">products</span>: [ <span class="number">1</span> ] &#125;</span><br></pre></td></tr></table></figure>
<p>注意：分析 createStore 的源码可知，在初始化的时候他自己会 dispatch 一个 action：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> ActionTypes = &#123;</span><br><span class="line">  INIT: <span class="string">'@@redux/INIT'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>会对当前 state 初始化。</p>
<p>至此，我们使用 Redux 编写了一个无 React 的例子。也对 Redux 有了一个基本的认知。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数组定义、使用、以及数组内存分析详解</title>
    <url>/2017/09/22/2017-09-22_Programing-Java-Basic-Java-array-user-guide/</url>
    <content><![CDATA[<p>本文主要是从容器概念到数组概念再到数组的三种定义以及各种情况的数组内存分析，以及一些数组常用的遍历以及反转、取最大值等操作。旨在全面性了解java数组。</p>
<h2 id="1、什么是容器"><a href="#1、什么是容器" class="headerlink" title="1、什么是容器"></a>1、什么是容器</h2><p>在讲数组之前，很有必要来谈谈容器的概念 所谓容器就是将多个数据存储到一起，每个数据称为该容器的元素。</p>
<blockquote>
<p>生活中的容器：水杯，衣柜，教室</p>
</blockquote>
<h2 id="2、什么是数组"><a href="#2、什么是数组" class="headerlink" title="2、什么是数组"></a>2、什么是数组</h2><p>所谓数组就是存储数据<strong>长度固定</strong>的<strong>容器</strong>，保证多个数据的<strong>数据类型一致</strong>。</p>
<h2 id="3、数组的三种定义"><a href="#3、数组的三种定义" class="headerlink" title="3、数组的三种定义"></a>3、数组的三种定义</h2><p>下面主要讲解下数组的三种定义方式。</p>
<h3 id="定义方式一"><a href="#定义方式一" class="headerlink" title="定义方式一"></a>定义方式一</h3><blockquote>
<p><code>数据类型[] 数组名字 = new 数据类型 [长度]</code> ;</p>
</blockquote>
<p>举例： 定义可以存储3个整数的数组容器，代码如： <code>int[] arr = new int[3]</code></p>
<h3 id="定义方式二"><a href="#定义方式二" class="headerlink" title="定义方式二"></a>定义方式二</h3><blockquote>
<p><code>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3...}</code>;</p>
</blockquote>
<p>举例： 定义存储1，2，3，4，5整数的数组容器。 <code>int[] arr = new int[]{1,2,3,4,5}</code>;</p>
<h3 id="定义方式三"><a href="#定义方式三" class="headerlink" title="定义方式三"></a>定义方式三</h3><blockquote>
<p><code>数据类型[] 数组名 = {元素1,元素2,元素3...};</code></p>
</blockquote>
<p>举例： 定义存储1，2，3，4，5整数的数组容器 <code>int[] arr = {1,2,3,4,5}</code>;</p>
<h2 id="4、数组的访问"><a href="#4、数组的访问" class="headerlink" title="4、数组的访问"></a>4、数组的访问</h2><p><strong>索引</strong>：从<code>0</code>开始，索引 (<code>index</code>)可以访问到数组中的元素。</p>
<p><strong>格式</strong>： <code>数组名[索引]</code></p>
<p><strong>数组长度属性</strong>： 数组长度是固定的，由于索引从0开始，所以数组的最大索引值为<code>数组名.length-1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="comment">//打印数组的属性，输出结果是5 </span></span><br><span class="line">System.out.println(arr.length); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、什么是内存"><a href="#5、什么是内存" class="headerlink" title="5、什么是内存"></a>5、什么是内存</h2><blockquote>
<p>在讲数组的原理内存前，必须了解的一个叫内存的概念。</p>
</blockquote>
<p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程 序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。 Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p>
<h3 id="5-1-Java虚拟机的内存划分"><a href="#5-1-Java虚拟机的内存划分" class="headerlink" title="5.1 Java虚拟机的内存划分"></a>5.1 Java虚拟机的内存划分</h3><p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。<br> <img src="https://upload-images.jianshu.io/upload_images/1940331-210e2332016efef9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java虚拟机的内存划分"></p>
<h3 id="5-2-数组在内存中的存储"><a href="#5-2-数组在内存中的存储" class="headerlink" title="5.2 数组在内存中的存储"></a>5.2 数组在内存中的存储</h3><h4 id="5-2-1-一个数组内存图"><a href="#5-2-1-一个数组内存图" class="headerlink" title="5.2.1 一个数组内存图"></a>5.2.1 一个数组内存图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">    System.out.println(arr);<span class="comment">//[I@5f150435 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上方法执行，输出的结果是<code>[I@5f150435</code>，这个是什么呢？是数组在内存中的地址。<code>new</code>出来的内容，都是在堆内存中存储的，而方法中的变量<code>arr</code>保存的是数组的地址。</p>
<p>输出<code>arr[0]</code>，就会输出arr保存的内存地址中数组中0索引上的元素，如没有具体确定值，则是类型的默认值！比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr=<span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">  System.out.println(arr);     <span class="comment">//  [Ljava.lang.String;@1b6d3586</span></span><br><span class="line">  System.out.println(arr[<span class="number">0</span>]);  <span class="comment">//  null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arrInt=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">  System.out.println(arrInt);    <span class="comment">// [I@1b6d3586</span></span><br><span class="line">  System.out.println(arrInt[<span class="number">0</span>]); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-28da6c1f89b1227e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组内存图"></p>
<h6 id="5-2-2-两个数组内存图"><a href="#5-2-2-两个数组内存图" class="headerlink" title="5.2.2 两个数组内存图"></a>5.2.2 两个数组内存图</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">    <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; </span><br><span class="line">    System.out.println(arr); </span><br><span class="line">    System.out.println(arr2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-93464f888eec949f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个数组内存图"></p>
<h6 id="5-2-3-两个变量指向一个数组"><a href="#5-2-3-两个变量指向一个数组" class="headerlink" title="5.2.3 两个变量指向一个数组"></a>5.2.3 两个变量指向一个数组</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 定义数组，存储3个元素 </span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">    <span class="comment">//数组索引进行赋值 </span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">5</span>; </span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">6</span>; </span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">7</span>; </span><br><span class="line">    <span class="comment">//输出3个索引上的元素值 </span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]); </span><br><span class="line">    <span class="comment">//定义数组变量arr2，将arr的地址赋值给arr2 </span></span><br><span class="line">    <span class="keyword">int</span>[] arr2 = arr; </span><br><span class="line">    arr2[<span class="number">1</span>] = <span class="number">9</span>; </span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-42b2add666df2164?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个变量指向一个数组"></p>
<h2 id="6、数组常见的异常"><a href="#6、数组常见的异常" class="headerlink" title="6、数组常见的异常"></a>6、数组常见的异常</h2><p>数组常见的异常主要有<code>数组越界异常</code>以及<code>空指针异常</code>，这是非常基础的，就不多做介绍了，这里主要分析下空指针异常在内存的情况<br> <img src="https://upload-images.jianshu.io/upload_images/1940331-e3c2b44c058df851?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组常见的异常"></p>
<h2 id="7、-数组遍历【重点】"><a href="#7、-数组遍历【重点】" class="headerlink" title="7、 数组遍历【重点】"></a>7、 数组遍历【重点】</h2><p>所谓数组遍历 就是将数组中的每个元素分别获取出来，就是遍历。遍历数组<strong>非常重要</strong>！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">4</span>]); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，我把这种方式叫做傻瓜式遍历，这种傻瓜式写法肯定不行，因此我们需要改 造成循环的写法。数组的索引是 <code>0</code> 到 <code>lenght-1</code> ，可以作为循环的条件出现。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i])</span><br><span class="line">       &#125; </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、数组获取最大值元素"><a href="#8、数组获取最大值元素" class="headerlink" title="8、数组获取最大值元素"></a>8、数组获取最大值元素</h2><blockquote>
<p>实现思路： 定义变量，保存数组0索引上的元素 遍历数组，获取出数组中的每个元素 将遍历到的元素和保存数组0索引上值的变量进行比较 如果数组元素的值大于了变量的值，变量记录住新的值 数组循环遍历结束，变量保存的就是数组中的最大值</p>
</blockquote>
<p><strong>真香警告</strong>：<strong>大家小心点，别被第一个和第二个婆娘给迷住了</strong> </p>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-1643dd7d135be094?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组获取最大值元素"></p>
<p> 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">15</span>, <span class="number">2000</span>, <span class="number">10000</span>, <span class="number">100</span>, <span class="number">4000</span> &#125;; </span><br><span class="line">    <span class="comment">//定义变量，保存数组中0索引的元素 </span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>]; </span><br><span class="line">    <span class="comment">//遍历数组，取出每个元素 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; </span><br><span class="line">    <span class="comment">//遍历到的元素和变量max比较 </span></span><br><span class="line">    <span class="comment">//如果数组元素大于max </span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; max) &#123; </span><br><span class="line">    <span class="comment">//max记录住大值 </span></span><br><span class="line">    max = arr[i]; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">System.out.println(<span class="string">"数组最大值是： "</span> + max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、-数组反转"><a href="#9、-数组反转" class="headerlink" title="9、 数组反转"></a>9、 数组反转</h2><p>所谓反转就是把数组元素位置颠倒过来</p>
<blockquote>
<p>实现思想：数组最远端的元素互换位置 实现反转，就需要将数组最远端元素位置交换 定义两个变量，保存数组的最小索引和最大索引 两个索引上的元素交换位置 最小索引++，最大索引—，再次交换位置 最小索引超过了最大索引，数组反转操作结束</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-ee48a8c6c306d894?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组反转"></p>
<p>具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </span><br><span class="line">    <span class="comment">/*循环中定义变量min=0最小索引 </span></span><br><span class="line"><span class="comment">    max=arr.length‐1最大索引 </span></span><br><span class="line"><span class="comment">    min++,max‐‐ */</span> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> min = <span class="number">0</span>, max = arr.length ‐ <span class="number">1</span>; min &lt;= max; min++, max‐‐)&#123;</span><br><span class="line">    <span class="comment">//利用第三方变量完成数组中的元素交换 </span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[min]; </span><br><span class="line">    arr[min] = arr[max]; </span><br><span class="line">    arr[max] = temp;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 反转后，遍历数组 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">     System.out.println(arr[i])</span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="10、数组作为方法参数和返回值"><a href="#10、数组作为方法参数和返回值" class="headerlink" title="10、数组作为方法参数和返回值"></a>10、数组作为方法参数和返回值</h2><p>首先明确一点：数组作为方法的返回值，返回的是数组的内存地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//调用方法，接收数组的返回值 </span></span><br><span class="line">     <span class="comment">//接收到的是数组的内存地址 </span></span><br><span class="line">     <span class="keyword">int</span>[] arr = getArray(); </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; </span><br><span class="line">     System.out.println(arr[i])</span><br><span class="line">        &#125; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 创建方法，返回值是数组类型创建方法，返回值是数组类型 </span></span><br><span class="line"><span class="comment">     return返回数组的地址 */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getArray() &#123; </span><br><span class="line">     <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">      <span class="comment">//返回数组的地址，返回到调用者</span></span><br><span class="line">     <span class="keyword">return</span> arr; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1940331-a80fb17676058804?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法栈、堆"></p>
<h2 id="11、方法的参数类型区别"><a href="#11、方法的参数类型区别" class="headerlink" title="11、方法的参数类型区别"></a>11、方法的参数类型区别</h2><blockquote>
<p><strong>方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.</strong></p>
</blockquote>
<p>分析下列程序代码，计算输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; <span class="keyword">int</span> b = <span class="number">2</span>; </span><br><span class="line">    System.out.println(a); </span><br><span class="line">    System.out.println(b); </span><br><span class="line">    change(a, b); </span><br><span class="line">    System.out.println(a); </span><br><span class="line">    System.out.println(b); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">    a = a + b; b = b + a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析下列程序代码，计算输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; </span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">    change(arr); </span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">200</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结: 方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.</p>
</blockquote>
<p>相信各位已经将上面的代码 copy 到 eclipse 或者 idea 中运行了，是不是结果很意外？而且对总结不是很理解？这位童靴，我估计你可能是忽略了这一点：数组是引用类型，数组本身元素类型没有影响的，就像数组元素全是int，数组依旧是引用类型！</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Generator 基础指南</title>
    <url>/2017/09/19/2017-09-19-Programing-JavaScript-ES6-Generator-Guide/</url>
    <content><![CDATA[<h3 id="ES6-Generator-基础指南"><a href="#ES6-Generator-基础指南" class="headerlink" title="ES6 Generator 基础指南"></a>ES6 Generator 基础指南</h3><blockquote>
<p>本文翻译自：<a href="https://davidwalsh.name/es6-generators" target="_blank" rel="noopener">The Basics Of ES6 Generators</a></p>
<p>由于个人能力有限，翻译中难免有纰漏和错误，望不吝指正</p>
</blockquote>
<p>JavaScript ES6(译者注：ECMAScript 2015)中最令人兴奋的特性之一莫过于<strong>Generator</strong>函数，它是一种全新的函数类型。它的名字有些奇怪，初见其功能时甚至更会有些陌生。本篇文章旨在解释其基本工作原理，并帮助你理解为什么 Generator 将在未来 JS 中发挥强大作用。</p>
<h4 id="Generator-从运行到完成的工作方式"><a href="#Generator-从运行到完成的工作方式" class="headerlink" title="Generator 从运行到完成的工作方式"></a>Generator 从运行到完成的工作方式</h4><p>但我们谈论 Generator 函数时，我们首先应该注意到的是，从“运行到完成”其和普通的函数表现有什么不同之处。</p>
<p>不论你是否已经意识到，你已经潜意识得认为函数具有一些非常基础的特性：函数一旦开始执行，那么在其结束之前，不会执行其他 JavaScript 代码。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> don't ever do crazy long-running loops like this</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">1e10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 0..1E10</span></span><br><span class="line"><span class="comment">// "Hello World"</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>for</code>循环会执行相当长的时间，长于 1 秒钟，但是在<code>foo()</code>函数执行的过程中，我们带有<code>console.log(...)</code>的定时器并不能够中断<code>foo()</code>函数的运行。因此代码被阻塞，定时器被推入事件循环的最后，耐心等待<code>foo</code>函数执行完成。</p>
<p>倘若<code>foo()</code>可以被中断执行？它不会给我们的带来前所未有的浩劫吗？</p>
<a id="more"></a>
<p>函数可以被中断对于多线程编程来说确实是一个挑战，但是值得庆幸的是，在 JavaScript 的世界中我们没必要为此而担心，因为 JS 总是单线程的（在任何时间只有一条命令/函数被执行）。</p>
<p><strong>注意：</strong> Web Workers 是 JavaScript 中实现与 JS 主线程分离的独立线程机制，总的说来，Web Workers 是与 JS 主线程平行的另外一个线程。在这儿我们并不介绍多线程并发的一个原因是，主线程和 Web Workers 线程只能够通过异步事件进行通信，因此每个线程内部从运行到结束依然遵循一个接一个的事件循环机制。</p>
<h4 id="运行-停止-运行"><a href="#运行-停止-运行" class="headerlink" title="运行-停止-运行"></a>运行-停止-运行</h4><p>由于 ES6Generators 的到来，我们拥有了另外一种类型的函数，这种函数可以在执行的过程中暂停一次或多次，在将来的某个时间继续执行，并且允许在 Generator 函数暂停的过程中运行其他代码。</p>
<p>如果你曾经阅读过关于并发或者多线程编程的资料，那你一定熟悉“协程”这一概念，“协程”的意思就是一个进程（就是一个函数）其可以自行选择终止运行，以便可以和其他代码<strong>“协作”</strong>完成一些功能。这一概念和“preemptive”相对，preemptive 认为可以在进程/函数外部对其终止运行。</p>
<p>根据 ES6 Generator 函数的并发行为，我们可以认为其是一种“协程”。在 Generator 函数体内部，你可以使用<code>yield</code>关键字在函数内部暂停函数的执行，在 Generator 函数外部是无法暂停一个 Generator 函数执行的；每当 Generator 函数遇到一个<code>yield</code>关键字就将暂停执行。</p>
<p>然后，一旦一个 Generator 函数通过<code>yield</code>暂停执行，其不能够自行恢复执行，需要通过外部的控制来重新启动 generator 函数，我们将在文章后面部分介绍这是怎么发生的。</p>
<p>基本上，只要你愿意，一个 Generator 函数可以暂停执行/重新启动任意多次。实际上，你可以再 Generator 函数内部使用无限循环（比如非著名的<code>while (true) { .. }</code>）来使得函数可以无尽的暂停/重新启动。然后这在普通的 JS 程序中却是疯狂的行径，甚至会抛出错误。但是 Generator 函数却能够表现的非常明智，有些时候你确实想利用 Generator 函数这种无尽机制。</p>
<p>更为重要的是，暂停/重新启动不仅仅用于控制 Generator 函数执行，它也可以在 generator 函数内部和外部进行双向的通信。在普通的 JavaScript 函数中，你可以通过传参的形式将数据传入函数内容，在函数内部通过<code>return</code>语句将函数的返回值传递到函数外部。在 generator 函数中，我们通过<code>yield</code>表达式将信息传递到外部，然后通过每次重启 generator 函数将其他信息传递给 generator。</p>
<h4 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h4><p>然我们看看新奇并且令人兴奋的 generator 函数的语法是怎样书写的。</p>
<p>首先，新的函数声明语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现<code>*</code>符号没？显得有些陌生且有些奇怪。对于从其他语言转向 JavaScript 的人来说，它看起来很像函数返回值指针。但是不要被迷惑到了，<code>*</code>只是用于标识 generator 函数而已。</p>
<p>你可能会在其他的文章/文档中看到如下形式书写 generator 函数<code>function* foo(){}</code>，而不是这样<code>function *foo() {}</code>(<code>*</code>号的位置有所不同)。其实两种形式都是合法的，但是最近我认为后面一种形式更为准确，因此在本篇文章中都是使用后面一种形式。</p>
<p>现在，让我们来讨论下 generator 函数的内部构成吧。在很多方面，generator 函数和普通函数无异，只有在 generator 函数内部有一些新的语法。</p>
<p>正如上面已经提及，我们最先需要了解的就是<code>yield</code>关键字，<code>yield__</code>被视为“yield 表达式”（并不是一条语句），因为当我们重新启动 generator 函数的时候，我们可以传递信息到 generator 函数内部，不论我们传递什么进去，都将被视为<code>yield__</code>表达式的运行结果。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> <span class="string">"foo"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>yield &quot;foo&quot;</code>表达式会在 generator 函数暂停时把“foo”字符串传递到外部。同时，当 generator 函数恢复执行的时候，其他的值又会通过其他表达式传入到函数里面作为<code>yield</code>表达式的返回值加<code>1</code>最后再将结果赋值给<code>x</code>变量。</p>
<p>看到 generator 函数的双向通信了吗？generator 函数将‘’foo‘’字符串传递到外部，暂停函数执行，在将来的某个时间点（可能是立即也可能是很长一段时间后），generator 会被重启，并且会传递一个值给 generator 函数，就好像<code>yield</code>关键字就是某种发送请求获取值的请求形式。</p>
<p>在任意表达式中，你可以仅使用<code>yield</code>关键字，后面不跟任何表达式或值。在这种情况下，就相当于将<code>undefined</code>通过<code>yield</code>传递出去。如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// note: `foo(..)` here is NOT a generator!!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"x: "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>; <span class="comment">// just pause</span></span><br><span class="line">  foo(<span class="keyword">yield</span>); <span class="comment">// pause waiting for a parameter to pass into `foo(..)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Generator-迭代器"><a href="#Generator-迭代器" class="headerlink" title="Generator 迭代器"></a>Generator 迭代器</h4><p>“Generator 迭代器”，是不是相当晦涩难懂？</p>
<p>迭代器是一种特殊的行为，准确说是一种设计模式，当我们通过调用<code>next()</code>方法去遍历一组值的集合时，例如，我们通过在长度为 5 的数组<code>[1, 2, 3, 4, 5]</code>上面实现了迭代器。当我们第一次调用<code>next()</code>的时候，会返回<code>1</code>。第二次调用<code>next()</code>返回<code>2</code>,如此下去，当所有的值都返回后，再次调用<code>next()</code>将返回<code>null</code>或者<code>false</code>或其他值，这意味着你已经遍历完真个数组中的值了。</p>
<p>我们是通过和 generator 迭代器进行交互来在 generator 函数外部控制 generator 函数，这听起来比起实际上有些复杂，考虑下面这个愚蠢的（简单的）例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了遍历<code>*foo()</code>generator 函数中的所有值，我们首先需要构建一个迭代器，我们怎么去构建这个迭代器呢？非常简单！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = foo();</span><br></pre></td></tr></table></figure>
<p>如此之简单，我们仅仅想执行普通函数一样执行 generator 函数，其将返回一个迭代器，但是 generator 函数中的代码并不会运行。</p>
<p>这似乎有些奇怪，并且增加了你的理解难度。你甚至会停下来思考，问为什么不通过<code>var it = new foo()</code>的形式来执行 generator 函数呢，这语法后面的原因可能相当复杂并超出了我们的讨论范畴。</p>
<p>好的，现在让我们开始迭代我们的 generator 函数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = it.next();</span><br></pre></td></tr></table></figure>
<p>通过上面的语句，<code>yield</code>表达式将 1 返回到函数外部，但是返回的值可能比想象中会多一些。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>在每一调用<code>next()</code>后，我们实际上从<code>yield</code>表达式的返回值中获取到了一个对象，这个对象中有<code>value</code>字段，就是<code>yield</code>返回的值，同时还有一个布尔类型的<code>done</code>字段，其用来表示 generator 函数是否已经执行完毕。</p>
<p>然我们把迭代执行完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:4, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:5, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>有趣的是，当我们获取到值为<code>5</code>的时候，<code>done</code>字段依然是<code>false</code>。这因为，实际上 generator 函数还么有执行完全，我们还可以再次调用<code>next()</code>。如果我们向函数内部传递一个值，其将被设置为<code>yield 5</code>表达式的返回值，只有在这<strong>时候</strong>，generator 函数才执行完全。</p>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>所以最终结果是，我们迭代执行完我们的 generator 函数，但是最终却没有结果（由于我们已经执行完所有的<code>yield__</code>表达式）。</p>
<p>你可能会想，我能不能在 generator 函数中使用<code>return</code>语句，如果我这样这，返回值会不会在最终的<code>value</code>字段里面呢？</p>
<p><strong>是</strong>…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:2, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>… <strong>不是.</strong></p>
<p>依赖于 generator 函数的最终返回值也许并不是一个最佳实践，因为当我们通过<code>for--of</code>循环来迭代 generator 函数的时候（如下），最终<code>return</code>的返回值将被丢弃（无视）。</p>
<p>为了完整，让我们来看一个同时有双向数据通信的 generator 函数的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> y / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// note: not sending anything into `next()` here</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)); <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)); <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>你可以看到，我们依然可以通过<code>foo(5)</code>传递参数（在例子中是<code>x</code>）给 generator 函数，就像普通函数一样，是的参数<code>x</code>为<code>5</code>.</p>
<p>在第一次执行<code>next(..)</code>的时候，我们并没有传递任何值，为什么？因为在 generator 内部并没有<code>yield</code>表达式来接收我们传递的值。</p>
<p>假如我们真的在第一次调用<code>next(..)</code>的时候传递了值进去，也不会带来什么坏处，它只是将这个传入的值抛弃而已。ES6 表明，generator 函数在这种情况只是忽略了这些没有被用到的值。（<strong>注意</strong>：在写这篇文章的时候，Chrome 和 FF 的每夜版支持这一特性，但是其他浏览有可能没有完全支持这一特性甚至可能会抛出错误）（译者注：文章发布于 2014 年）</p>
<p><code>yield(x + 1)</code>表达式将传递值<code>6</code>到外部，在第二次调用<code>next(12)</code>时候，传递<code>12</code>到 generator 函数内部作为<code>yield(x + 1)</code>表达式的值，因此<code>y</code>被赋值为<code>12 * 2</code>，值为<code>24</code>。接下来，下一条<code>yield(y / 3)</code>(<code>yield (24 / 3)</code>)将向外传递值<code>8</code>。第三次调用<code>next(13)</code>传递<code>13</code>到 generator 函数内部，给<code>yield(y / 3)</code>。是的<code>z</code>被设置为<code>13</code>.</p>
<p>最后，<code>return (x + y + z)</code>就是<code>return (5 + 24 + 13)</code>，也就是<code>42</code>将会作为最终的值返回出去。</p>
<p><strong>重新阅读几遍上面的实例</strong>。最开始有些难以理解。</p>
<h4 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for..of循环"></a><code>for..of</code>循环</h4><p>ES6 在语法层面上大力拥抱迭代器模式，提供了<code>for..of</code>循环来直接支持迭代器的遍历。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(v); <span class="comment">// still `5`, not `6` :(</span></span><br></pre></td></tr></table></figure>
<p>正如你所见，通过调用<code>foo()</code>生成的迭代器通过<code>for..of</code>循环来迭代，循环自动帮你对迭代器进行遍历迭代，每次迭代返回一个值，直到<code>done: true</code>，只要<code>done: false</code>，每次循环都将从<code>value</code>属性上获取到值赋值给迭代的变量（例子中的<code>v</code>）。一旦当<code>done</code>为<code>true</code>。循环迭代结束。（<code>for..of</code>循环不会对 generator 函数最终的 return 值进行处理）</p>
<p>正如你所看到的，<code>for..of</code>循环忽略了 generator 最后的<code>return 6</code>的值，同时，循环没有暴露<code>next()</code>出来，因此我们也不能够向 generator 函数内传递数据。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>OK,上面是关于 generator 函数的基本用法，如果你依然对 generator 函数感到费解，不要担心，我们所有人在一开始感觉都是那样的。</p>
<p>我们很自然的想到这一外来的语法对我们实际代码有什么作用呢？generator 函数有很多作用，我们只是挖掘了其非常粗浅的一部分。在我们发现 generator 函数如此强大之前我们应该更加深入的了解它。</p>
<p>在你练习上面代码片段之后（在 Chrome 或者 FF 每夜版本，或者 0.11+带有<code>--harmony</code>的 node 环境下），下面的问题也许会浮出水面：（译者注：现代浏览器最新版本都已支持 Generator 函数）</p>
<ol>
<li>怎样处理 generator 内部错误？</li>
<li>在 generator 函数内部怎么调用其他 generator 函数？</li>
<li>异步代码怎么和 generator 函数协同工作？</li>
</ol>
<p>这些问题，或者其他的问题都将在随后的文章中覆盖，敬请期待。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Generator 基础指南</title>
    <url>/2017/09/17/2017-09-17-Programing-JavaScript-Generator-intro/</url>
    <content><![CDATA[<h3 id="ES6-Generator-基础指南"><a href="#ES6-Generator-基础指南" class="headerlink" title="ES6 Generator 基础指南"></a>ES6 Generator 基础指南</h3><blockquote>
<p>本文翻译自：<a href="https://davidwalsh.name/es6-generators" target="_blank" rel="noopener">The Basics Of ES6 Generators</a></p>
</blockquote>
<p>JavaScript ES6(译者注：ECMAScript 2015)中最令人兴奋的特性之一莫过于<strong>Generator</strong>函数，它是一种全新的函数类型。它的名字有些奇怪，初见其功能时甚至更会有些陌生。本篇文章旨在解释其基本工作原理，并帮助你理解为什么 Generator 将在未来 JS 中发挥强大作用。</p>
<h4 id="Generator-从运行到完成的工作方式"><a href="#Generator-从运行到完成的工作方式" class="headerlink" title="Generator 从运行到完成的工作方式"></a>Generator 从运行到完成的工作方式</h4><p>但我们谈论 Generator 函数时，我们首先应该注意到的是，从“运行到完成”其和普通的函数表现有什么不同之处。</p>
<p>不论你是否已经意识到，你已经潜意识得认为函数具有一些非常基础的特性：函数一旦开始执行，那么在其结束之前，不会执行其他 JavaScript 代码。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> don't ever do crazy long-running loops like this</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">1e10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 0..1E10</span></span><br><span class="line"><span class="comment">// "Hello World"</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>for</code>循环会执行相当长的时间，长于 1 秒钟，但是在<code>foo()</code>函数执行的过程中，我们带有<code>console.log(...)</code>的定时器并不能够中断<code>foo()</code>函数的运行。因此代码被阻塞，定时器被推入事件循环的最后，耐心等待<code>foo</code>函数执行完成。</p>
<p>倘若<code>foo()</code>可以被中断执行？它不会给我们的带来前所未有的浩劫吗？</p>
<p>函数可以被中断对于多线程编程来说确实是一个挑战，但是值得庆幸的是，在 JavaScript 的世界中我们没必要为此而担心，因为 JS 总是单线程的（在任何时间只有一条命令/函数被执行）。</p>
<p><strong>注意：</strong> Web Workers 是 JavaScript 中实现与 JS 主线程分离的独立线程机制，总的说来，Web Workers 是与 JS 主线程平行的另外一个线程。在这儿我们并不介绍多线程并发的一个原因是，主线程和 Web Workers 线程只能够通过异步事件进行通信，因此每个线程内部从运行到结束依然遵循一个接一个的事件循环机制。</p>
<p>&lt;!&gt;</p>
<h4 id="运行-停止-运行"><a href="#运行-停止-运行" class="headerlink" title="运行-停止-运行"></a>运行-停止-运行</h4><p>由于 ES6Generators 的到来，我们拥有了另外一种类型的函数，这种函数可以在执行的过程中暂停一次或多次，在将来的某个时间继续执行，并且允许在 Generator 函数暂停的过程中运行其他代码。</p>
<p>如果你曾经阅读过关于并发或者多线程编程的资料，那你一定熟悉“协程”这一概念，“协程”的意思就是一个进程（就是一个函数）其可以自行选择终止运行，以便可以和其他代码<strong>“协作”</strong>完成一些功能。这一概念和“preemptive”相对，preemptive 认为可以在进程/函数外部对其终止运行。</p>
<p>根据 ES6 Generator 函数的并发行为，我们可以认为其是一种“协程”。在 Generator 函数体内部，你可以使用<code>yield</code>关键字在函数内部暂停函数的执行，在 Generator 函数外部是无法暂停一个 Generator 函数执行的；每当 Generator 函数遇到一个<code>yield</code>关键字就将暂停执行。</p>
<p>然后，一旦一个 Generator 函数通过<code>yield</code>暂停执行，其不能够自行恢复执行，需要通过外部的控制来重新启动 generator 函数，我们将在文章后面部分介绍这是怎么发生的。</p>
<p>基本上，只要你愿意，一个 Generator 函数可以暂停执行/重新启动任意多次。实际上，你可以再 Generator 函数内部使用无限循环（比如非著名的<code>while (true) { .. }</code>）来使得函数可以无尽的暂停/重新启动。然后这在普通的 JS 程序中却是疯狂的行径，甚至会抛出错误。但是 Generator 函数却能够表现的非常明智，有些时候你确实想利用 Generator 函数这种无尽机制。</p>
<p>更为重要的是，暂停/重新启动不仅仅用于控制 Generator 函数执行，它也可以在 generator 函数内部和外部进行双向的通信。在普通的 JavaScript 函数中，你可以通过传参的形式将数据传入函数内容，在函数内部通过<code>return</code>语句将函数的返回值传递到函数外部。在 generator 函数中，我们通过<code>yield</code>表达式将信息传递到外部，然后通过每次重启 generator 函数将其他信息传递给 generator。</p>
<h4 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h4><p>然我们看看新奇并且令人兴奋的 generator 函数的语法是怎样书写的。</p>
<p>首先，新的函数声明语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现<code>*</code>符号没？显得有些陌生且有些奇怪。对于从其他语言转向 JavaScript 的人来说，它看起来很像函数返回值指针。但是不要被迷惑到了，<code>*</code>只是用于标识 generator 函数而已。</p>
<p>你可能会在其他的文章/文档中看到如下形式书写 generator 函数<code>function* foo(){}</code>，而不是这样<code>function *foo() {}</code>(<code>*</code>号的位置有所不同)。其实两种形式都是合法的，但是最近我认为后面一种形式更为准确，因此在本篇文章中都是使用后面一种形式。</p>
<p>现在，让我们来讨论下 generator 函数的内部构成吧。在很多方面，generator 函数和普通函数无异，只有在 generator 函数内部有一些新的语法。</p>
<p>正如上面已经提及，我们最先需要了解的就是<code>yield</code>关键字，<code>yield__</code>被视为“yield 表达式”（并不是一条语句），因为当我们重新启动 generator 函数的时候，我们可以传递信息到 generator 函数内部，不论我们传递什么进去，都将被视为<code>yield__</code>表达式的运行结果。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> <span class="string">"foo"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>yield &quot;foo&quot;</code>表达式会在 generator 函数暂停时把“foo”字符串传递到外部。同时，当 generator 函数恢复执行的时候，其他的值又会通过其他表达式传入到函数里面作为<code>yield</code>表达式的返回值加<code>1</code>最后再将结果赋值给<code>x</code>变量。</p>
<p>看到 generator 函数的双向通信了吗？generator 函数将‘’foo‘’字符串传递到外部，暂停函数执行，在将来的某个时间点（可能是立即也可能是很长一段时间后），generator 会被重启，并且会传递一个值给 generator 函数，就好像<code>yield</code>关键字就是某种发送请求获取值的请求形式。</p>
<p>在任意表达式中，你可以仅使用<code>yield</code>关键字，后面不跟任何表达式或值。在这种情况下，就相当于将<code>undefined</code>通过<code>yield</code>传递出去。如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// note: `foo(..)` here is NOT a generator!!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"x: "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>; <span class="comment">// just pause</span></span><br><span class="line">  foo(<span class="keyword">yield</span>); <span class="comment">// pause waiting for a parameter to pass into `foo(..)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Generator-迭代器"><a href="#Generator-迭代器" class="headerlink" title="Generator 迭代器"></a>Generator 迭代器</h4><p>“Generator 迭代器”，是不是相当晦涩难懂？</p>
<p>迭代器是一种特殊的行为，准确说是一种设计模式，当我们通过调用<code>next()</code>方法去遍历一组值的集合时，例如，我们通过在长度为 5 的数组<code>[1, 2, 3, 4, 5]</code>上面实现了迭代器。当我们第一次调用<code>next()</code>的时候，会返回<code>1</code>。第二次调用<code>next()</code>返回<code>2</code>,如此下去，当所有的值都返回后，再次调用<code>next()</code>将返回<code>null</code>或者<code>false</code>或其他值，这意味着你已经遍历完真个数组中的值了。</p>
<p>我们是通过和 generator 迭代器进行交互来在 generator 函数外部控制 generator 函数，这听起来比起实际上有些复杂，考虑下面这个愚蠢的（简单的）例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了遍历<code>*foo()</code>generator 函数中的所有值，我们首先需要构建一个迭代器，我们怎么去构建这个迭代器呢？非常简单！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = foo();</span><br></pre></td></tr></table></figure>
<p>如此之简单，我们仅仅想执行普通函数一样执行 generator 函数，其将返回一个迭代器，但是 generator 函数中的代码并不会运行。</p>
<p>这似乎有些奇怪，并且增加了你的理解难度。你甚至会停下来思考，问为什么不通过<code>var it = new foo()</code>的形式来执行 generator 函数呢，这语法后面的原因可能相当复杂并超出了我们的讨论范畴。</p>
<p>好的，现在让我们开始迭代我们的 generator 函数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = it.next();</span><br></pre></td></tr></table></figure>
<p>通过上面的语句，<code>yield</code>表达式将 1 返回到函数外部，但是返回的值可能比想象中会多一些。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>在每一调用<code>next()</code>后，我们实际上从<code>yield</code>表达式的返回值中获取到了一个对象，这个对象中有<code>value</code>字段，就是<code>yield</code>返回的值，同时还有一个布尔类型的<code>done</code>字段，其用来表示 generator 函数是否已经执行完毕。</p>
<p>然我们把迭代执行完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:4, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:5, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>有趣的是，当我们获取到值为<code>5</code>的时候，<code>done</code>字段依然是<code>false</code>。这因为，实际上 generator 函数还么有执行完全，我们还可以再次调用<code>next()</code>。如果我们向函数内部传递一个值，其将被设置为<code>yield 5</code>表达式的返回值，只有在这<strong>时候</strong>，generator 函数才执行完全。</p>
<p>代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>所以最终结果是，我们迭代执行完我们的 generator 函数，但是最终却没有结果（由于我们已经执行完所有的<code>yield__</code>表达式）。</p>
<p>你可能会想，我能不能在 generator 函数中使用<code>return</code>语句，如果我这样这，返回值会不会在最终的<code>value</code>字段里面呢？</p>
<p><strong>是</strong>…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:2, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>… <strong>不是.</strong></p>
<p>依赖于 generator 函数的最终返回值也许并不是一个最佳实践，因为当我们通过<code>for--of</code>循环来迭代 generator 函数的时候（如下），最终<code>return</code>的返回值将被丢弃（无视）。</p>
<p>为了完整，让我们来看一个同时有双向数据通信的 generator 函数的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> y / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// note: not sending anything into `next()` here</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)); <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)); <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>你可以看到，我们依然可以通过<code>foo(5)</code>传递参数（在例子中是<code>x</code>）给 generator 函数，就像普通函数一样，是的参数<code>x</code>为<code>5</code>.</p>
<p>在第一次执行<code>next(..)</code>的时候，我们并没有传递任何值，为什么？因为在 generator 内部并没有<code>yield</code>表达式来接收我们传递的值。</p>
<p>假如我们真的在第一次调用<code>next(..)</code>的时候传递了值进去，也不会带来什么坏处，它只是将这个传入的值抛弃而已。ES6 表明，generator 函数在这种情况只是忽略了这些没有被用到的值。（<strong>注意</strong>：在写这篇文章的时候，Chrome 和 FF 的每夜版支持这一特性，但是其他浏览有可能没有完全支持这一特性甚至可能会抛出错误）（译者注：文章发布于 2014 年）</p>
<p><code>yield(x + 1)</code>表达式将传递值<code>6</code>到外部，在第二次调用<code>next(12)</code>时候，传递<code>12</code>到 generator 函数内部作为<code>yield(x + 1)</code>表达式的值，因此<code>y</code>被赋值为<code>12 * 2</code>，值为<code>24</code>。接下来，下一条<code>yield(y / 3)</code>(<code>yield (24 / 3)</code>)将向外传递值<code>8</code>。第三次调用<code>next(13)</code>传递<code>13</code>到 generator 函数内部，给<code>yield(y / 3)</code>。是的<code>z</code>被设置为<code>13</code>.</p>
<p>最后，<code>return (x + y + z)</code>就是<code>return (5 + 24 + 13)</code>，也就是<code>42</code>将会作为最终的值返回出去。</p>
<p><strong>重新阅读几遍上面的实例</strong>。最开始有些难以理解。</p>
<h4 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for..of循环"></a><code>for..of</code>循环</h4><p>ES6 在语法层面上大力拥抱迭代器模式，提供了<code>for..of</code>循环来直接支持迭代器的遍历。</p>
<p>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(v); <span class="comment">// still `5`, not `6` :(</span></span><br></pre></td></tr></table></figure>
<p>正如你所见，通过调用<code>foo()</code>生成的迭代器通过<code>for..of</code>循环来迭代，循环自动帮你对迭代器进行遍历迭代，每次迭代返回一个值，直到<code>done: true</code>，只要<code>done: false</code>，每次循环都将从<code>value</code>属性上获取到值赋值给迭代的变量（例子中的<code>v</code>）。一旦当<code>done</code>为<code>true</code>。循环迭代结束。（<code>for..of</code>循环不会对 generator 函数最终的 return 值进行处理）</p>
<p>正如你所看到的，<code>for..of</code>循环忽略了 generator 最后的<code>return 6</code>的值，同时，循环没有暴露<code>next()</code>出来，因此我们也不能够向 generator 函数内传递数据。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>OK,上面是关于 generator 函数的基本用法，如果你依然对 generator 函数感到费解，不要担心，我们所有人在一开始感觉都是那样的。</p>
<p>我们很自然的想到这一外来的语法对我们实际代码有什么作用呢？generator 函数有很多作用，我们只是挖掘了其非常粗浅的一部分。在我们发现 generator 函数如此强大之前我们应该更加深入的了解它。</p>
<p>在你练习上面代码片段之后（在 Chrome 或者 FF 每夜版本，或者 0.11+带有<code>--harmony</code>的 node 环境下），下面的问题也许会浮出水面：（译者注：现代浏览器最新版本都已支持 Generator 函数）</p>
<ol>
<li>怎样处理 generator 内部错误？</li>
<li>在 generator 函数内部怎么调用其他 generator 函数？</li>
<li>异步代码怎么和 generator 函数协同工作？</li>
</ol>
<p>这些问题，或者其他的问题都将在随后的文章中覆盖，敬请期待。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 TensorFlow 实现神经网络</title>
    <url>/2017/09/04/2017-09-04-Programing-AI-ML-use-TensorFlow-do-NN/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>　　一直关注 <code>数据科学</code> 、 <code>机器学习</code> 的同学，一定会经常看到或听到关于 <code>深度学习</code> 和 <code>神经网络</code> 相关信息。如果你对 <code>深度学习</code> 感兴趣，但却还没有实际动手操作过，你可以从这里得到实践。 </p>
<p>　　在本文中，我将介绍 <code>TensorFlow</code> , 帮你了解 <code>神经网络</code> 的实际作用，并使用 <code>TensorFlow</code> 来解决现实生活中的问题。 读这篇文章前，需要知道 <code>神经网络</code> 的基础知识和一些熟悉编程理念，文章中的代码是使用 <code>Pyhton</code> 编写的，所以还需要了解一些 <code>Python</code> 的基本语法，才能更有利对于文章的理解。                  </p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#When-to-apply-neural-net">什么时候应用神经网络？</a></li>
<li><a href="#solve-problems">通常神经网络能解决的问题</a></li>
<li><a href="#popular-libraries">了解图像数据和主流的库来解决问题</a></li>
<li><a href="#What-is-TensorFlow">什么是 TensorFlow？</a></li>
<li><a href="#A-typical-flow">TensorFlow 一个 典型 的 “ 流 ”</a></li>
<li><a href="#MLP">在 TensorFlow 中实现 MLP</a></li>
<li><a href="#Limitations-of-TensorFlow">TensorFlow 的限制</a></li>
<li><a href="#vs-libraries">TensorFlow 与其他库</a></li>
<li><a href="#Where-to-go-from-here">从这里去哪里？</a></li>
</ul>
<h3 id="什么时候用神经网络？"><a href="#什么时候用神经网络？" class="headerlink" title="什么时候用神经网络？"></a><a name="When-to-apply-neural-net"></a>什么时候用神经网络？</h3><p>　　<code>神经网络</code> 已经在相当一段时间成为机器学习中的焦点。 对于 <code>神经网络</code> 和 <code>深度学习</code> 上这里有更详细的解释 <a href="https://www.analyticsvidhya.com/blog/2016/08/evolution-core-concepts-deep-learning-neural-networks/" target="_blank" rel="noopener">点击阅读</a> 。 其 “更深” 的功能在许多领域都有取得巨大的突破，如图像识别，语音和自然语言处理等。</p>
<p>　　主要的问题在于如何用好 <code>神经网络</code> ？现在，每天都会有许多新发现，这个领域就像一个金矿，为了成为这个 “淘金热” 的一部分，必须记住几件事：</p>
<ul>
<li><p><strong>首先，<code>神经网络</code> 需要有明确和翔实的数据（主要是大数据）训练</strong>， 试着想象 <code>神经网络</code> 作为一个孩子，它一开始会观察它父母走路，然后它试图自己走，每一步就像学习执行一个特定的任务。 它可能会失败几次，但经过几次失败的尝试，它将会如何走路。所以需要为孩子提供更多的机会，如果不让它走，它可能永远不会学习如何走路。</p>
</li>
<li><p><strong>一些人会利用 <code>神经网络</code> 解决复杂的问题，如图像处理，</strong>  <code>神经网络</code> 属于一类代表学习的算法，这些算法可以把复杂的问题分解为简单的形式，使他们成为可以理解的（或 “可表示”），就像吞咽食物之前的咀嚼，让我们更容易吸收和消化。这个分解的过程如果使用传统的算法来实现也可以，但是实现过程将会很困难。</p>
</li>
<li><p><strong>选择适当类型的 <code>神经网络</code> ，来解决问题，</strong>  每个问题的复杂情况都不一样，所以数据决定你解决问题的方式。 例如，如果问题是序列生成的问题，<code>递归神经网络</code> 更合适。如果它是图像相关的问题，想更好地解决可以采取 <code>卷积神经网络</code>。</p>
</li>
<li><p><strong>最后最重要的就是 <code>硬件</code> 要求了，硬件是运行 <code>神经网络</code> 模型的关键。</strong> 神经网被 “发现” 很久以前，他们在近年来得到推崇的主要的原因就是计算资源更好，能更大发挥它的光芒，如果你想使用 <code>神经网络</code> 解决这些现实生活中的问题，那么你得准备购买一些高端的硬件了😆！</p>
</li>
</ul>
<h3 id="通常神经网络解决的问题"><a href="#通常神经网络解决的问题" class="headerlink" title="通常神经网络解决的问题"></a><a name="solve-problems"></a>通常神经网络解决的问题</h3><p>　　神经网络是一种特殊类型的 机器学习（ML）算法。 因此，作为每个 ML 算法都遵循 数据预处理 、模型建立 和 模型评估 的工作流流程。为了简明起见，下面列出了如何处理 <code>神经网络</code> 问题的 TODO 列表。</p>
<ul>
<li>检查它是否为 神经网络 ，把它看成一个传统的算法问题</li>
<li>做一个调查，哪个 神经网络 框架最适合解决这个问题</li>
<li>定义 神经网络 框架，通过它选择对应的 编程语言 和 库</li>
<li>将数据转换为正确的格式并分批分割</li>
<li>根据您的需要预处理数据</li>
<li>增强数据以增加大小并制作更好的训练模型</li>
<li>批次供给到 神经网络</li>
<li>训练和监测，培训和验证数据集的变化</li>
<li>测试你的模型，并保存以备将来使用</li>
</ul>
<p>　　本文将专注于图像数据，我们从 TensorFlow 入手。</p>
<h3 id="了解图像数据和主流的库来解决问题"><a href="#了解图像数据和主流的库来解决问题" class="headerlink" title="了解图像数据和主流的库来解决问题"></a><a name="popular-libraries"></a>了解图像数据和主流的库来解决问题</h3><p>　　图像大多排列为 3-D 阵列，具体指 高度、宽度 和 颜色通道。例如，如果你使用电脑截屏，它将首先转换成一个 3-D 数组，然后压缩它为 ‘.jpeg’ 或 ‘.png’ 文件格式。</p>
<p>　　虽然这些图像对于人类来说很容易理解，但计算机很难理解它们。 这种现象称为“语义空隙”。我们的大脑可以看看图像，并在几秒钟内读懂完整的图片。但计算机会将图像看作一个数字数组，问题来了，它想知道这是一张什么样的图像，我们应该怎么样把图像解释给机器它才能读懂？</p>
<p>　　在早期，人们试图将图像分解为机器的 “可理解” 格式，如“模板”。例如，面部总是具有在每个人中有所保留的特定结构，例如眼睛，鼻子或我们的脸的形状。 但是这种方法将是有缺陷的，因为当要识别的对象的数量将增加到一定量级时，“模板” 将不成立。</p>
<p>　　2012年一个深层神经网络架构赢得了 ImageNet 的挑战，从自然场景中识别对象，它在即将到来的 ImageNet 挑战中继续统治其主权，从而证明了解决图像问题的有用性。<br>人们通常使用哪些 库 / 语言 来解决图像识别问题？</p>
<p>最流行的库举几个例子：</p>
<ul>
<li><a href="http://caffe.berkeleyvision.org/" target="_blank" rel="noopener">Caffe</a></li>
<li><a href="http://deeplearning4j.org/" target="_blank" rel="noopener">DeepLearning4j</a></li>
<li><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a></li>
<li><a href="http://www.deeplearning.net/software/theano" target="_blank" rel="noopener">Theano</a></li>
<li><a href="http://torch.ch/" target="_blank" rel="noopener">Torch</a></li>
</ul>
<p>现在，我们了解了图像的存储方式以及使用的常用库，让我们看看 <code>TensorFlow</code> 提供的功能。</p>
<h3 id="什么是-TensorFlow-？"><a href="#什么是-TensorFlow-？" class="headerlink" title="什么是 TensorFlow ？"></a><a name="What-is-TensorFlow"></a>什么是 TensorFlow ？</h3><p>让我们从官方定义开始.</p>
<p>　　“<code>TensorFlow</code> 是一个开源软件库，用于使用数据流图进行数值计算。图中的节点表示数学运算，而图边表示在它们之间传递的多维数据阵列（也称为张量）。 灵活的架构允许您使用单一 API 将计算部署到桌面、服务器或移动设备中的一个或多个的 CPU 或 GPU 中。</p>
<p><img src="http://www.tensorfly.cn/images/tensors_flowing.gif" alt>     </p>
<p>　　如果感觉这听起来太高大上，不要担心。这里有我简单的定义，<code>TensorFlow</code> 看起来没什么，只是 numpy 有些难以理解。如果你以前使用过 numpy ，理解 TensorFlow 将是手到擒来！ numpy 和 TensorFlow 之间的主要区别是 TensorFlow 遵循惰性编程范例。</p>
<p>TensorFlow 的操作基本上都是对 session 的操作，它首先构建一个所有操作的图形，当我们调用 session 时 TensorFlow 就开始工作了。它通过将内部数据表示转换为张量（Tensor，也称为多维数组）来构建为可扩展的。 构建计算图可以被认为是 TensorFlow 的主要成分。</p>
<p>　　通过上面的介绍，很容易将 TensorFlow 分类为神经网络库，但它不仅仅是如此。它被设计成一个强大的神经网络库， 但它有能力做更多的事情。可以构建它为其他机器学习算法，如 决策树 或 k-最近邻，你可以从字面上理解，你可以做一切你在 numpy 上能做的事情！我们暂且称它为 “全能的 numpy” 。</p>
<p><strong>使用 TensorFlow 的优点是：</strong></p>
<ul>
<li><strong>它有一个直观的结构</strong> ，顾名思义它有 “张量流”，你可以轻松地可视每个图中的每一个部分。</li>
<li><strong>轻松地在 cpu / gpu 上进行分布式计算</strong> </li>
<li><strong>平台的灵活性</strong>  。可以随时随地运行模型，无论是在移动端、服务器还是 PC 上。</li>
</ul>
<h3 id="TensorFlow-的典型-“流”"><a href="#TensorFlow-的典型-“流”" class="headerlink" title="TensorFlow 的典型 “流”"></a><a name="A-typical-flow"></a>TensorFlow 的典型 “流”</h3><p>　　每个库都有自己的“实现细节”，即一种写其遵循其编码范例的方式。 例如，当实现 scikit-learn 时，首先创建所需算法的对象，然后在训练和测试集上构建一个模型获得预测，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># define hyperparamters of ML algorithm</span></span><br><span class="line">clf = svm.SVC(gamma=<span class="number">0.001</span>, C=<span class="number">100.</span>)</span><br><span class="line"><span class="comment"># train </span></span><br><span class="line">clf.fit(X, y)</span><br><span class="line"><span class="comment"># test </span></span><br><span class="line">clf.predict(X_test)</span><br></pre></td></tr></table></figure>
<p>正如我前面所说，TensorFlow 遵循一种懒惰的方法。 在 TensorFlow 中运行程序的通常工作流程如下：</p>
<ul>
<li><strong>建立一个计算图</strong>， 任何的数学运算可以使用 TensorFlow 支撑。</li>
<li><strong>初始化变量</strong>， 编译预先定义的变量   </li>
<li><strong>创建 session</strong>， 这是神奇的开始的地方 ！  </li>
<li><strong>在 session 中运行图</strong>， 编译图形被传递到 session ，它开始执行它。</li>
<li><strong>关闭 session</strong>， 结束这次使用。</li>
</ul>
<p>TensoFlow 中使用的术语很少 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">placeholder：将数据输入图形的一种方法</span><br><span class="line">feed_dict：将数值传递到计算图的字典</span><br></pre></td></tr></table></figure>
<p>让我们写一个小程序来添加两个数字！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># import tensorflow</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># build computational graph</span><br><span class="line">a = tf.placeholder(tf.int16)</span><br><span class="line">b = tf.placeholder(tf.int16)</span><br><span class="line"></span><br><span class="line">addition = tf.add(a, b)</span><br><span class="line"></span><br><span class="line"># initialize variables</span><br><span class="line">init = tf.initialize_all_variables()</span><br><span class="line"></span><br><span class="line"># create session and run the graph</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    print &quot;Addition: %i&quot; % sess.run(addition, feed_dict=&#123;a: 2, b: 3&#125;)</span><br><span class="line"></span><br><span class="line"># close session</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure>
<h3 id="在-TensorFlow-中实现神经网络"><a href="#在-TensorFlow-中实现神经网络" class="headerlink" title="在 TensorFlow 中实现神经网络"></a><a name="MLP"></a>在 TensorFlow 中实现神经网络</h3><p><em>注意：我们可以使用不同的神经网络体系结构来解决这个问题，但是为了简单起见，我们在深入实施中讨论 <code>前馈多层感知器</code>。</em></p>
<p>让我们记住对神经网络的了解。</p>
<p>神经网络的典型实现如下：</p>
<ul>
<li>定义要编译的神经网络体系结构</li>
<li>将数据传输到模型</li>
<li>整个运行中，数据首先被分成批次，以便它可以被摄取。首先对批次进行预处理，扩增，然后送入神经网络进行训练</li>
<li>然后，模型被逐步地训练</li>
<li>显示特定数量的时间步长的精度</li>
<li>训练后保存模型供将来使用</li>
<li>在新数据上测试模型并检查其运行方式</li>
</ul>
<p>在这里，我们解决了我们深刻的学习实践中的问题 - [识别数字]，让再我们花一点时间看看问题陈述。</p>
<p>　　我们的问题是图像识别，以识别来自给定的 28×28 图像的数字。 我们有一个图像子集用于训练，其余的用于测试我们的模型。首先下载训练和测试文件。数据集包含数据集中所有图像的压缩文件， train.csv 和 test.csv 都有相应的训练和测试图像的名称。数据集中不提供任何其他功能，只是原始图像以 “.png” 格式提供。</p>
<p>　　如之前说的，我们将使用 TensorFlow 来创建一个神经网络模型。 所以首先在你的系统中安装 TensorFlow 。 请参考 <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/g3doc/get_started/os_setup.md" target="_blank" rel="noopener">官方的安装指南</a> 进行安装，按您的系统规格。</p>
<p>我们将按照上述模板</p>
<ul>
<li>让我们来 导入所有需要的模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%pylab inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure>
<ul>
<li>让我们来 设置一个种子值，这样我们就可以控制我们的模型随机性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># To stop potential randomness</span></span><br><span class="line">seed = <span class="number">128</span></span><br><span class="line">rng = np.random.RandomState(seed)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一步是设置目录路径，以便保管！</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root_dir = os.path.abspath(<span class="string">'../..'</span>)</span><br><span class="line">data_dir = os.path.join(root_dir, <span class="string">'data'</span>)</span><br><span class="line">sub_dir = os.path.join(root_dir, <span class="string">'sub'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># check for existence</span></span><br><span class="line">os.path.exists(root_dir)</span><br><span class="line">os.path.exists(data_dir)</span><br><span class="line">os.path.exists(sub_dir)</span><br></pre></td></tr></table></figure>
<ul>
<li>现在让我们读取我们的数据集，这些是 .csv 格式，并有一个文件名以及相应的标签</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">train = pd.read_csv(os.path.join(data_dir，<span class="string">'Train'</span>，<span class="string">'train.csv'</span>))</span><br><span class="line">test = pd.read_csv(os.path.join（data_dir，<span class="string">'Test.csv'</span>))</span><br><span class="line">sample_submission = pd.read_csv(os.path.join(data_dir，<span class="string">'Sample_Submission.csv'</span>))</span><br><span class="line">train.head()</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">文件名</th>
<th style="text-align:right">标签</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">0.png</td>
<td style="text-align:right">4</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">1.png</td>
<td style="text-align:right">9</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">2.png</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">3.png</td>
<td style="text-align:right">7</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">4.png</td>
<td style="text-align:right">3</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>让我们看看我们的数据是什么样子！我们读取我们的形象并显示出来。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">img_name = rng.choice(train.filename)</span><br><span class="line">filepath = os.path.join(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'train'</span>, img_name)</span><br><span class="line"></span><br><span class="line">img = imread(filepath, flatten=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">pylab.imshow(img, cmap=<span class="string">'gray'</span>)</span><br><span class="line">pylab.axis(<span class="string">'off'</span>)</span><br><span class="line">pylab.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/3.png" alt>       </p>
<p>上面的图像表示为 numpy 数组，如下所示</p>
<p><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/one.png" alt>       </p>
<ul>
<li>为了方便数据操作，让我们 的存储作为 numpy 的阵列的所有图片</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">temp = []</span><br><span class="line"><span class="keyword">for</span> img_name <span class="keyword">in</span> train.filename:</span><br><span class="line">    image_path = os.path.join(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'train'</span>, img_name)</span><br><span class="line">    img = imread(image_path, flatten=<span class="literal">True</span>)</span><br><span class="line">    img = img.astype(<span class="string">'float32'</span>)</span><br><span class="line">    temp.append(img)</span><br><span class="line">    </span><br><span class="line">train_x = np.stack(temp)</span><br><span class="line"></span><br><span class="line">temp = []</span><br><span class="line"><span class="keyword">for</span> img_name <span class="keyword">in</span> test.filename:</span><br><span class="line">    image_path = os.path.join(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'test'</span>, img_name)</span><br><span class="line">    img = imread(image_path, flatten=<span class="literal">True</span>)</span><br><span class="line">    img = img.astype(<span class="string">'float32'</span>)</span><br><span class="line">    temp.append(img)</span><br><span class="line">    </span><br><span class="line">test_x = np.stack(temp)</span><br></pre></td></tr></table></figure>
<ul>
<li>由于这是典型的 ML 问题，为了测试我们的模型的正确功能，我们创建一个验证集，让我们以 70:30 的分割训练集 和 验证集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">split_size = int(train_x.shape[<span class="number">0</span>]*<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">train_x, val_x = train_x[:split_size], train_x[split_size:]</span><br><span class="line">train_y, val_y = train.label.values[:split_size], train.label.values[split_size:]</span><br></pre></td></tr></table></figure>
<ul>
<li>我们定义一些辅助函数，我们稍后在我们的程序中使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dense_to_one_hot</span><span class="params">(labels_dense, num_classes=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Convert class labels from scalars to one-hot vectors"""</span></span><br><span class="line">    num_labels = labels_dense.shape[<span class="number">0</span>]</span><br><span class="line">    index_offset = np.arange(num_labels) * num_classes</span><br><span class="line">    labels_one_hot = np.zeros((num_labels, num_classes))</span><br><span class="line">    labels_one_hot.flat[index_offset + labels_dense.ravel()] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> labels_one_hot</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preproc</span><span class="params">(unclean_batch_x)</span>:</span></span><br><span class="line">    <span class="string">"""Convert values to range 0-1"""</span></span><br><span class="line">    temp_batch = unclean_batch_x / unclean_batch_x.max()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp_batch</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_creator</span><span class="params">(batch_size, dataset_length, dataset_name)</span>:</span></span><br><span class="line">    <span class="string">"""Create batch with random samples and return appropriate format"""</span></span><br><span class="line">    batch_mask = rng.choice(dataset_length, batch_size)</span><br><span class="line">    </span><br><span class="line">    batch_x = eval(dataset_name + <span class="string">'_x'</span>)[[batch_mask]].reshape(<span class="number">-1</span>, <span class="number">784</span>)</span><br><span class="line">    batch_x = preproc(batch_x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> dataset_name == <span class="string">'train'</span>:</span><br><span class="line">        batch_y = eval(dataset_name).ix[batch_mask, <span class="string">'label'</span>].values</span><br><span class="line">        batch_y = dense_to_one_hot(batch_y)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> batch_x, batch_y</span><br></pre></td></tr></table></figure>
<ul>
<li>主要部分！ 让我们定义我们的神经网络架构。 我们定义一个神经网络具有 3 层，输入、隐藏 和 输出， 输入和输出中的神经元数目是固定的，因为输入是我们的 28×28 图像，并且输出是表示类的 10×1 向量。 我们在隐藏层中取 500 神经元。这个数字可以根据你的需要变化。我们把值 赋给 其余变量。 可以阅读 <a href="https://www.analyticsvidhya.com/blog/2016/03/introduction-deep-learning-fundamentals-neural-networks/" target="_blank" rel="noopener">神经网络的基础知识的文章</a> ，以更深的了解它是如何工作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### set all variables</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># number of neurons in each layer</span></span><br><span class="line"></span><br><span class="line">input_num_units = <span class="number">28</span>*<span class="number">28</span></span><br><span class="line"></span><br><span class="line">hidden_num_units = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">output_num_units = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define placeholders</span></span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="literal">None</span>, input_num_units])</span><br><span class="line">y = tf.placeholder(tf.float32, [<span class="literal">None</span>, output_num_units])</span><br><span class="line"></span><br><span class="line"><span class="comment"># set remaining variables</span></span><br><span class="line">epochs = <span class="number">5</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### define weights and biases of the neural network (refer this article if you don't understand the terminologies)</span></span><br><span class="line"></span><br><span class="line">weights = &#123;</span><br><span class="line">    <span class="string">'hidden'</span>: tf.Variable(tf.random_normal([input_num_units, hidden_num_units], seed=seed)),</span><br><span class="line">    <span class="string">'output'</span>: tf.Variable(tf.random_normal([hidden_num_units, output_num_units], seed=seed))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">biases = &#123;</span><br><span class="line">    <span class="string">'hidden'</span>: tf.Variable(tf.random_normal([hidden_num_units], seed=seed)),</span><br><span class="line">    <span class="string">'output'</span>: tf.Variable(tf.random_normal([output_num_units], seed=seed))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>现在创建我们的神经网络计算图</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">hidden_layer = tf.add(tf.matmul(x, weights[<span class="string">'hidden'</span>]), biases[<span class="string">'hidden'</span>])</span><br><span class="line">hidden_layer = tf.nn.relu(hidden_layer)</span><br><span class="line"></span><br><span class="line">output_layer = tf.matmul(hidden_layer, weights[<span class="string">'output'</span>]) + biases[<span class="string">'output'</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>此外，我们需要定义神经网络的成本</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output_layer, y))</span><br></pre></td></tr></table></figure>
<ul>
<li>设置优化器，即我们的反向传播算法。 这里我们使用 <a href="https://arxiv.org/abs/1412.6980" target="_blank" rel="noopener">Adam</a> ，这是梯度下降算法的高效变体。 有在 tensorflow 可用许多其它优化（参照 <a href="https://www.tensorflow.org/versions/r0.11/api_docs/python/train.html#optimizers" target="_blank" rel="noopener">此处</a> ）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(cost)</span><br></pre></td></tr></table></figure>
<ul>
<li>定义我们的神经网络结构后，让我们来 初始化所有的变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">init = tf.initialize_all_variables()</span><br></pre></td></tr></table></figure>
<ul>
<li>现在让我们创建一个 Session ，并在 Session 中运行我们的神经网络。我们还验证我们创建的验证集的模型准确性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># create initialized variables</span></span><br><span class="line">    sess.run(init)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">### for each epoch, do:</span></span><br><span class="line">    <span class="comment">###   for each batch, do:</span></span><br><span class="line">    <span class="comment">###     create pre-processed batch</span></span><br><span class="line">    <span class="comment">###     run optimizer by feeding batch</span></span><br><span class="line">    <span class="comment">###     find cost and reiterate to minimize</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        avg_cost = <span class="number">0</span></span><br><span class="line">        total_batch = int(train.shape[<span class="number">0</span>]/batch_size)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(total_batch):</span><br><span class="line">            batch_x, batch_y = batch_creator(batch_size, train_x.shape[<span class="number">0</span>], <span class="string">'train'</span>)</span><br><span class="line">            _, c = sess.run([optimizer, cost], feed_dict = &#123;x: batch_x, y: batch_y&#125;)</span><br><span class="line">            </span><br><span class="line">            avg_cost += c / total_batch</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Epoch:"</span>, (epoch+<span class="number">1</span>), <span class="string">"cost ="</span>, <span class="string">"&#123;:.5f&#125;"</span>.format(avg_cost)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nTraining complete!"</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># find predictions on val set</span></span><br><span class="line">    pred_temp = tf.equal(tf.argmax(output_layer, <span class="number">1</span>), tf.argmax(y, <span class="number">1</span>))</span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(pred_temp, <span class="string">"float"</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Validation Accuracy:"</span>, accuracy.eval(&#123;x: val_x.reshape(<span class="number">-1</span>, <span class="number">784</span>), y: dense_to_one_hot(val_y.values)&#125;)</span><br><span class="line">    </span><br><span class="line">    predict = tf.argmax(output_layer, <span class="number">1</span>)</span><br><span class="line">    pred = predict.eval(&#123;x: test_x.reshape(<span class="number">-1</span>, <span class="number">784</span>)&#125;)</span><br></pre></td></tr></table></figure>
<p>这将是上面代码的输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Epoch: <span class="number">1</span> cost = <span class="number">8.93566</span></span><br><span class="line">Epoch: <span class="number">2</span> cost = <span class="number">1.82103</span></span><br><span class="line">Epoch: <span class="number">3</span> cost = <span class="number">0.98648</span></span><br><span class="line">Epoch: <span class="number">4</span> cost = <span class="number">0.57141</span></span><br><span class="line">Epoch: <span class="number">5</span> cost = <span class="number">0.44550</span></span><br><span class="line"></span><br><span class="line">Training complete!</span><br><span class="line">Validation Accuracy: <span class="number">0.952823</span></span><br></pre></td></tr></table></figure>
<ul>
<li>验证我们自己的眼睛，让我们来 想象它的预言</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">img_name = rng.choice(test.filename)</span><br><span class="line">filepath = os.path.join(data_dir, <span class="string">'Train'</span>, <span class="string">'Images'</span>, <span class="string">'test'</span>, img_name)</span><br><span class="line"></span><br><span class="line">img = imread(filepath, flatten=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">test_index = int(img_name.split(<span class="string">'.'</span>)[<span class="number">0</span>]) - <span class="number">49000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Prediction is: "</span>, pred[test_index]</span><br><span class="line"></span><br><span class="line">pylab.imshow(img, cmap=<span class="string">'gray'</span>)</span><br><span class="line">pylab.axis(<span class="string">'off'</span>)</span><br><span class="line">pylab.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Prediction <span class="keyword">is</span>:  <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.analyticsvidhya.com/wp-content/uploads/2016/10/8.png" alt></p>
<ul>
<li>我们看到的模型性能是相当不错！ 现在让我们 创建一个提交</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sample_submission.filename = test.filename</span><br><span class="line"> </span><br><span class="line">sample_submission.label = pred</span><br><span class="line"></span><br><span class="line">sample_submission.to_csv(os.path.join(sub_dir, <span class="string">'sub01.csv'</span>), index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>　　终于完成了！ 我们刚刚创建了自己的训练神经网络！</p>
<h3 id="TensorFlow-的限制"><a href="#TensorFlow-的限制" class="headerlink" title="TensorFlow 的限制"></a><a name="Limitations-of-TensorFlow"></a>TensorFlow 的限制</h3><ul>
<li>尽管 TensorFlow 是强大的，它仍然是一个低水平库，例如，它可以被认为是机器级语言，但对于大多数功能，您需要自己去模块化和高级接口，如 keras</li>
<li>它仍然在继续开发和维护，这是多么👍啊！</li>
<li>它取决于你的硬件规格，配置越高越好</li>
<li>不是所有变成语言能使用它的 API 。</li>
<li>TensorFlow 中仍然有很多库需要手动导入，比如 OpenCL 支持。</li>
</ul>
<p>上面提到的大多数是在 TensorFlow 开发人员的愿景，他们已经制定了一个路线图，计划库未来应该如何开发。</p>
<h3 id="TensorFlow-与其他库"><a href="#TensorFlow-与其他库" class="headerlink" title="TensorFlow 与其他库"></a><a name="vs-libraries"></a>TensorFlow 与其他库</h3><p>　　TensorFlow 建立在类似的原理，如使用数学计算图表的 Theano 和 Torch，但是随着分布式计算的额外支持，TensorFlow 更好地解决复杂的问题。 此外，TensorFlow 模型的部署已经被支持，这使得它更容易用于工业目的，打开一些商业的三方库，如 Deeplearning4j ，H2O 和 Turi。 TensorFlow 有用于 Python，C ++ 和 Matlab 的 API 。 最近还出现了对 Ruby 和 R 等其他语言的支持。因此，TensorFlow 试图获得通用语言支持。</p>
<h3 id="从这里去哪里？"><a href="#从这里去哪里？" class="headerlink" title="从这里去哪里？"></a><a name="Where-to-go-from-here"></a>从这里去哪里？</h3><p>　　以上你看到了如何用 TensorFlow 构建一个简单的神经网络，这段代码是为了让人们了解如何开始实现 TensorFlow。 要解决更复杂的现实生活中的问题，你必须在这篇文章的基础上在调整一些代码才行。</p>
<p>　　许多上述功能可以被抽象为给出无缝的端到端工作流，如果你使用 scikit-learn ，你可能知道一个高级库如何抽象“底层”实现，给终端用户一个更容易的界面。尽管 TensorFlow 已经提取了大多数实现，但是也有更高级的库，如 TF-slim 和 TFlearn。</p>
<h3 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h3><ul>
<li><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFlow 官方库</a> </li>
<li>Rajat Monga（TensorFlow负责人） <a href="https://youtu.be/wmw8Bbb_eIE" target="_blank" rel="noopener">“TensorFlow为大家”</a>  的视频</li>
<li><a href="https://github.com/jtoy/awesome-tensorflow/#github-projects" target="_blank" rel="noopener">一个专用资源的策划列表</a>  </li>
</ul>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>AI</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>「体能训练理论」之金字塔</title>
    <url>/2017/08/17/2017-08-17-Life-Exercise-Pyramid/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>体能，人体基础运动能力的统称，人体的本质属性，它支撑着日常生活工作的需要，也支撑着运动技战术的表现。 </p>
<p>体能思路，是指导我们设计实施体能训练的思维方式，分析逻辑。</p>
<h2 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h2><p>体能训练是一门实践科学，实践先于理论，而理论印证实践。体能训练有四大基础学科，分别是运动解剖学、运动生理学、运动生物力学和运动训练学。</p>
<p>五大运动素质对应生理学和运动训练学；动力链对应解剖学和运动生物力学；功能性对应着生理和生物力。而金字塔则对应了它们全部！或者说金字塔其实是诸学科在体能训练中的交汇，它囊括了所有之前的理论，并且赋予了更深层的意义。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fhg20ydk8uj30go0brwh1.jpg" alt></p>
<p>金字塔代表了人体运动能力发展的客观规律，它是一个流程的引领，思维的分级，以及训练阶段的划分。</p>
<p>这里包括 <strong>关节功能+核心控制</strong>、<strong>基础动作模式</strong>、<strong>基础力量</strong>、<strong>综合体能</strong>、<strong>专项运动</strong>。他们在逻辑上互为基础和进阶，关节是动作的基础，动作承载力量，力量支撑各个运动素质，而专项是各个运动素质在具体运动中的表现。</p>
<p>也许这么说可能不能够让大家有清晰的认识，那么接下来我就把每层的内容和它们之间的逻辑关系简单的跟大家分享一下。 99%的运动者都是基础不足，上层过度。我们从基础开始，从下往上说起。</p>
<h3 id="运动基础（关节功能-核心控制）"><a href="#运动基础（关节功能-核心控制）" class="headerlink" title="运动基础（关节功能 + 核心控制）"></a>运动基础（关节功能 + 核心控制）</h3><p>运动基础主要内容包括 <strong>关节功能</strong> 和 <strong>核心控制</strong> 能力。<br><a id="more"></a><br>人体的关节功能有两个属性，一个是灵活性，一个是稳定性。举例来说，很多人由于长期缺乏锻炼，肩关节灵活性缺失，第一次学习竖直上举时，怎么努力都举不到头顶，显然应该先改善肩关节灵活性。再比如，膝关节的结构导致它只能进行屈伸的运动，所以我们要保证运动过程中不出现膝内扣，膝外翻的现象，也就是膝关节需要具备的稳定能力。在健身之前我们，应该先评估我们的关节功能。</p>
<p>运动基础中的第二部分内容就是核心控制能力。很多健身者入门者都会觉得核心是腹肌，觉得练核心的目的是拥有一个好看的腹肌。实际上，腹肌只是核心的一部分，核心是指一个区域，我们的整个躯干都属于核心区域。</p>
<p>运动的外在表现虽来源于四肢，比如跑步时你的四肢在运动，但是一个出色的外在运动表现是建立在稳定的核心基础之上的。如果躯干不稳定，在跑步的过程中整个脊柱很松散，甩来甩去，这样是很难提高跑步速度的。所以在学习动作之前，应该先加强核心控制能力。</p>
<p>所以我们会推荐没有进行过抗阻训练、长期久坐的同学先去练习一段时间的瑜伽和普拉提，瑜伽可以很好地改善关节灵活性，进而提高身体的柔韧性；而普拉提能提高的核心控制能力，并提高关节稳定性。<br>一个合格的健身训练者，应该了解不同的训练体系，他要知道自身还缺乏什么，然后向不同的训练体系去借鉴，以提高自己。</p>
<h3 id="基础动作模式"><a href="#基础动作模式" class="headerlink" title="基础动作模式"></a>基础动作模式</h3><h4 id="什么是基础动作模式？"><a href="#什么是基础动作模式？" class="headerlink" title="什么是基础动作模式？"></a>什么是基础动作模式？</h4><p>简单地说就是，所有动作肢体特有的运动程序。人体就这么些零件，所以很多的动作之间都存在着些许的共性，我们将这些共性提炼出来并进行功能上的抽象，那么就形成了我们现在所要说的基础动作模式——<strong>双腿蹲</strong>、<strong>单腿蹲</strong>、<strong>推</strong>、<strong>拉</strong>、<strong>旋转</strong>、<strong>屈髋</strong>。</p>
<ul>
<li><strong>蹲</strong>：分为单腿蹲、双腿蹲。对应的训练动作有剪蹲和深蹲。</li>
<li><strong>推</strong>：分为水平推、竖直推。对应的训练动作是卧推和实力举。</li>
<li><strong>拉</strong>：分为竖直拉、水平拉。竖直拉包括引体向上、高位下拉，水平拉包括弹力带划船等等。</li>
<li><strong>屈髋</strong>：最具代表性的动作就是硬拉。</li>
<li><strong>旋转</strong>：动作比较复杂，在训练当中比较少出现，适合比较资深的训练者，比如说劈和砍，比如下劈球，比如拿锤子砸轮胎。前期不建议做，当你有一定训练水平的时候再去做旋转类动作。</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fhg20yeticj30go0ptdmg.jpg" alt></p>
<h4 id="基础动作模式的意义是什么？"><a href="#基础动作模式的意义是什么？" class="headerlink" title="基础动作模式的意义是什么？"></a>基础动作模式的意义是什么？</h4><ol>
<li>教会我们如何正确的使用我们的身体</li>
<li>评估你的是否存在关节功能缺陷</li>
</ol>
<p>基于基础动作模式的学习意义和诊断意义，我们对待健身者或者需要进行体能训练的人很多时候都从这里开始。如果诊断结果良好，那么我们学习动作之后就可以上升到基础力量训练，如果诊断出关节功能缺陷，我们就要进行针对性的解决。</p>
<h3 id="基础力量（肌肉力量）"><a href="#基础力量（肌肉力量）" class="headerlink" title="基础力量（肌肉力量）"></a>基础力量（肌肉力量）</h3><p>力量是所有运动素质的基础，如果你没有足够的力量，很多事情都很难完成。你想学习倒立，如果上肢力量足够，只需要了解动作技巧和细节，可能半个小时就能学会倒立。但是如果力量水平很低，就算把各种技巧和细节都学会了，也没有力气把自身撑起来，更不可能完成倒立。日常生活中，力量水平不足经常会成为我们突破运动瓶颈的障碍，有足够的力量才能跑得更快、跑得更远、跳得更高。所以，力量是所有运动素质的基础。</p>
<p>因此，在金字塔的这层，我们就要从徒手训练的阶段进阶到自由力量训练的阶段。负重和徒手的训练效果差异非常大，它不仅仅在于力量的提高，在重心控制、身体平衡、协调性控制等方面的区别也很大。力量训练能让身体各项能力同时提高，只有真正进入力量训练阶段（对于健身来说），才可以说真正踏上健身入门之路。</p>
<h3 id="训练目标（综合体能和专项体能）"><a href="#训练目标（综合体能和专项体能）" class="headerlink" title="训练目标（综合体能和专项体能）"></a>训练目标（综合体能和专项体能）</h3><p>最后，我们来到了金字塔的顶端，这就是我们的最终追求。</p>
<p>综合体能在此指的是体能所包含的五大运动素质——力量，速度，灵敏，耐力，柔韧。对于有专项运动需求的人，我们需要有针对性的重点发展这五大运功素质中的某几个。</p>
<p>当我们身体各关节灵活性和稳定性都可以满足要求，且核心控制能力也很强的情况下，又在标准动作的基础上储备了足够的肌肉力量，那么，不管你的目标是减肥，增肌，或者是进行某一个竞技性运动项目，你都可以相对安全且轻松地达成你的目标。</p>
<p>一般我们把还处在第一第二层的健身者称为健身入门者。不管你是刚刚走进健身房的新手，还是健身多年的老司机，都可以根据这个健身发展流程来审视自己目前的训练处在哪一个阶段。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>体能训练金字塔告诉我们，体能训练要从关节功能和核心控制开始训练，通过六大基础运动模式的训练增强身体基础力量，只有基础力量够了，我们才能真正开始我们的训练目标，根据我们训练的项目增强专项体能，比如拳击，我们要增强力量，耐力，灵敏。</p>
<p>清楚了这个体能训练金字塔之后，更重要的事还是要去执行。执行层面会涉及更多技术问题，也就是我们常说的如何做标准的动作，如何制定适合自己的训练计划等等。</p>
<p>健身是一项系统性工程，愿每一个人都能找到方法，科学有效地塑造自己的身体。</p>
<blockquote>
<p>参考 </p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/20801623" target="_blank" rel="noopener">《体能训练之金字塔》</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>锻炼</category>
      </categories>
      <tags>
        <tag>锻炼</tag>
        <tag>日常生活</tag>
      </tags>
  </entry>
  <entry>
    <title>「体能训练理论」之动力链</title>
    <url>/2017/08/16/2017-08-16-Life-Exercise-Kinetic-Chain/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>与其说体能训练是一种行为，不如说体能训练是一种程序。只要符合逻辑，就可以自由组合。</p>
<h2 id="动力链"><a href="#动力链" class="headerlink" title="动力链"></a>动力链</h2><p>如果说 <strong>五大运动素质</strong>（力量、速度、耐力、灵敏、柔韧）代表了体能的宏观表现，那么动力链理论则阐释了人体解剖结构在运动中的客观规律，这二者同为人体的本质属性。</p>
<p>动力链这一理论早在1875年就被提出过，当时的定义还很简单，就是指几个相邻的关节所组成的复杂动作单元。后来在不断地实践与研究中，动力链理论也不断的升级，越来越清晰，越来越客观，也越来越复杂，并且逐渐成为了体能训练师们必备的思考工具之一。</p>
<p>来看看动力链的英文解释:</p>
<blockquote>
<p>The concept of the kinetic chain originated in 1875, when a mechanical engineer named Franz Reuleaux proposed that if a series of overlapping segments were connected via pin joints, these interlocking joints would create a system that would allow the movement of one joint to affect the movement of another joint within the kinetic link. Dr. Arthur Steindler adapted this theory in 1955, and included an analysis of human movement. Steindler suggested that the extremities be viewed as a series of rigid, overlapping segments and defined the kinetic chain as a “combination of several successively arranged joints constituting a complex motor unit.” The movements that occur within these segments present as two primary types—open and closed.</p>
</blockquote>
<p>这种模糊形容根本无法让人们理解它真正的内核，虽然它看起来就像是一堆联动的齿轮和杠杆。实际上它也真的很像一堆齿轮和杠杆，有的负责驱动，有的负责传力，有的负责稳定。</p>
<p>为了方便大家理解，下面我要将这个理论拆解开来跟大家分享。<br><a id="more"></a><br>首先，我们需要从以上的定义中提炼出来一些关键词，比如说 “运动”、“几个”、“相邻”等等。那么这几个词分别代表了什么？</p>
<ol>
<li>我们讨论问题的角度是<strong>运动</strong>的；</li>
<li>我们需要考虑的<strong>人体解剖结构</strong>问题；</li>
<li>我们需要考虑相邻关节的<strong>协作关系</strong>；</li>
<li>我们需要分析每一个关节的<strong>使用特点</strong>。</li>
</ol>
<p>所以，它似乎并不能被完美的定义，而是只可意会不可言传。<br> 那么关于动力链，我们需要掌握两个最基本的知识：<strong>动力链模型</strong>、<strong>开链与闭链</strong>。</p>
<h3 id="动力链模型"><a href="#动力链模型" class="headerlink" title="动力链模型"></a>动力链模型</h3><p>在动力链理论中，我们考虑运动的最小单位是<strong>关节</strong>，诸多关节运动的协作产生了整体上的复杂动作。所以每一个关节的功能就决定了整体动作的表现，任何一个关节功能受限都会导致整体动作的失衡。 </p>
<p>而我们所指的关节功能，可以从生物力学角度简单的概括为：</p>
<ul>
<li><strong>灵活</strong>(<strong>M</strong>,Mobility)</li>
<li><strong>稳定</strong>(<strong>S</strong>,Stability)</li>
</ul>
<p>但看起来简单的两个词，其实意义非常。</p>
<h4 id="什么是灵活？"><a href="#什么是灵活？" class="headerlink" title="什么是灵活？"></a>什么是灵活？</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg2avap5sj30ao08rdg4.jpg" alt></p>
<p>很多人的第一反应就是能自由的运动呗~然后部分专业人士可能会想到活动度。但是你的关节如果仅仅具备很好的活动度就能够胜任运动中的需求么？显然是不能的。所以灵活的意义远不止关节活动度，关节活动度仅仅是灵活的基础，而更重要的还有产力的能力。没错，这里的灵活既包括关节主被动活动范围，也包括产力的能力，比如产力的大小，产力的快慢等等。<br> 举个例子：小明的髋关节活动范围非常好，能竖叉能横叉，但是臀大肌并没有很好的力量，所以不能够支撑你的跑步与跳跃，所以此时的髋关节灵活性仍然是不足的，只不过这里强调的是力量的缺失。</p>
<h4 id="什么是稳定？"><a href="#什么是稳定？" class="headerlink" title="什么是稳定？"></a>什么是稳定？</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg2b1gendj30fa08t74f.jpg" alt></p>
<p>稳定就是稳定呗~就是待着不动呗~就是牢固呗~灵活还能说出个关节活动度，而稳定的定义真的让很多人摸不到头脑，因为似乎“稳定”一词已经很好地形容了关节的功能表现。但是实际上我们仍然可以对其进行深究，并且这样做是有意义的，因为表现的不同直接影响训练的手段。</p>
<p>如果我们把“稳定”定义为是一种提供安全性的保护，那么我们就可以假想出两个现象：</p>
<ol>
<li>一个非常贵重的瓷器抱在手中，我不能把它摔碎，所以我抱着不动~</li>
<li>同样是这个非常贵重的瓷器抱在手中，我不能把它摔碎，但是我可以慢慢的把它放在地上。<br>同样是保护瓷器不被摔碎，但是却有两个表现，一个是hold住，另外一个是慢慢的放在地上，一个不动，一个动。所以我们人体关节的稳定也是如此，既包括保持身体姿态，关节位置的相对固定，也包括有控制的缓冲外力，退让做功。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fhg2b6eo7uj30m80h477k.jpg" alt></p>
<p>举个例子：我们的核心区域在运动中应该尽可能的保持姿态的稳定，所以是抱着瓷器不动；我们的膝关节在走路与跑步中从伸到屈，缓冲脚落地产生的冲击力，所以是抱着瓷器往下放。 </p>
<p>在了解了 SM (稳定和灵活)的意义之后，更重要的是明白：这两种并不会孤立的存在，而是相辅相成同时存在的，只不过在人体整体动力链中体现的侧重点不一样，在肢体的协同运动中扮演的角色不一样。比如对于核心区域来说，灵活恰是其稳定的基础，因为不同体位下脊柱的排列形式直接影响稳定的表现。</p>
<p>当 SM 代表了关节功能之后，在人体的整体运动结构中，不同的关节所凸显出来的功能是不同的，并且它们遵循一定的逻辑分布。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fhg2bewsh2j30hs0b0t8y.jpg" alt></p>
<p>从下往上说：</p>
<ol>
<li><p>足弓——稳定</p>
<p> 第一个缓冲冲击力的关节，并且没有多大的关节活动度。</p>
</li>
<li><p>足踝——灵活</p>
<p> “足” “踝”形成了一个稳定与灵活兼备的整体，但是在运动中它是下肢蹬伸最后一个主动发力的关节，并且无时无刻不在调整着身体与地面之间的位置关系，所以在这里我们更强调它的灵活性。</p>
</li>
<li><p>膝关节——稳定</p>
<p> 强大的承重关节，且仅存在屈伸的动作（屈膝位的内外旋的意义是提供可控的缓冲空间，并非叫你主动旋转），更重要的是，无论走路、跑步、跳跃，膝关节都是非常重要的离心缓冲关节。</p>
</li>
<li><p>髋关节——灵活</p>
<p> 强大的发力关节，而且活动范围也非常广泛，它引领着下肢的动作产生。但是由于位置与功能的特殊，所以其稳定性也相当重要，直接可以影响核心的稳定结构，特别是在闭链状态下。</p>
</li>
<li><p>腰椎——稳定</p>
<p> 相对的绝对稳定体。所谓绝对，是因为腰椎所处的位置恰好为核心地带，这里的功能是维持姿态以及为上下肢的运动提供稳定基础，所以要“抱着缸不动”。而所谓相对，是因为不同的体位下腰椎的姿态是需要随之调整的，并不能以不变应万变。</p>
</li>
<li><p>胸椎——灵活</p>
<p> 胸椎的灵活性其实并不好，但是相比于腰椎来说就好太多了，特别是在旋转动作上。在旋转鞭打的动作模式中，胸椎是继下肢产力之后的第一个角速度放大的关节，其灵活程度直接影响了上肢的鞭打效果。当然，在更多的时候胸椎要参与承重，但即便承重，也是以其良好的灵活性为基础的，比如说手臂上举过头负重的动作。</p>
</li>
<li><p>颈椎——稳定</p>
<p> 虽然很灵活，但却需要很稳定！因为头部的位置变化会直接改变身体肌张力的大小分布，这个不仅可以让我们身体姿态发生变化，还会破坏掉本体感觉的准确性。当然，这也是猫在空中可以转体的原因，以及为什么我们打拳的时候不能回头。</p>
</li>
<li><p>肩胛胸关节——稳定</p>
<p> 这是一个很奇葩的关节，从动力链结构上看，它是稳定关节，但稳定的并不是它自己，而是肩关节。在实际运动中，肩胛胸关节和肩关节是联动运动的，而且前者为后者提供稳定性，是后者得以安全展现灵活的基础。但是这个“稳定”恰恰是通过肩胛胸关节本身的灵活性来展现的，比如手臂上举时的上回旋。</p>
</li>
<li><p>肩关节——灵活</p>
<p> 没的说，人体最灵活的关节，也是人体最不稳定的关节，其球窝关节的解剖结构已经说明了一切。</p>
</li>
<li><p>肘关节——稳定</p>
<p>结构上跟膝关节相对，但是实际上要比膝关节灵活的多。所以如果进化论成立的话，人类从四脚着地变成双脚着地的过程，使我们的下肢关节趋向于稳定，上肢关节趋向于灵活。而这正与 “开链”或者“闭链”的需求相适应。</p>
</li>
</ol>
<h3 id="开链-amp-闭链"><a href="#开链-amp-闭链" class="headerlink" title="开链&amp;闭链"></a>开链&amp;闭链</h3><p>我们的关节同时存在S与M，而在整体的运动中有不同的体现，甚至于同样是S或者M的上下肢关节却存在了显著的差别。那么在此我们需要引出一个新的概念：<strong>开链</strong> &amp; <strong>闭链</strong>。</p>
<h4 id="开链"><a href="#开链" class="headerlink" title="开链"></a>开链</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg2bltahoj30dg09h74k.jpg" alt></p>
<p>开链，简单地说就是我们身体产生力量，改变了外界物体的运动状态。比如说哑铃二头弯举，投掷，摘苹果等动作都是开链动作。我们可以认为我们的身体在对抗趋于无穷小的阻力，那么我们就可以随意改变物体的运动状态，随便摆弄它，所以此时我们的肢体的灵活性就可以充分的发挥。比如我们的上肢就是以开链运动为主的，所以它整体表现出更好的灵活性。</p>
<h4 id="闭链"><a href="#闭链" class="headerlink" title="闭链"></a>闭链</h4><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fhg2bq4z76j30fk0dp0tf.jpg" alt></p>
<p>闭链，简单的说就是我们的身体产生力量，却没能推动外界的物体，反而改变了我们自身的运动状态。比如说跑步与深蹲，我们扒地，我们蹬地，并没有让地板产生位移，我们自己却向前或者向上运动了。所以我们可以认为闭链运动时，我们的身体在对抗趋于无穷大的阻力，我们根本不可能改变它，所以只能运动我们自己。而在面对这样无穷大的阻力的时候，我们需要将我们的关节摆在力学结构最优的位置上才能发挥我们自身的最大经济性和效率，而且在这个状态下，各个关节的位置直接影响了身体的整体姿态和状态，所以灵活性被抑制。我们的下肢，最擅长、做的最多的就是闭链运动，所以它更加的趋于稳定。</p>
<p>开链和闭链直接影响我们的训练适应，因为它们所表现的力学结构是不同的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解动力链并不是让我们<strong>装逼</strong>的，而是让我们更加了解人体的客观规律来指导训练的。</p>
<p>它是一个非常好的思考工具。比如我们在训练下肢力量的时候，我们就需要考虑髋关节灵活性对于下肢力量表现的影响，于是乎我们可能更加重点强化髋的产力能力。但是当考虑到屈髋动作时，也许实际中更多的是开链的屈髋，所以我们就能以此为依据来选择髂腰肌和股直肌的训练动作。</p>
<p>除此之外，每个关节本身的功能完整性是非常重要的，如果一个关节有功能缺陷，那么在整体运动中它就不能够尽到它的职责，所以一定会有另外一个或者几个关节来代偿它的功能，那么就相当于一个3人的团队，一个请假了，另外两个就得加班。如果一次两次没关系，它要是请了一年的产假，那么另外俩人可能会由于长期超负荷工作而积劳成疾。当然，对于公司来说我可以再雇人，但是我们的人体可没有能再多长一个关节之说。</p>
<p>所以其实很多跑步膝的问题恰是由于髋和踝的功能缺陷而导致的。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fhg2buv4nwj30ia0a2dfx.jpg" alt></p>
<p><strong>最后我要再次强调</strong>：任何一个关节，稳定与灵活同时存在，只不过体现的程度和侧重不同。在动力链中，灵活的关节不代表没有稳定，更不代表稳定不重要；稳定的关节也需要灵活，而且灵活可能是稳定的基础。</p>
<p>了解了动力链，你会更懂运动中的人体，也许你有了思考问题的方向，但仍然缺少方法，所以你还需要具备<a href="http://qiubaiying.github.io/2017/07/10/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA-%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%80%A7/" target="_blank" rel="noopener">「功能性」</a>的思维方式。</p>
<blockquote>
<p>转自 <a href="https://zhuanlan.zhihu.com/p/20774747" target="_blank" rel="noopener">《体能训练之动力链》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>锻炼</category>
      </categories>
      <tags>
        <tag>锻炼</tag>
        <tag>日常生活</tag>
      </tags>
  </entry>
  <entry>
    <title>「体能训练理论」之功能性</title>
    <url>/2017/08/15/2017-08-15-Life-Exercise-Functional/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>体能训练是一种开源的程序它所依仗的并不是固有的方法手段，而是能够贯穿始终的逻辑，它是一种指导实践的思维方式，我们管它叫“体能思路”。</p>
<p>体能思路有两个方向，一个是原点，一个是过程。所谓原点我们认为是人体的本质属性，比如之前我们分享的五大运动素质以及动力链理论。所谓过程是我们分析问题实现目的的思考方向以及逻辑，它主要体现在接下来要跟大家分享的功能性原则和金字塔。</p>
<p>今天先来说功能性原则。</p>
<h2 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a>功能性</h2><p>我们所说的功能性是一种解决问题的思维方式，而功能性训练则定义了一种多关节参与，多平面运动的复杂练习。功能性训练是具体的，比较好理解，我就不赘述了，也不评价其优劣，因为在“功能性”的思维方式下，只存在目标之下的合适与否。</p>
<h3 id="什么是功能性？"><a href="#什么是功能性？" class="headerlink" title="什么是功能性？"></a>什么是功能性？</h3><p>我们把它定义为目标导向下的效率，所以它是一种程度的体现。如果一个练习与目标的相关性强，那么我们认为它具备较强的功能意义；而如果一个练习与它的目标背道而驰，那么我们就认为它缺乏功能意义。</p>
<a id="more"></a>
<p>举个例子，对于偏瘫患者来说，一个手指的屈伸就已经具备非常强的功能意义了，而对于一个马拉松爱好者来说，静蹲的价值可能并不是想象中那么高。</p>
<p>一般来说，在思考功能性问题的时候我习惯从以下三个方面入手：<strong>肌肉的生理适应</strong> 、<strong>动作模式</strong> 和 <strong>专项需求</strong>。</p>
<h4 id="1-肌肉的生理适应"><a href="#1-肌肉的生理适应" class="headerlink" title="1. 肌肉的生理适应"></a>1. 肌肉的生理适应</h4><p>其实练肌肉谁都会，是一个相对好入手的技能，但是当你给这个行为赋予体能训练使命的时候就需要思考一些问题，比如说你现在练习所发展的东东真的是你实际运动中所需要的东东么？</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fhg24pm22dj30e709474v.jpg" alt></p>
<p>我们都知道肌肉的生理收缩模式可以简单的分为向心收缩，离心收缩和静力收缩。现在的研究表明，这三种收缩模式的练习所产生的适应性提高存在显著的特异性。也就是说我向心练习所发展的能力只在向心运动中表现最好，在离心和静力中都不佳。同样，离心收缩也只能获得最好的离心能力收益。而静力就更变态，其训练最佳效果仅仅体现在所锻炼的关节角度下，换一个角度能够迁移的效果有可能都不到一半儿。这样看来，你的训练是不是并没有达到你想要的效果呢？</p>
<p>举个例子：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fhg251pmatj30go0b5q5d.jpg" alt></p>
<p>为什么静蹲对于跑步爱好者来说可能并没有那么理想？因为膝关节股四头肌在跑步中以离心缓冲为主，而且角度在伸膝末端的30°左右，而静蹲却是在屈曲90°左右的角度下呆着不动……着不动……不动……动……</p>
<p>除此之外，需要考虑的问题还很多，比如说发力模式，是加速？减速？还是匀速？再比如关节活动角度上发力点的位置，是伸展末端发力？屈曲极限发力？还是在屈伸过程中的某一点发力？阻力加在哪里，就会在哪里产生最好的适应，那么功能的意义就体现在这里。</p>
<h4 id="2-动作模式"><a href="#2-动作模式" class="headerlink" title="2. 动作模式"></a>2. 动作模式</h4><p>动作模式是动作程序的体现，而基础动作模式是诸多复杂动作模式共性的抽象体现，并且基础动作模式一定是符合解剖结构和生物力学特点的，说白了也就是我们人体被设计来应该完成的动作。</p>
<p>如果说大多数运动都可以认为是基础动作模式的升级与排列组合，同时基础动作模式本身又能衍生出来很多训练动作，那么选择和实际运动相对应的练习就是另一个功能性的体现了。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg25l7ep2j30g609o0ue.jpg" alt></p>
<p>比如说发展起跳能力，因为跳是蹲的升级，所以我一定首选深蹲练习；再比如说跑步，存在大量的下肢摆动与支撑的交替，摆动可以认为是下肢开链屈髋与蹬伸，而支撑可以认为是下肢单腿蹲的一瞬间，那么我会选择箱式单腿蹲，保加利亚蹲，悬垂屈髋等等；再再比如，拳击是基于“旋转”加“上肢推”加“单腿蹲”的动作模式，那么我就要练习剪蹲…旋转…单臂…推举…吗？</p>
<p>其实动作模式的选择要结合动力链一起去思考，这里除了要思考开链还是闭链之外，还要考虑动力链的完整性以及发力的顺序或者说是力学结构。说到上肢推的动作模式，水平推的话我相信很多人都会想到卧推和俯卧撑，那么这两个动作的功能性如何评价呢？</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg26a2ve0j30go0ce76n.jpg" alt></p>
<p><strong>卧推</strong>，一个挺奇葩的动作，奇葩在哪呢？来，咱们数数卧推的主动关节都有哪些：肩关节，肘关节。那么我们上肢链在上肢推动作模式下参与的关节都有哪些呢？肩关节，肘关节！就这些么？再想想！其实你还疏漏了一个非常重要的关节——<strong>肩胛胸关节</strong>！几乎所有上肢的动作都以肩胛胸关节的运动为基础，而卧推却并没有，特别是标准的卧推~</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fhg26h6oejj30go09lwgj.jpg" alt></p>
<p><strong>俯卧撑</strong>，虽然肩胛胸，肩关节，肘关节全面参与到运动中去，但不巧的是它是一个闭链运动，而实际运动中我们的上肢会以开链为主！呵呵~</p>
<p>别着急，认真你就输了！上面两段其实是个伪命题，我这么做主要是想通过这个平易近人的例子来帮助大家掌握的分析问题的思路！如果你需要发展上肢最大力量表现，那么显然卧推是你的首选。而如果你要优化上肢的力学结构，特别是水平推的发力顺序，那么俯卧撑是你首选。再如果你要提高上肢的延展性以及伴随旋转的加速能力，那么单臂水平推的练习给你的帮助最大！</p>
<p>所以，选择什么，看目标喽~</p>
<h4 id="3-专项需求"><a href="#3-专项需求" class="headerlink" title="3. 专项需求"></a>3. 专项需求</h4><p>其实这个非常好理解，也是功能性原则的根本目的，但是为了和上面两个方向区分开，这里主要针对的是不同的运动素质需求。</p>
<p>Q：对一个英超的后卫进行长距离高强度的游泳练习是否具备功能性意义？！</p>
<p>A：具备！</p>
<p>Q：为什么？</p>
<p>A：因为他喜欢游泳，这个可以让他心情愉悦然后更好的训练和比赛！</p>
<p>咳咳！当然，这样的答案是合情合理的！但是我们不妨换一个角度去分析。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg26rdi6vj30go0b4goo.jpg" alt></p>
<p>英超，几乎是足球联赛中对抗最强的，他们的后卫每场比赛动不动就跑个8千1万的，而这8千1万真心不是慢慢悠悠颠儿下来的，而是各种加速减速变向拼抢，所以其强度非常之大。那么这就需要很好的心肺系统功能，一方面体现在有氧与无氧耐力上，另一方面呼吸器官的机能上。游泳练习，不仅可以提高有氧以及无氧耐力，其水环境还可以给胸扩张带来阻力，直接锻炼了呼吸肌的收缩能力。另外，水环境真的能够给人们带来愉悦的感觉，特别是水流水压给肌肉和筋膜的按摩效果，真的是一举两得的“功能性”训练。</p>
<p>还有，你以为篮球运动员的拳击练习真的只是给枯燥乏味的体能训练增加一点乐趣么？并不是！</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg276m81pj31h50rgtbv.jpg" alt></p>
<p><strong>1. 拳击可以在发生场内冲突的时候很好地保护自己；</strong></p>
<p><strong>2. 拳击运动可以强化旋转动作模式下的速度、稳定、和准确性；</strong></p>
<p><strong>3. 拳击是手脚高度协调的运动，对于发展手脚搭配的动作灵敏有神奇的效果。</strong></p>
<p>而这些不就是一名篮球运动员所需要的么？！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以，功能性原则，解决的是“<strong>为什么练</strong>（for！not why）以及 <strong>练什么</strong>”的问题！</p>
<p>如果我们是简单活动活动身体那就算了，但如果我们要进行一个有针对性的体能训练，那么请琢磨琢磨你选择的动作是否合理，是否能够满足你的专项需求！</p>
<p>所以，招财猫式弹力带抗阻外旋真的是练习肩袖首推的动作么？</p>
<p>所以，蚌式练习和dirty dog真的是发展髋外旋外展能力最好的练习么？</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg28jvnhqj30dw099q3z.jpg" alt></p>
<p>所以，仰卧卷腹发展出来的腹直肌是好看呢？还是好用呢？</p>
<p>所以，我们真的要来一次大清洗，摒弃掉我们以前那些练习么？</p>
<p>当然不要！每一个动作都有它存在的意义，都有它的价值所在！有可能这个动作和你要发展的能力不直接相关，但是它可能是你进行“功能性”训练的基础，你不得不去做它！</p>
<p>所以，训练的逻辑很重要！</p>
<blockquote>
<p>转自<a href="https://zhuanlan.zhihu.com/p/20786373" target="_blank" rel="noopener">《体能训练之功能性》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>日常生活</category>
        <category>锻炼</category>
      </categories>
      <tags>
        <tag>锻炼</tag>
        <tag>日常生活</tag>
      </tags>
  </entry>
  <entry>
    <title>通过漫画形式来解释 ArrayBuffers 和 SharedArrayBuffers</title>
    <url>/2017/08/07/2017-08-07-Programing-JavaScript-ArrayBuffers-SharedArrayBuffers/</url>
    <content><![CDATA[<h1 id="通过漫画形式来解释-ArrayBuffers-和-SharedArrayBuffers"><a href="#通过漫画形式来解释-ArrayBuffers-和-SharedArrayBuffers" class="headerlink" title="通过漫画形式来解释 ArrayBuffers 和 SharedArrayBuffers"></a>通过漫画形式来解释 ArrayBuffers 和 SharedArrayBuffers</h1><p>这是本系列三篇文章中的第二篇：</p>
<ol>
<li><em>内存管理速成手册</em></li>
<li><em>通过漫画形式来解释 ArrayBuffers 和 SharedArrayBuffers</em></li>
<li><em>使用 Atomics 来在 SharedArrayBuffers 中避免竞用条件</em></li>
</ol>
<p>在上一篇中，我解释了一些自动内存管理的语言比如 JavaScript 怎么管理内存。同时我也解释了例如 C 语言，如何进行手动内存管理。</p>
<p>那么这和我们将要讨论的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffers</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" target="_blank" rel="noopener">SharedArrayBuffers</a> 有什么关系呢？这是因为 ArrayBuffer 也使得你能够手动处理数据，尽管这是在 JavaScript 中，一种具有自动内存管理的语言。</p>
<p>那么，你为什么想要进行手动处理呢？正如上一篇文章所描述，在使用自动内存管理上有一个权衡。自动内存管理使得开发者开发程序变得相对容易，但是它也带来了一些困扰。在某些场景中，自动内存管理可能会带来性能上的问题。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_01.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_01-500x285.png" alt="A balancing scale showing that automatic memory management is easier to understand, but harder to make fast"></a></p>
<p>例如，当你使用 JS 创建一个变量的时候，JS 引擎不得不猜测这个 JS 变量所包含数据的类型以及怎样在内存中进行存储。因为这些猜测，JS 引擎通常会为这些变量实际需要的内存分配更大的内存空间。根据不同的变量，分配的内存空间可能是实际所需的 2-8 倍，这将导致极大的内存浪费。除此之外，特性模式的创建和使用 JS 对象也将会使得其很难被 JS 引擎垃圾回收。</p>
<p>如果你正在进行手动的内存管理，你可以根据自己工作上的使用场景自己选择内存分配和解除分配的策略。当时在很多时候，却并不值得这样做。因为在很多使用场景下我们的程序并没有那么性能敏感以至于需要采用手动得内存管理。甚至在通常的使用中，手动内存管理甚至会使得程序更慢。但是在有些时候，你需要从一些更底层的操作来时的你的代码运行的更快，那么 ArrayBuffers 和 SharedArrayBuffers 将是很好的选择。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_02.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_02-500x285.png" alt="A balancing scale showing that manual memory management gives you more control for performance fine-tuning, but requires more thought and planning"></a></p>
<p>那么 ArrayBuffer 是怎么工作的呢？基本上和其他的 JavaScript 数组没有什么区别。除了，当你使用 ArrayBuffer 的时候，你不可以将任意的 JavaScript 数据类型到 ArrayBuffer 中，例如 objects 或者 strings。唯一能够放入 ArrayBuffer 中的只有字节（可以通过数字来表示）。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_03.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_03-500x377.png" alt="Two arrays, a normal array which can contain numbers, objects, strings, etc, and an ArrayBuffer, which can only contain bytes"></a></p>
<p>另外一件我必须明确说明的是，你并不能够直接的将字节放入 ArrayBuffer。这是因为，ArrayBuffer 并不知道一个字节有多大，也不知道不同的数字转化成字节的区别。ArrayBuffer 仅仅是一个「0」和「1」组成一行的二进制串。ArrayBuffer 也不知道分隔符应该放在该二进制串的什么位置。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_04.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_04-500x61.png" alt="A bunch of ones and zeros in a line"></a></p>
<p>为了给 ArrayBuffer 提供上下文，将上面的二进制串分割在相同尺寸的盒子里，我们需要一个称作「视窗」概念将二进制串分割到不同的盒子里。这些二进制数据上的视窗可以以带类型的数组存储，同时在 ArrayBuffer 中有不同带类型数组。比如，你可以通过 8 位整数的类型数组将上面的 ArrayBuffer 8 位一字节分割开来。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_05.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_05-500x177.png" alt="Those ones and zeros broken up into boxes of 8"></a></p>
<p>或者你可以使用无符号 16 位整数的数组，这样就将上面的 ArrayBuffer 分割成了 16 位一字节的不同块中，然后依然想无符号整数一样对其操作。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_06.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_06-500x153.png" alt="Those ones and zeros broken up into boxes of 16"></a></p>
<p>你甚至可以在同一个基础 buffer 上面拥有不同的「视窗」。不同的「视窗」在相同的操作下会带来不同的结果。比如，在 Int8 视窗中，你可能会得到 <code>0 &amp; 1</code> 表达式，而在同样的 buffer 下，在 Uint16 视窗下你可能会得到其他结果，尽管他们都拥有相同的二进制位串。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_07.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_07-500x262.png" alt="Those ones and zeros broken up into boxes of 16"></a></p>
<p>在上面描述得工作方式下，ArrayBuffer 的角色仅仅是向一块原始的内存。它模拟了像在 C 语言中直接获取\操作 内存的工作。你可能会产生疑问，为什么 JS 不直接提供给使用者直接获取/操作内存的接口而是添加 ArrayBuffer 这一抽象层呢？这是因为直接获取/操作内存可能会导致一些安全漏洞。我将在将来的文章中讨论这一块内容。那么，SharedArrayBuffers 又是什么呢？</p>
<p>为了解释 SharedArrayBuffers，我需要先简略解释 JavaScript 中并行运行代码。为了并行运行代码，你需要将工作拆分成不同部分。但是在一个典型的 app 中，所有的工作都是在一个独立的线程中完成。在之前的文章中我也提及过这一点…这个主线程就像一个全栈工程师一样。它掌管着 JavaScript、DOM、以及视图布局。所有你能够操作的工作都是在这个主线程帮助下完成的。在某些特定环境下，ArrayBuffers 可以减轻主线程的负担，代替完成主线程的部分工作。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_08.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_08-500x350.png" alt="The main thread standing at its desk with a pile of paperwork. The top part of that pile has been removed"></a></p>
<p>但是有时候减少主线程的工作依然是不够的。有时候你需要引进增援…你需要将工作分开。在很多编程语言中，将工作分成不同块每一块也就称作一个线程。这个多人共同完成一个项目是一个道理。</p>
<p>如果你有一些任务，同时该任务和其他任务相对独立，那么你就可以在其他线程中完成这些任务。因此，不同的线程就可以在同一时间完成互相独立的分离任务。在 JavaScript 中，我们可以通过被称作<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">web worker</a>的工具来完成以上工作。这些 web workers 与您在其他语言中使用的线程略有不同。默认情况下，它们不共享内存。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_09.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_09-500x360.png" alt="Two threads at desks next to each other. Their piles of paperwork are half as tall as before. There is a chunk of memory below each, but not connected to the other&#39;s memory"></a></p>
<p>这也就意味着，如果你想和其他线程共享数据，那么你就需要将数据从一个地方复制到另外一个地方。这是通过函数<a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" target="_blank" rel="noopener">postMessage</a> 完成的。postMessage 将所有输入的对象序列化，将其发送到另一个 web worker，并将其反序列化并放入内存中。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_10.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_10-500x355.png" alt="Thread 1 shares memory with thread 2 by serializing it, sending it across, where it is copied into thread 2&#39;s memory"></a></p>
<p>这事一个相当慢的过程，比如一些类型的数据，像 ArrayBuffers，你可以转移内存。这意味着你可以将某一特定的内存块移动到其他地方，这样其他的 web worker 就可以获取/操作 该内存块。但是之前的 web worker 将不能够再获取到该内存块了。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_11.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_11-500x360.png" alt="Thread 1 shares memory with thread 2 by transferring it. Thread 1 no longer has access to it"></a></p>
<p>这也许在某些场景中适用，但是在更多的情况，你可能需要更高效得并行策略，在这些场景下，你可能真实的想要共享内存单元。ShareArrayBuffer 能够帮助你达到此目的。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_12.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_12-500x349.png" alt="The two threads get some shared memory which they can both access"></a></p>
<p>通过 ShareArrayBuffer，web worker、不同线程可以在相同的内存块中读写数据。这也意味着你不爱需要通过 postMessage 来在不同的线程中通信传递数据。不同的 web worker 都有获取/操作数据的权限。但是这也会带来一些问题，比如两个线程在同一时间对数据进行操作。这也就是通常被称作「竞用条件」的现象。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13-500x201.png" alt="Drawing of two threads racing towards memory"></a></p>
<p>我将在<a href="https://hacks.mozilla.org/2017/06/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/" target="_blank" rel="noopener">下一篇文章</a>中解释什么是竞用条件。那么 SharedArrayBuffers 现阶段处于什么地位呢？庆幸得，在不久的将来，所有主流浏览器都贱支持 SharedArrayBuffers。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_14.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_14-500x169.png" alt="Logos of the major browsers high-fiving"></a></p>
<p>SharedArrayBuffers 在 Safari（Safari 10.1）中已经可以使用。Firefox 和 Chrome 也将在今年的七八月发布的版本中包含此项功能。Edge 浏览器计划在今年的秋天完成此项功能的更新。但是即使所有主流浏览器都已经支持 SharedArrayBuffers，我们也不希望应用程序开发人员直接使用它。</p>
<p>实际上，我们发对这样做。你应该在其之上进行抽象，使用更高层的一些库。我们所期待的是框架或库的开发者们能够创建一些工具库，这些工具库能够帮助我们更方便、安全的使用 SharedArrayBuffer。除此之外，一旦 SharedArrayBuffers 在平台上实现，WebAssembly 可以使用它来实现多线程。到时候，你就能够向 Rust 语言一样使用并发的抽象层，它将无所畏惧得将并发作为其主要目标。在下一篇文章中，我们将解释工具（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics" target="_blank" rel="noopener">Atomics</a> ）以及工具开发者是怎样来实现这一抽象层并如何避免竞用条件的。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15-500x335.png" alt="Layer diagram showing SharedArrayBuffer + Atomics as the foundation, and JS libaries and WebAssembly threading building on top"></a></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理速成手册</title>
    <url>/2017/08/05/2017-08-05-Programing-JavaScript-Memory-Manager/</url>
    <content><![CDATA[<h2 id="内存管理速成手册"><a href="#内存管理速成手册" class="headerlink" title="内存管理速成手册"></a>内存管理速成手册</h2><blockquote>
<p><a href="https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management/" target="_blank" rel="noopener">原文地址</a></p>
<p>_这是本系列文章中的第一篇：</p>
</blockquote>
<ol>
<li><em>内存管理速成手册</em></li>
<li><em>通过漫画形式来解释 ArrayBuffers 和 SharedArrayBuffers</em></li>
<li><em>使用 Atomics 来在 SharedArrayBuffers 中避免竞用条件</em></li>
</ol>
<p>在弄懂 <code>ArrayBuffer</code> 和 <code>SharedArrayBuffer</code> 为什么添加到 JavaScript 之前，你首先需要了解一些关于内存管理的知识。你可以把机器中的内存比喻成一组箱子，就像我把内存想象成办公室内部的信箱一样，或者是为学龄前儿童准备的用于存储杂物的小房间，如果你想给某位孩子准备一些礼物，你可以将物品放到某个箱子里。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_01.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_01-500x353.png" alt="A column of boxes with a child putting something in one of the boxes"></a></p>
<p>在每个箱子旁边都有一个与之对应的数字，这就是内存地址。正是因为有了地址，你才能够告诉别人你为其准备动物品存放的位置。每个箱子具有相同的尺寸，也因此每个内存箱子也具有相同的容量来存储信息。箱子的尺寸是根据不同的机器而定的。箱子的尺寸被称作「字长」。它通常被标识为「32 位」或者「64 位」。但是为了简单的展示，在本文中我们使用「8 位」的字长。（译者注：一个字长包含 8 个二进制位，也就是说一个内存单元的容量是 8 位）</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_02.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_02-500x121.png" alt="A box with 8 smaller boxes in it"></a></p>
<p>如果你打算将数字 2 放进其中一个内存箱子里，这将非常容易做到，因为数字可以很容易通过二进制来表示。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_03.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_03-500x229.png" alt="The number two, converted to binary 00000010 and put inside the boxes"></a></p>
<p>倘若我们想放入内存箱子中的不是数字，而比如是字母「H」，怎么办呢？我们需要通过某种方法将其转化成可以使用数字来表示。为了完成此项工作，我们需要编码。类似于 <a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a> 。同时我们需要某种工具来按照 UTF-8 中的对应关系将字符转化成数字…比如说一个编码环。有了编码和编码环后，我们就可以将任意字符存入到内存箱子中了。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_04.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_04-500x277.png" alt="The letter H, put through an encoder ring to get 72, which is then converted to binary and put in the boxes"></a></p>
<p>当我们打算将我们存入内存箱子中的信息取出时，我们需要将其放入一个解码器中，通过解码器将存放的数字转换成字母「H」。当你使用 JavaScript 工作时，你无须关心内存是怎样分配和使用的，因为在 JavaScript 中内存是自动管理的，内存管理和你的代码完全隔离。这意味着你不能够直接操作内存。JS 引擎将作为中介的角色，帮我们管理内存。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_05.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_05-500x371.png" alt="A column of boxes with a rope in front of it and the JS engine standing at that rope like a bouncer"></a></p>
<p>让我们一些 JS 代码，比如在 React 中，我们需要创建一个变量并对其赋值。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_06.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_06-500x373.png" alt="Same as above, with React asking the JS engine to create a variable"></a></p>
<p>JS 引擎的工作就是通过编码器将变量名转换成二进制表示。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_07.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_07-500x370.png" alt="The JS engine using an encoder ring to convert the string to binary"></a></p>
<p>然后在内存中找到闲余的空间用来存放上面转换后的二进制表示。这一过程被称作分配内存。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_08.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_08-500x367.png" alt="The JS engine finding space for the binary in the column of boxes"></a></p>
<p>接下来，JS 引擎会跟踪该变量并判断在程序中该变量是否还能够获取到。如果该变量不能够再被获取到，那么该内存箱子将会被回收再利用，以便 JS 引擎能够分配新的值到该内存中。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_09.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_09-500x379.png" alt="The garbage collector clearing out the memory"></a></p>
<p>JS 引擎监听变量所代表的字符串、对象、以及内存中的其他数据类型的数据，当这些值不能再被获取到的时候，JS 引擎将会把它们清除出内存，这一过程被称作「垃圾回收」。比如 JavaScript 语言，代码不能够直接操纵内存，被称作自动内存管理语言。这一自动内存管理机制会使得开发变得相对简单。但是自动内存管理也会带来一些头疼的地方。比如自动内存管理可能会带来性能不可预测。而手动进行内存管理的语言就不会有这些问题。比如，通过 C 语言内存管理的方式来写 React 代码（当然，通过<a href="https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/" target="_blank" rel="noopener">WebAssembly</a> 已经使得其<a href="https://www.youtube.com/watch?v=3GHJ4cbxsVQ" target="_blank" rel="noopener">成为现实</a>）。C 语言没有 JavaScript 自动内存管理的这一层功能抽象。所以，你可以直接操作内存，你可以从内存中对去数据，你也可以操作内存将数据存入内存中。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_10.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_10-500x360.png" alt="A WebAssembly version of React working with memory directly"></a></p>
<p>当你讲其它语言比如 C 语言传递给 WebAssembly，你使用的工具将会添加一些代码到 WebAssembly 中，比如，将添加对字节进行编码和解码的代码。这些代码被称作运行时环境。运行时环境也将像 JS 引擎在 JavaScript 语言中的作用一样，处理一些与之相同的工作。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_11.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_11-500x361.png" alt="An encoder ring being shipped down as part of the .wasm file"></a></p>
<p>但是对于手动内存管理的语言来说，运行时环境并不包含垃圾回收。这就意味着你必须手动来进行垃圾回收，即使是手动内存管理的语言，你通常也可以从该语言运行时环境中获取一些帮助。比如，在 C 语言中，C 语言运行时将会跟踪那些未被使用的内存，并将内存地址存储在一个链表中，该列表被称作「free list」。</p>
<p><a href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_12.png" target="_blank" rel="noopener"><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_12-500x360.png" alt="A free list next to the column of boxes, listing which boxes are free right now"></a></p>
<p>你可以使用 <code>malloc</code> 函数（memory allocate 简写）来请求运行时环境来寻找能够存放你数据的内存地址。这会使得这些内存地址从「free list」中移除。当你使用数据完成工作后，你必须通过<code>free</code>函数来讲该内存释放。</p>
<p>这样该内存地址将会被重新添加至「free list」中。你必须知道什么时候该调用这些函数。这也是为什么称为手动内存管理的原因所在 -- 你完全自己管理程序中的内存。作为开发者，断定什么时候该清除内存是一件相当困难的事。</p>
<p>如果在错误的时间点清除内存，将导致程序 bug，甚至一些安全漏洞。如果不对不在使用的内存进行处理，又将导致内存用尽。这也就是为什么现代语言都是用自动内存管理的原因 -- 避免人为错误。但是这也将会产生一些性能上的问题。</p>
<p>将在<a href="https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/" target="_blank" rel="noopener">下一篇</a>对此进行说明。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 实现自己的 Promise</title>
    <url>/2017/04/01/2017-04-01-Programing-JavaScript-drive-promise-in-ES6/</url>
    <content><![CDATA[<h2 id="一、JavaScript-异步编程背景"><a href="#一、JavaScript-异步编程背景" class="headerlink" title="一、JavaScript 异步编程背景"></a>一、JavaScript 异步编程背景</h2><p>​ 从去年 ES2015 发布至今，已经过去了一年多，ES2015 发布的新的语言特性中最为流行的也就莫过于 Promise 了，Promise 使得如今 JavaScript 异步编程如此轻松惬意，甚至慢慢遗忘了曾经那不堪回首的痛楚。</p>
<p>其实从 JavaScript 诞生，JavaScript 中的异步编程就已经出现，例如点击鼠标、敲击键盘这些事件的处理函数都是异步的，时间到了 2009 年，Node.js 横空出世，在整个 Node.js 的实现中，将回调模式的异步编程机制发挥的淋漓尽致，Node 的流行也是的越来越多的 JavaScripter 开始了异步编程，但是回调模式的副作用也慢慢展现在人们眼前，错误处理不够优雅以及嵌套回调带来的“回调地狱”。</p>
<p>这些副作用使得人们从回调模式的温柔乡中慢慢清醒过来，开始寻找更为优雅的异步编程模式，路漫漫其修远兮、吾将上下而求索。时间到了 2015 年，Promise 拯救那些苦苦探索的先驱。行使它历史使命的时代似乎已经到来。</p>
<p>​每个事物的诞生有他的历史使命，更有其历史成因，促进其被那些探索的先驱们所发现。<br>了解 nodejs 或者熟悉浏览器的人都知道，JavaScript 引擎是基于事件循环或单线程这两个特性的。更为甚者在浏览器中，更新 UI(也就是浏览器重绘、重拍页面布局)和执行 JavaScript 代码也在一个单线程中，可想而知，一个线程就相当于只有一条马路，如果一辆马车抛锚在路上了阻塞了马路，那么别的马车也就拥堵在了那儿，这个单线程容易被阻塞是一个道理，单线程也只能允许某一时间点只能够执行一段代码。<br>同时，JavaScript 没有想它的哥哥姐姐们那么财大气粗，像 Java 或者 C++，一个线程不够，那么再加一个线程，这样就能够同时执行多段代码了，但是这样就会带来的隐患就是状态不容易维护，JavaScript 选择了单线程非阻塞式的方式，也就是异步编程的方式，就像上面的马车抛锚在了路上，那么把马车推到路边的维修站，让其他马车先过去，等马车修好了再回到马路上继续行驶，这就是单线程非阻塞方式。正如 Promise 的工作方式一样，通过 Promise 去向服务器发起一个请求，毕竟请求有网络开销，不可能马上就返回请求结果的，这个时候 Promise 就处于 pending 状态，但是其并不会阻塞其他代码的执行，当请求返回时，修改 Promise 状态为 fulfilled 或者 rejected（失败请求）。同时执行绑定到这两个状态上面的“处理函数”。这就是异步编程的模式，也就是 Promise 兢兢业业的工作方式，在下面一个部分将详细讨论 Promise。</p>
<h2 id="二、Promise-基础"><a href="#二、Promise-基础" class="headerlink" title="二、Promise 基础"></a>二、Promise 基础</h2><p>​ 怎么一句话解释 Promise 呢？Promise 可以代指那些尚未完成的一些操作，但是其在未来的某个时间会返回某一特定的结果。</p>
<p>​ 当创建一个 Promise 实例后，其代表一个未知的值，在将来的某个时间会返回一个成功的返回值，或者失败的返回值，我们可以为这些返回值添加处理函数，当值返回时，处理函数被调用。Promise 总是处于下面三种状态之一：</p>
<ul>
<li>pending： Promise 的初始状态，也就是未被 fulfilled 或者 rejected 的状态。</li>
<li>fulfilled： 意味着 promise 代指的操作已经成功完成。</li>
<li>rejected：意味着 promise 代指的操作由于某些原因失败。</li>
</ul>
<p>一个处于 pending 状态的 promise 可能由于某个成功返回值而发展为 fulfilled 状态，也有可能因为某些错误而进入 rejected 状态，无论是进入 fulfilled 状态或者 rejected 状态，绑定到这两种状态上面的处理函数就会被执行。并且进入 fulfilled 或者 rejected 状态也就不能再返回 pending 状态了。</p>
<a id="more"></a>
<h2 id="三、边学边写"><a href="#三、边学边写" class="headerlink" title="三、边学边写"></a>三、边学边写</h2><p>上面说了那么多，其实都是铺垫。接下来我们就开始实现自己的 Promise 对象。go go go！！！</p>
<h3 id="第一步：Promise-构造函数"><a href="#第一步：Promise-构造函数" class="headerlink" title="第一步：Promise 构造函数"></a>第一步：Promise 构造函数</h3><p>Promise 有三种状态，pending、fulfilled、rejected。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span> <span class="comment">// Promise 的 初始状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span> <span class="comment">// Promise 成功返回后的状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span> <span class="comment">// Promise 失败后的状态</span></span><br></pre></td></tr></table></figure>
<p>有了三种状态后，那么我们怎么创建一个 Promise 实例呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(executor) <span class="comment">// 创建 Promise 的语法</span></span><br></pre></td></tr></table></figure>
<p>通过上面生成 promise 语法我们知道，Promise 实例是调用 Promise 构造函数通过 new 操作符生成的。这个构造函数我们可以先这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING <span class="comment">// 创建一个 promise 时，首先进行状态初始化。pending</span></span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span> <span class="comment">// result 属性用来缓存 promise 的返回结果，可以是成功的返回结果，或失败的返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到上面构造函数接受的参数 executor。它是一个函数，并且接受其他两个函数（resolve 和 reject）作为参数，当 resolve 函数调用后，promise 的状态转化为 fulfilled，并且执行成功返回的处理函数（不用着急后面会说到怎么添加处理函数）。当 reject 函数调用后，promise 状态转化为 rejected，并且执行失败返回的处理函数。</p>
<p>现在我们的代码大概是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING</span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    executor(<span class="function"><span class="params">data</span> =&gt;</span> resolveProvider(<span class="keyword">this</span>, data), err =&gt; rejectProvider(<span class="keyword">this</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveProvider</span>(<span class="params">promise, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = FULFILLED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejectProvider</span>(<span class="params">promise, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = FULFILLED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dont Repeat Yourselt！！！我们可以看到上面代码后面两个函数基本相同，其实我们可以把它整合成一个函数，在结合高阶函数的使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = status</span><br><span class="line">    promise.result = data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">        executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们的代码就看上去简洁多了。</p>
<h3 id="第二步：为-Promise-添加处理函数"><a href="#第二步：为-Promise-添加处理函数" class="headerlink" title="第二步：为 Promise 添加处理函数"></a>第二步：为 Promise 添加处理函数</h3><p>其实通过 new Promise(executor)已经可以生成一个 Promise 实例了，甚至我们可以通过传递到 executor 中的 resolve 和 reject 方法来改变 promise 状态，但是！现在的 promise 依然没啥卵用！！！因为我们并没有给它添加成功和失败返回的处理函数。</p>
<p>首先我们需要给我们的 promise 增加两个属性，successListener 和 failureListener 用来分别缓存成功处理函数和失败处理函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING</span><br><span class="line">        <span class="keyword">this</span>.successListener = []</span><br><span class="line">        <span class="keyword">this</span>.failureListener = []</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">        executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么添加处理函数呢？ECMASCRIPT 标准中说到，我们可以通过 promise 原型上面的 then 方法为 promise 添加成功处理函数和失败处理函数，可以通过 catch 方法为 promise 添加失败处理函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = status</span><br><span class="line">    promise.result = data</span><br><span class="line">    <span class="keyword">switch</span>(status) &#123;</span><br><span class="line">        <span class="keyword">case</span> FULFILLED: <span class="keyword">return</span> promise.successListener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line">        <span class="keyword">case</span> REJECTED: <span class="keyword">return</span> promise.failurelistener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING</span><br><span class="line">        <span class="keyword">this</span>.successListener = []</span><br><span class="line">        <span class="keyword">this</span>.failurelistener = []</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">        executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Promise 原型上面的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    then(...args) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">            <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">                <span class="keyword">this</span>.successListener.push(args[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">this</span>.failurelistener.push(args[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">                args[<span class="number">0</span>](<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">                args[<span class="number">1</span>](<span class="keyword">this</span>.result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在的 Promise 基本初具雏形了。甚至可以运用到一些简单的场景中了。举个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个延时 resolve 的 pormise*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">5</span>), <span class="number">2000</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">/* 创建一个及时 resolve 的 promise*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="number">5</span>)).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">/* 链式调用 then 方法还不能够使用！*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span> resolve(<span class="number">5</span>)).then(<span class="function"><span class="params">data</span> =&gt;</span> data).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read property 'then' of undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="第三步：Promise-的链式调用"><a href="#第三步：Promise-的链式调用" class="headerlink" title="第三步：Promise 的链式调用"></a>第三步：Promise 的链式调用</h3><p>Promise 需要实现链式调用，我们需要再次回顾下 then 方法的定义：</p>
<p>then 方法为 pormise 添加成功和失败的处理函数，同时 then 方法返回一个新的 promise 对象，这个新的 promise 对象 resolve 处理函数的返回值，或者当没有提供处理函数时直接 resolve 原始的值。</p>
<p>可以看出，promise 能够链式调用归功于 then 方法返回一个全新的 promise，并且 resolve 处理函数的返回值，当然，如果 then 方法的处理函数本身就返回一个 promise，那么久不用我们自己手动生成一个 promise 了。了解了这些，就开始动手写代码了。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isPromise = <span class="function"><span class="params">object</span> =&gt;</span> object &amp;&amp; object.then &amp;&amp; <span class="keyword">typeof</span> object.then === <span class="string">'function'</span></span><br><span class="line"><span class="keyword">const</span> noop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 同上面代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line"><span class="comment">// 同上面代码</span></span><br><span class="line">&#125;</span><br><span class="line">then(...args) &#123;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(noop)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> handler = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = fn(data)</span><br><span class="line">                <span class="keyword">if</span> (isPromise(result)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> successHandler = child.successListener[<span class="number">0</span>]</span><br><span class="line">    	    <span class="keyword">const</span> errorHandler = child.failureListener[<span class="number">0</span>]</span><br><span class="line">    	    result</span><br><span class="line">    	    .then(successHandler, errorHandler)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    statusProvider(child, FULFILLED)(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!fn) &#123;</span><br><span class="line">                statusProvider(child, <span class="keyword">this</span>.status)(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">            <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">                <span class="keyword">this</span>.successListener.push(handler(args[<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">this</span>.failureListener.push(handler(args[<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">                handler(args[<span class="number">0</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">                handler(args[<span class="number">1</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, arg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们写了一个 isPromise 方法，用于判断一个对象是否是 promise。就是判断对象是否有一个 then 方法，免责声明为了实现上的简单，我们不区分 thenable 和 promise 的区别，但是我们应该是知道。所有的 promise 都是 thenable 的，而并不是所有的 thenable 对象都是 promise。（thenable 对象是指带有一个 then 方法的对象，该 then 方法其实就是一个 executor。）isPromise 的作用就是用于判断 then 方法返回值是否是一个 promise，如果是 promise，就直接返回该 promise，如果不是，就新生成一个 promise 并返回该 promise。</p>
<p>​由于需要链式调用，我们对 successListener 和 failureListener 中处理函数进行了重写，并不是直接 push 进去 then 方法接受的参数函数了，因为 then 方法需要返回一个 promise，所以当 then 方法里面的处理函数被执行的同时，我们也需要对 then 方法返回的这个 promise 进行处理，要么 resolve，要么 reject 掉。当然，大部分情况都是需要 resolve 掉的，只有当 then 方法没有添加第二个参数函数，同时调用 then 方法的 promise 就是 rejected 的时候，才需要把 then 方法返回的 pormise 进行 reject 处理，也就是调用 statusProvider(child, REJECTED)(data).</p>
<p>Promise 实现的完整代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span> <span class="comment">// Promise 的 初始状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span> <span class="comment">// Promise 成功返回后的状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span> <span class="comment">// Promise 失败后的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isPromise = <span class="function"><span class="params">object</span> =&gt;</span> object &amp;&amp; object.then &amp;&amp; <span class="keyword">typeof</span> object.then === <span class="string">'function'</span></span><br><span class="line"><span class="keyword">const</span> noop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">promise.status = status</span><br><span class="line">promise.result = data</span><br><span class="line"><span class="keyword">switch</span>(status) &#123;</span><br><span class="line"><span class="keyword">case</span> FULFILLED: <span class="keyword">return</span> promise.successListener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line"><span class="keyword">case</span> REJECTED: <span class="keyword">return</span> promise.failureListener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING</span><br><span class="line">    <span class="keyword">this</span>.successListener = []</span><br><span class="line">    <span class="keyword">this</span>.failureListener = []</span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Promise 原型上面的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    then(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(noop)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> handler = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = fn(data)</span><br><span class="line">                <span class="keyword">if</span> (isPromise(result)) &#123;</span><br><span class="line">                    	<span class="keyword">const</span> successHandler = child.successListener[<span class="number">0</span>]</span><br><span class="line">    		<span class="keyword">const</span> errorHandler = child.failureListener[<span class="number">0</span>]</span><br><span class="line">    		result</span><br><span class="line">    		.then(successHandler, errorHandler)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    statusProvider(child, FULFILLED)(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!fn) &#123;</span><br><span class="line">                statusProvider(child, <span class="keyword">this</span>.status)(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">            <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">                <span class="keyword">this</span>.successListener.push(handler(args[<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">this</span>.failurelistener.push(handler(args[<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">                handler(args[<span class="number">0</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">                handler(args[<span class="number">1</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="四、怎么让我们的-toy-Promise-变强健"><a href="#四、怎么让我们的-toy-Promise-变强健" class="headerlink" title="四、怎么让我们的 toy Promise 变强健"></a>四、怎么让我们的 toy Promise 变强健</h3><p>在 ECMAScript 标准中，Promise 构造函数上面还提供了一些静态方法，比如 Promise.resolve、Promise.reject、Promsie.all、Promise.race。当我们有了上面的基础实现后，为我们的 toy Promise 添加上面这些新的功能一定能让其更加实用。</p>
<p>在我们的基本实现中，我们并没有区分 thenable 对象，其实 Promise.resolve 和 then 方法都可以接受一个 thenable 对象，并把该 thenable 对象转化为一个 promise 对象，如果想让我们的 toy Promise 用于生产的话，这也是要考虑的。</p>
<p>为了让我们的 toy Promise 变得更强壮，我们需要拥有强健的错误处理机制，比如验证 executor 必须是一个函数、then 方法的参数只能是函数或者 undefined 或 null，又比如 executor 和 then 方法中抛出的错误并不能够被 window.onerror 监测到，而只能够通过错误处理函数来处理，这也是需要考虑的因素。</p>
<p>如果我们的 <code>Promise polyfill</code> 是考虑支持多平台，那么首要考虑的就是浏览器环境或 Node.js 环境，其实在这两个平台，原生 Promise 都是支持两个事件的。就拿浏览器端举例：</p>
<p>unhandledrejection: 在一个事件循环中，如果我们没有对 promise 返回的错误进行处理，那么就会在 window 对象上面触发该事件。<br>rejectionhandled:如果在一个事件循环后，我们才去对 promise 返回的错误进行处理，那么就会在 window 对象上面监听到此事件。<br>关于这两个事件以及 node.js 平台上面类似的事件请参考 Nicholas C. Zakas 新书</p>
<p>Promise 能够很棒的处理异步编程，要想学好它我认为最好的方法就是亲自动手去实现一个自己的 Promise。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 修改历史记录</title>
    <url>/2017/03/24/2017-03-24-Programing-Git-Git-change-history/</url>
    <content><![CDATA[<h2 id="聊聊-Git-「改变历史」"><a href="#聊聊-Git-「改变历史」" class="headerlink" title="聊聊 Git 「改变历史」"></a>聊聊 Git 「改变历史」</h2><p>在本篇文章中，聊聊 Git 怎么改变历史记录。</p>
<h2 id="重写最后一次提交"><a href="#重写最后一次提交" class="headerlink" title="重写最后一次提交"></a>重写最后一次提交</h2><p>在我们开发的过程中，我们经常会遇到这样的问题，当我们进行了一次「冲动」的 Git 提交后。发现我们的 commit 信息有误，或者我们把不应该这次提交的文件添加到了此次提交中，或者有的文件忘记提交了，怎么办？这些问题都可以通过如下命令来进行弥补。</p>
<blockquote>
<p>git commit —amend</p>
</blockquote>
<p>举个例子，在一个刚初始化的 Git 仓库中，有如下两个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">total 0</span><br><span class="line">-rw-r--r--  1 ransixi  staff     0B  9 19 16:35 should-commit.js</span><br><span class="line">-rw-r--r--  1 ransixi  staff     0B  9 19 16:35 should-not-commit.js</span><br></pre></td></tr></table></figure>
<p>其中 should-commit.js 文件应该被提交，而 should-not-commit.js 不应该被提交，但是由于「冲动」，我把 should-not-commit.js 文件提交了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其实应该添加 should-commit.js 文件</span></span><br><span class="line">git add should-not-commit.js</span><br><span class="line"><span class="meta">#</span><span class="bash"> 啊哈，由于笔误，我把 commit 写成了 commmit</span></span><br><span class="line">git commit -m 'commmit 1'</span><br></pre></td></tr></table></figure>
<p>通过 git log 命令打印下当前的历史提交记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit fba6199e7fd5f325cc0bfcec4c599c93603d48f8 (HEAD -&gt; master)</span><br><span class="line">Author: ran.luo03 &lt;ran.luo03@ele.me&gt;</span><br><span class="line">Date:   Tue Sep 19 16:49:57 2017 +0800</span><br><span class="line"></span><br><span class="line">    commmit 1</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这样的错误的提交一定不能够给别人看到！是时候该祭出 git commit —amend 了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先，需要将 should-commit.js 文件添加到暂存区</span></span><br><span class="line">git add should-commit.js</span><br><span class="line"><span class="meta">#</span><span class="bash"> 其次，将 should-not-commit.js 文件从已暂存状态转为未暂存状态，不会删除 should-not-commit.js 文件。</span></span><br><span class="line">git rm --cache should-not-commit.js</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后，通过git commit --amend 修改提交信息</span></span><br><span class="line">git commit--amend</span><br></pre></td></tr></table></figure>
<p>当键入 git commit —amend 命令后，会打开 Git 默认编辑器，内容包括了上次错误提交的信息，我们只需将 commmit 1 改为 commit 1 就行了，然后保存退出编辑器。这样我们就完成了错误提交的修改，让我们再通过 git log 来查看一下历史提交记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit 2a410384e14dadaff9b98f823b9f239da055637d (HEAD -&gt; master)</span><br><span class="line">Author: ran.luo03 &lt;ran.luo03@ele.me&gt;</span><br><span class="line">Date:   Tue Sep 19 16:49:57 2017 +0800</span><br><span class="line"></span><br><span class="line">    commit 1</span><br></pre></td></tr></table></figure>
<p>啊哈，整个历史记录中只有我最新修改后的历史提交，你完全找不到上一次的提交踪迹了。是不是很酷呢？</p>
<p><strong>思考 1：</strong>怎么使用 git reset 命令修改最后一次提交记录？</p>
<h2 id="多个提交合并、排序、删除操作"><a href="#多个提交合并、排序、删除操作" class="headerlink" title="多个提交合并、排序、删除操作"></a>多个提交合并、排序、删除操作</h2><p>在一个大型项目中，为了保持提交历史的简洁和可逆，往往一个功能点或者一个 bug fix 对应一个提交，但是在我们实际开发的过程中，我们并不是完成整个功能才进行一次提交的，往往是开发了功能点的一部分，就需要给小伙伴们进行 code review，小的 commit 保证了 code review 的效率和准确性，想象一下如果一次给小伙伴 review 上千行代码，几十个文件，他一定会疯掉的。同时 code review 后的反馈，我们可能需要修改代码，然后再次提交。但是这些提交之间的反复修改不应该体现在最终的 PR 上面，因此， 我们需要根据功能点的前后对 commit 进行排序，对相同功能的 commits 进行合并，并删除一些不需要的 commit，根据最终的提交历史提 PR。</p>
<p>举个例子，将王之涣的<strong>登鹳雀楼</strong>摘抄到我的读书笔记中。</p>
<p>首先创建 poem 文件，将「黄河入海流」这句诗添加到了文件中，创建第一个 commit 如下：</p>
<p>通过 git log —oneline 命令来看看提交记录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">da5ee49 (HEAD -&gt; master) add 黄河入海流</span><br></pre></td></tr></table></figure>
<p>后来觉得，摘抄一句有些单调，不如将其前面一句也摘抄到笔记中吧，于是又出现了第二个 commit 如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">622c3c8 (HEAD -&gt; master) add 百日依山尽</span><br><span class="line">da5ee49 add 黄河入海流</span><br></pre></td></tr></table></figure>
<p>…</p>
<p>觉得自己太随性，摘抄一首诗竟然添加了如此之多的 commits，commits 如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">953aabb (HEAD -&gt; master) add 文章出处</span><br><span class="line">7fad941 add 摘抄时间</span><br><span class="line">731d00b add 作者：王焕之</span><br><span class="line">9a22044 add 标题：登鹳雀楼</span><br><span class="line">4fee22a add 更上一层楼</span><br><span class="line">d1293c5 add 欲穷千里目</span><br><span class="line">622c3c8 add 百日依山尽</span><br><span class="line">da5ee49 add 黄河入海流</span><br></pre></td></tr></table></figure>
<p>再看看上面的提交历史，觉得如此多的 commits 确实有些冗余了，commits 的顺序似乎也有些问题，因为 commits 的顺序并不是按照正常摘抄一首诗的顺序来组织的。而且觉得添加摘抄时间有些多余了，git 的历史提交记录就已经帮我记录了添加时间。</p>
<p>让我们来一步一步通过「重写历史」来修改上面的问题。</p>
<p>这次我使用的命令是 git rebase -i 或者 git rebase - -interactive， Git 官方文档对其如下解释：</p>
<blockquote>
<p>Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode can also be used to split commits</p>
</blockquote>
<p>可以看出，该命令罗列了将要 rebase 的提交记录，打开 Git 设置的编辑器，让用户有更多的选择，可以进行 commit 合并，对 commits 重新排序，删除 commit 等。</p>
<p><strong>第一步：删除「add 摘抄时间」commit</strong></p>
<p>运行命令</p>
<blockquote>
<p>git rebase -i HEAD~2</p>
</blockquote>
<p>Git 打开默认编辑器，出来如下对话信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick 7fad941 add 摘抄时间</span><br><span class="line">pick 953aabb add 文章出处</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Rebase 731d00b..953aabb onto 731d00b (2 commands)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Commands:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> p, pick = use commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> e, edit = use commit, but stop <span class="keyword">for</span> amending</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> f, fixup = like <span class="string">"squash"</span>, but discard this commit<span class="string">'s log message</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x, <span class="built_in">exec</span> = run <span class="built_in">command</span> (the rest of the line) using shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> d, drop = remove commit</span></span><br></pre></td></tr></table></figure>
<p>上面的对话信息中包含七条可选命令，很明显最后一条 d，drop 正式我需要的，因为我正打算删除 commit。于是我把第一行中的 pick 命令改为了 drop 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drop 7fad941 add 摘抄时间</span><br><span class="line">pick 953aabb add 文章出处</span><br></pre></td></tr></table></figure>
<p>保存并推出编辑器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Auto-merging poem</span><br><span class="line">CONFLICT (content): Merge conflict in poem</span><br><span class="line">error: could not apply 953aabb... add 文章出处</span><br><span class="line"></span><br><span class="line">When you have resolved this problem, run "git rebase --continue".</span><br><span class="line">If you prefer to skip this patch, run "git rebase --skip" instead.</span><br><span class="line">To check out the original branch and stop rebasing, run "git rebase --abort".</span><br><span class="line"></span><br><span class="line">Could not apply 953aabb... add 文章出处</span><br></pre></td></tr></table></figure>
<p>OMG!竟然竟然提示 poem 文件中有冲突！打开 poem 文件，手动删除不需要的内容及冲突的标记符号，按照上面的提示，运行 git rebase —continue 命令。心想，这下总该好了吧！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">poem: needs merge</span><br><span class="line">You must edit all merge conflicts and then</span><br><span class="line">mark them as resolved using git add</span><br></pre></td></tr></table></figure>
<p>rebase 依然没有成功，原来忘记将解决冲突的修改添加到暂存区了，通过运行 git add 命令后，再次执行 git rebase —continue。</p>
<p>出来一个对话框，提示我可以修改 commit 信息，没有修改，直接保存退出。来看看此时的提交历史记录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">b8f0233 (HEAD -&gt; master) add 文章出处</span><br><span class="line">731d00b add 作者：王焕之</span><br><span class="line">9a22044 add 标题：登鹳雀楼</span><br><span class="line">4fee22a add 更上一层楼</span><br><span class="line">d1293c5 add 欲穷千里目</span><br><span class="line">622c3c8 add 百日依山尽</span><br><span class="line">da5ee49 add 黄河入海流</span><br></pre></td></tr></table></figure>
<p>和之前的 commits log 信息进行对比，发现 <code>7fad941 add 摘抄时间</code> 提交，已经被我成功得删除了，虽然期间有些波折。同时我还注意到了，「add 文章出处」的 SHA1 的 hash 值也从 953aabb 变成了 b8f0233。说明，该 commit 是新创建的 commit。</p>
<p><strong>第二步：调整 commits 顺序</strong></p>
<p>看着上面提交历史记录总会有些别扭，因为不是安装诗本身的顺序来进行提交的，现在我需要修改提交的顺序。好吧，又该是 git rebase -i 命令大显身手的时候到了。</p>
<p>但是现在有个问题，git rebase -i 命令并不能够编辑最初的提交。不巧的是，我正需要改变第一个 commit 的顺序，这儿需要一点小技巧，用到 <code>--root</code> 选项，通过该选项，我们就能够编辑初始化的提交了。运行命令如下：</p>
<blockquote>
<p>git rebase -i —root</p>
</blockquote>
<p>Git 再次打开编辑器，提示如下对话信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick da5ee49 add 黄河入海流</span><br><span class="line">pick 622c3c8 add 百日依山尽</span><br><span class="line">pick d1293c5 add 欲穷千里目</span><br><span class="line">pick 4fee22a add 更上一层楼</span><br><span class="line">pick 9a22044 add 标题：登鹳雀楼</span><br><span class="line">pick 731d00b add 作者：王焕之</span><br><span class="line">pick b8f0233 add 文章出处</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Rebase b8f0233 onto a69da76 (7 commands)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Commands:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> p, pick = use commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> e, edit = use commit, but stop <span class="keyword">for</span> amending</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> f, fixup = like <span class="string">"squash"</span>, but discard this commit<span class="string">'s log message</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x, <span class="built_in">exec</span> = run <span class="built_in">command</span> (the rest of the line) using shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> d, drop = remove commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>
<p>修改上面的提交顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick 622c3c8 add 百日依山尽</span><br><span class="line">pick da5ee49 add 黄河入海流</span><br><span class="line">pick d1293c5 add 欲穷千里目</span><br><span class="line">pick 4fee22a add 更上一层楼</span><br><span class="line">pick 9a22044 add 标题：登鹳雀楼</span><br><span class="line">pick 731d00b add 作者：王焕之</span><br><span class="line">pick b8f0233 add 文章出处</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后保存并推出编辑器。</p>
<p>OMG，依然存在冲突，解决冲突，运行 git add . 和 git rebase —continue。最后来看看现在的历史提交记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ddb6576 (HEAD -&gt; master) add 文章出处</span><br><span class="line">a6e40b3 add 作者：王焕之</span><br><span class="line">ce83346 add 标题：登鹳雀楼</span><br><span class="line">cae4916 add 更上一层楼</span><br><span class="line">f79b9ac add 欲穷千里目</span><br><span class="line">fb65570 add 黄河入海流</span><br><span class="line">8e25185 add 白日依山尽</span><br></pre></td></tr></table></figure>
<p><strong>第三步：合并 commits</strong></p>
<p>添加标题和添加作者貌似应该放到一个 commit 里面，也就是说，我需要将<code>a6e40b3 add 作者：王焕之</code> 提交和 <code>ce83346 add 标题：登鹳雀楼</code> 合并成一个提交。这样显得提交更加简洁明晰。</p>
<p>依然使用命令</p>
<blockquote>
<p>git rebase -i HEAD~3</p>
</blockquote>
<p>Git 大概如下对话框：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick ce83346 add 标题：登鹳雀楼</span><br><span class="line">pick a6e40b3 add 作者：王焕之</span><br><span class="line">pick ddb6576 add 文章出处</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Rebase cae4916..ddb6576 onto cae4916 (3 commands)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Commands:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> p, pick = use commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> e, edit = use commit, but stop <span class="keyword">for</span> amending</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> f, fixup = like <span class="string">"squash"</span>, but discard this commit<span class="string">'s log message</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x, <span class="built_in">exec</span> = run <span class="built_in">command</span> (the rest of the line) using shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> d, drop = remove commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>
<p>这次我使用的命令是 s, squash。该命令用于合并两个或多个 commits，会将选择的 commit 合并到前一个 commt 中。修改上面对话第二行如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick ce83346 add 标题：登鹳雀楼</span><br><span class="line">squash a6e40b3 add 作者：王焕之</span><br><span class="line">pick ddb6576 add 文章出处</span><br></pre></td></tr></table></figure>
<p>然后保存并推出编辑器，啊哈，Git 似乎有点疑惑，它并不知道选择哪个 commit 信息作为合并的最终 commit 信息，于是 Git 打开了新的对话框，让我自己输入新的合并提交信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This is a combination of 2 commits.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the 1st commit message:</span></span><br><span class="line"></span><br><span class="line">add 标题：登鹳雀楼</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the commit message <span class="comment">#2:</span></span></span><br><span class="line"></span><br><span class="line">add 作者：王焕之</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>
<p>修改如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This is a combination of 2 commits.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the 1st commit message:</span></span><br><span class="line"></span><br><span class="line">add 标题：登鹳雀楼 作者：王焕之</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the commit message <span class="comment">#2:</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> add 作者：王焕之</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure>
<p>保存上面的修改，并推出编辑器。</p>
<p>再来看看最后的历史提交记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* b907e51 - (2 hours ago) add 文章出处 - ran.luo (HEAD -&gt; master)</span><br><span class="line">* bd0bfed - (3 hours ago) add 标题：登鹳雀楼 作者：王焕之 - ran.luo</span><br><span class="line">* cae4916 - (3 hours ago) add 更上一层楼 - ran.luo</span><br><span class="line">* f79b9ac - (3 hours ago) add 欲穷千里目 - ran.luo</span><br><span class="line">* fb65570 - (3 hours ago) add 黄河入海流 - ran.luo</span><br><span class="line">* 8e25185 - (3 hours ago) add 白日依山尽 - ran.luo</span><br></pre></td></tr></table></figure>
<p>啊哈，该历史提交记录终于是我想要的了。</p>
<p><strong>思考 2：</strong>假如通过 rebase 合并了多个 commits 后，发现并不是我们想要的结果，怎么使用 git reset 将其恢复到合并前状态？</p>
<p><strong>思考 3：</strong> 在上面的例子中，由于 git rebase -i 不能够直接编辑最初的提交记录，因而使用了 <code>--root</code> 选项，那么有没有什么<a href="https://stackoverflow.com/questions/645450/insert-a-commit-before-the-root-commit-in-git" target="_blank" rel="noopener">方法</a>可以在最初的 commit 之前添加一个 root commit 呢？这样 git rebase -i 就可以直接使用了。</p>
<h2 id="将其他分支的某个提交附加到当前分支"><a href="#将其他分支的某个提交附加到当前分支" class="headerlink" title="将其他分支的某个提交附加到当前分支"></a>将其他分支的某个提交附加到当前分支</h2><p>还记得文章开头提及的那个问题吗？修复了一个 master 分支上的线上 Bug，完成了项目的测试发布后，发现当前开发分支 dev 也存在同样的问题，怎么办？是把修复 Bug 的代码从 master 分支上线复制一遍到 dev 分支上，这显然效率不高，而且容易复制错误。还是以一个最小的例子来分析 Git 怎么帮我们解决这个问题。</p>
<p>当前版本库有两个分支，master 分支和 dev 分支，master 分支包含一个文件 file1，已经发布到线上，dev 分支是从 master 分支上分离出来的一个新的分支，并且已经完成了新功能的开发，添加了另外一个文件 file2。当前的提交图如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* 132cabb - (4 minutes ago) dev add file2 - ran.luo (dev)</span><br><span class="line">* daaae54 - (4 minutes ago) add file1 - ran.luo (HEAD -&gt; master)</span><br></pre></td></tr></table></figure>
<p>上面代码可以看出，当前 HEAD 指向 master 分支，并且发现一个线上 bug，需要紧急修复，我对 file1 文件内容进行修改，修复了该 bug。并提交一个新的 commit。当前的提交图如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* c6607dc - (4 seconds ago) master fix bug - ran.luo (HEAD -&gt; master)</span><br><span class="line">| * 132cabb - (6 minutes ago) dev add file2 - ran.luo (dev)</span><br><span class="line">|/</span><br><span class="line">* daaae54 - (7 minutes ago) add file1 - ran.luo</span><br></pre></td></tr></table></figure>
<p>因为 dev 分支是从 master 分支上分离出来的新分支，因此先前 master 分支上面的 bug 在 dev 分支上也存在，但是又有谁想再次手写代码修复一遍 bug 呢？这时候我们就需要用到 git cherry-pick 命令。Git 官方文档对其解释如下：</p>
<blockquote>
<p>git-cherry-pick - Apply the changes introduced by some existing commits</p>
</blockquote>
<p>由官网文档可知，git-cherry-pick 命令常用于将版本库的一个分支上的特定提交引入到另一个分支上，也就是说，其可以将其他分支带来的改变直接作用到当前分支，这不就是本例所需要的吗？</p>
<p>首先需要切换到 dev 分支，由于我们需要的是版本库中 master 分支上面的最新的一个关于 bug fix 的提交，将其附加到 dev 分支后面，使用如下命令：</p>
<blockquote>
<p>git cherry-pick master</p>
</blockquote>
<p>执行完毕后，我们切回 master 分支，再来看看当前的提交图：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* 439cb35 - (14 minutes ago) master fix bug - ran.luo (dev)</span><br><span class="line">* 132cabb - (20 minutes ago) dev add file2 - ran.luo</span><br><span class="line">| * c6607dc - (14 minutes ago) master fix bug - ran.luo (HEAD -&gt; master)</span><br><span class="line">|/</span><br><span class="line">* daaae54 - (21 minutes ago) add file1 - ran.luo</span><br></pre></td></tr></table></figure>
<p>啊哈，成功得将 master 分支的最新提交附加到了 dev 分支上面，又双叒叕一次改变了历史，心中的自豪感悠然而生。</p>
<p><strong>思考 4：</strong>既然 git cherry-pick 可以将某一分支上面的制定提交附加到当前分支上线，那么这样是否可能通过不同的操作顺序来对将要附加的提交进行排序呢？</p>
<p><strong>思考 5：</strong>有时候可能一次需要将版本库中某一分支上面的多个连续的提交一次性的附加到当前分支上面，git cherry-pick （git cherry-pick X..Y）命令是否也能够满足我们的需求呢？</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>当我还沉浸在改变历史的成就中难以自拔的时候，身边大佬的一句话让我清醒过来：「历史（记录）没有因你而变，而只是改变了历史（记录）的呈现方式」。当我查阅了.git/objects 中的关于记录 commit 的文件后，才发现我还是<code>too young too simple</code>。我并没有改变或删除这些记录 commit 的文件，而只是生成了一些新的 commit 文件，尽然以为我改变了历史记录，可笑！这也是我们为什么能够恢复到改变历史记录前状态的原因，关于 Git 中 hash、commit、history 的实质，请参考 <a href="https://zhuanlan.zhihu.com/p/27474934" target="_blank" rel="noopener">git inside —simplified —part ‘1’</a>。</p>
<p><strong>Warning</strong></p>
<p>改变历史提交提交记录并非完美，你需要遵循如下准则，只要没有其他开发人员获取到你版本库的副本，或者没有共享你的提交记录，那么你就可以尽情的完善你的提交记录，可以修改提交信息，合并或者拆分多个提交，对多个提交进行排序等等。不过，记住一点，如果你的版本库已经公开，并且其他开发人员已经共享了你的提交记录，那么你就不应该重写、修改该版本库中的任意部分。否则，你的合作者会埋怨你，你的家人和朋友也会嘲笑你、抛弃你。</p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>React 学习 - 开发环境搭建</title>
    <url>/2017/02/19/2017-02-19-Programing-JavaScript-setup-react-environment/</url>
    <content><![CDATA[<h2 id="1-安装-Yarn"><a href="#1-安装-Yarn" class="headerlink" title="1. 安装 Yarn"></a>1. 安装 Yarn</h2><p>包管理可以用 npm 或者 yarn，好多人推荐 yarn，我这里就用这个了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install yarn</span><br></pre></td></tr></table></figure>
<h2 id="2-初始化项目文件夹"><a href="#2-初始化项目文件夹" class="headerlink" title="2. 初始化项目文件夹"></a>2. 初始化项目文件夹</h2><p>首先要做的是创建一个工程目录，然后在目录中执行 yarn 初始化即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="3-安装-Webpack"><a href="#3-安装-Webpack" class="headerlink" title="3. 安装 Webpack"></a>3. 安装 Webpack</h2><p>Webpack 可以让整个开发过程及其方便，这里只讲如何使用它来搭建 React 开发环境</p>
<p>安装webpack</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack webpack-dev-server path</span><br></pre></td></tr></table></figure>
<p>创建 webpack 配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch webpack.config.js</span><br></pre></td></tr></table></figure>
<p>写入以下内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Html webpack plugin setting</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPluginConfig = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: <span class="string">'./client/index.html'</span>,</span><br><span class="line">  filename: <span class="string">'index.html'</span>,</span><br><span class="line">  inject: <span class="string">'body'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open browser plugin setting</span></span><br><span class="line"><span class="keyword">var</span> OpenBrowserPlugin = <span class="built_in">require</span>(<span class="string">'open-browser-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./client/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(<span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'index_bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">loader</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.jsx$/</span>, <span class="attr">loader</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style-loader!css-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    HtmlWebpackPluginConfig,</span><br><span class="line">    <span class="keyword">new</span> OpenBrowserPlugin(&#123; <span class="attr">url</span>: <span class="string">'http://localhost:8080'</span> &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要说明一下：</p>
<ul>
<li>entry: 整个项目的入口文件</li>
<li>output: 编译好的文件输出位置</li>
<li>loaders: 用来告诉loaders处理哪些文件</li>
<li>plugins: 启用的webpack插件</li>
</ul>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add html-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>上面我设置了 html 插件用来帮助把编译后的文件添加到body最后面，所以bundle.js这个js不需要我自己来添加到index.html中了</p>
<h3 id="css-loader-和-style-loader"><a href="#css-loader-和-style-loader" class="headerlink" title="css-loader 和 style-loader"></a>css-loader 和 style-loader</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add css-loader style-loader</span><br></pre></td></tr></table></figure>
<p>然后在webpack.config.js中就可以使用 css-loader 和 style-loader 了</p>
<p>之后我们在需要使用css的时候，直接用以下方式即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./App.css"</span>;</span><br></pre></td></tr></table></figure>
<p>另外在写 react 应用时，也可以直接使用内敛样式，例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> style = &#123;</span><br><span class="line">  backgroundColor: <span class="string">'#EEE'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">        &lt;h1&gt;Hello world&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="open-browser-webpack-plugin"><a href="#open-browser-webpack-plugin" class="headerlink" title="open-browser-webpack-plugin"></a>open-browser-webpack-plugin</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add open-browser-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>这个插件的作用是编译完成以后，打开浏览器</p>
<h2 id="设置-Babel"><a href="#设置-Babel" class="headerlink" title="设置 Babel"></a>设置 Babel</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add babel-loader babel-core babel-preset-es2015 babel-preset-react --dev</span><br></pre></td></tr></table></figure>
<p>preset 是 babel 的插件，用来让 babel 帮忙转译。然后再创建一个 babel 配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch .babelrc</span><br></pre></td></tr></table></figure>
<p>写入内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>:[</span><br><span class="line">        <span class="string">"es2015"</span>, <span class="string">"react"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-设置-React-环境"><a href="#4-设置-React-环境" class="headerlink" title="4. 设置 React 环境"></a>4. 设置 React 环境</h2><p>安装 React</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom</span><br></pre></td></tr></table></figure>
<p>当前目录是这个样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .babelrc</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── webpack.config.js</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>
<p>接下来我们加入 React 需要的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── client</span><br><span class="line">│   ├── components</span><br><span class="line">│   │   └── App.js</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── index.js</span><br><span class="line">├── package.json</span><br><span class="line">├── webpack.config.js</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>
<p>在 index.html 中写入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React App Setup<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 index.js 中写入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router, Route, hashHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  (<span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;hashHistory&#125;</span>&gt;</span></span></span><br><span class="line">    &lt;Route path="/" component=&#123;App&#125;/&gt;</span><br><span class="line">    &lt;Route path="/about" component=&#123;App&#125; /&gt;</span><br><span class="line">  &lt;/Router&gt;),</span><br><span class="line">  document.getElementById('root')</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在 App.js 中写入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">     &lt;div style=&#123;&#123;<span class="attr">textAlign</span>: <span class="string">'center'</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;h1&gt;Hello World&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-设置-React-Router"><a href="#5-设置-React-Router" class="headerlink" title="5. 设置 React-Router"></a>5. 设置 React-Router</h2><p>想要完成页面跳转以及一些复杂的多页面操作，可以使用 React-Router 来支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react-router</span><br></pre></td></tr></table></figure>
<p>使用例子可以看上面index.js内容</p>
<h2 id="6-启动-React"><a href="#6-启动-React" class="headerlink" title="6. 启动 React"></a>6. 启动 React</h2><p>修改package.json，加入scripts</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "webpack-dev-server",</span><br><span class="line">    "build": "webpack --progress --colors"</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>build 方法会把网站打包一下，然后放到之前定义好的目录里面。start 可以直接开启开发模式，并且开启预览</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure>
<h2 id="7-start-kit"><a href="#7-start-kit" class="headerlink" title="7. start kit"></a>7. start kit</h2><p>这些配置不需要每次都跑一次，我自己的放在 <a href="https://github.com/suyan/react-start-kit" target="_blank" rel="noopener">Github</a> 上。下载下来运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn install</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>
<p>即可开启一个 Web App 的开发了</p>
<h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><p><a href="https://scotch.io/tutorials/setup-a-react-environment-using-webpack-and-babel" target="_blank" rel="noopener">Setup a React Environment Using webpack and Babel</a></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>编程技术</tag>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 代码回滚回的正确姿势</title>
    <url>/2017/01/15/2017-01-15-Programing-Git-Git-revert-and-reset/</url>
    <content><![CDATA[<h1 id="git-revert-和-git-reset-的区别"><a href="#git-revert-和-git-reset-的区别" class="headerlink" title="git revert 和 git reset 的区别"></a><strong>git revert</strong> 和 <strong>git reset</strong> 的区别</h1><p> 先看图：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fcr9tu6vdjj30t30ez0y8.jpg" alt></p>
<p><strong>sourceTree</strong> 中 <strong>revert</strong> 译为<strong><code>提交回滚</code></strong>，作用为忽略你指定的版本，然后提交一个新的版本。新的版本中已近删除了你所指定的版本。</p>
<p><strong>reset</strong> 为 <strong>重置到这次提交</strong>，将内容重置到指定的版本。<code>git reset</code> 命令后面是需要加2种参数的：<code>–-hard</code> 和 <code>–-soft</code>。这条命令默认情况下是 <code>-–soft</code>。</p>
<p>执行上述命令时，这该条commit号之 后（时间作为参考点）的所有commit的修改都会退回到git缓冲区中。使用<code>git status</code> 命令可以在缓冲区中看到这些修改。而如果加上<code>-–hard</code>参数，则缓冲区中不会存储这些修改，git会直接丢弃这部分内容。可以使用 <code>git push origin HEAD --force</code> 强制将分区内容推送到远程服务器。</p>
<h2 id="代码回退"><a href="#代码回退" class="headerlink" title="代码回退"></a>代码回退</h2><p>默认参数 <code>-soft</code>,所有commit的修改都会退回到git缓冲区<br>参数<code>--hard</code>，所有commit的修改直接丢弃</p>
<pre><code>$ git reset --hard HEAD^         回退到上个版本
$ git reset --hard commit_id    退到/进到 指定commit_id
</code></pre><p>推送到远程    </p>
<pre><code>$ git push origin HEAD --force
</code></pre><a id="more"></a>    
<h2 id="可以吃的后悔药-gt-版本穿梭"><a href="#可以吃的后悔药-gt-版本穿梭" class="headerlink" title="可以吃的后悔药-&gt;版本穿梭"></a>可以吃的后悔药-&gt;版本穿梭</h2><p>当你回滚之后，又后悔了，想恢复到新的版本怎么办？</p>
<p>用<code>git reflog</code>打印你记录你的每一次操作记录</p>
<pre><code>$ git reflog

输出：
c7edbfe HEAD@{0}: reset: moving to c7edbfefab1bdbef6cb60d2a7bb97aa80f022687
470e9c2 HEAD@{1}: reset: moving to 470e9c2
b45959e HEAD@{2}: revert: Revert &quot;add img&quot;
470e9c2 HEAD@{3}: reset: moving to 470e9c2
2c26183 HEAD@{4}: reset: moving to 2c26183
0f67bb7 HEAD@{5}: revert: Revert &quot;add img&quot;
</code></pre><p>找到你操作的id如：<code>b45959e</code>，就可以回退到这个版本</p>
<pre><code>$ git reset --hard b45959e
</code></pre>]]></content>
      <categories>
        <category>编程技术</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 基础命令使用</title>
    <url>/2017/01/03/2017-01-03_Programing-Git-Git-command/</url>
    <content><![CDATA[<blockquote>
<p>随便整理的一些自用的Git指令</p>
</blockquote>
<h1 id="GitHub创建仓库提示代码"><a href="#GitHub创建仓库提示代码" class="headerlink" title="GitHub创建仓库提示代码"></a>GitHub创建仓库提示代码</h1><pre><code>echo &quot;# 项目名&quot; &gt;&gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin git@github.com:youdaily/youdaily.git
git push -u origin master
</code></pre><p>若仓库存在直接push</p>
<pre><code>git remote add origin git@github.com:youdaily/youdaily.git
git push -u origin master
</code></pre><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="创建仓库（初始化）"><a href="#创建仓库（初始化）" class="headerlink" title="创建仓库（初始化）"></a>创建仓库（初始化）</h2><pre><code>在当前指定目录下创建
git init

新建一个仓库目录
git init [project-name]

克隆一个远程项目
git clone [url]
</code></pre><h2 id="添加文件到缓存区"><a href="#添加文件到缓存区" class="headerlink" title="添加文件到缓存区"></a>添加文件到缓存区</h2><pre><code>添加所有变化的文件
 git add .

添加名称指定文件
git add text.txt
</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code>设置提交代码时的用户信息
git config [--global] user.name &quot;[name]&quot;
git config [--global] user.email &quot;[email address]&quot;
</code></pre><a id="more"></a>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><pre><code>提交暂存区到仓库区
git commit -m &quot;msg&quot;

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><pre><code># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><pre><code># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre><h2 id="标签Tags"><a href="#标签Tags" class="headerlink" title="标签Tags"></a>标签Tags</h2><pre><code>添加标签 在当前commit
git tag -a v1.0 -m &#39;xxx&#39; 

添加标签 在指定commit
git tag v1.0 [commit]

查看
git tag

删除
git tag -d V1.0

删除远程tag
git push origin :refs/tags/[tagName]

推送
git push origin --tags

拉取
git fetch origin tag V1.0

新建一个分支，指向某个tag
git checkout -b [branch] [tag]
</code></pre><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><pre><code># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><pre><code># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code># 生成一个可供发布的压缩包
$ git archives
</code></pre>]]></content>
      <categories>
        <category>编程技术</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中 ABC 模块使用</title>
    <url>/2016/12/03/2016-12-03-Programing-Python-Basic-ABC-Module/</url>
    <content><![CDATA[<h2 id="1-abc模块作用"><a href="#1-abc模块作用" class="headerlink" title="1.abc模块作用"></a>1.abc模块作用</h2><p>Python本身不提供抽象类和接口机制，要想实现抽象类，可以借助abc模块。ABC是Abstract Base Class的缩写。</p>
<h2 id="2-模块中的类和函数"><a href="#2-模块中的类和函数" class="headerlink" title="2.模块中的类和函数"></a>2.模块中的类和函数</h2><h3 id="abc-ABCMeta"><a href="#abc-ABCMeta" class="headerlink" title="abc.ABCMeta"></a>abc.ABCMeta</h3><p>这是用来生成抽象基础类的元类。由它生成的类可以被直接继承。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span>:</span></span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line"></span><br><span class="line">MyABC.register(tuple)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> issubclass(tuple, MyABC)</span><br><span class="line"><span class="keyword">assert</span> isinstance((), MyABC)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>上面这个例子中，首先生成了一个MyABC的抽象基础类，然后再将tuple变成它的虚拟子类。然后通过issubclass或者isinstance都可以判断出tuple是不是出于MyABC类。</p>
<p>另外，也可以通过复写<code>__subclasshook__(subclass)</code>来实现相同功能，它必须是classmethod</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_iterator</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterable</span>:</span></span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_iterator</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__iter__()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> MyIterable:</span><br><span class="line">            <span class="keyword">if</span> any(<span class="string">"__iter__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">MyIterable.register(Foo)</span><br></pre></td></tr></table></figure>
<h3 id="abc-abstractmethod-function"><a href="#abc-abstractmethod-function" class="headerlink" title="abc.abstractmethod(function)"></a>abc.abstractmethod(function)</h3><p>表明抽象方法的生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_method</span><span class="params">(self, ...)</span>:</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<h3 id="abc-abstractproperty-fget-fset-fdel-doc"><a href="#abc-abstractproperty-fget-fset-fdel-doc" class="headerlink" title="abc.abstractproperty([fget[,fset[,fdel[,doc]]]])"></a>abc.abstractproperty([fget[,fset[,fdel[,doc]]]])</h3><p>表明一个抽象属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line"><span class="meta">    @abstractproperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_abstract_property</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>上例只是只读属性，如果是读写属性，可以如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span> ...</span><br><span class="line">    x = abstractproperty(getx, setx)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Programing-Hexo-Paging_function</title>
    <url>/2016/11/23/2016-11-23_Programing-Hexo-Paging-function/</url>
    <content><![CDATA[<p>我们在搭建完Hexo + Github pages的博客后，会发现他的主页会默认显示很多的文章（默认 10 篇），而我们也许需要自定义分页进行管理主页博客的显示数量。</p>
<p>因此，本教程教会大家，如何设置主页的文章显示数量.</p>
<a id="more"></a>
<hr>
<p>首先我们找到Hexo的根配置文件_config.yml，注意不是主题的配置文件。<br>然后按照下面图片中的内容搜索：per_page，在图片中对应位置修改数字即可<br><img src="/2016/11/23/2016-11-23_Programing-Hexo-Paging-function/hexoPerPage-01.jpg" class title="设定"></p>
<p>之后我们就可以在我们的博客主页看到分页的效果啦！<br><img src="/2016/11/23/2016-11-23_Programing-Hexo-Paging-function/hexoPerPage-02.jpg" class title="结果"></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Programing-Hexo-Hexo_blog_read_more_button</title>
    <url>/2016/11/22/2016-11-22_Programing-Hexo-Hexo_blog_read_more_button/</url>
    <content><![CDATA[<p>我们在搭建好博客后，肯定是第一时间写一篇文章测试一下啦！但是细心的你一定会发现一个问题，那就是——主页为什么会展示每一篇文章的所有内容？而不是首页只展示文章的部分内容，再提供一个阅读全文的按钮呢？</p>
<p>本篇博客就是帮助各个同学实现阅读全文的功能，同时根据自己的使用经验给出意见和建议。要实现阅读全文，目前存在两种方法，我们会一个个讨论，评价其优缺点的。</p>
<h2 id="方法一：配置文件设置"><a href="#方法一：配置文件设置" class="headerlink" title="方法一：配置文件设置"></a>方法一：配置文件设置</h2><p>首先我们需要找到Hexo所使用主题的主配置文件_config.yml，注意此处不是Hexo的主配置文件，而是主题的。博主所使用的是NexT主题，因此在此以此为例。</p>
<a id="more"></a>
<p>方法一是搜索此处的 <code>auto_excerpt</code>，将 <code>enable</code> 改为 true，就自动可以对每一篇文章进行分割了，length 属性就是定义显示的字符数量。<br><img src="/2016/11/22/2016-11-22_Programing-Hexo-Hexo_blog_read_more_button/auto_excerpt_setting.png" class title="auto_excerpt_setting"></p>
<p>但是不得不说，很不建议使用此方法，主要原因是：</p>
<p>作者不能灵活控制显示内容，只能固定遵循字数设置<br>会丢失Markdown语法的格式，只显示纯文本<br>对！没错！Markdown的格式会全部丢失，所以整个首页的博客预览会非常难看。而主题作者推荐的做法也写的非常明显了，就是在图片中红框当中的内容。</p>
<h2 id="方法二：手动分割文章"><a href="#方法二：手动分割文章" class="headerlink" title="方法二：手动分割文章"></a>方法二：手动分割文章</h2><p>在文章当中需要分割的位置手动插入以下语句即可：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- more --&gt;</span></span></span><br></pre></td></tr></table></figure><br>效果还是很不错的，如图所示：<br><img src="/2016/11/22/2016-11-22_Programing-Hexo-Hexo_blog_read_more_button/read-more.png" class title="read more 按键"></p>
]]></content>
      <categories>
        <category>编程技术</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>基础技术</tag>
        <tag>编程技术</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
