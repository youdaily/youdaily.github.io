<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>You的日常</title>
  
  <subtitle>You的日常，我们的日常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://youdaily.github.io/"/>
  <updated>2019-12-10T09:28:13.848Z</updated>
  <id>https://youdaily.github.io/</id>
  
  <author>
    <name>You的日常</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019-02-28-杀猪盘骗局</title>
    <link href="https://youdaily.github.io/posts/9859ab2b/"/>
    <id>https://youdaily.github.io/posts/9859ab2b/</id>
    <published>2019-12-10T09:20:45.000Z</published>
    <updated>2019-12-10T09:28:13.848Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><hr><p>文章转载自：<a href="http://www.xinhuanet.com/legal/2019-02/28/c_1124172443.htm" target="_blank" rel="noopener">http://www.xinhuanet.com/legal/2019-02/28/c_1124172443.htm</a></p><p>侵删.</p><hr><h2 id="东南亚“杀猪盘”：“爱情”圈养的网络骗局"><a href="#东南亚“杀猪盘”：“爱情”圈养的网络骗局" class="headerlink" title="东南亚“杀猪盘”：“爱情”圈养的网络骗局"></a>东南亚“杀猪盘”：“爱情”圈养的网络骗局</h2><p>以“网恋”寻找诈骗对象，大额充值即封禁账号，数百人被骗；多地警方已侦破多个“杀猪盘”骗局</p><p><img src="https://i.loli.net/2019/12/10/DwngJ9jrLTzl2NP.png" alt="20191210172459.png"><br>受害者统计的部分省份被骗人数和金额。</p><p><img src="https://i.loli.net/2019/12/10/1sz5UMJOqdVXcGo.png" alt="20191210172446.png"><br>杨明凯与骗子“恋人”的聊天记录，对方怂恿他往网站账户充钱。</p><p>唐元被骗子哄骗让其帮忙下注，骗子称“未来的世界你都是我的，我怎么不相信你”。</p><p>“恋人”向唐元推荐下注的赌博网站。<br><img src="https://i.loli.net/2019/12/10/AWkvRmQF7YsMTBJ.png" alt="20191210172428.png"></p><p>“你二十五六岁了，这么大的人了，怎么还会被骗，是傻吗？”</p><p>催债电话里的声音越来越大，一直试图解释还不上贷款原因的杨明凯，听到这儿终于忍不住爆了一句粗口：“xxxx!”</p><p>28万元债务对于月薪7000元的杨明凯来说，想要每月按时还款是几乎不可能的，后果就是像这样的催债电话，每天都能打来好几个。</p><p>债务压垮了杨明凯，而这一切，都始于3个月前的一次网络“邂逅”。对方每天的嘘寒问暖，关心照顾，让杨明凯以为找到了对的人，在“恋人”的带领下，他们一起玩起了博彩游戏。只是这份感情，来得太快，离去得也让人猝不及防，随着这个帅气男子一同消失的，还有杨明凯在游戏账户上充值的28万元。</p><p>爱情童话与赚钱美梦同时破灭。与杨明凯一样梦碎的人，还有张君雅、唐元等近千人，分散在全国各地，他们的经历都如出一辙:社交网站上结识近乎完美的婚恋对象，在“恋人”的蛊惑下参与网络博彩，最终，全部积蓄和借款在充值进博彩账户后，与“恋人”一起消失。</p><p>在线上“恋人”看来，杨明凯们只不过是用所谓“爱情”圈养的“猪”，养肥了自然要“杀掉”。这种只进不出的骗局，被行业内的人取了个很形象又残酷的名字——“杀猪盘”。</p><p>参与过跨境“杀猪盘”侦破的刑警周深说，该犯罪手法在2016年以前就有，2018年开始泛滥。最早，犯罪人员通过同性恋网站寻找“猪仔”，后来拓展到婚恋交友平台。因为这些嫌疑人多在东南亚开设骗局，所以又被称为“东南亚杀猪盘”。</p><h3 id="“完美恋人”"><a href="#“完美恋人”" class="headerlink" title="“完美恋人”"></a>“完美恋人”</h3><p>杨明凯破碎的“爱情童话”，始于一次网络邂逅。</p><p>杨明凯喜欢同性。3个月前，他在社交平台上认识了一位男子。那个男人每天在微信对他嘘寒问暖，关心他的饮食起居。虽然对于那个男人发来的确认关系的消息，杨明凯总是谨慎的，“咱们还没见面呢，哪能这么快。”但是面对那个照片上帅气的男子，他还是心动了。</p><p>“在我们这个圈子，因为种种原因，谈感情的很少，很多都只是玩乐一下。”这个自称李信泽的男子，和他在这个社交平台上遇到的其他男人不一样，不提约炮，不提去夜店蹦迪，只在微信上说“在干吗呢？”、“记得吃饭”这样的话。</p><p>跟杨明凯一样，同在北京工作的张君雅，这一次也以为遇到了自己的“真命天子”。张君雅戴着方框眼镜，从事IT相关的工作，今年是她工作的第十年，差不多攒够了可以支付一套300多万房子的首付款。在婚恋网站上结识这个叫“李文瑞”的人之前，张君雅已经四年半没有谈过恋爱了，三十多岁的人的婚恋问题，不只是父母着急，自己也在暗暗焦虑。</p><p>她注册了世纪佳缘交友网站的账号，2018年10月25日一个世纪佳缘ID名为“戛纳坦率的幼柏”的人，给她回了消息，让张君雅添加他的微信。</p><p>加上了微信，自称李文瑞的男子介绍说，他是一个在北京工作的程序员，热爱健身和旅游。李文瑞经常给张君雅发来他正在健身的照片，照片上的他露着肌肉，对着镜头微笑。这正是张君雅喜欢的男生的样子。每天早中晚，这个男人总是会给她发来问候语，关心她吃饭了没，休息得如何。虽素未谋面，但张君雅对这个男人的好感就在这一声声嘘寒问暖中逐步上升。</p><p>因为工作忙，张君雅总是在晚上十点多才下班。微信那头的“恋人”，就会在她步行回家的那段路上，陪她语音聊天，也会经常唱歌给她听。一次加班的夜归，李文瑞在微信电话里，给张君雅唱起了《最浪漫的事》，听到手机那头的人的歌声，张君雅不禁落下了眼泪。</p><p>“当时我觉得这是很单纯的爱情，就像小男生和小女生一样。”张君雅说，当时他们互称大傻，二傻，是因为觉得对方是单纯善良的人。李文瑞跟张君雅提起过，自己有一段短暂的失败婚姻，他和前妻闪婚，因为性格不合离婚，没有生育孩子。</p><p>“如果有孩子就不会离婚。”李文瑞告诉张君雅。听到这样的话，张君雅觉得他是一个有担当的男人，又一次，为屏幕那边的男人流下了眼泪。</p><p>和张君雅一样，在广西桂林工作的唐元也在世纪佳缘网站遇到了一个叫她老婆的男人。对方离异，从事着IT工作，在广西的另一个市工作。“等咱们见了面，确定了关系，我就来桂林买房子，到时还要再到桂林开个分店，这样工作也能兼顾。”唐元觉得他是一个靠谱的人，陈伦仔细描绘着他们的未来，这点让她心动。</p><p>随着交往的深入，杨明凯、张君雅和唐元与“恋人”的感情日渐加深，甜蜜之中，他们丝毫没觉察到自己已成了一场“杀猪”骗局中正逐渐“养肥”的“猪仔”。</p><h3 id="博彩骗局"><a href="#博彩骗局" class="headerlink" title="博彩骗局"></a>博彩骗局</h3><p>“我要去香港出差了”。</p><p>在认识陈伦的一周后，唐元收到了他的信息。“等我出差回来，我来桂林找你玩。”他们甚至在微信上详细规划好了见面之后的行程。</p><p>2018年11月1日，李文瑞也告诉张君雅，他因为一个紧急任务，被派去了澳门，出差回来就可以见面了。为了这第一次见面，张君雅专门托朋友从法国给李文瑞带了一份见面礼。</p><p>出差回来，似乎就将迎来与爱人见面的幸福时刻，两个女孩期待着。但是在陈伦和李文瑞的规划中，这个相似的出差，预示着，“猪”已经养肥了，接下来，进入了“杀猪”阶段。</p><p>李文瑞告诉张君雅他正在帮澳门某家赌场维护网站，每天晚上八点到八点半的时间服务器会进行重启，他在后台修改赔率，就能保证赢钱。</p><p>张君雅在李文瑞的指导下，在这个名为“葡京娱乐”的网站上注册了账号。李文瑞告诉她，钱要先转到公司的财务上，财务把钱变成筹码充入账户。</p><p>第一天，张君雅往财务的账户里转账了1万元，在李文瑞的指导下操作了三次，第一次就赚了七百多元。李文瑞对张君雅说“你提现试试。”张君雅试了三次，每次一百元，成功。</p><p>陆陆续续，张君雅按李文瑞的指导，往“财务的账户”里充了17笔钱，总共90万，其中30万，是找朋友借的。当张君雅向新京报记者回忆起自己像着了魔一样疯狂向账户充钱的那几天，说“这是一个容易赚钱的机会吧，我不是一个把钱看得特别重的人，但是还是会心动。”</p><p>如出一辙，杨明凯的“恋人”也主动向杨明凯推荐了博彩网站。</p><p>相识的一周后，李信泽告诉杨明凯，最近他在看走势，玩彩票，掌握了规律，让杨明凯和他一块玩，他甩给了杨明凯一个二维码，上面写着“××快乐彩”，杨明凯扫码进入，界面简陋，手机屏上横着三个博彩游戏，挂着美女穿着比基尼的照片。最开始，游戏可以提现，从充了五万元开始，就无法提现了。联系客服，得到的答案总是：“你得再充钱，达到一定的数额和流动金额才能提现。”就这样，杨明凯通过各种借贷平台借款，往这个网站充了28万元。</p><p>君雅想提现还朋友钱，准备提现的当晚，李文瑞给张君雅打来了电话，一分钟的通话时长，很简短。电话里，李文瑞告诉张君雅“我今晚要去紧急维护这个网站，老板不让带手机，你早点睡，我完成任务了联系你。”</p><p>提现失败的两个小时后，网站不能登录了。张君雅有些担心，她想是不是李文瑞进行网站维护出了问题。整整一夜，这个网站都无法登录。</p><p>“二傻，快回消息啊，我很担心你。”即便无法提现，但张君雅最担心的还是“恋人”。张君雅给李文瑞发去了多条消息，都没有应答。直到11月10日晚上，张君雅和闺蜜打了一通电话，述说了自己的遭遇，闺蜜的疑惑让她怀疑了。她在网上输入“时时彩”，网页上，满屏的控诉骗局的文字。</p><p>11月11日的凌晨，张君雅报了警。民警确定地告诉她“你被骗了”。</p><h3 id="被骗之后"><a href="#被骗之后" class="headerlink" title="被骗之后"></a>被骗之后</h3><p>“我已经规划好了，今天分三次投，一定能赚，你的钱也都能拿出来。”像往常一样，杨明凯继续在李信泽的指挥下投注，然而这一次，等到的却是28万元全部赔进去的信息。唐元的“恋人”去香港出差维护赌博网站，告诉唐元自己找到了赌博网站的漏洞，在他的怂恿下往网站内充值了十五万元，而钱和网站，却在一夜之间消失了。</p><p>不到一周的时间内，杨明凯还未能弄明白这个赌博网站的游戏规则，而唐元和张君雅，也在她们“恋人”的指挥下，进行着网站的操作。</p><p>“我是信任他的，所以也信任这个网站。”张君雅在整个过程中，从未怀疑过这个和他谈情说爱的男人。11月11日，在报完警回家的路上，张君雅忍不住嚎啕大哭。</p><p>那段时间，张君雅的生活和工作都发生了剧烈的变化，被骗，工作调组，搬家。换房子的时候，租房的押金加上房租的三万元，她已经拿不出了。</p><p>杨明凯被骗后，就再未打开过他卧室的窗帘。每到周末，杨明凯就把自己关在月租1800元的8平米的小屋子内，一张双人床，一张桌子，占去了屋内几乎所有空间。因为空间不足，衣柜被他放在了客厅。杨明凯打开手机，卧在床上，放着综艺，看到好笑的情节，跟着笑几声。但是这种短暂的快乐很快就会在电话铃声响起时消失，他需要向电话那头的催收员解释，自己是因为被骗欠了钱，无力偿还。有时，他就把电话接了，放在一边，不说话。</p><p>挂了电话，杨明凯开始在心里一遍遍琢磨“自己为什么会被骗，为什么骗子会找上我。”他拿着每个月七千元的工资，但是每月应还欠款却高达三万元。没办法还上钱，催收的电话就一个个打进来，一个周日，杨明凯总共接到了十五个催收电话。</p><p>债务同样让距离杨明凯两千多公里的唐元陷入了经济上的窘境，这个春节，唐元没有回家，从初七开始，她就给自己从早到晚排满了课外辅导课程，希望能够多挣点钱早日还清在贷款平台上欠下的款。</p><p>过年回家，姐姐问杨明凯“你咋还穿着旧衣服呀？”</p><p>“没有瞅见喜欢的”。杨明凯轻飘飘地回答，但事实是他根本没钱买衣服。</p><p>被骗之后，杨明凯更愿意一个人待着，喜欢和朋友相处的他也不主动找朋友吃饭了。身边的朋友，只有两个与杨明凯交好的，知道他被骗的经历。</p><p>被骗之后的张君雅也不愿再回朋友的消息。</p><p>“你再不回消息，我们就报警了！”在十几条微信消息未读之后，看到这条信息，张君雅才回复朋友“我没事，不要担心我。”第二天，朋友一大早就来到了张君雅家，但是张君雅不愿意多讲，只告诉他“亏了钱”。</p><p>“朋友其实也难理解”，杨明凯说，对于他们受骗的人来说，过多地倾诉自己的经历，他人也只是当个故事听听罢了。</p><h3 id="抱团取暖"><a href="#抱团取暖" class="headerlink" title="抱团取暖"></a>抱团取暖</h3><p>被骗后，杨明凯、唐元、张君雅都加入了类似的受害者微信群，群友之间似乎更能互相理解。</p><p>入群之后，杨明凯发现，和自己有着同样遭遇的人，遍布全国各地，涉案的金额有的高达几百万。被骗的人有开公司的老板，有还在上学的学生，还有六十多岁的老人。杨明凯加入的北京群，目前总共有44人，据群管理员刘子彤的不完全统计，群里受害人被骗总金额达1080万元。</p><p>通过群友们的互相交流，杨明凯了解了更多和他相似的经历。</p><p>一个60多岁的男同性恋，被骗后没有选择报警。一个骗子在和女孩交流的过程中发现自己真的爱上了女孩，向女孩摊牌了，让她等他回国。</p><p>群里偶尔会讨论一下某某警方破案的新闻。“太傻了，活该被骗。”看到网友们类似的评论，他们委屈，难过，却只能在群里互相鼓励一下。</p><p>2019年2月23日，北京又有人被骗了，杨明凯、刘子彤等三个人，便专门陪着受害人去报警，“警方当时就以诈骗立案了。”杨明凯觉得欣慰。</p><p>大概每一个月左右，他们就会在线下聚一下，杨明凯跟着群友们，一起去过故宫看展，也去了雍和宫祈福，希望通过活动，化解心里的悲苦。</p><p>聚在一块的时候，他们喜欢谈论他们总结出来的骗子的套路，“你的骗子还会唱歌呢？”一次线下聚会，张君雅被其他受害人打趣道。刘子彤在张君雅接受采访时，也会笑着向记者总结“骗子都爱健身，都是程序员。”</p><p>因为被骗，他们都变身成了能够快速识别骗子的“反诈大亨”，杨明凯练就了一眼就能识别出骗子的本领，“那种一上来就自我介绍，关注的人都是一些好久不活跃的僵尸的，没有实名认证的，肯定就是骗子。”被骗后，他又主动加过两个骗子，第一个以为他是同行，他向第二个摊牌，然后互相对骂。</p><p>他们关注着网上的各种破案的信息，有时看到了哪里的警方破了案，他们就会在脑袋里搜索一下自己认识的受害人的案例，估摸一下是不是这起案子的受害者，要是能够并案就能够看到希望。</p><h3 id="“杀猪盘”"><a href="#“杀猪盘”" class="headerlink" title="“杀猪盘”"></a>“杀猪盘”</h3><p>烟台、舟山、绍兴、宁波、深圳等多地警方都曾破获“杀猪盘”骗局。</p><p>一个参与过跨境“杀猪盘”侦破的刑警周深告诉新京报记者，这些“杀猪盘”许多都开设在东南亚地区，这些年实体赌博不景气，网络赌博开始兴起。“杀猪盘”是他们（从业者）自己给网络交友赌博诈骗取的名字，真假网赌往往混杂在一起，金主也是两边投资。</p><p>周深介绍，“杀猪盘”最严重的四个地方为菲律宾马尼拉地区、柬埔寨西哈努克市、老挝金三角经济特区、中缅边境地区。开盘口的几乎都是福建老板。东南亚地区“杀猪盘”泛滥，原因复杂，菲律宾是东南亚地区网络赌博唯一合法的地区，有许多盘口盘踞在这里。而拿周深经常去办案的中缅边境来说，向来都是毒品、枪支、非法走私、绑架勒索的重灾区，多种类型的暴力犯罪交织在一起，“杀猪盘”诈骗只是其中一种。</p><p>周深在侦破行动中曾发现，缅甸佤邦某县的一个四层娱乐城中，一楼是实体的赌场，二楼以上都是“杀猪盘”的办公地点。另一栋18层高的大楼将在今年四月完工，也将提供给“杀猪盘”和各种网络贷款办公。</p><p>周深是从2017年开始接触这类犯罪的，据他估计，该犯罪手法在2016年以前就有，2018年开始泛滥。最早，犯罪人员通过同性恋网站寻找“猪仔”，后来拓展到婚恋交友平台。</p><p>“‘杀猪’关键是‘养猪’，所以婚恋交友网站和聊天交友工具、聊天剧本被称为‘猪圈’、‘猪食槽’和‘猪饲料’。”周深说。</p><p>周深告诉新京报记者，诈骗团伙有专门供料的人员，每天会提供不同的受害人名单给负责行骗的人物色“猪仔”。一位在菲律宾某博彩盘口从事推广工作的人也向新京报记者证实，公司会为负责推广的人提供各种联系人的微信号、QQ号等，而他所要做的，就是陪人“谈情说爱”，然后“杀猪”。</p><p>杨明凯把骗子的微信置顶了，心情不好时，他就会发过去几句骂人的话，虽然没有人再回应。唐元也还在坚持给她的骗子发消息，骂也好，劝也好，而那个被她改为“大骗子”备注的微信号再无回应。</p><p>张君雅通过域名反查，发现在她的钱消失后第二天，骗子又建了一个新的网站，“又去骗其他人了”。</p><p>“猪”被养肥杀了，这些猎人们就会去寻找新的猎物，一位正在菲律宾做博彩推广的人对新京报记者说，这个局“啥时候聊到人倾家荡产了，啥时候就结束！”</p><p>（文中所有受访对象均为化名）（记者 刘思洁 刘经宇）</p><hr></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div id=&quot;vip-container&quot;&gt;&lt;hr&gt;
&lt;p&gt;文章转载自：&lt;a href=&quot;http://www.xinhuanet.com/legal/2019-02/28/c_1124172443.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ht
      
    
    </summary>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="杀猪盘" scheme="https://youdaily.github.io/tags/%E6%9D%80%E7%8C%AA%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>2019-12-10-Life-Weixin-251事件</title>
    <link href="https://youdaily.github.io/posts/17fb87b9/"/>
    <id>https://youdaily.github.io/posts/17fb87b9/</id>
    <published>2019-12-10T06:48:03.000Z</published>
    <updated>2019-12-10T09:26:57.984Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>继 <code>网易暴裁病员</code> 事件后, 华为的<code>251</code> 事件引发的讨论在网络上引起的讨论越来越多。</p><h2 id="事件始末"><a href="#事件始末" class="headerlink" title="事件始末"></a>事件始末</h2><p>42岁的李洪元没想到，一笔30万元的离职补偿款会换来251天的牢狱之灾。</p><p>李洪元于2005年10月入职华为，2018年1月31日因举报所在的逆变器销售管理部门存在操作违规行为而被 HR 劝退离职。</p><p>据深圳市龙岗区人民检察院《不起诉决定书》，2017 年 12 月到 2018 年 3 月期间，李洪元以向华为公司举报部门主管在业务上存在违规操作的行为进行要挟，从部门主管处勒索人民币约 30 万。</p><p>2018 年 3 月 8 日，逆变器销售管理部门主管通过部门秘书的个人银行账户向李洪元转款约 30 万元，交易摘要为 <code>“离职经济补偿”</code>。</p><p>李洪元称，这笔 30 万的款项属于 <code>“离职经济补偿”</code>：他在华为工作长达 12 年，与公司协商获得个人离职经济补偿款 331776.73 元，扣除税金约 3 万元，到账约 30 万。</p><p>2018 年 12 月 16 日，李洪元被深圳市公安局刑事拘留。李洪元称，罪名是 <code>“涉嫌职务侵占”</code>，12 月 28 日，补充报案罪名变为 <code>“涉嫌敲诈勒索”</code>，报案人是其前雇主——深圳华为技术有限公司，证据是那笔从部门秘书个人账户汇出的、30 万元的转账记录。</p><p>2019 年 1 月 22 日，经检察院批准，李洪元被深圳市公安局逮捕。</p><p>李洪元的代理律师、广东意本律师事务所律师谢连喜认为，本案关键之一在于款项是通过私人账户转出。“（这种做法）是不合理的，”谢连喜说，李洪元的行为尚不构成敲诈勒索罪。按照法律规定，敲诈勒索罪的界定包括两个要件，行为人要以非法占有为目的，并且要使用威胁或者要挟的手段，逼迫他人交付财物。</p><p>谢连喜说，李洪元不具备非法性和强制性两个要件，“向公司提起的经济补偿是合法的，他本人也没有进行威胁或要挟，逼迫对方交付财物。”</p><p>经过两次退回侦查机关补充侦查，一次延长审查起诉期限后，2019 年 8 月 22 日，深圳市龙岗区人民检察院认为犯罪事实不清、证据不足，不符合起诉条件，决定对李洪元不起诉，次日，李洪元重获自由。</p><p>据李洪元讲述，不起诉的直接证据是一段两个多小时的录音。他与华为人力资源部门协商离职赔偿，其中未谈及任何以 <code>“举报业务造假”</code> 来要挟获取赔偿。</p><p>李洪元为此失去了 <code>251</code> 天的人身自由。据深圳市龙岗区人民检察院《刑事赔偿决定书》，李洪元获得了包括人身自由损害赔偿金、精神损害抚慰金共计约 <code>10</code> 万元的国家赔偿；同时会向李洪元原工作单位及其父亲所在的工作单位发函，为其消除影响、恢复名誉。</p><h2 id><a href="#" class="headerlink" title=" "></a> </h2><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div id=&quot;vip-container&quot;&gt;&lt;p&gt;继 &lt;code&gt;网易暴裁病员&lt;/code&gt; 事件后, 华为的&lt;code&gt;251&lt;/code&gt; 事件引发的讨论在网络上引起的讨论越来越多。&lt;/p&gt;
&lt;h2 id=&quot;事件始末&quot;&gt;&lt;a href=&quot;#事件始末&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="251" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/251/"/>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="251" scheme="https://youdaily.github.io/tags/251/"/>
    
  </entry>
  
  <entry>
    <title>每日一文：剩男现象</title>
    <link href="https://youdaily.github.io/posts/db7d6965/"/>
    <id>https://youdaily.github.io/posts/db7d6965/</id>
    <published>2019-12-04T03:24:27.000Z</published>
    <updated>2019-12-10T02:01:57.706Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在中国，30岁以上的未婚男性被称作「剩男」，指的是还没有找到妻子的「剩下的男士」——而在一个性别越发失衡的国家里，这已经成为一大问题。</p><p>1980年，中国新生儿男女比例仍处于正常区间。但到了90年，比例增加了但也没到很严重的程度，而 2000 的人口普查资料更显示，当年新生儿性男女比例失衡不但达到历史新高，第三胎男女比例更高达 6 : 1。</p><a id="more"></a><h2 id="计划生育政策"><a href="#计划生育政策" class="headerlink" title="计划生育政策"></a>计划生育政策</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-e0890c8eb8c1be1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>作为独生子女政策的遗物，中国男性人数较女性多出数百万人。尽管这项政策在 2015 年取消，但由此产生的影响仍会持续几十年之久。</p><p>性别失衡导致很多男性难以找到伴侣——这种失衡状态有可能进一步扩大。</p><p>到 2020 年，中国适婚男性人数将较女性高出 3000 万。</p><p>美国政治经济学家，尼古拉斯·艾伯斯塔德（Nicholas Ebesdfestadt）在他的《人口的未来》（The Demographic Future）一书中预测，到 2030 年，30多岁的中国男性将有超过四分之一未婚。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-4ac165863443967b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>由于女性人数远低于男性，为了寻找合适的伴侣——并赶在其他人之前赢得女性的芳心——一些男性已经使出浑身解术寻找妻子。他们花费巨额资金，而且使用了许多新颖的求偶方式，但有时候仍然无法成功。</p><h2 id="99部iPhone求婚遭拒"><a href="#99部iPhone求婚遭拒" class="headerlink" title="99部iPhone求婚遭拒"></a>99部iPhone求婚遭拒</h2><p>据媒体报道，有一位 40 岁的中国商人在 2015 年起诉一家上海婚介机构未能帮助其找到妻子，但他之前已经向该机构支付了700万元人民币。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-4ad84fa049bc2fdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在另外一起事件中，一位广州程序员买了 99 部iPhone向自己的女友求婚。不幸的是，他却遭到对方拒絶。由于现场照片在社交媒体上广泛传播，进一步加剧了他的屈辱感。</p><p>之所以出现这种现象，部分原因在于，传统和现代的相亲方式未必总能奏效。春节一直以来都是单身人士相亲的重要机会。</p><p>春节通常在1月末和2月中旬之间，多数人都会在春节期间走亲访友，为单身人士提供了很多与潜在配偶见面的机会。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-466432874955a895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>但这种传统的相亲方式已经让位给现代化的新模式。与其他地方一样，网上相亲在中国发展迅猛，而微信等聊天应用也逐步成为人们彼此相识的流行方式。</p><p>最近几年，中国的约会越来越开放，越来越向西方国家的方式靠拢。年轻一代拥有更多选择，他们会追随内心感觉，而不是听从父母之命。</p><h2 id="颠覆传统"><a href="#颠覆传统" class="headerlink" title="颠覆传统"></a>颠覆传统</h2><p>来自苏州的李君现在20多岁，仍然单身。她注意到，越来越多的单身男性组织到一起，租用公共娱乐场所举行相亲活动。<br><img src="https://upload-images.jianshu.io/upload_images/1940331-59a81f58e1aed161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>其他男性则向心理学家和造型师求助，希望提升自己的吸引力。<br><img src="https://upload-images.jianshu.io/upload_images/1940331-db71ca8a826faa06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>为了避免遭到父母的「逼婚」，有的人甚至使用「来租我吧」这样的手机应用僱佣假女友蒙蔽自己的父母。据媒体报道，租一个假女朋友一天的费用最高可达1万元人民币。<br><img src="https://upload-images.jianshu.io/upload_images/1940331-4ec7b7813efbae5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>现代化约会方式为中国女性提供了更多选择。<br><img src="https://upload-images.jianshu.io/upload_images/1940331-658b8fbbcc0526a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在较为贫穷的农村地区，找对象的问题最为突出，而支付订婚礼金的传统则令问题愈加严重。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-eddb9c9da9d6b961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>她认为这属于中国「丈母娘经济」的一部分。「如果男人想要结婚，未来的丈母娘就会要求他先买套房子再谈下一步。这也是最近几年房价大幅上涨的原因之一。」她说。</p><p>但男性背负的这种财务负担也导致很多女性难以找到对象。大量男性选择晚婚导致这一问题进一步加剧，部分原因在于结婚的财务负担过重。而当他们想要成家时，往往希望找一个比自己年轻的女士。在中国，夫妻年龄差距在10至20岁，甚至更大，已经成为一种越发普遍的现象。</p><p>一旦到了32岁，女性就很难找到合适的男性。很多符合条件的中国男性都会跟年轻漂亮的女性结婚。</p><p>专家表示，女性往往渴望财务稳定，而能够提供稳定财务状况的男性往往年龄较大。</p><p>当然，反之亦然。她表示，受过良好教育且财务独立的单身女性被称作「剩女」。<br><img src="https://upload-images.jianshu.io/upload_images/1940331-63b8007031fd0484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="父母施压"><a href="#父母施压" class="headerlink" title="父母施压"></a>父母施压</h2><p>也有的已婚人士表示，父母是中国人找对象的一大压力来源，而且始终挥之不去。</p><p>父母认为，他们有责任帮助成年后的子女组建家庭。所以他们会强迫子女找对象、约会，然后凖备结婚。<br><img src="https://upload-images.jianshu.io/upload_images/1940331-85441b05978162c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这便产生了另外一个问题。父母总是干涉子女的婚姻大事。</p><p>父母经常安排子女跟陌生人相亲。如果子女没有结婚，父母就会面临社会的批评，所以女孩的父母往往会让他们的女儿跟陌生人相亲，并在30岁之前结婚。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-fcf10be798dd9083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>此外还有户外相亲角。在中国的一线城市上海，相亲角里有很多父母为单身子女张贴的手写广告，详细介绍了他们的收入、教育和性格。有的父母每周都会去相亲角，但坚持多年之后却仍然一无所获。</p><p>相亲和求爱方式的变化使得人们更加看重爱情，而不是财务安全等物质因素。</p><p>跟世界其他地方一样，普遍的爱情规律在中国仍然适用。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在中国，30岁以上的未婚男性被称作「剩男」，指的是还没有找到妻子的「剩下的男士」——而在一个性别越发失衡的国家里，这已经成为一大问题。&lt;/p&gt;
&lt;p&gt;1980年，中国新生儿男女比例仍处于正常区间。但到了90年，比例增加了但也没到很严重的程度，而 2000 的人口普查资料更显示，当年新生儿性男女比例失衡不但达到历史新高，第三胎男女比例更高达 6 : 1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="剩男" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E5%89%A9%E7%94%B7/"/>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="剩男" scheme="https://youdaily.github.io/tags/%E5%89%A9%E7%94%B7/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Python 字典的实现过程</title>
    <link href="https://youdaily.github.io/posts/f8a39f2f/"/>
    <id>https://youdaily.github.io/posts/f8a39f2f/</id>
    <published>2019-11-27T03:41:06.000Z</published>
    <updated>2019-12-10T02:02:05.747Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="Python-字典"><a href="#Python-字典" class="headerlink" title="Python 字典"></a>Python 字典</h2><p>字典是一种内置于 Python 中非常有用的数据类型，总的来说它是一些由键（key）索引的对象，这里的 key 是必须是不可变的。 以下是一个简单的字典用法示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'fengsp'</span>: <span class="number">10</span>, <span class="string">'amy'</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'fengsp'</span>]</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="string">'fengsp'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()</span><br><span class="line">[<span class="string">'amy'</span>]</span><br></pre></td></tr></table></figure><p>通常我们会多次的检索一个值（value），因此通过 key 来检索一个对象的过程必须是个非常快速的操作。对于 CPython 本身，多种语法特性都是在字典的帮助下支持的，例如，类实例就是使用字典来储存实例属性，可见字典的性能至关重要。</p><a id="more"></a><h2 id="PyDictObject-结构体"><a href="#PyDictObject-结构体" class="headerlink" title="PyDictObject 结构体"></a>PyDictObject 结构体</h2><p>在 CPython 源码中，字典是一个 C 的结构体， PyDictObject：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PyDictObject</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    Py_ssize_t ma_fill;  <span class="comment">/* # Active + # Dummy */</span></span><br><span class="line">    Py_ssize_t ma_used;  <span class="comment">/* # Active */</span></span><br><span class="line">    Py_ssize_t ma_mask;</span><br><span class="line"></span><br><span class="line">    PyDictEntry *ma_table;</span><br><span class="line">    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, <span class="keyword">long</span> hash);</span><br><span class="line">    PyDictEntry ma_smalltable[PyDict_MINSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Py_ssize_t me_hash;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    PyObject *me_value;</span><br><span class="line">&#125; PyDictEntry;</span><br></pre></td></tr></table></figure><p>在此数据结构中的这些字段分别是：</p><h3 id="ma-fill"><a href="#ma-fill" class="headerlink" title="ma_fill"></a>ma_fill</h3><p>表示所有激活元素（active entry）和虚拟元素（dummy entry）的计数。 如果删除一个 key，这个元素将成为虚拟元素，并且 ma_fill 任然保持不变；如果添加一个新的 key 并且新 key 不属于虚拟元素，则 ma_fill 增加 1。</p><h3 id="ma-used"><a href="#ma-used" class="headerlink" title="ma_used"></a>ma_used</h3><p>对象中所有激活元素的计数。如果添加一个新 key，ma_used 会增加 1，如果删除一个 key，这个字段将减 1。</p><h3 id="ma-mask"><a href="#ma-mask" class="headerlink" title="ma_mask"></a>ma_mask</h3><p>哈希表的位掩码，这个表中包含 ma_mask + 1 个哈希槽(slot)。 这里储存位掩码而不是大小，因为在查找元素的一个 key 时，使用 slot = key_hash &amp; mask 就能直接获得哈希槽序号。</p><h3 id="ma-table"><a href="#ma-table" class="headerlink" title="ma_table"></a>ma_table</h3><p>一个 PyDictEntry 结构体的数组， PyDictEntry 包含 key 对象、value 对象，以及 key 的哈希； 这些 key 的哈希作为缓存储存起来，例如，当我们搜索一个 key 时，我们可以通过使用缓存哈希来执行快速比较查找。</p><h3 id="ma-lookup"><a href="#ma-lookup" class="headerlink" title="ma_lookup"></a>ma_lookup</h3><p>一个用于查找 key 的函数指针。初始化时它被设置为 lookdict_string。 lookdict_string 假定字典的 key 全是 PyStringObject 类型，这是一个使得查找 StringDictObject 类型的 key 可以快很多的最佳优化。 如果一个 key 不是 PyStringObject 类型，那么ma_lookup 将改为一种更慢的普通查找函数。</p><h3 id="ma-smalltable"><a href="#ma-smalltable" class="headerlink" title="ma_smalltable"></a>ma_smalltable</h3><p>一个有 8 个槽的哈希表（译者注：这里应该是最小 8 个槽，因为 PyDict_MINSIZE=8）。 这样小字典也能直接存储在这里，并且不会再调用 malloc()。</p><h3 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h3><p>两个不同的 key 可能会被散列到相同的槽，这被称之为碰撞。当碰撞发生时，Python 使用 开放寻址法 来解决碰撞：如果这个槽不能再容纳这个 key（译者注：指槽中已经有 key），那么就寻找其他槽。</p><p>例如，这里有个简单的方法，如果槽 i 不能再容纳这个 key，就尝试槽 i+1 、i+2 等等。对于每条哈希，我们现在定义了能容纳它的所有槽的列表，如果删除其中一个 key，整个列表将会被破坏，这就是这里为什么我们需要虚拟元素（dummy）。</p><p>这个简单的开放寻址线性算法会使其退化为线性堆，这将导致性能降低，因为我们每次查找一个 key 都要扫描所有的槽。在实际中，CPython 使用如下算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DUMMY = <span class="string">'dummy'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以我的水平并不足够理解算法是如何工作的，</span></span><br><span class="line"><span class="comment"># 最后的结果会覆盖 0 到 ma_mask 之间的所有整数。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_addressing_in_cpython</span><span class="params">(table, key, hash)</span>:</span></span><br><span class="line">    free_slot = <span class="literal">None</span></span><br><span class="line">    perturb = hash</span><br><span class="line">    i = slot_index = hash &amp; ma_mask</span><br><span class="line">    <span class="keyword">while</span> table[slot_index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> table[slot_index].key != key:</span><br><span class="line">        <span class="keyword">if</span> table[slot_index].key <span class="keyword">is</span> DUMMY <span class="keyword">and</span> free_slot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            free_slot = slot_index</span><br><span class="line">        i = (<span class="number">5</span> * i + perturb + <span class="number">1</span>)</span><br><span class="line">        slot_index = i &amp; ma_mask</span><br><span class="line">        perturb &gt;&gt;= <span class="number">5</span></span><br><span class="line">    <span class="keyword">if</span> table[slot_index] <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> free_slot <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> free_slot</span><br><span class="line">    <span class="keyword">return</span> slot_index</span><br></pre></td></tr></table></figure><h2 id="哈希表大小"><a href="#哈希表大小" class="headerlink" title="哈希表大小"></a>哈希表大小</h2><p>如果我们持续添加 key 到字典中，那很快就会没有足够的空间来装下所有的 keys，现在就需要对哈希表扩容（resize）。</p><p>CPython 会在每次添加 key 时检查表大小，如果哈希表已经处于三分之二满（相对于 <code>ma_fill</code>），将扩容哈希表。如果字典中包含接近或超过 50000 keys，扩容后新的大小将为 <code>ma_used * 4</code>，其他时候扩容后为 <code>ma_used * 2</code>。</p><p>哈希表不会在从字典中删除大量 keys 时引发调整大小，这意味着哈希表将不会变小。这不是什么大问题，因为大多数时候我们我们只使用字典一段时间，然后就丢弃掉整个字典。如果你真的建立了一个非常大的字典，并且从中删除了许多 keys，那么你应该用剩余的 key 创建一个新的字典。</p><h2 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h2><p>许多字典实例被频繁的创建和销毁，为了减少创建和销毁的次数，一种 <code>free_dicts</code> 数组被用于容纳不再使用的字典对象，相当于一个简单的缓存。如果我们需要一个 PyDictObject 对象，它将从可用的空闲列表中获取。</p><h2 id="键共享与有序字典"><a href="#键共享与有序字典" class="headerlink" title="键共享与有序字典"></a>键共享与有序字典</h2><p>当字典用作对象属性的容器时，它们会占用比必要更多的内存，因为键是相同的，但它们却被复制到每个实例中了。自 Python 3.6 起，一个属性字典与同一类实例的其他属性字典共用 keys，例如有如下这样的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, username, email)</span>:</span></span><br><span class="line">        self.username = username</span><br><span class="line">        self.email = email</span><br></pre></td></tr></table></figure><p>这些属性字典将会被像这样存储：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是在属性字典之间共享的</span></span><br><span class="line"><span class="comment"># 并且这也是排序的</span></span><br><span class="line">keys = [</span><br><span class="line">    (<span class="number">5317300778844242624</span>, <span class="string">'username'</span>),</span><br><span class="line">    (<span class="number">268341141884068675</span>, <span class="string">'email'</span>),</span><br><span class="line">]</span><br><span class="line"><span class="comment"># this hash table just stores the index to the key entries</span></span><br><span class="line"><span class="comment"># 这个哈希表仅把索引存储到键元素中</span></span><br><span class="line"><span class="comment"># 这是简化的</span></span><br><span class="line">index_table = [<span class="number">0</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">1</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是值</span></span><br><span class="line">values = [<span class="string">'user01'</span>, <span class="string">'user01@example.com'</span>]</span><br></pre></td></tr></table></figure><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Python-字典&quot;&gt;&lt;a href=&quot;#Python-字典&quot; class=&quot;headerlink&quot; title=&quot;Python 字典&quot;&gt;&lt;/a&gt;Python 字典&lt;/h2&gt;&lt;p&gt;字典是一种内置于 Python 中非常有用的数据类型，总的来说它是一些由键（key）索引的对象，这里的 key 是必须是不可变的。 以下是一个简单的字典用法示例：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;d = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;fengsp&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;amy&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;d[&lt;span class=&quot;string&quot;&gt;&#39;fengsp&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;del&lt;/span&gt; d[&lt;span class=&quot;string&quot;&gt;&#39;fengsp&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;d.keys()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&#39;amy&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通常我们会多次的检索一个值（value），因此通过 key 来检索一个对象的过程必须是个非常快速的操作。对于 CPython 本身，多种语法特性都是在字典的帮助下支持的，例如，类实例就是使用字典来储存实例属性，可见字典的性能至关重要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://youdaily.github.io/tags/Python/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>网易裁员事件-《网易裁员，让保安把身患绝症的我赶出公司。我在网易亲身经历的噩梦》</title>
    <link href="https://youdaily.github.io/posts/b8422409/"/>
    <id>https://youdaily.github.io/posts/b8422409/</id>
    <published>2019-11-24T07:49:37.000Z</published>
    <updated>2019-12-10T09:28:23.597Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>以下为《网易裁员，让保安把身患绝症的我赶出公司。我在网易亲身经历的噩梦！》全文内容：</p><p>我是网易的一名游戏策划。14年从上海交大毕业后就进入网易工作，5年里，我和大部分网易员工一样以“网易人”的称号为傲。</p><p>直到18年底开始传出网易毁约应届生、年前最后一天裁员、威胁员工的消息时，仍不愿相信这是网易的所为，更想不到不久后我就会在身患绝症的情况下亲身经历逼迫、算计、监视、陷害、威胁，甚至被保安赶出公司。</p><h2 id="01-患病"><a href="#01-患病" class="headerlink" title="01 患病"></a>01 患病</h2><p>这5年里，除了某段时间经常在后半夜两三点钟下班，主管说第二天早上可以请病假晚到一会儿之外，我请病假的次数屈指可数。</p><p>但去年年底感冒后开始头晕体虚，爬楼梯开始吃力，这才开始多次向主管和代理主管请病假就医。</p><p>今年1月底，被确诊为扩张型心肌病。心脏扩大近一倍。期间跟代理主管说了是心脏出了问题，但只是请病假更方便了一些，没有因病减少或耽误丝毫工作。</p><p>3月底主管找我谈绩效，说他跟代理主管聊过了，这次准备给我评D绩效，因为我现在不适合在这里继续工作了。</p><p>当时我很懵，因为我和代理主管每天吃饭的时候都在讨论项目的开发方向，很多重要的功能也都是我俩加班讨论确定的，重要功能他也都交给我做，组内的业绩排名也基本是他第一我第二。</p><p>我不明白他为什么要突然捅我一刀。</p><p>我又问主管原因，结果主管给出的都是因为组内人数过多，因为老员工的评判标准要比新员工高这种很敷衍的理由。</p><h2 id="02-威胁不让拿N-1"><a href="#02-威胁不让拿N-1" class="headerlink" title="02 威胁不让拿N+1"></a>02 威胁不让拿N+1</h2><a id="more"></a><p>因为这半年项目的管理工作都是由代理主管负责的，主管完全没有参与项目管理。</p><p>所以我又找主管说这个D绩效和我的实际工作不符，并亲自阐述我这半年的业绩。</p><p>结果刚阐述没几句就被主管打断，说我现在已经不适合继续在这工作下去了，说我只能接受这个结果并在一个月内离职，而且这期间要把我积攒的11天年假休完，并在年假前把离职申请发了，电脑也还了。</p><p>4月总共21个工作日，除掉我的年假，额外给我的时间是10个工作日。</p><p>我不愿发申请，主管和HR就轮番找我谈话逼我，并且变相威胁说拿N+1的话会对我非常不利，句句都是以“怕影响我找下一份工作”的角度劝我不要拿N+1。</p><p>接下来我发现不止我一个，周围还有其他同事被主管约谈劝退。</p><p>随后发现网上有很多网易同事曝出公司裁员，并通过威胁不给赔偿的事实。然而其中的很多爆料却都被辟谣、删帖或举报言论不实了。</p><p>不过这些帖子却给了我很大的帮助和指引。让我知道接下来的谈话要录音，不能签字等。</p><p>其中印象最深的一个帖子，是一个网易同事被HR逼走之后，觉得很委屈。底下评论的人没有安慰他，而是骂他太窝囊。</p><p>当时我很不理解，但现在想起来，如果不是看到了那些骂声，恐怕我也会和那位同事一样。</p><p>虽然同事们的爆料都被压制住了，但却给我这个正在被裁的人带来了好处。</p><p>接下来HR和主管找我谈话的时候，竟然松口说可以给我约四分之一的补偿，不过仍然说拿N+1的话会对我很不利。</p><p>他们一边跟我说少拿那点补偿不算什么，一边又说公司会因为我多拿那点补偿对我这样那样的，让我有种公司比我个人还穷的错觉。</p><p>我说这次是因为要让我走强行给我打了D绩效，不给我N+1，那我原本应得的绩效奖金总可以给我吧？</p><p>然而HR说绩效奖金是不受法律保护的，而且已经分完了。</p><h2 id="03-设陷阱阻拦我绩效申诉"><a href="#03-设陷阱阻拦我绩效申诉" class="headerlink" title="03 设陷阱阻拦我绩效申诉"></a>03 设陷阱阻拦我绩效申诉</h2><p>接下来我开始找工作，并主动说了自己患扩张型心肌病的实情，结果都被拒绝了。</p><p>期间我又去医院看了几位医生，这才意识到原来药物只是控制我的病情恶化速度，原来可能只有几年时间，然后只能靠心脏移植来续命。</p><p>期间主管和HR继续找我谈话，每次我都试图和他们谈我的工作内容，然而他们每次谈话都不停地强调就是要裁掉我，和绩效无关，即便绩效高也要裁掉我。</p><p>而且不停地让我觉得留下来没有意义，好像我留在公司就是累赘一样。</p><p>5年来，我第一次开始想要逃离这里，而且每一次谈话就强烈一次。然而我无处可逃。</p><p>唯一有所不同的是，他们再次用背调威胁我的时候，我感觉不到害怕了。</p><p>一直以来把前途看得无比重要的我，终于不用再为前途担忧了。</p><p>和绩效无关，那我能想到的这半年来我犯的别的错就只有生病了，然而这个错我改不了，所以我还是只能从绩效的角度出发。</p><p>这时我收到了绩效通知邮件，说不回复邮件就算认同此次绩效评定，于是我回邮件进行绩效申诉。</p><p>结果申诉后主管找我谈话，说绩效申诉对我没什么好处，所以他跟HR说这个流程可以稍缓缓，还说他特批我可以不用来公司打卡了。</p><p>平时请病假和即将到期的年假都要保证丝毫不影响工作，如今对员工这么好，实在不敢消受。</p><p>当天HR也找我谈话，要撤掉我的工位，还说接下来就不用来公司打卡了，并再次催我请年假，且在这之前把电脑还了，离职手续先办掉。</p><p>第二天我依旧去上班，结果发现已经被踢出了工作圈，很多证据因此无法收集。</p><p>当天收到了HR要求提供绩效复核证据的邮件，要求两天内提供绩效复核的证据，否则就又视为认可此次绩效结果。</p><p>也就是说如果我按照主管和HR说的还了电脑第二天开始不去公司了，就会稀里糊涂地认可了绩效结果。</p><p>幸好我已经提前准备了一些业绩证据，于是很快提交了复核证据。</p><h2 id="04-监视和旷工威胁"><a href="#04-监视和旷工威胁" class="headerlink" title="04 监视和旷工威胁"></a>04 监视和旷工威胁</h2><p>差不多从这时候开始，我就经常在公司看到几个面生的人。</p><p>之后我的工位被调到远离策划组的过道角落位置，他们几个间或从我座位旁经过。</p><p>有时去我旁边的会议室打电话时还不时看向我。搞得我每次用u盘拷证据都很紧张很小心。</p><p>我一度想拍下来，又怕真是同事被误伤，觉得被监视这种事离自己太遥远了。</p><p>等待绩效复核的同时，我按照网上大家说的对付非法裁员的常用方法，不发离职申请，也不请年假，每天按时打卡上下班。</p><p>结果HR又给我发消息说如果不请年假就算我旷工。（迟到早退旷工公司是可以直接开除且不需要支付补偿金的）</p><p>▲ HR聊天截图</p><p>我在网易的5年时间里，一次迟到早退都没有。</p><p>不管是连续几周加班到后半夜，还是连续的996，第二天我都没有迟到过。</p><p>感冒发烧身体不舒服，强撑着也要在周维护的早上爬起去公司，也要等半夜周版本测试结束才能离开公司，我依然没有迟到早退。</p><p>我坚持了5年，可坚持到最后，只是因为我不愿意接受他们的摆布，就威胁要强行算我旷工。</p><p>我不服。于是仍然拒绝按HR说的做，坚持等绩效复核。</p><h2 id="05-强行挑刺"><a href="#05-强行挑刺" class="headerlink" title="05 强行挑刺"></a>05 强行挑刺</h2><p>之前HR给我发的邮件都是两天内不申诉就算认同绩效结果、两天内不提供证据就算认同绩效结果，让我以为很快就会开展绩效复核。</p><p>可等我提供完证据后，复核却一再推迟。</p><p>绩效复核开始前的一个小时，主管再次找我谈话，说如果真的走到绩效复核这一步，那他就跟HR说直接走辞退流程，接下来就要很严格地去做了。</p><p>我问他为什么不能进行绩效复核，如果我拿到我应得的绩效呢？</p><p>主管说那也是走辞退流程，还问我现在手上已经没有工作要做了，接下来打算怎么办呢。</p><p>可他越是阻拦，我就越是坚持要绩效复核。</p><p>虽然3月底这次谈的这次绩效名义上是“2018年下半年绩效”，但以往主管和我谈的都是最近半年的业绩，所以我提供的业绩证明也是18年10月-19年3月的。</p><p>结果在之后的绩效复核中，主管说要从18年5月开始算半年的工作量。</p><p>19年3月底谈的半年绩效，怎么算能把18年5月份算进来？</p><p>但我能理解主管要这么算的目的。5月中旬我才因为前一个项目组解散进入这个项目组，还在熟悉项目内容。而6月我又休了一个很长的年假（网易的年假6月30日清空，当时小主管也是刁难不愿给假，另外一个同事年假期间还要每天下午去公司干活儿）。</p><p>所以按照主管的算法，自然会对我的业绩影响很大。</p><p>而且这样一来，我提供的业绩证明就基本都没用了。</p><p>关于我的工作业绩，我不做任何主观的评价，只想客观说明几点：</p><p>公司有游戏设计专家进行业绩评审，我18年11月底刚刚通过评审晋升。</p><p>而项目组有业绩排名，在项目周报上公示。</p><p>▲ 18年11月业绩排名</p><p>▲ 18年12月业绩排名</p><p>11月份我的业绩排名在组内7人中排名第2，12月份在组内6人中排名第2，而我负责的功能bug率为全组最低。即便确诊后病情严重期，我的排名也基本稳定第2名。</p><p>尤其是3月，如果不是主管让人把我负责的已经完成的单子转到别人名下，我应该是第一名。</p><p>被我反驳后主管又强行挑刺说我有一个bug，我反驳说这个bug是接口bug，不是我的bug，而且影响很小。</p><p>结果主管说所有的问题都是策划的问题，问我同意吗。</p><p>那现在如果我说所有的错也都是主管的错，不知主管你同意吗？那你愿意也为这个接口bug引咎辞职吗？</p><p>现场只有一个HR旁听，完全就是走个过场而已，绩效申诉的真正作用应该也就是为了让员工默认绩效结果。</p><p>真心觉得自己患病后还那么卖力地工作没有一点意义。</p><h2 id="06-用保安威胁我"><a href="#06-用保安威胁我" class="headerlink" title="06 用保安威胁我"></a>06 用保安威胁我</h2><p>复核结束后主管和HR找我谈话，说要在绩效复核结果出来之前就让我离职，并再次强调不管我的绩效是什么都要让我离职。</p><p>又说项目运营不下去我有责任，想通过变相背锅的方式让我离职。</p><p>然而这半年来我和代理主管不停地讨论着怎么修补之前主管和小主管们留下的设计缺陷。</p><p>其中有两个缺陷导致游戏后期完全无法继续运营下去，一个是让玩家花一两百块通过该系统获得的属性强过之前玩家需要花十几万才能获得的属性，另一个则是彻底打破了职业平衡。</p><p>即便主管这半年都没有负责项目组的工作，可只要他一直在玩我们的游戏，就不可能发现不了这么严重的问题。</p><p>然而主管和小主管只是在游戏开服时暗示我们充值过万才能做出好的设计，半强制地带动组内策划们充一波钱。</p><p>当时主管布置给我们策划的一项任务，就是每人要“维护”游戏内的几个大R玩家，并每周作为工作内容来汇报。</p><p>两个月后，维护的大R基本都走了，主管和小主管们就不怎么登陆游戏了。只有我和代理主管每天努力地把游戏等级维持在服务器最高等级。</p><p>而游戏里玩家们的行为也如他们所期，都是进来充几十万，两个月后，就没几个玩家在玩了。好不容易留下的那几个大R，在后期看到自己十几万获得的属性，只要百来块就能获得了，也愤而退游。</p><p>某位小主管凭借这两个设计晋升了策划主管。</p><p>而我何德何能，身患重病还有此殊荣为不作为的主管和犯错的小主管背完最后一口锅。</p><p>谈话时主管多次数落我说你看xxx（其他在他手底下被裁的同事）多久就走了？xxx可是没拿补偿金的。好像我应该和其他同事攀比谁更快签字离职，谁不拿补偿金似的。</p><p>又举其他人离开的例子，说这次很多人都走了，问我跟我一起进来的人还有几个在的？多吗？</p><p>说严选、考拉、邮箱比我们裁得更厉害，让我接受这个结果。（我主管的职级是高级经理，在网易内部绝对的高管，他的话可以代表网易承认裁员的事实）还说在其他公司，都只会上午通知，下午就让员工走人，也没有N+1，不按劳动法来也是很正常的。</p><p>说他没有说上午通知我，下午就让我走，还耐着性子跟我沟通了这么多，没有要HR和IT直接来收我的机器，收我的工牌让我走对吗？</p><p>接着说我只有两个选择，一是主动签字，二是被动签字。</p><p>我问他如果我不签字呢？</p><p>结果主管说那接下来就是保安和IT的事了。</p><p>我问跟保安有什么关系，他说他也不知道，他只是猜测而已。</p><p>从他用保安来威胁我时，我就决定了，我一定不会签字，一定要去仲裁。</p><p>不过我还是很害怕，也不敢想象被保安赶出公司的狼狈。</p><p>然而我只是一个在网易兢兢业业加班了5年患了重病的老员工，只是被主管HR威胁逼迫时不愿意签字而已。</p><p>不签字难道不是员工的自由吗？为什么到了网易这里却成了员工必须遵守的规则，不遵守就要用保安赶出去？</p><p>公司可以一而再再而三地威胁算计员工，员工却不能反抗？</p><h2 id="07-住院时的威胁"><a href="#07-住院时的威胁" class="headerlink" title="07 住院时的威胁"></a>07 住院时的威胁</h2><p>疾病再加上主管和HR的一再威胁逼迫，压得我每天都透不过气来，每分每秒都处在要崩溃的边缘，最后终于撑不住住院了。</p><p>而我将住院的事情告知主管请假后，HR给我打电话问我住院的地址，说主管和HR很关心我的病情，有一个文件要寄给我。</p><p>我问文件内容是什么，HR说让我先签收自己看。</p><p>我说我都不知道内容是什么，而且我在住院不方便，不能签收。</p><p>结果HR说“收个稿件你觉得会影响你养病？”“如果你觉得现在收不方便，那我们寄回你老家，让你家人帮你收也可以的。”</p><p>我想如果他们也有父母的话，应该也会知道父母年龄大了受不了刺激。</p><p>背调威胁、旷工威胁、保安威胁、住院了还要威胁，而且还用我的家人来威胁。</p><p>而且所有的威胁都是变相威胁，或许他们觉得这样就能掩盖威胁员工的本质了吧！</p><p>在我住院的时候，项目也迎来了最重要的一次活动，3个活动玩法中两个核心玩法都是我之前制作的。而再之前的次重要活动也是我负责制作的。</p><p>当我躺在病床上看着主管们朋友圈转发我的活动时，再没有丝毫的自豪感，只是觉得有些悲凉。</p><p>在网易这么多年，见过程序被分配了超负荷工作量最后被挑刺说有bug的，也见过UI累死累活两年在项目马上上线时主管向UI主管说坏话给调走的，我只是比他们更惨了一点而已。</p><p>在网易，你努力了还是会有回报的，只是不一定回报在你身上。</p><p>接下来的3个月，我度过了人生中最漫长的一个病假。</p><p>上一次这么长时间无所事事地闲着，似乎还是小学升初中的暑假。</p><p>这期间我想通了两件事。</p><p>一件关于生存。</p><p>虽然在网易游戏工作，但我的收入并不高，早年好不容易涨薪也只多拿了800块钱，主要的工资涨幅也都在被裁前的那几个月，拿了没多久就要被裁掉。</p><p>5年来我拿到的项目分红奖金加起来也只有不到3000块。</p><p>除去支付公司附近高昂的房租和偿还上学时家里欠的债，所剩无几，也曾因此买不起高端手机和没有在游戏中充值足够多的金额而影响了绩效评价。</p><p>现在的我无房无车，未来还需要生活费医药费以及巨额的心脏移植费用。</p><p>父母年龄大了，而我未来非但不能赡养父母，还要指望父母去借钱给我治病。</p><p>他们借钱供我读完了大学，而现在，我不能再让他们去借钱了。因为上学时借的钱我毕业了可以赚钱还，而现在再借钱很可能会成为死账，没人可以还了。</p><p>所以我一定要继续工作。</p><p>另一件是为什么之前经受网易裁员手段的同事都想仲裁想曝光网易的行为。</p><p>网易的行为其实就是在卸磨杀驴。</p><p>气愤的不是卸了磨之后不给水喝，而是卸了磨非但不给水喝，还用刀子对着你。</p><p>然而同事们都担心影响前途，所以不敢做。</p><p>那如果我注定没有前途了的话，为什么我不来做这件事呢？</p><h2 id="08-被早退"><a href="#08-被早退" class="headerlink" title="08 被早退"></a>08 被早退</h2><p>7月份的时候，因为继续休病假公司就要额外多支付我半个月工资的补偿金，于是主管给我发消息说要接听HR的电话才可以继续休病假。</p><p>为了避免再次在电话里被威胁，我回复说已经依法提供了病假所需的全部材料，如果公司觉得还缺少什么材料我可以补充，结果主管回复说必须接听HR电话才能继续休病假。</p><p>因为我已经仔细查过相关法律条文，确定自己依法提供了病假所需材料，于是拒绝接听。</p><p>结果7月底，我上系统看了一眼，发现自己竟平白多出了4次早退记录。</p><p>网易的考勤系统只显示上班打卡时间，下班打卡时间是隐藏的。所以除了证明没迟到外，员工很难进行其他和考勤有关的维权。</p><p>不过我在请病假前留了张自己的考勤截图。</p><p>▲ 5-10考勤记录</p><p>▲ 7-31考勤记录</p><p>5月10号是我请病假前在公司的最后一天，可以看到，当时还没有早退记录。</p><p>而5月10号开始我一直在休病假。</p><p>所以这4次早退记录到底是从医院早退，还是从家里早退？</p><h2 id="09-被诬陷发反动内容"><a href="#09-被诬陷发反动内容" class="headerlink" title="09 被诬陷发反动内容"></a>09 被诬陷发反动内容</h2><p>接下来我联系了一些网易同事，说了自己想仲裁和曝光公司的想法。</p><p>结果两天后有关部门突然找到我家，说我有反动倾向和自杀倾向，依据是我搜索和浏览过相关内容。说要找我调查情况，让我母亲赶快把我交出来。</p><p>我母亲说我患病并苦苦哀求，保证会看好我不做任何事，他们才没有找我调查。</p><p>紧接着我收到HR的邮件，说必须回公司去签署一份告知书，否则会对我后续休病假十分不利。</p><p>因为担心回去之后会被以早退等理由开除，我给老板发了投诉邮件，阐述了以往绩效评定中就存在的种种不公平之处，以及近期主管和HR通过强行打低绩效达到变相裁员的目的和他们威胁算计我的种种行为。</p><p>当然重点是附上了详细的业绩证据，可以证明主管给我的评定理由不成立以及我的实际业绩，申请专业的绩效复核。</p><p>这时候我依然相信主管和HR的行为只是个人的处理方式，相信公司会给我一个公正的评判。</p><p>之后我去公司，HR找我谈话时竟清楚地知道有关部门找我的事以及下的定论，还把定论升级为“有关部门说我发反党反政府”，试图以此作为我无法继续留下工作的一个理由。（公司的规定是员工有自杀、反动等倾向及发表任何不利公司的言论，公司均可直接开除并不支付任何补偿金）</p><p>我这才想起来，在被主管用保安威胁后，我把内部聊天软件的个性签名改成了“此去泉台招旧部，旌旗十万斩阎罗”，这是我能想到的唯一一件和发反党反政府内容有关的事了。</p><p>而整个病假期间，我除了和几个网易同事聊过仲裁曝光公司的事情外，没通过网络发表发送过任何内容。</p><p>所以这件事有三种可能：</p><ol><li><p>有关部门确实和公司这样说的，但我没发，那这就是在诬陷我。</p></li><li><p>有关部门没和公司这样说，那就是公司在诬陷有关部门。</p></li><li><p>是公司向有关部门这样举报我的。那就是公司在诬陷我。</p></li></ol><p>我想如果病假期间我为了找工作把之前的工作内容发给HR或猎头，可能就是这样的结局了吧。</p><p>▲ 其他同事经历</p><h2 id="10-老板知情后的继续威胁"><a href="#10-老板知情后的继续威胁" class="headerlink" title="10 老板知情后的继续威胁"></a>10 老板知情后的继续威胁</h2><p>这次谈话的人多了一个HR总监。</p><p>他没提签告知书继续休病假的事情，却提出之前主管和HR提过的要求，让我回家办公，不用来公司打卡。我拒绝了。</p><p>然后他又说如果我不按他说的做，那他就不管了，说公司有那么多的法务和专业人员，交给他们处理。我就想我又没犯法，就算公司有1000个法务和我有什么关系？于是再次拒绝。</p><p>他又提出公司要给我提供一次心理咨询，我拒绝了。</p><p>然后他又提出让我签字授权他们和我的医生聊一下以及让我到他们指定的医疗机构去检查，但不告诉我这样做的目的。</p><p>因为当时我的症状还是比较严重，担心会被说成“医疗期结束后仍无法从事工作”，于是跟他说签字可以，但是公司要保证不会以“医疗期结束后仍无法从事工作”为由开除我，结果他说不能保证，于是我又拒绝了。</p><p>而根据HR总监和HR之后的表述，老板把我的投诉邮件给他们看过了。</p><p>于是接下来HR找我谈话时，换了更隐晦的威胁方式。</p><p>跟我说仲裁就算我赢了，公司也会通过不断上诉拖我两年时间，我耗不起的。</p><p>至此，我彻底对来自公司的公正评判不抱任何希望了，还有些后悔将我掌握的全部业绩证明发给老板了。</p><p>大公司的确有比小公司更完善的制度，但更多的都是维护公司利益的。</p><p>不过他们承诺如果同意签字，可以给到高于N+1的金额。</p><p>关键是要拿这笔钱是有附加条件的，要分12个月拿。这意味着不仅要放弃后续一切的法律途径维权，而且变得没有保障。</p><p>其实如果我相信公司的话，可能也会选择接受，毕竟于我而言，每一分钱都是救命钱。</p><p>然而此前千方百计逼我走，威胁不让我拿N+1，不肯给我应得的奖金，连病假都不愿让我休，中秋礼盒都没我的份……我经历的这一切让我已经不敢相信公司了。</p><p>事实证明公司在这方面的确是毫无信用可言。</p><p>在公司后来给出的单方解除通知书上，明确写着N+1和应发的工资会在9月9日前发放。然而9月9日我没有收到一分钱。</p><p>最后N+1还是我去申请劳动仲裁后才拿到的。（其他同事的大额赔偿金也有被公司一直拖着不给，去申请了仲裁公司才给的。）</p><p>因为我拒绝接受他们开出的条件，并且表达了会通过法律途径维权，于是HR给我母亲打电话，说我生了这个病就没法继续在这工作了。</p><p>我母亲说确诊后也一直在加班，是因为他们一直威胁我特别是最后主管威胁要让保安赶我出去才会病情加重。</p><p>结果HR说让我母亲劝我，否则他们也不愿意看到保安来清退我。</p><p>我母亲说网易这样欺负人我们就向社会求助。</p><p>巧的是，第二天一早，又有工作人员来敲门，拿着电话说有关部门人员要找我母亲，问我母亲我的情绪怎么样，跟我母亲说我现在离职还没离职，让看好我不要做出什么事来。</p><p>我母亲怕出事，于是劝我说要不主动签字算了。</p><p>而我却感觉自己好像被无数的铁链捆绑着，喘不过气来。勒得越紧，我就越是想挣脱。</p><p>但是我的身体还是太没用了，于是我没能去公司，又去了医院。</p><p>请了病假之后，HR给我打电话，在我告知了人在医院身体状态不好的情况下，仍然要让我去一趟公司。</p><p>我说我需要休息，如果身体状况好些就过去。结果回去刚睡下，就被HR接二连三的电话吵醒。最后我母亲接了电话，告诉她我实在去不了她才肯作罢。</p><h2 id="11-保安暴力驱赶"><a href="#11-保安暴力驱赶" class="headerlink" title="11 保安暴力驱赶"></a>11 保安暴力驱赶</h2><p>周末休息了两天，周一我去了公司。</p><p>HR和HR总监找我谈话，我又陈述了病假回来后仍然被他们排挤的事情。HR总监冷嘲热讽地说他也能感觉到我留在这里并不愉悦，不明白我为什么还不走。</p><p>你们千方百计排挤我边缘化我，想要逼我主动离职，我当然不愉悦了。可如果我主动离职，不就中了你们的下怀了吗？</p><p>所以不好意思，就算给我的是一坨屎，我也要咽下去。</p><p>期间我表明了自己拒不接受公司开出的条件、要用法律来维权的态度。</p><p>而HR和HR总监再一次变相威胁要让保安赶我走，还说要让保安来清点我的个人物品。</p><p>至此，主管、HR总监和HR三个人均以保安驱赶作威胁，也说明这不是个人临时决定的行为，而是一项自上而下用来压迫员工的方针。</p><p>即便再次被威胁，最后从会议室离开的时候我还是先问HR总监我可以回去了吗？他说可以我才走的。</p><p>HR总监、HR谈话变声后来自你的游戏我的心00:0016:02</p><p>结果我刚回到工位，HR和HR总监就忽然带着几个保安围了上来，然后保安开始拆我的电脑，搜查我的个人物品。</p><p>除此之外还有另外几个不是穿着保安服的人在稍远处等着，不时和HR总监交涉，总共加起来有七八个人。</p><p>其中就有我之前频繁看到，怀疑是在监视我的人。</p><p>虽然此前已经被用保安驱赶威胁过3次了，可真的发生时我还是被这阵仗吓到了。</p><p>我想我但凡有一丁点的阻拦，那就又不知道是什么后果了。</p><p>于是9月9日，我和隔壁阿里的创始人同一天“退休”了。</p><p>我俩一样是在退休前“被早退”，也一样是被簇拥着离开公司的。只不过他被员工簇拥着，我被保安、HR和其他不知什么职位的人簇拥着。</p><p>这一天见证了一个互联网行业的伟大人物离场，一个互联网大时代的落幕。</p><p>而就在十几米外的另一边，一个互联网公司的绝症老员工被保安赶出了公司，一个互联网人的小时代也落幕了。</p><p>再次声明，我不是临时工，不是外包人员，在网易的5年里，我的职位一直是高级数值策划，是一名正式员工。</p><p>需要员工的时候就让其无限度地加班，不需要了就无所不用其极地要立马赶走，千方百计不让员工拿到奖金和法定的补偿金，还不许员工维权和抗争。</p><p>在我患病之后，我没有感受到他们哪怕一丁点的关怀，有的只是算计和威胁。</p><p>我想这些才是网易的规则吧。</p><p>离开时我也验证了一件事。</p><p>就是之前我频繁见到的生面孔，最后一天我被保安驱赶时，看到他们和保安HR们汇合了。</p><p>现在我想请公司证明一下，我和他们的频繁相遇真的是因为缘分，而不是公司安排他们监视我想搜集我什么把柄。</p><p>还想请公司澄清一下，HR、HR总监谈话时有意无意地提到我住在哪个小区，真的只是在拉家常而已。</p><p>不然我胆子小，会担心发完这篇文章我会有人身危险。</p><p>回想起刚进网易那会儿，午餐有酸奶，晚餐有水果，生日的时候有超市现金卡，下班后有免费的健身课。</p><p>后来酸奶水果都没了，工资强行打入网易宝，健身课要自费，员工的吃饭时间也被严格限制。</p><p>以前便宜又实惠的自动售货机也被换成了昂贵的严选零食，生日礼物也变成了考拉严选的折扣券和满减券，工作邮箱里充斥着大量的严选考拉等喊着员工福利实际却并没让利多少的促销邮件。</p><p>真不明白这样赚员工的钱又能赚多少呢？</p><p>如今又取消桶装水，限制纸巾，缩减奖金，坑应届生，威胁员工……</p><p>以前这里的确是养猪场，但现在在我眼里更像是屠宰场。</p><p>虽然现在这些都和我无关了，可我还是想说，公司怎么对待玩家，怎么对待员工，这些迟早都有一天会反作用于公司。即便没有立刻反应出来，可这些效应其实一直都在滚雪球。</p><p>如果有一天无论是从业者还是用户，在提起网易时都嗤之以鼻，那时该如何收场？</p><p>人散了，还能网聚起来。人心散了，就真的聚不起来了。</p><h2 id="12-举步维艰的维权"><a href="#12-举步维艰的维权" class="headerlink" title="12 举步维艰的维权"></a>12 举步维艰的维权</h2><p>经过这几个月的时间，我也统计出了这5年来我在网易加班的总时长，大约4000个小时，基本都是项目组强制的加班。</p><p>因为很大一部分证据无法收集，以及被保安驱赶时丢失的u盘和电脑里没能拷出来的证据，最后我带出来的只有一部分加班证据，但是能证明的加班时长还是有2400个小时。</p><p>当时我甚至觉得加班也有成就感，觉得那些朝九晚五的人就是在虚度人生。</p><p>可回过头来看时，我发现我们大部分的加班、迭代甚至推倒重做，都只是在为主管们的错误决策买单而已。</p><p>他们的KPI其实都是底层员工透支健康堆起来的。</p><p>主管们让员工超负荷自己却落得清闲，其实真正应该加班认真做决策把控方向的，恰恰是他们自己。</p><p>而对我个人而言，这些加班其实并没有太大的意义，这才是最可悲的地方。</p><p>5年的加班我也只拿到了1天的加班工资，还是公司设计的陷阱。</p><p>被赶出公司后我开始追讨加班工资，然而公司辩称我所有的加班都是不合规的。</p><p>那仅有的1天加班工资也成为了我所有其他加班不合规的佐证。</p><p>不过追讨加班工资的官司我还是会和公司打到底的，因为那每一分钱都是我的血汗钱。</p><p>上个月我去医院拿药发现医保用不了，查了一下才发现我的社保8月份就已经停保了。</p><p>离职证明公司也拖了一个半月不给我，即便我找劳动监察投诉，又跟HR说等着离职证明要领失业金，HR还是跟我说他们要考虑给不给我。</p><p>之后好不容易拿到离职证明去办理失业登记，又被工作人员告知公司开的证明不合规，于是我又联系HR说明了马上就要过了失业金办理期限，让帮忙盖公司公章。</p><p>结果HR回复我说她请示过了，因为我和公司对于解除劳动关系的理由存在争议，所以不能给我盖公章。言外之意就是我要放弃劳动仲裁，他们才肯给我盖章。</p><p>最后又是一番交涉，我才终于拿到证明材料，办理了失业证。未来的8个月时间里，我可以领到失业金了。</p><p>虽然我从未想过自己有一天要靠失业金生存下去。</p><p>要工资条的经过也和要离职证明的经过一样难。</p><p>前两次我给监察大队长打电话说公司没有提供工资条，每次大队长都说他联系公司让公司提供，可是公司根本就不给提供。</p><p>第三次我给大队长打电话问工资条的事，大队长说公司跟他说上了法庭再说。</p><p>我问为什么我要一张工资条也要到了法庭上才能拿到？并坚决要求尽快拿到工资条。</p><p>就这样我才终于从HR手上拿到了工资条，此时距离大队长第一次说打电话让公司提供工资条已经过去了一周多。</p><p>可我拿到工资条发现上面只有一个最终发给我的金额。我跟HR说我要工资条就是想看各项明细，知道为什么是这个最终金额的。</p><p>结果HR说我们公司的工资条就是这样的，不可能为你一个人提供单独的工资条，反正工资条我们已经给你了。说完转身就走。</p><p>我连忙说这样的工资条我不能收，然后把工资条还给了她们，并再次给监察大队长打电话说了这件事。</p><p>大队长也说让我收下公司给的工资条，说法律上没有规定工资条上必须要有明细。</p><p>如果我拿了这张工资条，公司就算是提供了工资条，但是我拿到这样一张工资条有什么用呢？那我要工资条这件事不就成了走个过场了吗？</p><p>每一次的维权都让我觉得举步维艰，也让我对后续的维权有了深深的担忧，我很怕后续的所有维权都成了走个过场。</p><p>关于违法解除的仲裁，我之前咨询过律师，说赢的几率大。</p><p>如果输了，我不怪任何人，但我会公开我和公司双方的证据，让大家给一个公正的评判。</p><h2 id="13-可能是人生的终局之战"><a href="#13-可能是人生的终局之战" class="headerlink" title="13 可能是人生的终局之战"></a>13 可能是人生的终局之战</h2><p>这些天经常站在窗边看平时上下班走的那条路，恍然记起以前凌晨两三点从公司回住处，打着哆嗦一边骑车一边唱“直到整条街上，剩我和路灯”。回去躺在床上还在兴奋地想着工作上的事。</p><p>那时我觉得房子、车子、另一半，所有的一切都在向我走来。</p><p>但是现在我又意识到，可能人生总要有一个点，你无法再通过努力改变自己的前途和命运，使自己的人生变得更好了。</p><p>我想我已经接近这个点了。</p><p>对不起，真的对不起，但是我真的尽力了。</p><p>事到如今我没有什么不敢面对的，但我唯独不敢面对我的父母。</p><p>那时候不管家里再穷，我的学习用品都是最好的。</p><p>我很怕看到母亲哭，我不知道该说什么。</p><p>我最大的愿望就是让父母过上好日子，不让他们再受累了，但我可能做不到了。</p><p>从今年年初到现在，我一直被各种恐惧笼罩着，害怕会晕倒，害怕会猝死，害怕父母成为失独老人，害怕失业，害怕无法生存下去，害怕被威胁到前途，害怕被保安赶出去，害怕被自杀，害怕被关押，害怕曝光会被压制被报复。</p><p>然而每一次害怕的时候，脑海里总是冒出那句“包拯今日冒死闯法场救贤王，根本就没想过要活着离开。包拯一死，何足挂齿。”</p><p>或许我感觉什么都能打倒我的时候，恰恰也是什么都无法打倒我的时候。</p><p>至少我还能一战。</p><p>我知道于网易这个庞然大物而言，这篇文章微不足道。然而于我个人而言，却是一生中最重要的仪式之一。</p><p>这篇文章发出来会有什么后果，我其实能够预料到，因为我的力量太小了。</p><p>我知道我最终还是无法击败任何人，我只是击败了我自己而已。</p><p>就像亲手推倒一座自己建造的高楼，用了二十几年一砖一瓦精心搭建，垮掉却是一瞬间的。</p><p>但我相信每一个细小的反抗的声音，都会汇成一条汹涌的河。</p><p>相信无论任何公司或领导，以任何手段侵害员工的权益，威胁压制不许员工反抗，不管权势再大，最终都一定会受到应有的惩罚。</p><p>这篇文章中仅仅陈述了和我的权益被侵害相关的事实，证据中可能涉及公司机密和个人隐私的部分也都模糊掉了。</p><p>如果我还是像之前曝光的同事一样受到起诉威胁，那我无能为力。</p><p>我知道接下来很长一段时间里，我还是要一个人对抗网易的HR团队、公关团队、法务团队和其他叫不出名字的团队，但这一次我不想再退缩了。</p><p>人在，塔在。</p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '17107-1574822888948-597',        name: 'you的日常',        qrcode: 'https://graph.baidu.com/resource/212d06441ad68c2deaf0601574822828.png',        keyword: 'vip',    });</script><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下为《网易裁员，让保安把身患绝症的我赶出公司。我在网易亲身经历的噩梦！》全文内容：&lt;/p&gt;
&lt;p&gt;我是网易的一名游戏策划。14年从上海交大毕业后就进入网易工作，5年里，我和大部分网易员工一样以“网易人”的称号为傲。&lt;/p&gt;
&lt;p&gt;直到18年底开始传出网易毁约应届生、年前最后一天裁员、威胁员工的消息时，仍不愿相信这是网易的所为，更想不到不久后我就会在身患绝症的情况下亲身经历逼迫、算计、监视、陷害、威胁，甚至被保安赶出公司。&lt;/p&gt;
&lt;h2 id=&quot;01-患病&quot;&gt;&lt;a href=&quot;#01-患病&quot; class=&quot;headerlink&quot; title=&quot;01 患病&quot;&gt;&lt;/a&gt;01 患病&lt;/h2&gt;&lt;p&gt;这5年里，除了某段时间经常在后半夜两三点钟下班，主管说第二天早上可以请病假晚到一会儿之外，我请病假的次数屈指可数。&lt;/p&gt;
&lt;p&gt;但去年年底感冒后开始头晕体虚，爬楼梯开始吃力，这才开始多次向主管和代理主管请病假就医。&lt;/p&gt;
&lt;p&gt;今年1月底，被确诊为扩张型心肌病。心脏扩大近一倍。期间跟代理主管说了是心脏出了问题，但只是请病假更方便了一些，没有因病减少或耽误丝毫工作。&lt;/p&gt;
&lt;p&gt;3月底主管找我谈绩效，说他跟代理主管聊过了，这次准备给我评D绩效，因为我现在不适合在这里继续工作了。&lt;/p&gt;
&lt;p&gt;当时我很懵，因为我和代理主管每天吃饭的时候都在讨论项目的开发方向，很多重要的功能也都是我俩加班讨论确定的，重要功能他也都交给我做，组内的业绩排名也基本是他第一我第二。&lt;/p&gt;
&lt;p&gt;我不明白他为什么要突然捅我一刀。&lt;/p&gt;
&lt;p&gt;我又问主管原因，结果主管给出的都是因为组内人数过多，因为老员工的评判标准要比新员工高这种很敷衍的理由。&lt;/p&gt;
&lt;h2 id=&quot;02-威胁不让拿N-1&quot;&gt;&lt;a href=&quot;#02-威胁不让拿N-1&quot; class=&quot;headerlink&quot; title=&quot;02 威胁不让拿N+1&quot;&gt;&lt;/a&gt;02 威胁不让拿N+1&lt;/h2&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="网易裁员事件" scheme="https://youdaily.github.io/tags/%E7%BD%91%E6%98%93%E8%A3%81%E5%91%98%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>今日一文：妈妈的手套</title>
    <link href="https://youdaily.github.io/posts/a735f994/"/>
    <id>https://youdaily.github.io/posts/a735f994/</id>
    <published>2019-11-20T08:38:49.000Z</published>
    <updated>2019-12-10T02:02:25.710Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>昨天晚上给妈妈打电话的时候，妈妈说预报里面说：明天家里要下雪了，你那边冷吗？你要多穿点衣服，不要冻着啦！</p><h2 id="妈妈的手套"><a href="#妈妈的手套" class="headerlink" title="妈妈的手套"></a>妈妈的手套</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-fed24a8c6ace4bf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手套"></p><blockquote><p>图文无关</p></blockquote><p>记得那年冬天，我上初二，学校周末放假了，我和弟弟两个人闹矛盾，然后我的手不小心被刀划伤了。小时候的我们，都不是让母亲省心的孩子。弟弟那时还小，把我划伤后就和其它的小伙伴出去玩了。妈妈听到了我的哭声，从地里回来，带着我去村上的医疗室包扎伤口。医生仔细检查完伤口，进行了消毒包扎，然后对妈妈说：现在天冷，注意手不要冻着了，不然会很麻烦的。</p><p>回家后，妈妈让我坐在椅子上烤火看电视，然后自己又到田里去忙了。我在家里看着电视，听着外面呼呼的风声，心想天可真冷啊。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-afdea73a422163cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="北风吹"></p><a id="more"></a><p>第二天是周一，我们要一大早就去学校上课，并且我要在学习住校，周末才能回家。一大早，妈妈帮我收拾好东西，临出门的时候妈妈从房间拿出来一个很 <code>丑</code> 的 <code>手套</code>，递给我然后说道：这几点带着这个，天冷了主要别冻着了。我看着手里的手套，那是一个很大的<code>手套</code>，完全不符合我现在手的尺寸;  <code>手套</code> 腕部的地方很长，手指的部分除了大拇指有一个手指外，其它的几个手指都 是一个整体、并且没有封口; 看着就像是现在我们常用的护腕，只是多了大拇指那一点；<code>手套</code> 是使用的灰色的毛线织成的。妈妈看我不太情愿，拿起 <code>手套</code> 准备套在我受伤的手上。我把手往后缩了缩，妈妈顿了顿，一把抓过我的手，边小心地往受伤的手上套边说道：不想带就别受伤啊。我突然就哭了起来，但还是任由妈妈套上了手套，期间有几次妈妈碰到了伤口，我哭的更厉害了。妈妈没有安慰我，套完手套就进屋去了，我看着外面在等我的同学，我抹了抹眼泪和他们一起到学校去了。</p><p>一离开妈妈的视线，我就尝试 <code>扯</code> 下手套，但是试了几次，单手不太方便、伤口被碰了几次，最后还是放弃了。</p><p>到学校后，受伤的手给我的生活带来了很多的不便，原来能够很快完成的事情，现在很慢才能完成，例如扣衣服、上厕所完了提裤子。</p><p>比起生活上的不便，我更在意的是同学对我 <code>手套</code> 的评论。有些同学，会问怎么回事？有些同学会直接说：手套真丑，剩下的大部分同学都选择了忽视。我还是尝试要拿掉手套，但是终究还是没成功，本来最后一次都要成功了，忽然想到了医生那句：冻坏了就麻烦了，只得作罢。之后，我把受伤的手，放在桌子下面、衣服兜里、用手护着，反正就是减少被同学看到的机会。</p><p>终于又到了回家的日子。回到家后，我没看看妈妈，在上小学的弟弟说妈妈到田里去忙了，弟弟对我说道：哥哥，对不起，我不是故意弄伤你的。你也不要怪妈妈，那个手套是妈妈那天晚上花了一晚上织成的，毛线是妈妈从爸爸的毛衣上面拆下来的。那天你走了后，妈妈在家里哭了好久。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-1964f27924a42e33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="妈妈不哭"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>天冷了，你那边冷吗？你要多穿点衣服，不要冻着啦！</p><hr><p>图片来源于网络，侵删。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;昨天晚上给妈妈打电话的时候，妈妈说预报里面说：明天家里要下雪了，你那边冷吗？你要多穿点衣服，不要冻着啦！&lt;/p&gt;
&lt;h2 id=&quot;妈妈的手套&quot;&gt;&lt;a href=&quot;#妈妈的手套&quot; class=&quot;headerlink&quot; title=&quot;妈妈的手套&quot;&gt;&lt;/a&gt;妈妈的手套&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-fed24a8c6ace4bf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;手套&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图文无关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记得那年冬天，我上初二，学校周末放假了，我和弟弟两个人闹矛盾，然后我的手不小心被刀划伤了。小时候的我们，都不是让母亲省心的孩子。弟弟那时还小，把我划伤后就和其它的小伙伴出去玩了。妈妈听到了我的哭声，从地里回来，带着我去村上的医疗室包扎伤口。医生仔细检查完伤口，进行了消毒包扎，然后对妈妈说：现在天冷，注意手不要冻着了，不然会很麻烦的。&lt;/p&gt;
&lt;p&gt;回家后，妈妈让我坐在椅子上烤火看电视，然后自己又到田里去忙了。我在家里看着电视，听着外面呼呼的风声，心想天可真冷啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-afdea73a422163cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;北风吹&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="天冷了" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E5%A4%A9%E5%86%B7%E4%BA%86/"/>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="天冷了" scheme="https://youdaily.github.io/tags/%E5%A4%A9%E5%86%B7%E4%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>今日一文：国足又输球了</title>
    <link href="https://youdaily.github.io/posts/39a2d06b/"/>
    <id>https://youdaily.github.io/posts/39a2d06b/</id>
    <published>2019-11-18T08:26:14.000Z</published>
    <updated>2019-12-10T02:02:34.022Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>11 月 14 日晚，中国男足又输球了。</p><h2 id="比赛相关"><a href="#比赛相关" class="headerlink" title="比赛相关"></a>比赛相关</h2><p>11 月 14 日晚，2022 年世界杯亚洲区预选赛预赛阶段（四十强赛）A组的一场关键战役在此间打响，中国男足和叙利亚队伍的比赛正式上演。此前，中国队已踢过三场小组赛，分别以 <strong>5:0</strong> 和 <strong>7:0</strong> 战胜了马尔代夫和关岛，以 <strong>0:0</strong> 踢平菲律宾队。</p><p>比赛中中国男足在上半场扳平比分后，下半场因为一粒乌龙球以 <strong>1:2</strong> 遗憾负于小组最强对手叙利亚队，目前在小组中仅以净胜球优势排在第二位。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-11f7aa4a650f9008?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足比分"></p><p>在 <strong>1:2</strong> 不敌叙利亚队，再一次，将出线主动权拱手让出。本场战罢，中国队 2 胜 1 平 1 负积 7 分，以净胜球优势领先菲律宾队排在四十强赛 A 组的第二位，叙利亚队则以四战全胜积 12 分排名第一。依照“四十强赛”的规则，总共 40 支球队分成 8 个小组参加世界杯亚洲区的预选赛，8 个小组的第一名以及 4 个表现最佳的第二名球队也得以参加预选赛下一轮的比赛。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-9eb2079921b316e7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分组"></p><p>中国队唯一一次入围世界杯是在 2002 年的日韩世界杯，当时中国队输掉了所有三场比赛，并且未进一球。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/1940331-5509e9a7619401a0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足比赛经过"></p><p>根据亚足联安排，国足在四十强赛A组的下一轮比赛定于 2020 年 3 月 26 日举行，届时国足将在主场迎战马尔代夫队。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-76d171ffee9dcfe1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足新赛程"></p><p>在赛后新闻发布会上中国男足主教练里皮宣布辞职并承担输球责任。“我们今晚输球了，我的年薪收入非常高，这场输球我承担全部责任，所以我向大家宣布现在辞职，不再担任中国队主教练。”，没等翻译讲完，里皮便离开了新闻发布会，留下一脸茫然的记者和工作人员。对于这位拿着2300万欧元年薪、全球收入最高国家队主教练来说，他和国足的缘分，真的到头了。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-f3470af85020cae7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="里皮辞职"></p><p>11 月 15 日早上，足协官方微博上发表声明对国家队失利”深表歉意”。声明称：“接受里皮的辞职请求。并表示接下来“将会深刻反思，重组男足国家队，打好接下来的四十强赛”。”</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-ef20fb7f3ed632ee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足协道歉"></p><h2 id="中国女足的世界杯之旅"><a href="#中国女足的世界杯之旅" class="headerlink" title="中国女足的世界杯之旅"></a>中国女足的世界杯之旅</h2><p>上面是中国男足的情况，那作为另一个极端的中国女足的情况呢？</p><p>2019年法国女足世界杯上，中国女足先是 1:0 不敌德国队，后以 1:0 战胜南非队，在最后一轮则与西班牙队战平，最终以小组第三的成绩出线。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-211119c43021cb6d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="女足比赛日程"></p><p>但是在1/8决赛中 0-2 不敌意大利女足，无缘 8 强。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-a966191a7aff8ce8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="女足比赛日程"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>世界杯的比赛暂时告一段落，男足主教练“银狐”也离开了，中足协也道歉了，广大球迷也吐槽了，事件的热点也慢慢地退去了。但是，作为中国的足球事业却是刚刚起步，很多的问题需要解决。有人说是球员问题，有人说是教练问题，有人说是体制问题。其实对于广大的 “吃瓜群众” 来说，是谁的问题并不重要，重要的是什么时候才能真正的赢一场呢？</p><p>中国足球加油，中国加油…</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-71ce94dc3aff39e9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中国加油"></p><hr><p>图片来源于网络，侵删。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;11 月 14 日晚，中国男足又输球了。&lt;/p&gt;
&lt;h2 id=&quot;比赛相关&quot;&gt;&lt;a href=&quot;#比赛相关&quot; class=&quot;headerlink&quot; title=&quot;比赛相关&quot;&gt;&lt;/a&gt;比赛相关&lt;/h2&gt;&lt;p&gt;11 月 14 日晚，2022 年世界杯亚洲区预选赛预赛阶段（四十强赛）A组的一场关键战役在此间打响，中国男足和叙利亚队伍的比赛正式上演。此前，中国队已踢过三场小组赛，分别以 &lt;strong&gt;5:0&lt;/strong&gt; 和 &lt;strong&gt;7:0&lt;/strong&gt; 战胜了马尔代夫和关岛，以 &lt;strong&gt;0:0&lt;/strong&gt; 踢平菲律宾队。&lt;/p&gt;
&lt;p&gt;比赛中中国男足在上半场扳平比分后，下半场因为一粒乌龙球以 &lt;strong&gt;1:2&lt;/strong&gt; 遗憾负于小组最强对手叙利亚队，目前在小组中仅以净胜球优势排在第二位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-11f7aa4a650f9008?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;国足比分&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;1:2&lt;/strong&gt; 不敌叙利亚队，再一次，将出线主动权拱手让出。本场战罢，中国队 2 胜 1 平 1 负积 7 分，以净胜球优势领先菲律宾队排在四十强赛 A 组的第二位，叙利亚队则以四战全胜积 12 分排名第一。依照“四十强赛”的规则，总共 40 支球队分成 8 个小组参加世界杯亚洲区的预选赛，8 个小组的第一名以及 4 个表现最佳的第二名球队也得以参加预选赛下一轮的比赛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-9eb2079921b316e7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;分组&quot;&gt;&lt;/p&gt;
&lt;p&gt;中国队唯一一次入围世界杯是在 2002 年的日韩世界杯，当时中国队输掉了所有三场比赛，并且未进一球。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="世界杯" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="世界杯" scheme="https://youdaily.github.io/tags/%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>今日一文：三罢对香港经济的影响</title>
    <link href="https://youdaily.github.io/posts/9bb99421/"/>
    <id>https://youdaily.github.io/posts/9bb99421/</id>
    <published>2019-11-15T08:26:14.000Z</published>
    <updated>2019-12-10T02:02:44.582Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我们都知道，最近香港的局势不太稳定，暴徒们恶意破坏的行径，已经严重影响到香港居民的方方面面。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-41ab7b2376308e2c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一条满是砖块垃圾的马路"></p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-c28106337cf53a62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在沙田，一列火车因抗议者的扰乱而暂停服务，乘客被迫下车"></p><p>我们都知道，动荡的社会环境中，社会生产活动肯定会受到影响，这些影响最后将以经济数据的形式呈现出来。8 月份开始的 “三罢（罢工、罢课、罢市）” 活动，更是将对经济的影响放大了。这篇文章里，我们将尝试从香港政府已经公布的经济数据中，去发现暴力活动对香港经济造成的影响。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-20fdf6abb39bee30?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><blockquote><p>因为经济数据，具有一定的延后性，我们这里只从现有的数据出发，去分析问题。至于当下实际的情况，只能通过后续更新的数据再去分析啦。</p></blockquote><a id="more"></a><hr><h2 id="三罢对香港经济的影响"><a href="#三罢对香港经济的影响" class="headerlink" title="三罢对香港经济的影响"></a>三罢对香港经济的影响</h2><p>三罢（罢工、罢课、罢市）对经济的影响对经济的影响是巨大的。</p><p>香港私人消费总额的年度变化在今年第三季罕有地出现负增长。虽然背后的最大成因仍需科学验证，但初步认为与全球经济衰退、美中贸易战和香港的社会动荡和罢市行动有关。而私人消费 (Private Consumption) 是香港的经济产值(GDP)中占最大份额组成，2018年的占比比高达68.3% (图1)，因此每当私人消费下跌，经常伴随经济衰退。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-fa7bd48162dceffa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1 香港各项经济环节佔经济产值的百分比，2018年。资料来源：贸易发展局 (2019) [1]"></p><p>但到底是经济衰退带动私人消费下跌，还是其他外在因素引发私人消费下跌，从而令GDP下跌？这里有两种不同的说法<br>说法一：由于通胀和人口增长等因素，私人消费一般长期持续正增长，但当经济衰退，预期和实际失业人数增加，打击私人消费信心，导致私人消费下跌；<br>说法二：当外在因素如罢市行动或支持节约消费行动生效，私人消费下跌，因而造成经济衰退。</p><p>在过去大半年的香港却同时出现以上两种情况，消费下跌的真正原因仍有待进一步研究。</p><p>数据方面，私人消费的年度增长率由今年第二季的 +1.3% 转为第三季的 -3.5%，虽然跌幅比其他组别为细，但由于占比巨大，对GDP增长的影响举足轻重 (图2)：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-d20d0dfb20690132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2 香港生产总值各项分项的年度增长率，2019年第二及第三季比较，资料来源：香港统计处[2]"></p><p>私人消费的组成以「零售总值」和「食肆收益」两项最具代表，图3是过去一年零售总值的每月年度变化率，自今年2月起至最新的9月份数字均是负数，而且有持续扩大迹象，最新8、9月份的跌幅更急跌两成多，打破了过去十几年的记录。但由于早自2月份已经出现双位数跌幅，远早于罢市行动，反映部份原因与罢市和社会动动荡等近期本地因素无关。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-b364e626da46cc57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3 香港零售总值年度变化2018年9月-2019年9月。资料来源：Trading Economics"></p><p>但零售数据较难分析成因，因为随着网络科技和智能手机的普及，愈来愈多的购物是透过网购完成，而零售总值的统计仍然只限于实体零售，网购未有定期统计数据 (事实上亦较难准确统计，尤其是二手货网购平台和非本地网购等)，因此部份零售总值的下跌可能源于愈来愈多消费者由实体店购物改为网购而已，同时，当社会动荡，经常变相戒严，亦会鼓励更多消费者改为网购，因此零售总值数据对反映私人消费变化有重大缺点。</p><p>食肆收益数据亦出现类似情况，不外出用餐可改为在家用餐，但如此一来已直接造成GDP减少 (因为GDP是不计算家庭成员的家务工作产出价值)，二来也影响商用物业租用，间接影响GDP数据。</p><p>图4显示食肆收益价值指数及其年度变化，过去十年持续正增长，平均年增长4%，但自今年4月起已经出现负值 (若以收益数量指数计算，更早在2月起已经变负)，最新9月份的跌幅高达13.1%，比2009年国际金融风暴时的跌幅还要大得多。</p><p>图4 香港食肆收益价值指数及其年度变化 2009 - 2019年9月。资料来源：香港统计处 [3]</p><p>其中各类餐饮均出现大幅下跌，只有快餐继续上升，这通常反映消费信心疲弱，减少在高级食肆消费，转食较经济的快餐。</p><p>图5显示中式餐饮自2月起已经出现下跌，但6月起跌幅扩大至双位数，最新9月份跌幅更达-20.3%；非中式餐馆的收益下跌相比没有中式的严重，9月份的跌幅为-14.5%，而且负增长由4月起才出现；酒吧的收益下跌最突然，由6月起突然由正转负，且一跌就跌双位数，9月份跌幅为-18.8%，可能与旅游警示、游客减少有关。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-447a5ecf51a117ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5 香港四类食肆的收益价值指数年度变化 2009 - 2019年9月。资料来源：香港统计处 [3]"></p><p>各类私人消费自6月起均有较明显的下跌，反映6月起市场出现突变，但由于同期美中贸易谈判曾经破裂，直到10月中美之间才再次开启了新一轮的和谈，但因为10月份的数据还没有对外公布，需待下个月数据出台再作分析。</p><p>参考：</p><p>[1]  香港贸易发展局 (2019) 香港经济概况，10月25日。<br><a href="http://hong-kong-economy-research.hktdc.com/business-news/article/%E5%B8%82%E5%A0%B4%E7%92%B0%E5%A2%83/%E9%A6%99%E6%B8%AF%E7%B6%93%E8%B2%BF%E6%A6%82%E6%B3%81/etihk/tc/1/1X000000/1X09OVUL.htm" target="_blank" rel="noopener">http://hong-kong-economy-research.hktdc.com/business-news/article/%E5%B8%82%E5%A0%B4%E7%92%B0%E5%A2%83/%E9%A6%99%E6%B8%AF%E7%B6%93%E8%B2%BF%E6%A6%82%E6%B3%81/etihk/tc/1/1X000000/1X09OVUL.htm</a></p><p>[2] 香港统计处 (2019) 二零一九年第三季本地生产总值预先估计数字，香港政府 10月31日。<br><a href="https://www.censtatd.gov.hk/press_release/pressReleaseDetail.jsp?charsetID=2&amp;pressRID=4506" target="_blank" rel="noopener">https://www.censtatd.gov.hk/press_release/pressReleaseDetail.jsp?charsetID=2&amp;pressRID=4506</a></p><p>[3] 香港统计处 (2019) 表E088：按食肆类别划分的食肆收益，香港政府 11月5日。<br><a href="https://www.censtatd.gov.hk/hkstat/sub/sp320_tc.jsp?productCode=D5600088" target="_blank" rel="noopener">https://www.censtatd.gov.hk/hkstat/sub/sp320_tc.jsp?productCode=D5600088</a></p><hr><p>PS: 图片来源于互联网，侵删。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;我们都知道，最近香港的局势不太稳定，暴徒们恶意破坏的行径，已经严重影响到香港居民的方方面面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-41ab7b2376308e2c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;一条满是砖块垃圾的马路&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-c28106337cf53a62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;在沙田，一列火车因抗议者的扰乱而暂停服务，乘客被迫下车&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们都知道，动荡的社会环境中，社会生产活动肯定会受到影响，这些影响最后将以经济数据的形式呈现出来。8 月份开始的 “三罢（罢工、罢课、罢市）” 活动，更是将对经济的影响放大了。这篇文章里，我们将尝试从香港政府已经公布的经济数据中，去发现暴力活动对香港经济造成的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-20fdf6abb39bee30?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为经济数据，具有一定的延后性，我们这里只从现有的数据出发，去分析问题。至于当下实际的情况，只能通过后续更新的数据再去分析啦。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="香港" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E9%A6%99%E6%B8%AF/"/>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="香港" scheme="https://youdaily.github.io/tags/%E9%A6%99%E6%B8%AF/"/>
    
  </entry>
  
  <entry>
    <title>今日一文：矛盾的日本人</title>
    <link href="https://youdaily.github.io/posts/223d2e53/"/>
    <id>https://youdaily.github.io/posts/223d2e53/</id>
    <published>2019-11-14T08:26:14.000Z</published>
    <updated>2019-12-10T02:02:54.943Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>早上的时候，因为工作需要和日本的客户开了个会，就是我们作为方案提供方，想客户推广公司的产品，我基本全程 <code>打酱油</code>，主讲的另外的两个同事。主要通过英语进行讲解，日本那边有一个英语翻译，复杂将双方的意思进行传达。会议讲述的内容是已经在很多场合下讲过很多次了，客户也没有问特别深奥的问题，整个过程下来感觉也没有给客户留下特别的印象。</p><p>会上的一件小事，却让我感到有点吃惊。</p><p>既然是推广，那肯定会有答疑环节，日方的翻译和同事就一个问题讨论了几分钟了，突然有个声音出现，说着日语，然后那个翻译很快地就用几句话结束了交谈。</p><p>我还在郁闷，这是怎么回事呢？怎么突然就结束啦。正当我还在疑惑的时候，旁边的同事说道：“1个小时过的真快，这就结束了”。</p><p>然后同事有顺口提到：日本人也真是的，说一小时就一小时，多一分钟都不行。我们约的一个小时的会议，我们 10 点 55 开始的会议，现在刚11：54 就结束了会议。</p><p>会后，我对这个话题比较的感兴趣，就去搜索了相关的内容。这一搜，发现了一个重要的事实：日本人对待时间这件事情上就是一个 <code>矛盾</code> 的混合体。一方面，日本人有很重的时间观念，对于 <code>守时</code> 这件事情上的表现近乎刻板。另一方面，日本人也是“加班狂人”。为什么会出现这种看似 <code>矛盾</code> 的现象呢，这背后的原因是什么呢？</p><p>顺着这个思路，来展开我们今天的话题。</p><a id="more"></a><h2 id="日本人-守时-到什么程度呢"><a href="#日本人-守时-到什么程度呢" class="headerlink" title="日本人 守时 到什么程度呢"></a>日本人 <code>守时</code> 到什么程度呢</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-52e923987fe896e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>和日本人有过接触经验的人，都对日本人的 <code>守时</code> 的时间观念印象深刻。</p><p>日本人开会从来不迟到，也不会无故延长会议时间。就想我们今天遇到的这样，说是 1 个小时的会员，一定不会开到 1 小时零 1 分。日本人守时的习惯，尤其是“不迟到”这点更是多数日本人天生养成的习惯。比如在企业、公共机构或与他人会面的方方面面，必定“正确守时”即便是准时到达也会视为“迟到”，这已成为常识。关系亲密的人之间也有迟到的，不过也会事先邮件通知。</p><p>日本人不光在私人小事上，做到守时，在很复杂的系统上也能做到守时。</p><p>日本的新干线列车的晚点时间是以分钟计算延迟的，就是说延迟 1 分钟以上就算是延迟了。作为对比，在其他国家，如意大利定为 15 分钟、英国为 10 分钟、连号称规矩严谨与日本不相上下的德国也只定为 5 分钟。几年前的一个道歉事件，曾经被广泛报道。经营日本筑波快线（Tsukuba Express）的日本首都圈新都市铁道公司原定于 11 月 14 日上午 9 点 44 分 40 秒发出，但由于操作员的失误，结果列车没有按照原定计划，在 9 点 44 分 20 秒提前 20 秒发了车。令人意想不到的是，铁路公司竟然郑重其事的在网页上发布了如下的道歉声明。日本铁路公司的电车只要晚1分钟，车内必定播放道歉的广播。而新干线的到达和出发时刻是以15秒为单位设定的。</p><p>日本的机场在守时上也不输铁路，OAG 发布的最新准点率统计表明，<code>大阪国际机场</code> 在全球小型机场中准点率排名第一，<code>东京羽田机场</code> 在名列大型机场准点排行第一。准点率是衡量一个机场成熟度的重要指标。</p><p>铁路和机场，这样复杂的系统都没有阻止日本人守时的脚步，这些复杂系统做到这么 <code>精确</code> 的守时背后，是许许多多的小个体守时的缩影，可以说，<code>守时</code> 观念已经深入了日本人的骨髓。</p><h2 id="日本人独特的-“加班文化”"><a href="#日本人独特的-“加班文化”" class="headerlink" title="日本人独特的 “加班文化”"></a>日本人独特的 “加班文化”</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-075be3d4d4be32f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果说日本人 <code>不迟到</code> 是一个特色，那与之相关的一定是另一个特色—- <code>加班文化</code>。</p><p>在日本，加班对于每一个职场人士来说是“家常便饭”，乃至于“过劳死”成为日本加班文化的一个显著特征。日本是出名的“加班大国”，在日文中有“超勤文化”的表述，有时被说成“过劳文化”。日本人以加班为荣，对他们来说加班才是常态，晚上写字楼里的灯光也有个专有名词——“劳工之光”。对不少日本男性来说，“朝6晚11”的工作模式相当普遍，这比之前国内的“996”，似乎还要厉害一点。清早从家乘地铁到公司，上班然后“例行”加班后，再和同事酌酒交际到深夜，便是正常一天的工作行程。日本妻子也大多习惯了丈夫早出晚归，甚至在很多日本女人的观念里，丈夫如果每天正常下班回家是一种在职场上无能的表现。</p><p>那是什么原因让日本的加班文化如此盛行呢？</p><p>首先，由于连年的经济不景气，日本公司不断地缩减人工规模，员工随时可能被裁员，剩下的员工不得不处理大量的工作任务来减少自己被裁的可能性，从而导致加班不可避免。</p><p>第二，日本的终身雇佣制度使得就业市场缺乏活力，员工很难跳槽寻找更好的工作，被迫工作更长时间。</p><p>第三，日本企业大多实行终身雇佣制和工龄薪酬制度，工作时间更长意味着更易获得成功，每周多工作几个小时的员工被提升到管理岗位的机会更大，同时也可以获得更多的薪酬。</p><p>第四，日本独特的职场文化：强调不带条件的服从和忠诚，以集体主义为最高目标，个人在集体中只有义务，个人的需求会被自动忽视。</p><p>第五点，日本人内向拘谨，不愿给别人添麻烦，因此，他们工作勤奋、守规则、敬业心强、对企业忠诚。</p><p>与加班文化同时伴生的一个问题是：工作效率低下。2013年日本每小时劳动生产价值为41.3美元，不到挪威的一半，在34个经合组织国家中排名20位，“日本人以工作努力闻名，但效率低下和官僚作风同样有名”，一家英国的每天曾经这样评价日本的加班文化。</p><h2 id="其实这就是真实的日本人"><a href="#其实这就是真实的日本人" class="headerlink" title="其实这就是真实的日本人"></a>其实这就是真实的日本人</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-6001b03e5fd58a72?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>近乎苛责的 <code>守时</code>  和独特的 <code>加班文化</code> 夹杂在一起的日本人，就是一对矛盾的集合体，同时，这也是最真实的日本人。</p><p>好消息是，情况正在向好的方向发展。最近几届的日本政府都在积极推动“禁止加班”，通过立法的手段来禁止 日益加剧的 <code>加班文化</code> 。同时企业也通过内部改革来减少加班文化的土壤，例如减少时薪。最近看到的消息说：微软日本公司，已经实现每周休假 3  天的制度。</p><p>没有谁的生活是容易的，简单生活，才能更好的享受生活。</p><hr><p>PS: 图片来源于互联网，侵删。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;早上的时候，因为工作需要和日本的客户开了个会，就是我们作为方案提供方，想客户推广公司的产品，我基本全程 &lt;code&gt;打酱油&lt;/code&gt;，主讲的另外的两个同事。主要通过英语进行讲解，日本那边有一个英语翻译，复杂将双方的意思进行传达。会议讲述的内容是已经在很多场合下讲过很多次了，客户也没有问特别深奥的问题，整个过程下来感觉也没有给客户留下特别的印象。&lt;/p&gt;
&lt;p&gt;会上的一件小事，却让我感到有点吃惊。&lt;/p&gt;
&lt;p&gt;既然是推广，那肯定会有答疑环节，日方的翻译和同事就一个问题讨论了几分钟了，突然有个声音出现，说着日语，然后那个翻译很快地就用几句话结束了交谈。&lt;/p&gt;
&lt;p&gt;我还在郁闷，这是怎么回事呢？怎么突然就结束啦。正当我还在疑惑的时候，旁边的同事说道：“1个小时过的真快，这就结束了”。&lt;/p&gt;
&lt;p&gt;然后同事有顺口提到：日本人也真是的，说一小时就一小时，多一分钟都不行。我们约的一个小时的会议，我们 10 点 55 开始的会议，现在刚11：54 就结束了会议。&lt;/p&gt;
&lt;p&gt;会后，我对这个话题比较的感兴趣，就去搜索了相关的内容。这一搜，发现了一个重要的事实：日本人对待时间这件事情上就是一个 &lt;code&gt;矛盾&lt;/code&gt; 的混合体。一方面，日本人有很重的时间观念，对于 &lt;code&gt;守时&lt;/code&gt; 这件事情上的表现近乎刻板。另一方面，日本人也是“加班狂人”。为什么会出现这种看似 &lt;code&gt;矛盾&lt;/code&gt; 的现象呢，这背后的原因是什么呢？&lt;/p&gt;
&lt;p&gt;顺着这个思路，来展开我们今天的话题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="矛盾" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E7%9F%9B%E7%9B%BE/"/>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="矛盾" scheme="https://youdaily.github.io/tags/%E7%9F%9B%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>副业赚钱？ 我用自己的教训来给你指路</title>
    <link href="https://youdaily.github.io/posts/e8927964/"/>
    <id>https://youdaily.github.io/posts/e8927964/</id>
    <published>2019-11-13T08:36:39.000Z</published>
    <updated>2019-12-10T02:03:09.571Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p><code>副业赚钱</code>, 是每个人读梦寐以求的，毕竟 <code>躺着就能把钱挣了</code> 还是很舒服的。</p><p>最近在不断的总结和反思着一个多月以来的 <code>折腾之旅</code> , 得到了下面的几点教训。这里分享出来给大家参考。</p><h2 id="涉及的东西太多"><a href="#涉及的东西太多" class="headerlink" title="涉及的东西太多"></a>涉及的东西太多</h2><p>自从 9 月份开始说要开始自己的折腾之旅开始，先后试过下面平台及方向。</p><div class="table-container"><table><thead><tr><th>平台</th><th>内容、方向</th></tr></thead><tbody><tr><td>简书</td><td>书写、技术付费文章</td><td></td></tr><tr><td>公众号</td><td>书写、图片转载</td></tr><tr><td>头条号</td><td>图片转载</td></tr><tr><td>悟空问答</td><td>影视领域认证</td></tr><tr><td>抖音</td><td>视频搬运</td></tr><tr><td>TiTok</td><td>视频搬运</td></tr><tr><td>微视</td><td>视频搬运</td></tr><tr><td>好看视频</td><td>视频搬运</td></tr><tr><td>Youtobe</td><td>视频搬运</td></tr><tr><td>Gitbook</td><td>技术付费文章</td></tr><tr><td>小专栏</td><td>技术付费专栏</td></tr></tbody></table></div><p>还有很多就试过一两次的，然后觉得不靠谱的就不再列出来了，如果列出来这份清单会很长很长。</p><p>上面的这些内容，大部分都在上班时间抽空来完成的。质量可定也好不到哪里去，基本上可以说大部分的内容都是拼凑完成的，另外一些内容，虽然加入了自己的一些东西，但是大部分都不是太深入。</p><a id="more"></a><h2 id="没有明确的方向"><a href="#没有明确的方向" class="headerlink" title="没有明确的方向"></a>没有明确的方向</h2><p>上面的那份清单里面，已经列出来了，目前试过的方向包括</p><ul><li>技术付费文章</li><li>视频搬运</li><li>图片转载</li></ul><p>上面的每个领域，都是很大的领域，在其中的领域如果做的好，都可以做的很成功。但是毫无疑问，每个领域的成功都需要投入很多的精力，包括但不限于：时间，金钱。</p><blockquote><p>为什么是为了赚钱的，怎么还需要投入金钱呢？这里解释下原因：很多领域开始赚钱前是需要一个“门槛”的，有些门槛对新人来说感觉很高，此时适当的金钱投入，是可以帮我们快速跨过这个门槛的。</p></blockquote><h2 id="无法持续的输出"><a href="#无法持续的输出" class="headerlink" title="无法持续的输出"></a>无法持续的输出</h2><p>上面的那份清单里面的每一个，都需要持续不断的 <code>原创</code> 输出，才有可能成功。如果只是 <code>转载</code>、<code>搬运</code>、<code>洗稿</code>，成功的可能性基本没有。</p><blockquote><p>这里为什么不把话说满呢？因为现实中的的确确出现一些，<code>山寨货</code> 最后逆袭 <code>正版货</code> 的故事。福建莆田的鞋类生产就是一个很好的例子。</p></blockquote><p>为什么我们一定要坚持原创呢？因为原创是制约你走的更远的决定性条件。在刚开始的时候，你 <code>搬运</code> 了，没人会关注到你，因为你太小了。如果有一天你长大了，很多人都可以看到你的时候，你的所有问题都会暴露在众人面前，一旦发生了问题，众人的 <code>口水</code> 真的就把你淹没了,然后就真的没有然后了。</p><blockquote><p>大家可以参看下 <code>李现ins点赞</code> 的 <code>故事</code>。</p></blockquote><p>可能走的越远，越能体会到 <code>人言可畏</code> 这句话的真正威力吧。</p><hr><p>上面的内容是对自己这一段时间的复盘，下面来简短的写下自己接下来的计划。</p><h2 id="精简自己的内容"><a href="#精简自己的内容" class="headerlink" title="精简自己的内容"></a>精简自己的内容</h2><div class="table-container"><table><thead><tr><th>平台</th><th>内容、方向</th></tr></thead><tbody><tr><td>简书</td><td>书写、技术付费文章</td></tr><tr><td>公众号</td><td>书写、技术付费文章</td></tr><tr><td>Gitbook</td><td>技术付费文章</td></tr></tbody></table></div><p>之所以这么选择，理由如下：</p><ul><li><code>技术文章</code> 基本就是自己平时工作、学习的再记录。把学到的东西分享出去，不仅可以促进自己不断的学习，还能把自己的知识分享给更多的人，这是多方共赢的。</li><li><code>书写</code> 主要的目的是记录平时生活、工作，同时系统化的构建自己的知识体系。</li></ul><p>下面对着3个平台的功能进行下区分，</p><ul><li><code>简书</code> 上面是所有的内容的整合地，类似于目录的作用。</li><li><code>公众号</code> 上面主要是日常生活的中的见闻分享。通过日常的一个点，去发散开来，理论上不设任何的领域限制。</li><li><code>Gitbook</code> 上面主要是</li></ul><h2 id="持续原创输出"><a href="#持续原创输出" class="headerlink" title="持续原创输出"></a>持续原创输出</h2><p>上面提到的两个方向都是需要持续不断的更新内容，才能看到后来的光明。<br>其实对于各个行业都需要持续不断的的产出，才有可能成功。坚持下来，才有可能看到阳光；如果不坚持，一定就看不到阳光。</p><p>即使 <code>强</code> 如李佳琦也会有翻船的时候。</p><blockquote><p>具体事件可以参见这篇文章 <a href="https://new.qq.com/rain/a/20191105A0PNQX00" target="_blank" rel="noopener">https://new.qq.com/rain/a/20191105A0PNQX00</a></p></blockquote><p>虽然李佳琦带货会翻车，但是不可否认李佳琦的带货能力，毕竟他是曾经打败过 <code>马爸爸</code> 的男人。</p><p>上面写就是我这一段时间来的总结，是一个悲伤的故事，说出来让大家笑一笑。</p><p>最后附上我的微信公众号，欢迎大家关注。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-9b2b8d44ef7010f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" &quot;you的日常&quot; 公众号 "></p><blockquote><p>有需要的朋友，请到评论区留言吧，我们来互相关注啊。</p></blockquote><p>希望大家都能够早日通过 “副业” 赚到钱。</p><p>加油…</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;副业赚钱&lt;/code&gt;, 是每个人读梦寐以求的，毕竟 &lt;code&gt;躺着就能把钱挣了&lt;/code&gt; 还是很舒服的。&lt;/p&gt;
&lt;p&gt;最近在不断的总结和反思着一个多月以来的 &lt;code&gt;折腾之旅&lt;/code&gt; , 得到了下面的几点教训。这里分享出来给大家参考。&lt;/p&gt;
&lt;h2 id=&quot;涉及的东西太多&quot;&gt;&lt;a href=&quot;#涉及的东西太多&quot; class=&quot;headerlink&quot; title=&quot;涉及的东西太多&quot;&gt;&lt;/a&gt;涉及的东西太多&lt;/h2&gt;&lt;p&gt;自从 9 月份开始说要开始自己的折腾之旅开始，先后试过下面平台及方向。&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;平台&lt;/th&gt;
&lt;th&gt;内容、方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;简书&lt;/td&gt;
&lt;td&gt;书写、技术付费文章&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;公众号&lt;/td&gt;
&lt;td&gt;书写、图片转载&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;头条号&lt;/td&gt;
&lt;td&gt;图片转载&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;悟空问答&lt;/td&gt;
&lt;td&gt;影视领域认证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;抖音&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TiTok&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;微视&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;好看视频&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Youtobe&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gitbook&lt;/td&gt;
&lt;td&gt;技术付费文章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;小专栏&lt;/td&gt;
&lt;td&gt;技术付费专栏&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;还有很多就试过一两次的，然后觉得不靠谱的就不再列出来了，如果列出来这份清单会很长很长。&lt;/p&gt;
&lt;p&gt;上面的这些内容，大部分都在上班时间抽空来完成的。质量可定也好不到哪里去，基本上可以说大部分的内容都是拼凑完成的，另外一些内容，虽然加入了自己的一些东西，但是大部分都不是太深入。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="副业" scheme="https://youdaily.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E5%89%AF%E4%B8%9A/"/>
    
    
      <category term="日常生活" scheme="https://youdaily.github.io/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="https://youdaily.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="副业" scheme="https://youdaily.github.io/tags/%E5%89%AF%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>使用Python Flask 实现 RESTful API</title>
    <link href="https://youdaily.github.io/posts/1d89d585/"/>
    <id>https://youdaily.github.io/posts/1d89d585/</id>
    <published>2019-10-18T03:36:18.000Z</published>
    <updated>2019-12-10T02:03:23.828Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在工作学习中，我们经常会需要将自己的开发成果对外提供服务，此时的选择很多，但是什么才是最高效的呢？</p><p>想必聪明的你，已经想到了：通过 <code>API</code> 的方式对外提供服务。既然我们在学习 Python 过程中，那我们就使用 Python 来实现自己的 API 吧。</p><p>下面将从下面几个方面进行讲解：</p><ul><li>API 简介</li><li>RESTful API 简介</li><li>使用Python Flask 实现 RESTful API</li></ul><hr><h2 id="API-简介"><a href="#API-简介" class="headerlink" title="API 简介"></a>API 简介</h2><p>API 是英语 <code>Application Programming Interfaces</code> 的3个首字母组成的，翻译成中文即 <code>应用程序编程接口</code>。</p><p>API 通常是由服务器（Server）提供（服务器有各种各样的类型，一般我们浏览网页用到的是web server，即网络服务器），通过调用 API，本地计算机可以读取、编辑网站数据，就像人类可以加载网页、提交信息等。</p><p>通俗地，API可以理解为家用电器的插头，用户(本地电脑)只需要将插头插入插座的，不需要考虑电器内部(服务器)里面是如何运作的。通过提供 API, 将内部的实现细节封装了起来，对本地电脑简化的流程，同时减少了出错的可能。</p><p>另外一个角度上讲API是一套协议，规定了与外界的沟通方式：如何发送请求和接受响应。只有大家同遵循同样的方式，就可以很快速的接入我们的服务。</p><hr><h2 id="RESTful-API-简介"><a href="#RESTful-API-简介" class="headerlink" title="RESTful API 简介"></a>RESTful API 简介</h2><p>RESTful API 即满足 RESTful 风格设计的API，RESTful 表示的是一种互联网软件架构(以网络为基础的应用软件的架构设计)，如果一个架构符合 <code>REST</code> (Representational State Transfer的缩写，翻译成中文是 <code>&quot;表现层状态转化&quot;</code>.)原则，就称它为 RESTful 架构。</p><p>那什么是 <code>REST</code> 原则呢？<code>Representational State Transfer</code> 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，基本就理解了什么是 <code>REST</code> 设计原则。</p><p>从下面几个角度来分解这个问题。</p><blockquote><p>下面的部分内容可以忽略，可以直接跳到总结的部分。</p></blockquote><a id="more"></a><h3 id="资源（Resources）"><a href="#资源（Resources）" class="headerlink" title="资源（Resources）"></a>资源（Resources）</h3><p>REST 的名称”表现层状态转化”中，省略了主语。 <code>&quot;表现层&quot;</code> 其实指的是 <code>&quot;资源&quot;</code> （Resources）的 <code>&quot;表现层&quot;</code> 。</p><p>所谓 <code>&quot;资源&quot;</code> ，就是网络上的一个实体，或者说是网络上的一个具体信息。</p><p>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。<br>你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓 <code>上网</code>，就是与互联网上一系列的 <code>&quot;资源&quot;</code> 互动，调用它的URI。</p><h3 id="表现层（Representation）"><a href="#表现层（Representation）" class="headerlink" title="表现层（Representation）"></a>表现层（Representation）</h3><p><code>&quot;资源&quot;</code> 是一种信息实体，它可以有多种外在表现形式。我们把 <code>&quot;资源&quot;</code> 具体呈现出来的形式，叫做它的 <code>&quot;表现层&quot;</code> （Representation）。</p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对 <code>&quot;表现层&quot;</code> 的描述。</p><h3 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h3><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。</p><p>因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 <code>&quot;表现层状态转化&quot;</code>。</p><p>客户端用到的手段，只能是HTTP协议。</p><p>具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p><p>它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>RESTful 架构的特点：</p><ul><li>每一个URI代表一种资源；</li><li><p>客户端和服务器之间，传递这种资源的某种表现层；把 <code>&quot;资源&quot;</code> 具体呈现出来的形式，叫做它的 <code>&quot;表现层&quot;</code> （Representation）。</p><p>  比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p></li><li><p>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p><p>  四个表示操作方式的动词分别是：GET、POST、PUT、DELETE。</p><p>  它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p></li></ul><p>完整的 RESTful API 的简介在这里：</p><p><a href="https://www.restapitutorial.com/lessons/whatisrest.html" target="_blank" rel="noopener">https://www.restapitutorial.com/lessons/whatisrest.html</a> </p><blockquote><p>英文版，可能需要翻墙。</p></blockquote><p>简单总结下官方的介绍的内容：</p><ul><li>Client-Server：服务器端与客户端分离。</li><li>Stateless（无状态）：每次客户端请求必需包含完整的信息，换句话说，每一次请求都是独立的。</li><li>Cacheable（可缓存）：服务器端必需指定哪些请求是可以缓存的。</li><li>Layered System（分层结构）：服务器端与客户端通讯必需标准化，服务器的变更并不会影响客户端。</li><li>Uniform Interface（统一接口）：客户端与服务器端的通讯方法必需是统一的。</li><li>Code on demand（按需执行代码）：服务器端可以在上下文中执行代码或者脚本。</li></ul><hr><h2 id="使用Python-Flask-实现Restful-API"><a href="#使用Python-Flask-实现Restful-API" class="headerlink" title="使用Python Flask 实现Restful API"></a>使用Python Flask 实现Restful API</h2><p>前面啰嗦了这么久终于到这里了，这里才是我们实作的重头戏。</p><p>这部分将从下面的几个环节展开：</p><ul><li>Flask 框架简介</li><li>RESTful services 规划</li><li>Python 实现上面的规划</li><li>优化上面的实现</li></ul><p>下面让我们开始。</p><h3 id="Flask-框架简介"><a href="#Flask-框架简介" class="headerlink" title="Flask 框架简介"></a>Flask 框架简介</h3><p>我们在前面有几篇文章已经介绍过 Flask 框架。</p><p><strong>python-高级-Flask Hello World </strong><br><a href="https://xiaozhuanlan.com/topic/7256839401" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/7256839401</a></p><p><strong>Python-高级-Flask 路由</strong><br><a href="https://xiaozhuanlan.com/topic/0758412369" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/0758412369</a></p><p>里面介绍了 Flask 框架的相关基础知识，同时我们也介绍了关于 Flask 框架路由的知识，如果没看过，请移步到那里去看看。</p><p>在 <code>Python-高级-Flask Hello World</code> 里面，我们写了个最简单的 <code>Hello World</code> 的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, World!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>我们下面的内容，将基于这个例子进行扩展。</p><p>HTTP(与web应用会话的协议)有许多不同的访问URL方法。<br>默认情况下，<code>Flask</code> 路由只回应GET请求，但是通过 <code>route()</code> 装饰器传递 <code>method</code> s参数可以改变这个行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/login', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        do_the_login()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        show_the_login_form()</span><br></pre></td></tr></table></figure><p>HTTP 方法（通常也被叫做“谓词”，如上面code 里面的 <code>GET</code> 和 <code>POST</code> ）告知服务器，客户端想对请求的页面做些什么。</p><p>下面的都是非常常见的方法：</p><ul><li>GET(方法)浏览器告知服务器：只 获取 页面上的信息并发给我。这是最常用的方法。</li><li>POST(方法)浏览器告诉服务器：想在 URL 上发布新信息。并且，服务器必须确保 数据已存储且仅存储一次。这是 HTML 表单通常发送数据到服务器的方法。</li><li>PUT(方法)类似 POST 但是服务器可能触发了存储过程多次，多次覆盖掉旧值。你可能会问这有什么用，当然这是有原因的。考虑到传输中连接可能会丢失，这种情况下浏览器和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。因为 <code>POST</code> 它只触发一次，所以用 <code>POST</code> 是不可能的。</li><li>DELETE(方法)删除给定位置的信息。</li></ul><h3 id="RESTful-services-规划"><a href="#RESTful-services-规划" class="headerlink" title="RESTful services 规划"></a>RESTful services 规划</h3><p>经过上面知识的准备，我们开始来规划我们的RESTful services。</p><p>这里的规划，通常会与实际的需求有关系。所有的程序设计行为都是要与需求相关联的，如果做出来的东西不符合需求，那做得再好的程序也不是合格的程序。</p><p>回归到这里，我们假设我们的需求如下：写一个 <code>To Do List</code> 应用，并且设计一个web service, 方便使用中查看、添加、修改、删除 这些任务。</p><p><code>To Do List</code> 应用，通常长这样<br><img src="https://images.xiaozhuanlan.com/photo/2019/711398c10c7e7dee36a0e17a28efb00a.png" alt="`To Do List` 应用"></p><p>可能会比较简单，实际的需求会比这个复杂的多。这里举个简单的例子，只是起到 <code>抛砖引玉</code> 的作用。</p><p>我们将分下面几步走来规划这个。</p><h4 id="规划一个根URL"><a href="#规划一个根URL" class="headerlink" title="规划一个根URL"></a>规划一个根URL</h4><p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://[hostname]/todo/api/v1.0/</span><br></pre></td></tr></table></figure></p><p>上面的URL包括了应用程序的名称、API版本，这是十分有用的，既提供了命名空间的划分，同时又与其它系统区分开来。</p><p>版本号在升级新特性时十分有用，当一个新功能特性增加在新版本下面时，并不影响旧版本。</p><h4 id="规划资源的URL"><a href="#规划资源的URL" class="headerlink" title="规划资源的URL"></a>规划资源的URL</h4><p>这个例子十分简单，只有任务清单。</p><p>我们定义有以下字段：<br>|HTTP 方法|URL|作用|<br>|—-|—-|—-|<br>|GET|<a href="http://[hostname]/todo/api/v1.0/tasks|查看所有的任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks|查看所有的任务|</a><br>|GET|<a href="http://[hostname]/todo/api/v1.0/tasks/task_id|查看特定" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks/task_id|查看特定</a> id 的任务|<br>|PSOT|<a href="http://[hostname]/todo/api/v1.0/tasks|创建一个新的任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks|创建一个新的任务|</a><br>|PUT|<a href="http://[hostname]/todo/api/v1.0/tasks/task_id|更新一个已有的任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks/task_id|更新一个已有的任务|</a><br>|DELETE|<a href="http://[hostname]/todo/api/v1.0/tasks/task_id|删除一个任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks/task_id|删除一个任务|</a></p><p>同时定义一条任务清单包含下面的几个字段：</p><div class="table-container"><table><thead><tr><th>id</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>task_id</td><td>唯一标识</td><td>整型</td></tr><tr><td>title</td><td>简短的任务描述</td><td>字符串型</td></tr><tr><td>description</td><td>完整的任务描述</td><td>文本型</td></tr><tr><td>done</td><td>任务完成状态</td><td>布尔值型</td></tr></tbody></table></div><p>到这里我们的service 规划就完成了，下面我们将使用 Python 来进行实现。</p><h3 id="Python-实现上面的规划"><a href="#Python-实现上面的规划" class="headerlink" title="Python 实现上面的规划"></a>Python 实现上面的规划</h3><p>我们先实现第一个web service的入口点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 python_mastery 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/python_mastery'</span>,</span><br><span class="line">        <span class="string">'done'</span>: <span class="literal">False</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 pythonml 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/pythonml'</span>,</span><br><span class="line">        <span class="string">'done'</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: tasks&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><blockquote><p>在这里我们看到 <code>jsonify</code> 模块，这个与标准的 <code>json</code> 库的差别，对于目前我们的使用来说，基本可以忽略不计，如果非要深究这个问题，请移步到这里：<a href="https://www.jianshu.com/p/a25357f2d930" target="_blank" rel="noopener">https://www.jianshu.com/p/a25357f2d930</a>.</p></blockquote><p>和最开始的例子相比，并没有改变太多代码。</p><p>我们将任务清单存储在 list 内（内存），list 存放两个非常简单的数组字典。每个实体就是我们上面定义的字段。</p><p>而 index 入口点有一个 <code>get_tasks</code> 函数与 <code>/todo/api/v1.0/tasks</code> URI关联，只接受 HTTP 的 <code>GET</code> 方法。</p><p>这个响应并非一般文本，而是 JSO N格式的数据，是经过 Flask 框架的 <code>jsonify</code> 模块格式化过的数据。</p><p>运行 app.py 。</p><p>使用浏览器去测试 web service 并不是一个好的办法，因为要创建不同种类的 HTTP 请求。这里我们选择第三方工具 <code>postman</code> 来进行验证。</p><p>如果没有安装 <code>postman</code> ，快点去安装一个。</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/93a094856a1e7c74ab3c92f4e180ba66.png" alt="GET `/todo/api/v1.0/tasks`"></p><p>这样就调用了一个RESTful service方法！</p><p>现在，我们写第二个版本的GET方法获取特定的任务。获取单个任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> abort</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_task</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    task = list(filter(<span class="keyword">lambda</span> t: t[<span class="string">'id'</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> len(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'task'</span>: task[<span class="number">0</span>]&#125;)</span><br></pre></td></tr></table></figure><p>第二个函数稍稍复杂了一些。任务的 id 包含在 URL 内，Flask 将 task_id 参数传入了函数内。</p><p>通过参数，检索 tasks 数组。如果参数传过来的 id 不存在于数组内，我们需要返回错误代码 404 ，按照 HTTP 的规定，404 意味着是 “Resource Not Found”，资源未找到。</p><p>如果找到任务在内存数组内，我们通过 <code>jsonify</code> 模块将字典打包成 JSON 格式，并发送响应到客户端上。就像处理一个实体字典一样。</p><p>试试 <code>postman</code> 来进行验证<br><img src="https://images.xiaozhuanlan.com/photo/2019/7216c0b416a349237ddec9b2a5cfcdf9.png" alt="请求 `#2 id` 的资源"></p><p>当我们请求 <code>#2 id</code> 的资源时，可以获取，但是当我们请求<code>#3</code> 的资源时返回了 <code>404</code> 错误。并且返回了一段奇怪的 HTML 错误，而不是我们期望的 JSON，这是因为 Flask 产生了默认的 404 响应。<br><img src="https://images.xiaozhuanlan.com/photo/2019/1efeaa08c6403904824c96b21b528b81.png" alt="默认的 404 响应"></p><p>客户端需要收到的都是 JSON 的响应，因此我们需要改进 404 错误处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> make_response</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_found</span><span class="params">(error)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> make_response(jsonify(&#123;<span class="string">'error'</span>: <span class="string">'Not found'</span>&#125;), <span class="number">404</span>)</span><br></pre></td></tr></table></figure><p>这样我们就得到了友好的API错误响应：<br><img src="https://images.xiaozhuanlan.com/photo/2019/fafa73efa68f6532801f92d4c1f9627c.png" alt="友好的API错误响应"></p><p>接下来我们实现 POST 方法，插入一个新的任务到数组中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json <span class="keyword">or</span> <span class="keyword">not</span> <span class="string">'title'</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    task = &#123;</span><br><span class="line">        <span class="string">'id'</span>: tasks[<span class="number">-1</span>][<span class="string">'id'</span>] + <span class="number">1</span>,</span><br><span class="line">        <span class="string">'title'</span>: request.json[<span class="string">'title'</span>],</span><br><span class="line">        <span class="string">'description'</span>: request.json.get(<span class="string">'description'</span>, <span class="string">""</span>),</span><br><span class="line">        <span class="string">'done'</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">    tasks.append(task)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'task'</span>: task&#125;), <span class="number">201</span></span><br></pre></td></tr></table></figure><p>request.json 里面包含请求数据，如果不是 JSON 或者里面没有包括 title 字段，将会返回 <code>400</code> 的错误代码。</p><p>当创建一个新的任务字典，使用最后一个任务 id 数值加 1 作为新的任务 id（最简单的方法产生一个唯一字段）。这里允许不带 description 字段，默认将 done 字段值为 <code>False</code> 。</p><p>将新任务附加到 tasks 数组里面，并且返回客户端 <code>201</code> 状态码和刚刚添加的任务内容。HTTP定义了 <code>201</code> 状态码为“Created”。</p><p>测试上面的新功能：<br><img src="https://images.xiaozhuanlan.com/photo/2019/672c558fba34aa19096446cfbc82dbb1.png" alt="创建一个新的任务"></p><p>其中 <code>postman</code> 上的设定：<br><img src="https://images.xiaozhuanlan.com/photo/2019/a637eb063fc96ceb8c483e74fe956f41.png" alt="header"><br><img src="https://images.xiaozhuanlan.com/photo/2019/b5fbbda40e05b9f774f245493f9f9e14.png" alt="body"></p><p>完成上面的事情，就可以看到更新之后的 list 数组内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"专栏Link： https://xiaozhuanlan.com/python_mastery"</span>,</span><br><span class="line">            <span class="attr">"done"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"订阅 python_mastery 专栏"</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"专栏Link： https://xiaozhuanlan.com/pythonml"</span>,</span><br><span class="line">            <span class="attr">"done"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"订阅 pythonml 专栏"</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"link https://xiaozhuanlan.com/topic/0758412369"</span>,</span><br><span class="line">            <span class="attr">"done"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Read 专栏文章"</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成剩下的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['PUT'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_task</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    task = list(filter(<span class="keyword">lambda</span> t: t[<span class="string">'id'</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> len(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'title'</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'description'</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'done'</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> type(request.json[<span class="string">'done'</span>]) <span class="keyword">is</span> <span class="keyword">not</span> bool:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">'title'</span>] = request.json.get(<span class="string">'title'</span>, task[<span class="number">0</span>][<span class="string">'title'</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">'description'</span>] = request.json.get(<span class="string">'description'</span>, task[<span class="number">0</span>][<span class="string">'description'</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">'done'</span>] = request.json.get(<span class="string">'done'</span>, task[<span class="number">0</span>][<span class="string">'done'</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'task'</span>: task[<span class="number">0</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['DELETE'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_task</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    task = list(filter(<span class="keyword">lambda</span> t: t[<span class="string">'id'</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> len(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    tasks.remove(task[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'result'</span>: <span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure><p> <code>delete_task</code> 函数没什么太特别的。<br> <code>update_task</code> 函数需要检查所输入的参数，防止产生错误的 bug 。确保是预期的 JSON 格式写入数据库里面。</p><p>测试将任务 #2 的 <code>done</code> 字段变更为 <code>done</code> 状态：<br><img src="https://images.xiaozhuanlan.com/photo/2019/0c57c10023df70c913da73e3ad2bbbbf.png" alt=" `done` 状态"></p><p>其中 <code>postman</code> 上的设定：<br><img src="https://images.xiaozhuanlan.com/photo/2019/a637eb063fc96ceb8c483e74fe956f41.png" alt="header"><br><img src="https://images.xiaozhuanlan.com/photo/2019/9cf8ee53537e2369b88a0de7a18389c4.png" alt="body"></p><p>经过上面的操作，我们理论上已经完成了基本的开发任务了。虽我们的目前的service 还存在很多可以改进的地方，例如</p><ul><li>更方便的扩展</li><li>安全性验证</li><li>使用数据库</li><li>其它可优化的地方</li></ul><p>下面针对这3个点，来做具体分析，但是这也只是假设的情况，请实际根据需求来完成。</p><h3 id="优化上面的实现"><a href="#优化上面的实现" class="headerlink" title="优化上面的实现"></a>优化上面的实现</h3><h4 id="更方便的扩展"><a href="#更方便的扩展" class="headerlink" title="更方便的扩展"></a>更方便的扩展</h4><p>假设现在使用者想修改 一个任务的 <code>done</code> 为 <code>True</code>, 他需要自己组合请求的 URL, 那服务器端可以直接返回 API URL 吗？</p><p>答案是可以。</p><p>我们可以通过下面的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> url_for</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_public_task</span><span class="params">(task)</span>:</span></span><br><span class="line">    new_task = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> field <span class="keyword">in</span> task:</span><br><span class="line">        <span class="keyword">if</span> field == <span class="string">'id'</span>:</span><br><span class="line">            new_task[<span class="string">'uri'</span>] = url_for(<span class="string">'get_task'</span>, task_id=task[<span class="string">'id'</span>], _external=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_task[field] = task[field]</span><br><span class="line">    <span class="keyword">return</span> new_task</span><br></pre></td></tr></table></figure><p>通过 Flask 的 url_for 模块，获取任务时，将任务中的 id 字段替换成 uri 字段，并且把值改为 uri 值。</p><p>当我们返回包含任务的 list 时，通过这个函数处理后，返回完整的 uri 给客户端。</p><p>把之前的 <code>get_tasks()</code> 做一些简单的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: list(map(make_public_task, tasks))&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意变化是： <code>return jsonify({&#39;tasks&#39;: list(map(make_public_task, tasks))})</code></p></blockquote><p>检查下结果<br><img src="https://images.xiaozhuanlan.com/photo/2019/c401c2b24ac93baedb12910bb6f771db.png" alt="替换 URL "></p><p>这种办法拿到的是完整 <code>uri</code> 而不是一个 <code>id</code> 。</p><h4 id="安全性验证"><a href="#安全性验证" class="headerlink" title="安全性验证"></a>安全性验证</h4><p>我们已经基本完成了整个功能，但是我们还有一个问题: web service 任何人都可以访问的，在当前爬虫满地跑的年代。这可不行。</p><p>当前 service 是所有客户端都可以连接的，如果有别人知道了这个API就可以写个客户端随意修改数据了。这是个十分严重的问题。</p><p>那要怎么解决这个问题呢？</p><p>最简单的办法是在 web service 中，只允许用户名和密码验证通过的客户端连接。</p><p>在一个常规的web应用中，应该有登录表单提交去认证，同时服务器会创建一个会话过程去进行通讯。</p><p>这个会话过程id会被存储在客户端的cookie里面。不过这样就违返了我们REST中无状态的规则，因此，我们需求客户端每次都将他们的认证信息发送到服务器。</p><p>此我们有两种方法表单认证方法去做，分别是 Basic 和 Digest。</p><p>这个问题已经有很多大佬已经提供了完整的解决方案，我们只是拿来使用就可以了。Flask 插件中的 Flask-HTTPAuth 就可以满足这个功能。</p><p><a href="https://github.com/miguelgrinberg/flask-httpauth" target="_blank" rel="noopener">https://github.com/miguelgrinberg/flask-httpauth</a></p><p>老规矩，首先安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask_httpauth</span><br></pre></td></tr></table></figure><p>然后就是实现功能。假设web service只有用户 <code>python</code> 和密码为 <code>python_mastery</code> 的用户接入。下面就设置了一个Basic HTTP认证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask.ext.httpauth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line">auth = HTTPBasicAuth()</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.get_password</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_password</span><span class="params">(username)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">'python'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'python_mastery'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.error_handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unauthorized</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> make_response(jsonify(&#123;<span class="string">'error'</span>: <span class="string">'Unauthorized access'</span>&#125;), <span class="number">401</span>)</span><br></pre></td></tr></table></figure><p><code>get_password</code> 函数是一个回调函数，获取一个已知用户的密码。</p><blockquote><p>在实际的系统中，函数是需要到数据库中检查的，这里只是一个小示例。</p></blockquote><p>当发生认证错误之后，<code>error_handler</code> 回调函数会发送错误的代码给客户端。这里我们自定义一个错误代码 401，返回 JSON 数据，而不是 HTML 。</p><p>将 <code>@auth.login_required</code> 装饰器添加到需要验证的函数上面：</p><p>修改之前的函数实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="meta">@auth.login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: tasks&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意这里的不同是：<code>@auth.login_required</code></p></blockquote><p><img src="https://images.xiaozhuanlan.com/photo/2019/e6dd4df100b1ac6b504726810dfa2646.png" alt="Unauthorized access"></p><p>这里表示了没通过验证，下面试着把用户名与密码一起带过去进行验证：</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/b749b5151105a428c450b07baa5de32f.png" alt="一起验证"></p><p>其中 <code>postman</code> 设定：<br><img src="https://images.xiaozhuanlan.com/photo/2019/2af3f6b1c73091f4c29c777df0ec06dc.png" alt="base_auth"></p><p>这个认证插件十分灵活，可以随指定需要验证的APIs。</p><h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><p>对于复杂的系统，使用数据库进行数据管理，那是基础条件。鉴于这是另外一个很大的主题，这里就不再深入讨论了。感兴趣的可以去阅读相关的文档及资料。</p><blockquote><p>刚发现，这个专栏里面也相关的入门文章。<br>如果感兴趣，请移步：<a href="https://xiaozhuanlan.com/topic/0789431562" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/0789431562</a></p></blockquote><h4 id="其它可优化的地方"><a href="#其它可优化的地方" class="headerlink" title="其它可优化的地方"></a>其它可优化的地方</h4><p>目前我们的系统基本实现了最简单的一个功能，一些复杂的功能，暂时还没有考虑进来。<br>例如：</p><ul><li>处理多用户。<br>  如果系统支持多用户认证，则任务清单也是对应多用户的。此时的问题复杂度就翻倍了，我们同时要提供用户信息的管理，同时要把用户的任务对应关联起来。</li><li>通过 GET 请求检索任务清单时，我们一次性的返回了所有的任务，但是在任务及用户巨量的时候，这是无法接受的。<br>  有很多办法可以进扩展。<ul><li>第一，添加分页参数，使客户端只请求一部份数据。</li><li>第二，添加筛选关键字等。所有这些元素可以添加到URL上面的参数。</li></ul></li></ul><p>上面就是这次分享的全部内容，谢谢大家的阅读。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在工作学习中，我们经常会需要将自己的开发成果对外提供服务，此时的选择很多，但是什么才是最高效的呢？&lt;/p&gt;
&lt;p&gt;想必聪明的你，已经想到了：通过 &lt;code&gt;API&lt;/code&gt; 的方式对外提供服务。既然我们在学习 Python 过程中，那我们就使用 Python 来实现自己的 API 吧。&lt;/p&gt;
&lt;p&gt;下面将从下面几个方面进行讲解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 简介&lt;/li&gt;
&lt;li&gt;RESTful API 简介&lt;/li&gt;
&lt;li&gt;使用Python Flask 实现 RESTful API&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;API-简介&quot;&gt;&lt;a href=&quot;#API-简介&quot; class=&quot;headerlink&quot; title=&quot;API 简介&quot;&gt;&lt;/a&gt;API 简介&lt;/h2&gt;&lt;p&gt;API 是英语 &lt;code&gt;Application Programming Interfaces&lt;/code&gt; 的3个首字母组成的，翻译成中文即 &lt;code&gt;应用程序编程接口&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;API 通常是由服务器（Server）提供（服务器有各种各样的类型，一般我们浏览网页用到的是web server，即网络服务器），通过调用 API，本地计算机可以读取、编辑网站数据，就像人类可以加载网页、提交信息等。&lt;/p&gt;
&lt;p&gt;通俗地，API可以理解为家用电器的插头，用户(本地电脑)只需要将插头插入插座的，不需要考虑电器内部(服务器)里面是如何运作的。通过提供 API, 将内部的实现细节封装了起来，对本地电脑简化的流程，同时减少了出错的可能。&lt;/p&gt;
&lt;p&gt;另外一个角度上讲API是一套协议，规定了与外界的沟通方式：如何发送请求和接受响应。只有大家同遵循同样的方式，就可以很快速的接入我们的服务。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;RESTful-API-简介&quot;&gt;&lt;a href=&quot;#RESTful-API-简介&quot; class=&quot;headerlink&quot; title=&quot;RESTful API 简介&quot;&gt;&lt;/a&gt;RESTful API 简介&lt;/h2&gt;&lt;p&gt;RESTful API 即满足 RESTful 风格设计的API，RESTful 表示的是一种互联网软件架构(以网络为基础的应用软件的架构设计)，如果一个架构符合 &lt;code&gt;REST&lt;/code&gt; (Representational State Transfer的缩写，翻译成中文是 &lt;code&gt;&amp;quot;表现层状态转化&amp;quot;&lt;/code&gt;.)原则，就称它为 RESTful 架构。&lt;/p&gt;
&lt;p&gt;那什么是 &lt;code&gt;REST&lt;/code&gt; 原则呢？&lt;code&gt;Representational State Transfer&lt;/code&gt; 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，基本就理解了什么是 &lt;code&gt;REST&lt;/code&gt; 设计原则。&lt;/p&gt;
&lt;p&gt;从下面几个角度来分解这个问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下面的部分内容可以忽略，可以直接跳到总结的部分。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://youdaily.github.io/tags/Python/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python-高级-实用-操作 Excel</title>
    <link href="https://youdaily.github.io/posts/dd3965e6/"/>
    <id>https://youdaily.github.io/posts/dd3965e6/</id>
    <published>2019-10-15T03:31:13.000Z</published>
    <updated>2019-12-10T02:03:34.430Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h1 id="Python-高级-实用-操作-Excel"><a href="#Python-高级-实用-操作-Excel" class="headerlink" title="Python-高级-实用-操作 Excel"></a>Python-高级-实用-操作 Excel</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>Excel 是我们日常工作学习中都会使用到的很重要的工具。但是处理过程中难免会遇到重复的操作，同时面对大量数据时手工操作也可能因为误操作导致错误发生。我们刚好在学习 Python, 那有没有办法通过 code 来读取 Excel 文件。</p><p>答案是肯定的，下面我们就使用 Python 来进行操作 Excel 文件。</p><h2 id="模块选择"><a href="#模块选择" class="headerlink" title="模块选择"></a>模块选择</h2><p>熟悉 Python 世界的读者，就会明白：在 Python 的世界里，做一件事情，官方建议只有一种方法。但是现实中，大佬太多，互相之间看不上别人做的东西，重复造轮子的现象比较严重。</p><p>如果百度或google 一下：“Python Excel”, 下面的几个第三方模块库常常出现在推荐列表中</p><ul><li>openpyxl</li><li>xlsxwriter</li><li>xlutils</li><li>xlwings</li></ul><p>经过实际的验证(验证过程略), 我挑选 <code>xlwings</code> 作为实际使用的模块。</p><h2 id="xlwings-简介"><a href="#xlwings-简介" class="headerlink" title="xlwings 简介"></a><code>xlwings</code> 简介</h2><p>众所周知，VBA 可以很高效的操作 Excel，提高办公效率。<br>在 Python 中，我们可以通过 pywin32 来调用 windows 系统的 API 来实现 VBA 的很多功能，但是写起来比较复杂。</p><p><code>xlwings</code> 是基于 BSD-licensed 的一个 Python 第三方的模块，对 <code>pywin32</code> 进行了封装，可以很方便的和 Excel 进行交互，它有以下优点：</p><ul><li>语法接近 VBA</li><li>可以用 Python 代码取代 VBA 编写宏</li><li>在 windows 可以用 Python 编写 Excel 用户自定义函数</li><li>全功能支持 Numpy Pandas matplotlib 等科学计算库</li><li>支持 Windows 和 MacOS</li><li>支持 Py3.3+</li></ul><a id="more"></a><p>官方地址： <a href="https://www.xlwings.org/" target="_blank" rel="noopener">https://www.xlwings.org/</a></p><h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="推荐的方式"><a href="#推荐的方式" class="headerlink" title="推荐的方式"></a>推荐的方式</h4><p>推荐使用 <code>Anaconda</code>  来安装，可以省去很多麻烦，</p><blockquote><p>Anaconda 是一个包含了Python 常用模块的第三方整合的包，里面包含了很多实用的工具及模块，是Python 快速学习及开发比较推荐的方式。同时他也提供命令行工具 <code>conda</code> 方便来对模块进行安装，其功能类似于Python 官方的 <code>pip</code> 工具。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install xlwings</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="自己手动安装"><a href="#自己手动安装" class="headerlink" title="自己手动安装"></a>自己手动安装</h4><p>当然自己手动安装也是可以的，下面是自己手动使用 <code>pip</code> 安装的过程。<br>使用 <code>pip</code> 安装，需要先手动安装 <code>pywin32</code> , 这是一个将 OS 的一些底层操作进行高级封装的模块，简化了对系统的复杂操作。 </p><p>下载地址:<br><a href="https://sourceforge.net/projects/pywin32/files/pywin32/" target="_blank" rel="noopener">https://sourceforge.net/projects/pywin32/files/pywin32/</a></p><p>安装 pywin32 后，使用 pip 安装 <code>xlwings</code>即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install xlwings</span><br></pre></td></tr></table></figure></p><p><code>xlwings</code>的 官方安装文档,<br><a href="https://docs.xlwings.org/en/stable/installation.html" target="_blank" rel="noopener">https://docs.xlwings.org/en/stable/installation.html</a></p><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>引入库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br></pre></td></tr></table></figure></p><p>打开Excel程序，默认设置：程序可见，只打开不新建工作薄<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app = xw.App(visible=True,add_book=False)</span><br><span class="line"># 新建工作簿 (如果不接下一条代码的话，Excel会一闪而过就走了）</span><br><span class="line"></span><br><span class="line">wb = app.books.add()</span><br></pre></td></tr></table></figure></p><p>打开已有工作簿（支持绝对路径和相对路径）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wb = app.books.open(<span class="string">'temp.xlsx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接使用下面这条</span></span><br><span class="line"><span class="comment">#wb = xw.Book('temp.xlsx')</span></span><br><span class="line"><span class="comment"># 这样的话就不会频繁打开新的Excel</span></span><br></pre></td></tr></table></figure></p><p>保存工作簿<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.save(<span class="string">'example.xlsx'</span>)</span><br></pre></td></tr></table></figure></p><p>退出工作簿（可省略）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.close()</span><br></pre></td></tr></table></figure></p><p>退出Excel<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.quit()</span><br></pre></td></tr></table></figure></p><p>引用Excel工作表，单元格<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 引用工作表</span></span><br><span class="line">sht = wb.sheets[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#sht = wb.sheets[第一个sheet名]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用单元格</span></span><br><span class="line">rng = sht.range(<span class="string">'a1'</span>)</span><br><span class="line"><span class="comment"># rng = sht['a1']</span></span><br><span class="line"><span class="comment"># rng = sht[0,0] 第一行的第一列即a1,相当于pandas的切片</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用区域</span></span><br><span class="line">rng = sht.range(<span class="string">'a1:a5'</span>)</span><br><span class="line"><span class="comment"># rng = sht['a1:a5']</span></span><br><span class="line"><span class="comment"># rng = sht[:5,0]</span></span><br></pre></td></tr></table></figure></p><h2 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h2><h3 id="一份完整的sample-代码"><a href="#一份完整的sample-代码" class="headerlink" title="一份完整的sample 代码"></a>一份完整的sample 代码</h3><p>我们把刚刚的过程，写到一起，再来回顾下函数的基础使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"><span class="comment"># 打开一个新的 workbook </span></span><br><span class="line">wb = xw.Book()</span><br><span class="line"><span class="comment"># 打开当前目录已经存在的一个 workbook </span></span><br><span class="line">wb = xw.Book(<span class="string">'temp.xlsx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入完整的路径打开一个 workbook </span></span><br><span class="line">FileName = <span class="string">"C:\\python\\to\\temp.xlsx"</span></span><br><span class="line"><span class="comment"># FileName = r"C:\python\to\temp.xlsx"</span></span><br><span class="line"></span><br><span class="line">wb = xw.Book(fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 sheet 的三种方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 打开第一个 sheet</span></span><br><span class="line">sheet = wb.sheets[<span class="number">0</span>]</span><br><span class="line"><span class="comment">## 打开名字为 "youdaily" sheet</span></span><br><span class="line">sheet = wb.sheets[<span class="string">"youdaily"</span>]</span><br><span class="line"><span class="comment">## 打开当前活动的 sheet</span></span><br><span class="line">sheet = wb.sheets.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读写数据到 sheet </span></span><br><span class="line"><span class="comment">## 当前活动的 sheet 中读写一个单元格的数据</span></span><br><span class="line"></span><br><span class="line">sht = wb.sheets.active</span><br><span class="line">sht.range(<span class="string">'A1'</span>).value = <span class="string">"youdaily"</span></span><br><span class="line">print(sht.range(<span class="string">'A1'</span>).value)</span><br><span class="line"><span class="comment">## youdaily</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前活动的 sheet 中读写一行单元格的数据</span></span><br><span class="line"><span class="comment">## 将列表储存在A1：C1中</span></span><br><span class="line">sht.range(<span class="string">'A1'</span>).value=[<span class="string">"youdaily"</span>,<span class="string">"age"</span>,<span class="string">"gender"</span>]</span><br><span class="line">print(sht.range(<span class="string">'A1:C1'</span>).value)</span><br><span class="line"><span class="comment">## ['youdaily', 'age', 'gender']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># #当前活动的 sheet 中读写一列单元格的数据</span></span><br><span class="line"><span class="comment"># 将列表储存在A1:A3中</span></span><br><span class="line">sht.range(<span class="string">'A1'</span>).options(transpose=<span class="literal">True</span>).value=[<span class="string">"youdaily"</span>,<span class="number">18</span>,<span class="number">1</span>]</span><br><span class="line">print(sht.range(<span class="string">"A1:A3"</span>).value)</span><br><span class="line"><span class="comment">## ['youdaily', 18.0, 1.0]</span></span><br><span class="line"></span><br><span class="line">sht.range(<span class="string">'A1:A3'</span>).value = [<span class="string">"youdaily"</span>, <span class="number">20</span>, <span class="number">2</span>]</span><br><span class="line">print(sht.range(<span class="string">"A1:A3"</span>).value)</span><br><span class="line"><span class="comment">## ['youdaily', 18.0, 1.0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 当前活动的 sheet 中读写多行多列单元格的数据</span></span><br><span class="line"><span class="comment">## 将2x2表格，即二维数组，储存在A1:B2中，如第一行1，2，第二行3，4</span></span><br><span class="line">wb = xw.Book()</span><br><span class="line">sht = wb.sheets.active</span><br><span class="line">sht.range(<span class="string">'A1'</span>).options(expand=<span class="string">'table'</span>).value=[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">print(sht.range(<span class="string">"A1"</span>).expand().value)</span><br><span class="line"><span class="comment">## [[1.0, 2.0], [3.0, 4.0]]</span></span><br><span class="line"><span class="comment">## expand 的详细用法请参考文档</span></span><br><span class="line">sht.range(<span class="string">'A1:B2'</span>).value = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">print(sht.range(<span class="string">'A1:B2'</span>).value)</span><br><span class="line"><span class="comment">## [[1.0, 2.0], [3.0, 4.0]]</span></span><br></pre></td></tr></table></figure><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>有了上面的回顾后，我们再来一个实例来再学习一次。</p><p>需求：删除 Excel 文件中，满足条件的单元格所在的一整行.</p><p>我们的Excel 文件长这样。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-a73d9fda25c0a8fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="excel"></p><blockquote><p>你当然可以在Excel 中使用Excel 自带的方法，来实现去重的功能，但是那不是手动了吗？<br>现在是数据少的时候，如果数据多了呢？手动操作，出错的概率会大大的增加。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2019-11-09 17:14:03</span></span><br><span class="line"><span class="comment"># @Author  : youdaily (youdaily)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"></span><br><span class="line">fn = <span class="string">"temp.xlsx"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeleteTools</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    删除满足某些条件的行</span></span><br><span class="line"><span class="string">    data.xlsx 中有很多重复的数据    </span></span><br><span class="line"><span class="string">    需要删除那些重复的</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        super(DeleteTools, self).__init__()</span><br><span class="line">        self.ExistSet = set()</span><br><span class="line">        self.ToDelList = list()</span><br><span class="line">        self.fn = fn</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rule</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 可以自定义规则来操作</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># visible 控制 Excel 打开是否显示界面</span></span><br><span class="line">        <span class="comment">## add_book 控制是否添加新的 workbook</span></span><br><span class="line">        app = xw.App(visible=<span class="literal">True</span>, add_book=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># app.display_alerts = False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开 temp.xlsx 文件到 wookbook 中</span></span><br><span class="line">        wb = app.books.open(fn)</span><br><span class="line">        <span class="comment"># 切换到当前活动的 sheet 中</span></span><br><span class="line">        sheet = wb.sheets.active</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择 A1 所在的一列</span></span><br><span class="line">        <span class="comment">## 当 Excel 格式复杂的时候,不建议使用 expand</span></span><br><span class="line">        <span class="comment">## 可以这样选择</span></span><br><span class="line">        ARange = sheet.range(<span class="string">"A1:A100"</span>)</span><br><span class="line">        <span class="comment"># ARange = sheet.range("A1").expand("download")</span></span><br><span class="line">        <span class="keyword">for</span> A <span class="keyword">in</span> ARange:</span><br><span class="line">            <span class="keyword">if</span> str(A.value).strip() <span class="keyword">not</span> <span class="keyword">in</span> self.ExistSet:</span><br><span class="line">                self.ExistSet.add(str(A.value).strip())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># address = A.address</span></span><br><span class="line">                <span class="comment">## 获取 A 所在的位置坐标</span></span><br><span class="line">                self.ToDelList.append(A.address)</span><br><span class="line">                <span class="comment">## print(A.value)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.ToDelList:</span><br><span class="line">            td = self.ToDelList.pop()</span><br><span class="line">            <span class="comment"># 删除 A 所在的一行</span></span><br><span class="line">            sheet.range(td).api.EntireRow.Delete()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 保存 wookbook</span></span><br><span class="line">        <span class="comment">## 相当于Excel 的 Ctrl+S 快捷键</span></span><br><span class="line">        sheet.autofit()</span><br><span class="line">        wb.save()</span><br><span class="line">        app.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    d = DeleteTools(fn)</span><br><span class="line">    d.Delete()</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>通过 <code>xlwings</code> 模块去自动操作 excel , 将日常需要手动操作的过程通过代码来自动操作，减少犯错的可能，一次次的不犯错，就是巨大的成功，在迎娶“白富美”的路上越走越远了。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-高级-实用-操作-Excel&quot;&gt;&lt;a href=&quot;#Python-高级-实用-操作-Excel&quot; class=&quot;headerlink&quot; title=&quot;Python-高级-实用-操作 Excel&quot;&gt;&lt;/a&gt;Python-高级-实用-操作 Excel&lt;/h1&gt;&lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;Excel 是我们日常工作学习中都会使用到的很重要的工具。但是处理过程中难免会遇到重复的操作，同时面对大量数据时手工操作也可能因为误操作导致错误发生。我们刚好在学习 Python, 那有没有办法通过 code 来读取 Excel 文件。&lt;/p&gt;
&lt;p&gt;答案是肯定的，下面我们就使用 Python 来进行操作 Excel 文件。&lt;/p&gt;
&lt;h2 id=&quot;模块选择&quot;&gt;&lt;a href=&quot;#模块选择&quot; class=&quot;headerlink&quot; title=&quot;模块选择&quot;&gt;&lt;/a&gt;模块选择&lt;/h2&gt;&lt;p&gt;熟悉 Python 世界的读者，就会明白：在 Python 的世界里，做一件事情，官方建议只有一种方法。但是现实中，大佬太多，互相之间看不上别人做的东西，重复造轮子的现象比较严重。&lt;/p&gt;
&lt;p&gt;如果百度或google 一下：“Python Excel”, 下面的几个第三方模块库常常出现在推荐列表中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;openpyxl&lt;/li&gt;
&lt;li&gt;xlsxwriter&lt;/li&gt;
&lt;li&gt;xlutils&lt;/li&gt;
&lt;li&gt;xlwings&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过实际的验证(验证过程略), 我挑选 &lt;code&gt;xlwings&lt;/code&gt; 作为实际使用的模块。&lt;/p&gt;
&lt;h2 id=&quot;xlwings-简介&quot;&gt;&lt;a href=&quot;#xlwings-简介&quot; class=&quot;headerlink&quot; title=&quot;xlwings 简介&quot;&gt;&lt;/a&gt;&lt;code&gt;xlwings&lt;/code&gt; 简介&lt;/h2&gt;&lt;p&gt;众所周知，VBA 可以很高效的操作 Excel，提高办公效率。&lt;br&gt;在 Python 中，我们可以通过 pywin32 来调用 windows 系统的 API 来实现 VBA 的很多功能，但是写起来比较复杂。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xlwings&lt;/code&gt; 是基于 BSD-licensed 的一个 Python 第三方的模块，对 &lt;code&gt;pywin32&lt;/code&gt; 进行了封装，可以很方便的和 Excel 进行交互，它有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法接近 VBA&lt;/li&gt;
&lt;li&gt;可以用 Python 代码取代 VBA 编写宏&lt;/li&gt;
&lt;li&gt;在 windows 可以用 Python 编写 Excel 用户自定义函数&lt;/li&gt;
&lt;li&gt;全功能支持 Numpy Pandas matplotlib 等科学计算库&lt;/li&gt;
&lt;li&gt;支持 Windows 和 MacOS&lt;/li&gt;
&lt;li&gt;支持 Py3.3+&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://youdaily.github.io/tags/Python/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python-高级-爬虫-Requests 库高级使用</title>
    <link href="https://youdaily.github.io/posts/3c355061/"/>
    <id>https://youdaily.github.io/posts/3c355061/</id>
    <published>2019-10-13T03:29:35.000Z</published>
    <updated>2019-12-10T02:03:44.418Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="Headers（定制请求头）"><a href="#Headers（定制请求头）" class="headerlink" title="Headers（定制请求头）"></a>Headers（定制请求头）</h2><h3 id="什么是Headers请求头呢？"><a href="#什么是Headers请求头呢？" class="headerlink" title="什么是Headers请求头呢？"></a>什么是Headers请求头呢？</h3><p>请求头就是访问网页时的各种简单的证明信息，里面包含了很多内容。</p><p>比如你要获取信息的格式、访问的时间、是否用了代理（使用透明代理时浏览器依旧会发送你的真实IP，只有高匿代理才不会）、浏览器标识（User-Agent）等。</p><p>提示：给大家举一个非常直白的例子，浏览器就像是你的专属外卖配送员，各网站就像外卖商家，配送员到商家取餐时，需要提供订单号、我是谁的配送员、要取什么餐等等信息。</p><p>这里以chrome浏览器为例，首先 F12 打开调试模式，然后访问一个网站，将会在NetWork下看到对目标网页的请求信息，如下图：<br><img src="https://images.xiaozhuanlan.com/photo/2019/b2f2ccdcfc8c21bd8cf347564f09ec12.png" alt></p><p>通过设置header可以跳过一些简单的反爬或者防盗链措施。对付防盗链，服务器会识别 headers 中的 referer 是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在 headers 中加入 referer 。</p><blockquote><p>爬虫和反爬虫就像是双生兄弟一样，其中</p></blockquote><h3 id="一个响应内容的小例子"><a href="#一个响应内容的小例子" class="headerlink" title="一个响应内容的小例子"></a>一个响应内容的小例子</h3><p>这里以上海证券交易所为例，比如我要获取整个市场当日的基金成交信息，地址：<a href="http://www.sse.com.cn/market/funddata/overview/day/" target="_blank" rel="noopener">http://www.sse.com.cn/market/funddata/overview/day/</a><br><img src="https://images.xiaozhuanlan.com/photo/2019/4fa96803c51d0ccd800998dc044d5560.png" alt="当日的基金成交信息"></p><p>经过分析，其数据所在网址为<br><a href="http://query.sse.com.cn/marketdata/tradedata/queryNewTradingByProdTypeData.do?jsonCallBack=jsonpCallback10558&amp;searchDate=2019-10-08&amp;prodType=jj&amp;_=1570591517567" target="_blank" rel="noopener">http://query.sse.com.cn/marketdata/tradedata/queryNewTradingByProdTypeData.do?jsonCallBack=jsonpCallback10558&amp;searchDate=2019-10-08&amp;prodType=jj&amp;_=1570591517567</a></p><p>里面几个参数 <code>searchDate=2019-10-08</code> 和 <code>_=1570591517567</code> 很明显是时间戳，如果需要定时访问时，还是要构造一个url的。</p><p>使用time库的time方法即可。</p><a id="more"></a><p>时间戳的长度跟url中有差别，是因为精度问题，只需要乘以1000然后取整即可。</p><p>构造好url后，直接访问以下试试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">timestamp = int(time.time()*<span class="number">1000</span>)</span><br><span class="line">url = <span class="string">'http://query.sse.com.cn/marketdata/tradedata/queryTradingByProdTypeData.do?jsonCallBack=jsonpCallback21071&amp;searchDate=&amp;prodType=jj&amp;_=&#123;&#125;'</span>.format(timestamp)</span><br><span class="line">res = requests.get(url)</span><br><span class="line">html = res.content.decode()</span><br><span class="line">print(html)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到结果</span></span><br><span class="line">jsonpCallback21071(&#123;“jsonCallBack”:”jsonpCallback21071″,”success”:”false”,”error”:”系统繁忙…”,”errorType”:”ExceptionInterceptor”&#125;)</span><br></pre></td></tr></table></figure><br>虽然有一些信息，但明显是出错了。<br><img src="https://images.xiaozhuanlan.com/photo/2019/a52113b1b8f0f60145e15418c2c2a611.png" alt="出错了"></p><p>我们通过浏览器来查看这个链接的请求头到底是什么：</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/b8451173af49b6f9b5c59c093079b477.png" alt="请求头"></p><p>复制过来，构造一个dict类型的header字典，再次访问试试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">myheaders = &#123;</span><br><span class="line">        <span class="string">'Referer'</span>: <span class="string">'http://www.sse.com.cn/market/funddata/overview/day/'</span>, </span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span></span><br><span class="line">             &#125;</span><br><span class="line">timestamp = int(time.time()*<span class="number">1000</span>)</span><br><span class="line">url = <span class="string">'http://query.sse.com.cn/marketdata/tradedata/queryTradingByProdTypeData.do?jsonCallBack=jsonpCallback21071&amp;searchDate=&amp;prodType=jj&amp;_=&#123;&#125;'</span>.format(timestamp)</span><br><span class="line">res = requests.get(url, headers=myheaders)</span><br><span class="line">html = res.content.decode()</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><br>完全没毛病了：<br><img src="https://images.xiaozhuanlan.com/photo/2019/338ebf5fb19f485f6e5abe8b105c5867.png" alt="成功了"></p><h3 id="Headers各主要字段的解释"><a href="#Headers各主要字段的解释" class="headerlink" title="Headers各主要字段的解释"></a>Headers各主要字段的解释</h3><p>在Requests Headers中各主要字段的解释如下：</p><ul><li>User-Agent<br> 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求</li><li>Content-Type<br>  在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。</li><li>application/xml<br> 在 XML RPC，如 RESTful/SOAP 调用时使用</li><li>application/json<br> 在 JSON RPC 调用时使用</li><li>application/x-www-form-urlencoded<br>  浏览器提交 Web 表单时使用</li></ul><blockquote><p>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</p></blockquote><h3 id="其他响应方式"><a href="#其他响应方式" class="headerlink" title="其他响应方式"></a>其他响应方式</h3><p>二进制响应内容：res.content，解码前，是byte格式。</p><p>JSON 响应内容：Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据 <code>res.json()</code> 。如果 JSON 解码失败， r.json() 就会抛出一个异常。例如，响应内容是 401 (Unauthorized)，尝试访问 r.json() 将会抛出  <code>ValueError: No JSON object could be decoded</code>异常。</p><p>原始响应内容：在罕见的情况下，你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw。 如果你确实想这么干，那请你确保在初始请求中设置了 <code>stream=True</code>。</p><h2 id="构造Url"><a href="#构造Url" class="headerlink" title="构造Url"></a>构造Url</h2><p>前文中目标 url 有很多参数，一方面很不美观，也容易出错，我们完全可以把参数全部摘出来放到一个 dict 字典中，然后在请求网页数据时将这个字典数据传递给 <code>params</code> 参数，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">myheaders = &#123;</span><br><span class="line">    <span class="string">'Referer'</span>: <span class="string">'http://www.sse.com.cn/market/funddata/overview/day/'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timestamp = int(time.time()*<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">localtime = time.localtime()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里以当前日期为例，如果需要特定日期，直接为`searchDate` 赋值就可以了</span></span><br><span class="line"><span class="comment"># searchDate = "&#123;0&#125;-&#123;1&#125;-&#123;2&#125;".format("2019"， "10"， "08")</span></span><br><span class="line">searchDate = <span class="string">"&#123;&#125;-&#123;:0&gt;2d&#125;-&#123;:0&gt;2d&#125;"</span>.format(localtime.tm_year,localtime.tm_mon, localtime.tm_mday)</span><br><span class="line"></span><br><span class="line">pp = &#123;</span><br><span class="line">    <span class="string">'jsonCallBack'</span>: <span class="string">'jsonpCallback22341'</span>,</span><br><span class="line">    <span class="string">'searchDate'</span>: searchDate,</span><br><span class="line">    <span class="string">'prodType'</span>: <span class="string">'jj'</span>,</span><br><span class="line">    <span class="string">'_'</span>: timestamp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://query.sse.com.cn/marketdata/tradedata/queryTradingByProdTypeData.do'</span></span><br><span class="line">res = requests.get(url, headers=myheaders, params=pp)</span><br><span class="line">html = res.content.decode()</span><br><span class="line"></span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure></p><h2 id="Timeout-超时设置"><a href="#Timeout-超时设置" class="headerlink" title="Timeout(超时设置)"></a>Timeout(超时设置)</h2><p>连接超时指的是在你的客户端实现到远端机器端口的连接时（对应的是<code>connect()</code>_），Request 会等待的秒数。<br>一个很好的实践方法是把连接超时设为比 3 的倍数略大的一个数值，因为 TCP 数据包重传窗口 (<code>TCP packet retransmission window</code>) 的默认大小是 3。</p><p>有时候，我们访问的网页可能挂了、或者网络不稳定，或者网速太差等等原因导致整个程序卡在某个页面上了，这就非常耽误事，毕竟爬虫需要批量抓很多内容的，有些内容我们可以临时放弃并做标记，将所有都爬完后再考虑是否重新爬之前超时的页面。为防止服务器不能及时响应，大部分发至外部服务器的请求都应该带着 timeout 参数。</p><p>在默认情况下，除非显式指定了 timeout 值，requests 是不会自动进行超时处理的。</p><p>如果没有 timeout，你的代码可能会挂起若干分钟甚至更长时间。</p><p>你可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">requests.get(‘https://xiaozhuanlan.com/python_mastery’, timeout=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><blockquote><p>timeout 仅对连接过程有效，与响应体的下载无关。</p></blockquote><p>timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）<code>If no timeout is specified explicitly, requests do not time out.</code>。</p><p>如果远端服务器很慢，你可以让 Request 永远等待，传入一个 None 作为 timeout 值，然后就可以了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">'https://xiaozhuanlan.com/python_mastery'</span>, timeout=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Headers（定制请求头）&quot;&gt;&lt;a href=&quot;#Headers（定制请求头）&quot; class=&quot;headerlink&quot; title=&quot;Headers（定制请求头）&quot;&gt;&lt;/a&gt;Headers（定制请求头）&lt;/h2&gt;&lt;h3 id=&quot;什么是Headers请求头呢？&quot;&gt;&lt;a href=&quot;#什么是Headers请求头呢？&quot; class=&quot;headerlink&quot; title=&quot;什么是Headers请求头呢？&quot;&gt;&lt;/a&gt;什么是Headers请求头呢？&lt;/h3&gt;&lt;p&gt;请求头就是访问网页时的各种简单的证明信息，里面包含了很多内容。&lt;/p&gt;
&lt;p&gt;比如你要获取信息的格式、访问的时间、是否用了代理（使用透明代理时浏览器依旧会发送你的真实IP，只有高匿代理才不会）、浏览器标识（User-Agent）等。&lt;/p&gt;
&lt;p&gt;提示：给大家举一个非常直白的例子，浏览器就像是你的专属外卖配送员，各网站就像外卖商家，配送员到商家取餐时，需要提供订单号、我是谁的配送员、要取什么餐等等信息。&lt;/p&gt;
&lt;p&gt;这里以chrome浏览器为例，首先 F12 打开调试模式，然后访问一个网站，将会在NetWork下看到对目标网页的请求信息，如下图：&lt;br&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2019/b2f2ccdcfc8c21bd8cf347564f09ec12.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;通过设置header可以跳过一些简单的反爬或者防盗链措施。对付防盗链，服务器会识别 headers 中的 referer 是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在 headers 中加入 referer 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;爬虫和反爬虫就像是双生兄弟一样，其中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一个响应内容的小例子&quot;&gt;&lt;a href=&quot;#一个响应内容的小例子&quot; class=&quot;headerlink&quot; title=&quot;一个响应内容的小例子&quot;&gt;&lt;/a&gt;一个响应内容的小例子&lt;/h3&gt;&lt;p&gt;这里以上海证券交易所为例，比如我要获取整个市场当日的基金成交信息，地址：&lt;a href=&quot;http://www.sse.com.cn/market/funddata/overview/day/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.sse.com.cn/market/funddata/overview/day/&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2019/4fa96803c51d0ccd800998dc044d5560.png&quot; alt=&quot;当日的基金成交信息&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过分析，其数据所在网址为&lt;br&gt;&lt;a href=&quot;http://query.sse.com.cn/marketdata/tradedata/queryNewTradingByProdTypeData.do?jsonCallBack=jsonpCallback10558&amp;amp;searchDate=2019-10-08&amp;amp;prodType=jj&amp;amp;_=1570591517567&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://query.sse.com.cn/marketdata/tradedata/queryNewTradingByProdTypeData.do?jsonCallBack=jsonpCallback10558&amp;amp;searchDate=2019-10-08&amp;amp;prodType=jj&amp;amp;_=1570591517567&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面几个参数 &lt;code&gt;searchDate=2019-10-08&lt;/code&gt; 和 &lt;code&gt;_=1570591517567&lt;/code&gt; 很明显是时间戳，如果需要定时访问时，还是要构造一个url的。&lt;/p&gt;
&lt;p&gt;使用time库的time方法即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://youdaily.github.io/tags/Python/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python-高级-爬虫-Requests 库基础使用</title>
    <link href="https://youdaily.github.io/posts/c1efdcfc/"/>
    <id>https://youdaily.github.io/posts/c1efdcfc/</id>
    <published>2019-10-10T03:27:37.000Z</published>
    <updated>2019-12-10T02:03:52.981Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h2><p><code>Requests</code> 库就非常优雅，虽然不是原生python模块，但自己安装也非常简单，只需要使用以下命令即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p>作为 GitHub上关注数最多的 Python 项目之一，使用的是 urllib3，继承了urllib2的所有特性。requests实现了 HTTP协议中绝大部分功能，它提供的功能包括 Keep-Alive、连接池、Cookie持久化、内容自动解压、HTTP代理、SSL认证、连接超时、Session等很多特性，最重要的是它同时兼容 python2 和 python3。</p><p>同时，Requests对于HEAD, POST, PUT, PATCH, 和 DELETE方法的api同样简单。它可以处理多部分上传，同样支持自动转码，文档更好，还有更多的特性。</p><blockquote><p>值得注意的是，网络上有种言论是因为requests不支持异步，所以不推荐使用，但是随着 Python 语言本身的发展，现在已经可以很方便的将<code>requests</code>转为异步。</p></blockquote><h3 id="查看所安装-Requests-的版本"><a href="#查看所安装-Requests-的版本" class="headerlink" title="查看所安装 Requests 的版本"></a>查看所安装 Requests 的版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.__version__</span><br><span class="line"><span class="string">'2.21.0'</span></span><br></pre></td></tr></table></figure><h2 id="常用的-Requests-方法及说明"><a href="#常用的-Requests-方法及说明" class="headerlink" title="常用的 Requests 方法及说明"></a>常用的 Requests 方法及说明</h2><h3 id="请求URL：GET"><a href="#请求URL：GET" class="headerlink" title="请求URL：GET"></a>请求URL：GET</h3><p>当我们导入requests模块之后就可以使用get命令来获取网页了，我们以自己的小专栏为例，测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.get(<span class="string">'https://xiaozhuanlan.com/python_mastery'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>请求url之后，我们可以通过 <code>response.status_code</code> 或者 <code>response.ok</code> 命令来查看是否访问成功。</p><p>网页的具体内容则可以通过方法 <code>response.content.decode()</code> 来获取，其中 <code>decode()</code> 是用于解析内容编码的，如果网页编码格式是 <code>gb2312</code> 之类的，需要 <code>decode(&#39;gbk&#39;)</code> ，如果是 <code>utf8</code> ，则需要 <code>decode(&#39;utf-8&#39;)</code> 传入不同的参数。当参数为空时，默认为当前脚本的编码格式。<br><img src="https://images.xiaozhuanlan.com/photo/2019/e0ecacb5b5aab5cb0f1a9d34f7625038.png" alt="response.content.decode()"></p><p>其中对象response的属性 <code>status_code</code> 代表网页的htpp状态码，爬虫在抓取过程中经常遇到的的状态码有以下几种：</p><ul><li>200<br>  一切正常，网页资源正常获取到。</li><li>500<br>  如果在网页上会提示Bad Request，表示网页服务器返回给请求端的错误提示，提示请求端修复请求信息。</li><li>500<br>  Internal Server Error，网页服务器方面的问题，在爬虫抓取网站的过程中如果过快、被禁止等，会引发该类问题。表示服务器限制了客户端的访问。</li><li>404(“Not Found”) 和410(“Gone”)<br>  表示请求的网页资源不存在。</li><li>301<br>  重定向，请求的url呗重新定向到了另外一个url请求，通常需要请求端向另外一个url发送get请求才能得到所需要的网页资源。</li></ul><p>这里只是摘抄了部分返回值的情况，完整的内容请参见 https 状态码<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">HTTP 响应代码</a></p><h3 id="传递URL的参数"><a href="#传递URL的参数" class="headerlink" title="传递URL的参数"></a>传递URL的参数</h3><p>与后面要将到的 <code>post</code> 方式请求url相比，通过在url上添加参数也是网页服务器的设计之一，具体使用哪种方式是有网站程序来控制。</p><p>最经典、使用率最高的就是百度搜索了，百度搜索就是典型的通过 url 来传递搜索词和其他变量的，当然，也有一些 post 的内容在此处用不到暂时不展开讲。</p><p>用百度搜索一下，此处以关键词 “小专栏 Python 从入门到精通”为例，</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/649d4725ae4bde13071acda730a5c131.png" alt="百度搜索"></p><p>可以看到其中 <code>wd</code> 是关键词，<code>wd</code> 的具体值中空格变成了<code>+</code>，这是 url 转码导致的，在我们传递 url 参数时，有时候也需要这样的处理。</p><p>我们试着用requests来传递参数，目标地址：<code>https://www.baidu.com/s</code>，构造一个参数字典：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>params = &#123;<span class="string">'wd'</span>:<span class="string">'小专栏 Python 从入门到精通'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.get(<span class="string">'https://www.baidu.com/s'</span>, params=params)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.url)</span><br><span class="line">https://www.baidu.com/s?wd=%E5%B0%8F%E4%B8%93%E6%A0%8F+Python+%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A</span><br></pre></td></tr></table></figure><br>可以看到，url 已经传递了参数过来。浏览器访问该链接时中文讲自动解析。</p><blockquote><p>如果我们直接请求该网址，可能网页内容无法或许到，因为我们访问的是 <code>https</code> ，需要 <code>ssl</code> 证书，此后的教程中我会讲到该部分内容。</p></blockquote><h2 id="请求URL：POST"><a href="#请求URL：POST" class="headerlink" title="请求URL：POST"></a>请求URL：POST</h2><p>前面讲到传递 url 参数时提到 <code>post</code> 方法，<code>post</code> 方法就是 url 保持不变而具体的请求变量内容以 <code>post</code> 的形式发送过去。可以直接理解为将 url 中的参数改到了 <code>post</code> 的data中，<code>post</code> 还有一个好处是当传递的内容很长时，通过 url 是无法发送的（有最大长度），<code>post</code> 就没问题。而且，除了用于登录，像图片上传、文件上传，发表文章、论坛发帖顶贴等也基本使用的是 <code>post</code> 方法。</p><p>这里假设登录 wordpress 的博客后台来举例，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造一个post的form Data</span></span><br><span class="line">postdata = &#123;</span><br><span class="line"><span class="string">'log'</span>: <span class="string">'XXXXXXXXXXXX'</span>,</span><br><span class="line"><span class="string">'pwd'</span>: <span class="string">'XXXXXXXXXXXX'</span>,</span><br><span class="line"><span class="string">'wp-submit'</span>: <span class="string">'登录'</span>,</span><br><span class="line"><span class="string">'redirect_to'</span>: <span class="string">'http://xxx.xxx.xxx/'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行post命令</span></span><br><span class="line">response = requests.post(url, data=postdata)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看取得的网页内容</span></span><br><span class="line">response.content.decode()</span><br></pre></td></tr></table></figure><p>以上就是requests库的基础用法。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Requests&quot;&gt;&lt;a href=&quot;#Requests&quot; class=&quot;headerlink&quot; title=&quot;Requests&quot;&gt;&lt;/a&gt;Requests&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Requests&lt;/code&gt; 库就非常优雅，虽然不是原生python模块，但自己安装也非常简单，只需要使用以下命令即可：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install requests&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;作为 GitHub上关注数最多的 Python 项目之一，使用的是 urllib3，继承了urllib2的所有特性。requests实现了 HTTP协议中绝大部分功能，它提供的功能包括 Keep-Alive、连接池、Cookie持久化、内容自动解压、HTTP代理、SSL认证、连接超时、Session等很多特性，最重要的是它同时兼容 python2 和 python3。&lt;/p&gt;
&lt;p&gt;同时，Requests对于HEAD, POST, PUT, PATCH, 和 DELETE方法的api同样简单。它可以处理多部分上传，同样支持自动转码，文档更好，还有更多的特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;值得注意的是，网络上有种言论是因为requests不支持异步，所以不推荐使用，但是随着 Python 语言本身的发展，现在已经可以很方便的将&lt;code&gt;requests&lt;/code&gt;转为异步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;查看所安装-Requests-的版本&quot;&gt;&lt;a href=&quot;#查看所安装-Requests-的版本&quot; class=&quot;headerlink&quot; title=&quot;查看所安装 Requests 的版本&quot;&gt;&lt;/a&gt;查看所安装 Requests 的版本&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; requests&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;requests.__version__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;2.21.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;常用的-Requests-方法及说明&quot;&gt;&lt;a href=&quot;#常用的-Requests-方法及说明&quot; class=&quot;headerlink&quot; title=&quot;常用的 Requests 方法及说明&quot;&gt;&lt;/a&gt;常用的 Requests 方法及说明&lt;/h2&gt;&lt;h3 id=&quot;请求URL：GET&quot;&gt;&lt;a href=&quot;#请求URL：GET&quot; class=&quot;headerlink&quot; title=&quot;请求URL：GET&quot;&gt;&lt;/a&gt;请求URL：GET&lt;/h3&gt;&lt;p&gt;当我们导入requests模块之后就可以使用get命令来获取网页了，我们以自己的小专栏为例，测试一下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; requests&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;response = requests.get(&lt;span class=&quot;string&quot;&gt;&#39;https://xiaozhuanlan.com/python_mastery&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://youdaily.github.io/tags/Python/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>你真的掌握变量和类型了吗（二）类型转换</title>
    <link href="https://youdaily.github.io/posts/5a507748/"/>
    <id>https://youdaily.github.io/posts/5a507748/</id>
    <published>2019-09-08T07:09:34.000Z</published>
    <updated>2019-12-10T02:04:13.837Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="六、还有哪些引用类型"><a href="#六、还有哪些引用类型" class="headerlink" title="六、还有哪些引用类型"></a>六、还有哪些引用类型</h2><blockquote><p>在<code>ECMAScript</code>中，引用类型是一种数据结构，用于将数据和功能组织在一起。</p></blockquote><p>我们通常所说的对象，就是某个特定引用类型的实例。</p><p>在<code>ECMAScript</code>关于类型的定义中，只给出了<code>Object</code>类型，实际上，我们平时使用的很多引用类型的变量，并不是由<code>Object</code>构造的，但是它们原型链的终点都是<code>Object</code>，这些类型都属于引用类型。</p><ul><li><code>Array</code> 数组</li><li><code>Date</code> 日期</li><li><code>RegExp</code> 正则</li><li><code>Function</code> 函数</li></ul><h3 id="6-1-包装类型"><a href="#6-1-包装类型" class="headerlink" title="6.1 包装类型"></a>6.1 包装类型</h3><p>为了便于操作基本类型值，<code>ECMAScript</code>还提供了几个特殊的引用类型，他们是基本类型的包装类型：</p><ul><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code></li></ul><p>注意包装类型和原始类型的区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> === <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"><span class="number">123</span> === <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// false</span></span><br><span class="line"><span class="string">"ConardLi"</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"ConardLi"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"ConardLi"</span>)); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"ConardLi"</span>); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><blockquote><p>引用类型和包装类型的主要区别就是对象的生存期，使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"ConardLi"</span>;</span><br><span class="line">name.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.color); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="6-2-装箱和拆箱"><a href="#6-2-装箱和拆箱" class="headerlink" title="6.2 装箱和拆箱"></a>6.2 装箱和拆箱</h3><ul><li><p>装箱转换：把基本类型转换为对应的包装类型</p></li><li><p>拆箱操作：把引用类型转换为基本类型</p></li></ul><p>既然原始类型不能扩展属性和方法，那么我们是如何使用原始类型调用方法的呢？</p><p>每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而让我们能够调用一些方法和属性，例如下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"ConardLi"</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = name.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>实际上发生了以下几个过程：</p><ul><li>创建一个<code>String</code>的包装类型实例</li><li>在实例上调用<code>substring</code>方法</li><li>销毁实例</li></ul><p>也就是说，我们使用基本类型调用方法，就会自动进行装箱和拆箱操作，相同的，我们使用<code>Number</code>和<code>Boolean</code>类型时，也会发生这个过程。</p><p>从引用类型到基本类型的转换，也就是拆箱的过程中，会遵循<code>ECMAScript规范</code>规定的<code>toPrimitive</code>原则，一般会调用引用类型的<code>valueOf</code>和<code>toString</code>方法，你也可以直接重写<code>toPeimitive</code>方法。一般转换成不同类型的值遵循的原则不同，例如：</p><ul><li>引用类型转换为<code>Number</code>类型，先调用<code>valueOf</code>，再调用<code>toString</code></li><li>引用类型转换为<code>String</code>类型，先调用<code>toString</code>，再调用<code>valueOf</code></li></ul><p>若<code>valueOf</code>和<code>toString</code>都不存在，或者没有返回基本类型，则抛出<code>TypeError</code>异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"valueOf"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"toString"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ConardLi"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj - <span class="number">1</span>); <span class="comment">// valueOf   122</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj&#125;</span>ConardLi`</span>); <span class="comment">// toString  ConardLiConardLi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"toPrimitive"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj2 - <span class="number">1</span>); <span class="comment">// valueOf   122</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"valueOf"</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"toString"</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj3 - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// valueOf</span></span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>除了程序中的自动拆箱和自动装箱，我们还可以手动进行拆箱和装箱操作。我们可以直接调用包装类型的<code>valueOf</code>或<code>toString</code>，实现拆箱操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"123"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num.valueOf()); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num.toString()); <span class="comment">//string</span></span><br></pre></td></tr></table></figure><h2 id="七、类型转换"><a href="#七、类型转换" class="headerlink" title="七、类型转换"></a>七、类型转换</h2><p>因为<code>JavaScript</code>是弱类型的语言，所以类型转换发生非常频繁，上面我们说的装箱和拆箱其实就是一种类型转换。</p><p>类型转换分为两种，隐式转换即程序自动进行的类型转换，强制转换即我们手动进行的类型转换。</p><p>强制转换这里就不再多提及了，下面我们来看看让人头疼的可能发生隐式类型转换的几个场景，以及如何转换：</p><h3 id="7-1-类型转换规则"><a href="#7-1-类型转换规则" class="headerlink" title="7.1 类型转换规则"></a>7.1 类型转换规则</h3><p>如果发生了隐式转换，那么各种类型互转符合下面的规则：</p><p><img src="http://www.conardli.top/img/bl/bl_8_convert.png" alt></p><h3 id="7-2-if-语句和逻辑语句"><a href="#7-2-if-语句和逻辑语句" class="headerlink" title="7.2 if 语句和逻辑语句"></a>7.2 if 语句和逻辑语句</h3><p>在<code>if</code>语句和逻辑语句中，如果只有单个变量，会先将变量转换为<code>Boolean</code>值，只有下面几种情况会转换成<code>false</code>，其余被转换成<code>true</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>;</span><br><span class="line"><span class="literal">undefined</span>;</span><br><span class="line">(<span class="string">""</span>);</span><br><span class="line"><span class="literal">NaN</span>;</span><br><span class="line"><span class="number">0</span>;</span><br><span class="line"><span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="7-3-各种运数学算符"><a href="#7-3-各种运数学算符" class="headerlink" title="7.3 各种运数学算符"></a>7.3 各种运数学算符</h3><p>我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="literal">true</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span> - <span class="literal">null</span>; <span class="comment">//  1</span></span><br><span class="line"><span class="number">1</span> * <span class="literal">undefined</span>; <span class="comment">//  NaN</span></span><br><span class="line"><span class="number">2</span> * [<span class="string">"5"</span>]; <span class="comment">//  10</span></span><br></pre></td></tr></table></figure><p>注意<code>+</code>是个例外，执行<code>+</code>操作符时：</p><ul><li>1.当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li><li>2.当一侧为<code>Number</code>类型，另一侧为原始类型，则将原始类型转换为<code>Number</code>类型。</li><li>3.当一侧为<code>Number</code>类型，另一侧为引用类型，将引用类型和<code>Number</code>类型转换成字符串后拼接。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> + <span class="string">"123"</span>; <span class="comment">// 123123   （规则1）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">null</span>; <span class="comment">// 123    （规则2）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">true</span>; <span class="comment">// 124    （规则2）</span></span><br><span class="line"><span class="number">123</span> + &#123;&#125;; <span class="comment">// 123[object Object]    （规则3）</span></span><br></pre></td></tr></table></figure><h3 id="7-4"><a href="#7-4" class="headerlink" title="7.4 =="></a>7.4 ==</h3><p>使用<code>==</code>时，若两侧类型相同，则比较结果和<code>===</code>相同，否则会发生隐式转换，使用<code>==</code>时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：</p><ul><li><strong>1.NaN</strong></li></ul><p><code>NaN</code>和其他任何类型比较永远返回<code>false</code>(包括和他自己)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><strong>2.Boolean</strong></li></ul><p><code>Boolean</code>和其他任何类型比较，<code>Boolean</code>首先被转换为<code>Number</code>类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">"2"</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">"1"</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">"2"</span>]; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>这里注意一个可能会弄混的点：<code>undefined、null</code>和<code>Boolean</code>比较，虽然<code>undefined、null</code>和<code>false</code>都很容易被想象成假值，但是他们比较结果是<code>false</code>，原因是<code>false</code>首先被转换成<code>0</code>：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><strong>3.String 和 Number</strong></li></ul><p><code>String</code>和<code>Number</code>比较，先将<code>String</code>转换为<code>Number</code>类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> == <span class="string">"123"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == <span class="number">0</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>4.null 和 undefined</strong></li></ul><p><code>null == undefined</code>比较结果是<code>true</code>，除此之外，<code>null、undefined</code>和其他任何结果的比较值都为<code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="string">""</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="string">""</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><strong>5.原始类型和引用类型</strong></li></ul><p>当原始类型和引用类型做比较时，对象类型会依照<code>ToPrimitive</code>规则转换为原始类型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"[object Object]"</span> == &#123;&#125;; <span class="comment">// true</span></span><br><span class="line"><span class="string">"1,2,3"</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>来看看下面这个比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] == ![]; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>!</code>的优先级高于<code>==</code>，<code>![]</code>首先会被转换为<code>false</code>，然后根据上面第三点，<code>false</code>转换成<code>Number</code>类型<code>0</code>，左侧<code>[]</code>转换为<code>0</code>，两侧比较相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([<span class="literal">null</span>] ==</span><br><span class="line">  <span class="literal">false</span>[<span class="literal">undefined</span>]) == <span class="comment">// true</span></span><br><span class="line">  <span class="literal">false</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>根据数组的<code>ToPrimitive</code>规则，数组元素为<code>null</code>或<code>undefined</code>时，该元素被当做空字符串处理，所以<code>[null]、[undefined]</code>都会被转换为<code>0</code>。</p><p>所以，说了这么多，推荐使用<code>===</code>来判断两个值是否相等…</p><h3 id="7-5-一道有意思的面试题"><a href="#7-5-一道有意思的面试题" class="headerlink" title="7.5 一道有意思的面试题"></a>7.5 一道有意思的面试题</h3><p>一道经典的面试题，如何让：<code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code>。</p><p>根据上面的拆箱转换，以及<code>==</code>的隐式转换，我们可以轻松写出答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  value: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="八、判断-JavaScript-数据类型的方式"><a href="#八、判断-JavaScript-数据类型的方式" class="headerlink" title="八、判断 JavaScript 数据类型的方式"></a>八、判断 JavaScript 数据类型的方式</h2><h3 id="8-1-typeof"><a href="#8-1-typeof" class="headerlink" title="8.1 typeof"></a>8.1 typeof</h3><p><strong>适用场景</strong></p><p><code>typeof</code>操作符可以准确判断一个变量是否为下面几个原始类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">"ConardLi"</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>你还可以用它来判断函数类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// function</span></span><br></pre></td></tr></table></figure><p><strong>不适用场景</strong></p><p>当你用<code>typeof</code>来判断引用类型时似乎显得有些乏力了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> /^\d*$/; <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>除函数外所有的引用类型都会被判定为<code>object</code>。</p><p>另外<code>typeof null === &#39;object&#39;</code>也会让人感到头痛，这是在<code>JavaScript</code>初版就流传下来的<code>bug</code>，后面由于修改会造成大量的兼容问题就一直没有被修复…</p><h3 id="8-2-instanceof"><a href="#8-2-instanceof" class="headerlink" title="8.2 instanceof"></a>8.2 instanceof</h3><p><code>instanceof</code>操作符可以帮助我们判断引用类型具体是什么类型的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>() <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们先来回顾下原型链的几条规则：</p><ul><li>1.所有引用类型都具有对象特性，即可以自由扩展属性</li><li>2.所有引用类型都具有一个<code>__proto__</code>（隐式原型）属性，是一个普通对象</li><li>3.所有的函数都具有<code>prototype</code>（显式原型）属性，也是一个普通对象</li><li>4.所有引用类型<code>__proto__</code>值指向它构造函数的<code>prototype</code></li><li>5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的<code>__proto__</code>中去找</li></ul><p><code>[] instanceof Array</code>实际上是判断<code>Array.prototype</code>是否在<code>[]</code>的原型链上。</p><p>所以，使用<code>instanceof</code>来检测数据类型，不会很准确，这不是它设计的初衷：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>另外，使用<code>instanceof</code>也不能检测基本数据类型，所以<code>instanceof</code>并不是一个很好的选择。</p><h3 id="8-3-toString"><a href="#8-3-toString" class="headerlink" title="8.3 toString"></a>8.3 toString</h3><p>上面我们在拆箱操作中提到了<code>toString</code>函数，我们可以调用它实现从引用类型的转换。</p><blockquote><p>每一个引用类型都有<code>toString</code>方法，默认情况下，<code>toString()</code>方法被每个<code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，<code>toString()</code> 返回 <code>&quot;[object type]&quot;</code>，其中<code>type</code>是对象的类型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.toString(); <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure><p>注意，上面提到了<code>如果此方法在自定义对象中未被覆盖</code>，<code>toString</code>才会达到预想的效果，事实上，大部分引用类型比如<code>Array、Date、RegExp</code>等都重写了<code>toString</code>方法。</p><p>我们可以直接调用<code>Object</code>原型上未被覆盖的<code>toString()</code>方法，使用<code>call</code>来改变<code>this</code>指向来达到我们想要的效果。</p><p><img src="http://www.conardli.top/img/bl/bl_9_jc.png" alt></p><h3 id="8-4-jquery"><a href="#8-4-jquery" class="headerlink" title="8.4 jquery"></a>8.4 jquery</h3><p>我们来看看<code>jquery</code>源码中如何进行类型判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> class2type = &#123;&#125;;</span><br><span class="line">jQuery.each( <span class="string">"Boolean Number String Function Array Date RegExp Object Error Symbol"</span>.split( <span class="string">" "</span> ),</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"> i, name </span>) </span>&#123;</span><br><span class="line">class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase();</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">type: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( obj == <span class="literal">null</span> ) &#123;</span><br><span class="line"><span class="keyword">return</span> obj + <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"object"</span> || <span class="keyword">typeof</span> obj === <span class="string">"function"</span> ?</span><br><span class="line">class2type[<span class="built_in">Object</span>.prototype.toString.call(obj) ] || <span class="string">"object"</span> :</span><br><span class="line"><span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isFunction: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> jQuery.type(obj) === <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始类型直接使用<code>typeof</code>，引用类型使用<code>Object.prototype.toString.call</code>取得类型，借助一个<code>class2type</code>对象将字符串多余的代码过滤掉，例如<code>[object function]</code>将得到<code>array</code>，然后在后面的类型判断，如<code>isFunction</code>直接可以使用<code>jQuery.type(obj) === &quot;function&quot;</code>这样的判断。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ecma-international.org/ecma-262/9.0/index.html" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/9.0/index.html</a></li><li><a href="https://while.dev/articles/explaining-truthy-falsy-null-0-and-undefined-in-typescript/" target="_blank" rel="noopener">https://while.dev/articles/explaining-truthy-falsy-null-0-and-undefined-in-typescript/</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/28</a></li><li><a href="https://juejin.im/post/5bc5c752f265da0a9a399a62" target="_blank" rel="noopener">https://juejin.im/post/5bc5c752f265da0a9a399a62</a></li><li><a href="https://juejin.im/post/5bbda2b36fb9a05cfd27f55e" target="_blank" rel="noopener">https://juejin.im/post/5bbda2b36fb9a05cfd27f55e</a></li><li>《JS 高级程序设计》</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p><ul><li>了解<code>JavaScript</code>中的变量在内存中的具体存储形式，可对应实际场景</li><li>搞懂小数计算不精确的底层原因</li><li>了解可能发生隐式类型转换的场景以及转换原则</li><li>掌握判断<code>JavaScript</code>数据类型的方式和底层原理</li></ul><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div id=&quot;vip-container&quot;&gt;&lt;h2 id=&quot;六、还有哪些引用类型&quot;&gt;&lt;a href=&quot;#六、还有哪些引用类型&quot; class=&quot;headerlink&quot; title=&quot;六、还有哪些引用类型&quot;&gt;&lt;/a&gt;六、还有哪些引用类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在
      
    
    </summary>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>你真的掌握变量和类型了吗（一）数据类型</title>
    <link href="https://youdaily.github.io/posts/f20134e9/"/>
    <id>https://youdaily.github.io/posts/f20134e9/</id>
    <published>2019-09-03T07:06:26.000Z</published>
    <updated>2019-12-10T02:04:22.803Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>变量和类型是学习<code>JavaScript</code>最先接触到的东西，但是往往看起来最简单的东西往往还隐藏着很多你不了解、或者容易犯错的知识，比如下面几个问题：</p><ul><li><code>JavaScript</code>中的变量在内存中的具体存储形式是什么？</li><li><code>0.1+0.2</code>为什么不等于<code>0.3</code>?发生小数计算错误的具体原因是什么？</li><li><code>Symbol</code>的特点，以及实际应用场景是什么？</li><li><code>[] == ![]</code>、<code>[undefined] == false</code>为什么等于<code>true</code>?代码中何时会发生隐式类型转换？转换的规则是什么？</li><li>如何精确的判断变量的类型？</li></ul><p>如果你还不能很好的解答上面的问题，那说明你还没有完全掌握这部分的知识，那么请好好阅读下面的文章吧。</p><p>本文从底层原理到实际应用详细介绍了<code>JavaScript</code>中的变量和类型相关知识。</p><h2 id="一、JavaScript数据类型"><a href="#一、JavaScript数据类型" class="headerlink" title="一、JavaScript数据类型"></a>一、JavaScript数据类型</h2><p><a href="http://www.ecma-international.org/ecma-262/9.0/index.html" target="_blank" rel="noopener">ECMAScript标准</a>规定了<code>7</code>种数据类型，其把这<code>7</code>种数据类型又分为两种：原始类型和对象类型。</p><p><strong>原始类型</strong></p><ul><li><code>Null</code>：只包含一个值：<code>null</code></li><li><code>Undefined</code>：只包含一个值：<code>undefined</code></li><li><code>Boolean</code>：包含两个值：<code>true</code>和<code>false</code></li><li><code>Number</code>：整数或浮点数，还有一些特殊值（<code>-Infinity</code>、<code>+Infinity</code>、<code>NaN</code>）</li><li><code>String</code>：一串表示文本值的字符序列</li><li><code>Symbol</code>：一种实例是唯一且不可改变的数据类型</li></ul><p>(在<code>es10</code>中加入了第七种原始类型<code>BigInt</code>，现已被最新<code>Chrome</code>支持)</p><p><strong>对象类型</strong></p><ul><li><code>Object</code>：自己分一类丝毫不过分，除了常用的<code>Object</code>，<code>Array</code>、<code>Function</code>等都属于特殊的对象</li></ul><h2 id="二、为什么区分原始类型和对象类型"><a href="#二、为什么区分原始类型和对象类型" class="headerlink" title="二、为什么区分原始类型和对象类型"></a>二、为什么区分原始类型和对象类型</h2><h3 id="2-1-不可变性"><a href="#2-1-不可变性" class="headerlink" title="2.1 不可变性"></a>2.1 不可变性</h3><p>上面所提到的原始类型，在<code>ECMAScript</code>标准中，它们被定义为<code>primitive values</code>，即原始值，代表值本身是不可被改变的。</p><p>以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'ConardLi'</span>;</span><br><span class="line">str.slice(<span class="number">1</span>);</span><br><span class="line">str.substr(<span class="number">1</span>);</span><br><span class="line">str.trim(<span class="number">1</span>);</span><br><span class="line">str.toLowerCase(<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// ConardLi</span></span><br></pre></td></tr></table></figure><p>在上面的代码中我们对<code>str</code>调用了几个方法，无一例外，这些方法都在原字符串的基础上产生了一个新字符串，而非直接去改变<code>str</code>，这就印证了字符串的不可变性。</p><p>那么，当我们继续调用下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str += <span class="string">'6'</span></span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// ConardLi6</span></span><br></pre></td></tr></table></figure><p>你会发现，<code>str</code>的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解：</p><p>在<code>JavaScript</code>中，每一个变量在内存中都需要一个空间来存储。</p><p>内存空间又被分为两种，栈内存与堆内存。</p><a id="more"></a><p>栈内存：</p><ul><li>存储的值大小固定</li><li>空间较小</li><li>可以直接操作其保存的变量，运行效率高</li><li>由系统自动分配存储空间</li></ul><p><code>JavaScript</code>中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。</p><p><img src="http://www.conardli.top/img/bl/bl_1_stack.png" alt></p><p>由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的。</p><p>在上面的代码中，我们执行了<code>str += &#39;6&#39;</code>的操作，实际上是在栈中又开辟了一块内存空间用于存储<code>&#39;ConardLi6&#39;</code>，然后将变量<code>str</code>指向这块空间，所以这并不违背<code>不可变性的</code>特点。</p><p><img src="http://www.conardli.top/img/bl/bl_2_stack.png" alt></p><h3 id="2-2-引用类型"><a href="#2-2-引用类型" class="headerlink" title="2.2 引用类型"></a>2.2 引用类型</h3><p>堆内存：</p><ul><li>存储的值大小不定，可动态调整</li><li>空间较大，运行效率低</li><li>无法直接操作其内部存储，使用引用地址读取</li><li>通过代码进行分配空间</li></ul><p>相对于上面具有不可变性的原始类型，我习惯把对象称为引用类型，引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"ConardLi"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> obj4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><img src="http://www.conardli.top/img/bl/bl_3_heap.png" alt></p><blockquote><p>由于内存是有限的，这些变量不可能一直在内存中占用资源，这里推荐下这篇文章<a href="https://juejin.im/post/5cb33660e51d456e811d2687" target="_blank" rel="noopener">JavaScript中的垃圾回收和内存泄漏</a>，这里告诉你<code>JavaScript</code>是如何进行垃圾回收以及可能会发生内存泄漏的一些场景。</p></blockquote><p>当然，引用类型就不再具有<code>不可变性</code>了，我们可以轻易的改变它们： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj1.name = <span class="string">"ConardLi6"</span>;</span><br><span class="line">obj2.age = <span class="number">19</span>;</span><br><span class="line">obj4.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name:"ConardLi6"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age:19&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>以数组为例，它的很多方法都可以改变它自身。</p><ul><li><code>pop()</code> 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素</li><li><code>push()</code>向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>shift()</code>把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值</li><li><code>unshift()</code>向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>reverse()</code>颠倒数组中元素的顺序，改变原数组，返回该数组</li><li><code>sort()</code>对数组元素进行排序，改变原数组，返回该数组</li><li><code>splice()</code>从数组中添加/删除项目，改变原数组，返回被删除的元素</li></ul><p>下面我们通过几个操作来对比一下原始类型和引用类型的区别：</p><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><p>当我们把一个变量的值复制到另一个变量上时，原始类型和引用类型的表现是不一样的，先来看看原始类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = name;</span><br><span class="line">name2 = <span class="string">'code秘密花园'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// ConardLi;</span></span><br></pre></td></tr></table></figure><p><img src="http://www.conardli.top/img/bl/bl_4_copy.png" alt></p><p>内存中有一个变量<code>name</code>，值为<code>ConardLi</code>。我们从变量<code>name</code>复制出一个变量<code>name2</code>，此时在内存中创建了一个块新的空间用于存储<code>ConardLi</code>，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。</p><p>复制一个引用类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj;</span><br><span class="line">obj2.name = <span class="string">'code秘密花园'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// code秘密花园</span></span><br></pre></td></tr></table></figure><p><img src="http://www.conardli.top/img/bl/bl_5_copy.png" alt></p><p>当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的<code>obj2</code>实际上和<code>obj</code>指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。</p><h3 id="2-4-比较"><a href="#2-4-比较" class="headerlink" title="2.4 比较"></a>2.4 比较</h3><p>当我们在对两个变量进行比较时，不同类型的变量的表现是不同的：</p><p><img src="http://www.conardli.top/img/bl/bl_6_compare.png" alt></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name === name2); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj === obj2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>对于原始类型，比较时会直接比较它们的值，如果值相等，即返回<code>true</code>。</p><p>对于引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为<code>false</code>。</p><h3 id="2-5-值传递和引用传递"><a href="#2-5-值传递和引用传递" class="headerlink" title="2.5 值传递和引用传递"></a>2.5 值传递和引用传递</h3><p>借助下面的例子，我们先来看一看什么是值传递，什么是引用传递：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  name = <span class="string">'code秘密花园'</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(name);</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><p>执行上面的代码，如果最终打印出来的<code>name</code>是<code>&#39;ConardLi&#39;</code>，没有改变，说明函数参数传递的是变量的值，即值传递。如果最终打印的是<code>&#39;code秘密花园&#39;</code>，函数内部的操作可以改变传入的变量，那么说明函数参数传递的是引用，即引用传递。</p><p>很明显，上面的执行结果是<code>&#39;ConardLi&#39;</code>，即函数参数仅仅是被传入变量复制给了的一个局部变量，改变这个局部变量不会对外部变量产生影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">'code秘密花园'</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// code秘密花园</span></span><br></pre></td></tr></table></figure><p>上面的代码可能让你产生疑惑，是不是参数是引用类型就是引用传递呢？</p><p>首先明确一点，<code>ECMAScript</code>中所有的函数的参数都是按值传递的。</p><p>同样的，当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递，下面我们再按一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">'ConardLi'</span>;</span><br><span class="line">  obj = &#123;<span class="attr">name</span>:<span class="string">'code秘密花园'</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// ConardLi</span></span><br></pre></td></tr></table></figure><p>可见，函数参数传递的并不是变量的<code>引用</code>，而是变量拷贝的副本，当变量是原始类型时，这个副本就是值本身，当变量是引用类型时，这个副本是指向堆内存的地址。所以，再次记住：</p><blockquote><p><code>ECMAScript</code>中所有的函数的参数都是按值传递的。</p></blockquote><h2 id="三、分不清的null和undefined"><a href="#三、分不清的null和undefined" class="headerlink" title="三、分不清的null和undefined"></a>三、分不清的null和undefined</h2><p><img src="http://www.conardli.top/img/bl/bl_7_null.png" alt></p><p>在原始类型中，有两个类型<code>Null</code>和<code>Undefined</code>，他们都有且仅有一个值，<code>null</code>和<code>undefined</code>，并且他们都代表无和空，我一般这样区分它们：</p><p><strong>null</strong></p><p>表示被赋值过的对象，刻意把一个对象赋值为<code>null</code>，故意表示其为空，不应有值。</p><p>所以对象的某个属性值为<code>null</code>是正常的，<code>null</code>转换为数值时值为<code>0</code>。</p><p><strong>undefined</strong> </p><p>表示“缺少值”，即此处应有一个值，但还没有定义，</p><p>如果一个对象的某个属性值为<code>undefined</code>，这是不正常的，如<code>obj.name=undefined</code>，我们不应该这样写，应该直接<code>delete obj.name</code>。</p><p><code>undefined</code>转为数值时为<code>NaN</code>(非数字值的特殊值)</p><p><code>JavaScript</code>是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是<code>undefined</code>的意义所在。对于<code>JAVA</code>这种强类型语言，如果有<code>&quot;undefined&quot;</code>这种情况，就会直接编译失败，所以在它不需要一个这样的类型。</p><h2 id="四、不太熟的Symbol类型"><a href="#四、不太熟的Symbol类型" class="headerlink" title="四、不太熟的Symbol类型"></a>四、不太熟的Symbol类型</h2><p><code>Symbol</code>类型是<code>ES6</code>中新加入的一种原始类型。</p><blockquote><p>每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。</p></blockquote><p>下面来看看<code>Symbol</code>类型具有哪些特性。</p><h3 id="4-1-Symbol的特性"><a href="#4-1-Symbol的特性" class="headerlink" title="4.1 Symbol的特性"></a>4.1 Symbol的特性</h3><p><strong>1.独一无二</strong></p><p>直接使用<code>Symbol()</code>创建新的<code>symbol</code>变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的<code>toString()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>();  <span class="comment">// Symbol() </span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym4 = <span class="built_in">Symbol</span>(&#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;); <span class="comment">// Symbol([object Object])</span></span><br><span class="line"><span class="built_in">console</span>.log(sym2 === sym3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>我们用两个相同的字符串创建两个<code>Symbol</code>变量，它们是不相等的，可见每个<code>Symbol</code>变量都是独一无二的。</p><p>如果我们想创造两个相等的<code>Symbol</code>变量，可以使用<code>Symbol.for(key)</code>。</p><blockquote><p>使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>.for(<span class="string">'ConardLi'</span>);</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">'ConardLi'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym1 === sym2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>2.原始类型</strong></p><p>注意是使用<code>Symbol()</code>函数创建<code>symbol</code>变量，并非使用构造函数，使用<code>new</code>操作符会直接报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// Uncaught TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><p>我们可以使用<code>typeof</code>运算符判断一个<code>Symbol</code>类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>) === <span class="string">'symbol'</span></span><br></pre></td></tr></table></figure><p><strong>3.不可枚举</strong></p><p>当使用<code>Symbol</code>作为对象属性时，可以保证对象不会出现重名属性，调用<code>for...in</code>不能将其枚举出来，另外调用<code>Object.getOwnPropertyNames、Object.keys()</code>也不能获取<code>Symbol</code>属性。</p><blockquote><p>可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name:<span class="string">'ConardLi'</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'name2'</span>)]:<span class="string">'code秘密花园'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj); <span class="comment">// ["name"]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">// ["name"]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [Symbol(name)]</span></span><br></pre></td></tr></table></figure><h3 id="4-2-Symbol的应用场景"><a href="#4-2-Symbol的应用场景" class="headerlink" title="4.2 Symbol的应用场景"></a>4.2 Symbol的应用场景</h3><p>下面是几个<code>Symbol</code>在程序中的应用场景。</p><p><strong>应用一：防止XSS</strong></p><p>在<code>React</code>的<code>ReactElement</code>对象中，有一个<code>$$typeof</code>属性，它是一个<code>Symbol</code>类型的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> REACT_ELEMENT_TYPE =</span><br><span class="line">  (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">'function'</span> &amp;&amp; <span class="built_in">Symbol</span>.for &amp;&amp; <span class="built_in">Symbol</span>.for(<span class="string">'react.element'</span>)) ||</span><br><span class="line">  <span class="number">0xeac7</span>;</span><br></pre></td></tr></table></figure><p><code>ReactElement.isValidElement</code>函数用来判断一个React组件是否是有效的，下面是它的具体实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object === <span class="string">'object'</span> &amp;&amp; object !== <span class="literal">null</span> &amp;&amp; object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可见<code>React</code>渲染时会把没有<code>$$typeof</code>标识，以及规则校验不通过的组件过滤掉。</p><p>如果你的服务器有一个漏洞，允许用户存储任意<code>JSON</code>对象， 而客户端代码需要一个字符串，这可能会成为一个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON</span></span><br><span class="line"><span class="keyword">let</span> expectedTextButGotJSON = &#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    dangerouslySetInnerHTML: &#123;</span><br><span class="line">      __html: <span class="string">'/* put your exploit here */'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> message = &#123; <span class="attr">text</span>: expectedTextButGotJSON &#125;;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  &#123;message.text&#125;</span><br><span class="line">&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure><p>而<code>JSON</code>中不能存储<code>Symbol</code>类型的变量，这就是防止<code>XSS</code>的一种手段。</p><p><strong>应用二：私有属性</strong></p><p>借助<code>Symbol</code>类型的不可枚举，我们可以在类中模拟私有属性，控制变量读写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateField = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>[privateField] = <span class="string">'ConardLi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  getField()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[privateField];</span><br><span class="line">  &#125;</span><br><span class="line">  setField(val)&#123;</span><br><span class="line">    <span class="keyword">this</span>[privateField] = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用三：防止属性污染</strong></p><p>在某些情况下，我们可能要为对象添加一个属性，此时就有可能造成属性覆盖，用<code>Symbol</code>作为对象属性可以保证永远不会出现同名属性。</p><p>例如下面的场景，我们模拟实现一个<code>call</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> result = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在某个对象上临时调用一个方法，又不能造成属性污染，<code>Symbol</code>是一个很好的选择。</p><h2 id="五、不老实的Number类型"><a href="#五、不老实的Number类型" class="headerlink" title="五、不老实的Number类型"></a>五、不老实的Number类型</h2><p>为什么说<code>Number</code>类型不老实呢，相信大家都多多少少的在开发中遇到过小数计算不精确的问题，比如<code>0.1+0.2!==0.3</code>，下面我们来追本溯源，看看为什么会出现这种现象，以及该如何避免。</p><p>下面是我实现的一个简单的函数，用于判断两个小数进行加法运算是否精确：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeFloat</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> binaryN = n.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> binaryM = m.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>的二进制是    <span class="subst">$&#123;binaryN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;m&#125;</span>的二进制是    <span class="subst">$&#123;binaryM&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> MN = m + n;</span><br><span class="line">  <span class="keyword">const</span> accuracyMN = (m * <span class="number">100</span> + n * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> binaryMN = MN.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> accuracyBinaryMN = accuracyMN.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制是<span class="subst">$&#123;binaryMN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是    <span class="subst">$&#123;accuracyBinaryMN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制再转成十进制是<span class="subst">$&#123;to10(binaryMN)&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是再转成十进制是<span class="subst">$&#123;to10(accuracyBinaryMN)&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>在js中计算是<span class="subst">$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? <span class="string">''</span> : <span class="string">'不'</span>&#125;</span>准确的`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">to10</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pre = (n.split(<span class="string">'.'</span>)[<span class="number">0</span>] - <span class="number">0</span>).toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> arr = n.split(<span class="string">'.'</span>)[<span class="number">1</span>].split(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr.length) &#123;</span><br><span class="line">    result += arr[i] * <span class="built_in">Math</span>.pow(<span class="number">2</span>, -(i + <span class="number">1</span>));</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">judgeFloat(<span class="number">0.1</span>, <span class="number">0.2</span>);</span><br><span class="line">judgeFloat(<span class="number">0.6</span>, <span class="number">0.7</span>);</span><br></pre></td></tr></table></figure><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制3.png" alt="image"></p><h3 id="5-1-精度丢失"><a href="#5-1-精度丢失" class="headerlink" title="5.1 精度丢失"></a>5.1 精度丢失</h3><p>计算机中所有的数据都是以<code>二进制</code>存储的，所以在计算时计算机要把数据先转换成<code>二进制</code>进行计算，然后在把计算结果转换成<code>十进制</code>。</p><p>由上面的代码不难看出，在计算<code>0.1+0.2</code>时，<code>二进制</code>计算发生了精度丢失，导致再转换成<code>十进制</code>后和预计的结果不符。</p><h3 id="5-2-对结果的分析—更多的问题"><a href="#5-2-对结果的分析—更多的问题" class="headerlink" title="5.2 对结果的分析—更多的问题"></a>5.2 对结果的分析—更多的问题</h3><p><code>0.1</code>和<code>0.2</code>的二进制都是以1100无限循环的小数，下面逐个来看JS帮我们计算所得的结果：</p><p><strong>0.1的二进制</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure><p><strong>0.2的二进制</strong>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure></p><p><strong>理论上讲，由上面的结果相加应该：</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001100111</span></span><br></pre></td></tr></table></figure><p><strong>实际JS计算得到的0.1+0.2的二进制</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure><p>看到这里你可能会产生更多的问题：</p><blockquote><p>为什么 js计算出的 0.1的二进制 是这么多位而不是更多位？？？</p><p>为什么 js计算的（0.1+0.2）的二进制和我们自己计算的（0.1+0.2）的二进制结果不一样呢？？？</p><p>为什么 0.1的二进制 + 0.2的二进制 != 0.3的二进制？？？</p></blockquote><h3 id="5-3-js对二进制小数的存储方式"><a href="#5-3-js对二进制小数的存储方式" class="headerlink" title="5.3 js对二进制小数的存储方式"></a>5.3 js对二进制小数的存储方式</h3><p>小数的<code>二进制</code>大多数都是无限循环的，<code>JavaScript</code>是怎么来存储他们的呢？</p><p>在<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.19" target="_blank" rel="noopener">ECMAScript®语言规范</a>中可以看到，<code>ECMAScript</code>中的<code>Number</code>类型遵循<code>IEEE 754</code>标准。使用64位固定长度来表示。</p><p>事实上有很多语言的数字类型都遵循这个标准，例如<code>JAVA</code>,所以很多语言同样有着上面同样的问题。</p><p>所以下次遇到这种问题不要上来就喷<code>JavaScript</code>…</p><p>有兴趣可以看看下这个网站<a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">http://0.30000000000000004.com/</a>，是的，你没看错，就是<a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">http://0.30000000000000004.com/</a>！！！</p><h3 id="5-4-IEEE-754"><a href="#5-4-IEEE-754" class="headerlink" title="5.4 IEEE 754"></a>5.4 IEEE 754</h3><p><code>IEEE754</code>标准包含一组实数的二进制表示法。它有三部分组成：</p><ul><li><p>符号位</p></li><li><p>指数位</p></li><li><p>尾数位</p></li></ul><p>三种精度的浮点数各个部分位数如下：</p><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制1.png" alt="image"></p><p><code>JavaScript</code>使用的是64位双精度浮点数编码，所以它的<code>符号位</code>占<code>1</code>位，指数位占<code>11</code>位，尾数位占<code>52</code>位。</p><p>下面我们在理解下什么是<code>符号位</code>、<code>指数位</code>、<code>尾数位</code>，以<code>0.1</code>为例：</p><p>它的二进制为：<code>0.0001100110011001100...</code></p><p>为了节省存储空间，在计算机中它是以科学计数法表示的，也就是</p><p><code>1.100110011001100...</code> X 2<sup>-4</sup></p><p>如果这里不好理解可以想一下十进制的数：</p><p><code>1100</code>的科学计数法为<code>11</code> X 10<sup>2</sup></p><p>所以：</p><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制2.png" alt="image"></p><p><code>符号位</code>就是标识正负的，<code>1</code>表示<code>负</code>，<code>0</code>表示<code>正</code>；</p><p><code>指数位</code>存储科学计数法的指数；</p><p><code>尾数位</code>存储科学计数法后的有效数字；</p><p>所以我们通常看到的二进制，其实是计算机实际存储的尾数位。</p><h3 id="5-5-js中的toString-2"><a href="#5-5-js中的toString-2" class="headerlink" title="5.5 js中的toString(2)"></a>5.5 js中的toString(2)</h3><p>由于尾数位只能存储<code>52</code>个数字，这就能解释<code>toString(2)</code>的执行结果了：</p><p>如果计算机没有存储空间的限制，那么<code>0.1</code>的<code>二进制</code>应该是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span>...</span><br></pre></td></tr></table></figure><br>科学计数法尾数位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>...</span><br></pre></td></tr></table></figure><p>但是由于限制，有效数字第<code>53</code>位及以后的数字是不能存储的，它遵循，如果是<code>1</code>就向前一位进<code>1</code>，如果是<code>0</code>就舍弃的原则。</p><p>0.1的二进制科学计数法第53位是1，所以就有了下面的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure><p><code>0.2</code>有着同样的问题，其实正是由于这样的存储，在这里有了精度丢失，导致了<code>0.1+0.2!=0.3</code>。</p><p>事实上有着同样精度问题的计算还有很多，我们无法把他们都记下来，所以当程序中有数字计算时，我们最好用工具库来帮助我们解决，下面是两个推荐使用的开源库：</p><ul><li><a href="https://github.com/nefe/number-precision" target="_blank" rel="noopener">number-precision</a></li><li><a href="https://github.com/josdejong/mathjs/" target="_blank" rel="noopener">mathjs/</a></li></ul><h3 id="5-6-JavaScript能表示的最大数字"><a href="#5-6-JavaScript能表示的最大数字" class="headerlink" title="5.6 JavaScript能表示的最大数字"></a>5.6 JavaScript能表示的最大数字</h3><p>由与<code>IEEE 754</code>双精度64位规范的限制：</p><p><code>指数位</code>能表示的最大数字：<code>1023</code>(十进制)</p><p><code>尾数位</code>能表达的最大数字即尾数位都位<code>1</code>的情况</p><p>所以JavaScript能表示的最大数字即位</p><p><code>1.111...</code>X 2<sup>1023</sup> 这个结果转换成十进制是<code>1.7976931348623157e+308</code>,这个结果即为<code>Number.MAX_VALUE</code>。</p><h3 id="5-7-最大安全数字"><a href="#5-7-最大安全数字" class="headerlink" title="5.7 最大安全数字"></a>5.7 最大安全数字</h3><p>JavaScript中<code>Number.MAX_SAFE_INTEGER</code>表示最大安全数字,计算结果是<code>9007199254740991</code>，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是<code>1.111...</code>X 2<sup>52</sup>。</p><p>我们同样可以用一些开源库来处理大整数：</p><ul><li><a href="https://github.com/justmoon/node-bignum" target="_blank" rel="noopener">node-bignum</a></li><li><a href="https://github.com/substack/node-bigint" target="_blank" rel="noopener">node-bigint</a></li></ul><p>其实官方也考虑到了这个问题，<code>bigInt</code>类型在<code>es10</code>中被提出，现在<code>Chrome</code>中已经可以使用，使用<code>bigInt</code>可以操作超过最大安全数字的数字。</p><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;变量和类型是学习&lt;code&gt;JavaScript&lt;/code&gt;最先接触到的东西，但是往往看起来最简单的东西往往还隐藏着很多你不了解、或者容易犯错的知识，比如下面几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JavaScript&lt;/code&gt;中的变量在内存中的具体存储形式是什么？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0.1+0.2&lt;/code&gt;为什么不等于&lt;code&gt;0.3&lt;/code&gt;?发生小数计算错误的具体原因是什么？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Symbol&lt;/code&gt;的特点，以及实际应用场景是什么？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[] == ![]&lt;/code&gt;、&lt;code&gt;[undefined] == false&lt;/code&gt;为什么等于&lt;code&gt;true&lt;/code&gt;?代码中何时会发生隐式类型转换？转换的规则是什么？&lt;/li&gt;
&lt;li&gt;如何精确的判断变量的类型？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你还不能很好的解答上面的问题，那说明你还没有完全掌握这部分的知识，那么请好好阅读下面的文章吧。&lt;/p&gt;
&lt;p&gt;本文从底层原理到实际应用详细介绍了&lt;code&gt;JavaScript&lt;/code&gt;中的变量和类型相关知识。&lt;/p&gt;
&lt;h2 id=&quot;一、JavaScript数据类型&quot;&gt;&lt;a href=&quot;#一、JavaScript数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript数据类型&quot;&gt;&lt;/a&gt;一、JavaScript数据类型&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/9.0/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECMAScript标准&lt;/a&gt;规定了&lt;code&gt;7&lt;/code&gt;种数据类型，其把这&lt;code&gt;7&lt;/code&gt;种数据类型又分为两种：原始类型和对象类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原始类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Null&lt;/code&gt;：只包含一个值：&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Undefined&lt;/code&gt;：只包含一个值：&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Boolean&lt;/code&gt;：包含两个值：&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number&lt;/code&gt;：整数或浮点数，还有一些特殊值（&lt;code&gt;-Infinity&lt;/code&gt;、&lt;code&gt;+Infinity&lt;/code&gt;、&lt;code&gt;NaN&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt;：一串表示文本值的字符序列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Symbol&lt;/code&gt;：一种实例是唯一且不可改变的数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(在&lt;code&gt;es10&lt;/code&gt;中加入了第七种原始类型&lt;code&gt;BigInt&lt;/code&gt;，现已被最新&lt;code&gt;Chrome&lt;/code&gt;支持)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object&lt;/code&gt;：自己分一类丝毫不过分，除了常用的&lt;code&gt;Object&lt;/code&gt;，&lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Function&lt;/code&gt;等都属于特殊的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二、为什么区分原始类型和对象类型&quot;&gt;&lt;a href=&quot;#二、为什么区分原始类型和对象类型&quot; class=&quot;headerlink&quot; title=&quot;二、为什么区分原始类型和对象类型&quot;&gt;&lt;/a&gt;二、为什么区分原始类型和对象类型&lt;/h2&gt;&lt;h3 id=&quot;2-1-不可变性&quot;&gt;&lt;a href=&quot;#2-1-不可变性&quot; class=&quot;headerlink&quot; title=&quot;2.1 不可变性&quot;&gt;&lt;/a&gt;2.1 不可变性&lt;/h3&gt;&lt;p&gt;上面所提到的原始类型，在&lt;code&gt;ECMAScript&lt;/code&gt;标准中，它们被定义为&lt;code&gt;primitive values&lt;/code&gt;，即原始值，代表值本身是不可被改变的。&lt;/p&gt;
&lt;p&gt;以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&#39;ConardLi&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str.substr(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str.trim(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str.toLowerCase(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(str);  &lt;span class=&quot;comment&quot;&gt;// ConardLi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面的代码中我们对&lt;code&gt;str&lt;/code&gt;调用了几个方法，无一例外，这些方法都在原字符串的基础上产生了一个新字符串，而非直接去改变&lt;code&gt;str&lt;/code&gt;，这就印证了字符串的不可变性。&lt;/p&gt;
&lt;p&gt;那么，当我们继续调用下面的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;str += &lt;span class=&quot;string&quot;&gt;&#39;6&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(str);  &lt;span class=&quot;comment&quot;&gt;// ConardLi6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你会发现，&lt;code&gt;str&lt;/code&gt;的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;JavaScript&lt;/code&gt;中，每一个变量在内存中都需要一个空间来存储。&lt;/p&gt;
&lt;p&gt;内存空间又被分为两种，栈内存与堆内存。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>如何写出一个惊艳面试官的深拷贝</title>
    <link href="https://youdaily.github.io/posts/5e503604/"/>
    <id>https://youdaily.github.io/posts/5e503604/</id>
    <published>2019-09-01T06:59:01.000Z</published>
    <updated>2019-12-10T02:04:31.920Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>最近经常看到很多<code>JavaScript</code>手写代码的文章总结，里面提供了很多<code>JavaScript Api</code>的手写实现。</p><p>里面的题目实现大多类似，而且说实话很多代码在我看来是非常简陋的，如果我作为面试官，看到这样的代码，在我心里是不会合格的，本篇文章我拿最简单的深拷贝来讲一讲。</p><p>看本文之前先问自己三个问题：</p><ul><li><p>你真的理解什么是深拷贝吗？</p></li><li><p>在面试官眼里，什么样的深拷贝才算合格？</p></li><li><p>什么样的深拷贝能让面试官感到惊艳？</p></li></ul><p>本文由浅入深，带你一步一步实现一个惊艳面试官的深拷贝。</p><h2 id="深拷贝和浅拷贝的定义"><a href="#深拷贝和浅拷贝的定义" class="headerlink" title="深拷贝和浅拷贝的定义"></a>深拷贝和浅拷贝的定义</h2><p>深拷贝已经是一个老生常谈的话题了，也是现在前端面试的高频题目，但是令我吃惊的是有很多同学还没有搞懂深拷贝和浅拷贝的区别和定义。例如前几天给我提<code>issue</code>的同学：</p><p><img src="https://i.loli.net/2019/08/30/8U5e2I6lmzBHcW9.jpg" alt></p><p>很明显这位同学把拷贝和赋值搞混了，如果你还对赋值、对象在内存中的存储、变量和类型等等有什么疑问，可以看看我这篇文章：<br><a href="https://juejin.im/post/5cec1bcff265da1b8f1aa08f" target="_blank" rel="noopener">https://juejin.im/post/5cec1bcff265da1b8f1aa08f</a> 。</p><p>你只要少搞明白<code>拷贝</code>和<code>赋值</code>的区别。</p><p>我们来明确一下深拷贝和浅拷贝的定义：</p><p>浅拷贝：</p><p><img src="https://i.loli.net/2019/08/30/N3CB7obYhn5Lvxz.jpg" alt></p><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><a id="more"></a><p>深拷贝：</p><p><img src="https://i.loli.net/2019/08/30/OFIGRqZeWkBn9cr.jpg" alt></p><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><p>话不多说，浅拷贝就不再多说，下面我们直入正题：</p><h2 id="乞丐版"><a href="#乞丐版" class="headerlink" title="乞丐版"></a>乞丐版</h2><p>在不使用第三方库的情况下，我们想要深拷贝一个对象，用的最多的就是下面这个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify());</span><br></pre></td></tr></table></figure><p>这种写法非常简单，而且可以应对大部分的应用场景，但是它还是有很大缺陷的，比如拷贝其他引用类型、拷贝函数、循环引用等情况。</p><p>显然，面试时你只说出这样的方法是一定不会合格的。</p><p>接下来，我们一起来手动实现一个深拷贝方法。</p><h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><p>如果是浅拷贝的话，我们可以很容易写出下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        cloneTarget[key] = target[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性依次添加到新对象上，返回。</p><p>如果是深拷贝的话，考虑到我们要拷贝的对象是不知道有多少层深度的，我们可以用递归来解决问题，稍微改写上面的代码：</p><ul><li>如果是原始类型，无需继续拷贝，直接返回</li><li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行 <strong>深拷贝后</strong> 依次添加到新对象上。</li></ul><p>很容易理解，如果有更深层次的对象可以继续递归直到属性为原始类型，这样我们就完成了一个最简单的深拷贝：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看下面的测试用例进行测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: <span class="string">'ConardLi'</span>,</span><br><span class="line">    field4: &#123;</span><br><span class="line">        child: <span class="string">'child'</span>,</span><br><span class="line">        child2: &#123;</span><br><span class="line">            child2: <span class="string">'child2'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2019/08/31/Nxr21XJnVgqOTs5.png" alt></p><p>这是一个最基础版本的深拷贝，这段代码可以让你向面试官展示你可以用递归解决问题，但是显然，他还有非常多的缺陷，比如，还没有考虑数组。</p><h2 id="考虑数组"><a href="#考虑数组" class="headerlink" title="考虑数组"></a>考虑数组</h2><p>在上面的版本中，我们的初始化结果只考虑了普通的<code>object</code>，下面我们只需要把初始化代码稍微一变，就可以兼容数组了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行下面的测试用例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2019/08/31/2LokZ1hMcGbBYU7.jpg" alt></p><p>OK，没有问题，你的代码又向合格迈进了一小步。</p><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>我们执行下面这样一个测试用例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br><span class="line">target.target = target;</span><br></pre></td></tr></table></figure><p>可以看到下面的结果：</p><p><img src="https://i.loli.net/2019/08/31/JMiLz6qt2BYdvjm.png" alt></p><p>很明显，因为递归进入死循环导致栈内存溢出了。</p><p>原因就是上面的对象存在循环引用的情况，即对象的属性间接或直接的引用了自身的情况：</p><p><img src="https://i.loli.net/2019/09/01/uYyaqztP23xh5Vf.jpg" alt></p><p>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。</p><p>这个存储空间，需要可以存储<code>key-value</code>形式的数据，且<code>key</code>可以是一个引用类型，我们可以选择<code>Map</code>这种数据结构：</p><ul><li>检查<code>map</code>中有无克隆过的对象</li><li>有 - 直接返回</li><li>没有 - 将当前对象作为<code>key</code>，克隆对象作为<code>value</code>进行存储</li><li>继续克隆</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new Map(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(target, cloneTarget);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key], map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来执行上面的测试用例：</p><p><img src="https://i.loli.net/2019/08/31/z1OWfmFcAJ9SR8I.jpg" alt></p><p>可以看到，执行没有报错，且<code>target</code>属性，变为了一个<code>Circular</code>类型，即循环应用的意思。</p><p>接下来，我们可以使用，<code>WeakMap</code>提代<code>Map</code>来使代码达到画龙点睛的作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/09/01/AWrneLyJavhTfOG.jpg" alt></p><p>为什么要这样做呢？，先来看看<code>WeakMap</code>的作用：</p><blockquote><p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p></blockquote><p>什么是弱引用呢？</p><blockquote><p>在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。</p></blockquote><p>我们默认创建一个对象：<code>const obj = {}</code>，就默认创建了一个强引用的对象，我们只有手动将<code>obj = null</code>，它才会被垃圾回收机制进行回收，如果是弱引用对象，垃圾回收机制会自动帮我们回收。</p><p>举个例子：</p><p>如果我们使用<code>Map</code>的话，那么对象间是存在强引用关系的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span> : <span class="string">'ConardLi'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">target.set(obj,<span class="string">'code秘密花园'</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>虽然我们手动将<code>obj</code>，进行释放，然是<code>target</code>依然对<code>obj</code>存在强引用关系，所以这部分内存依然无法被释放。</p><p>再来看<code>WeakMap</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span> : <span class="string">'ConardLi'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">target.set(obj,<span class="string">'code秘密花园'</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>如果是<code>WeakMap</code>的话，<code>target</code>和<code>obj</code>存在的就是弱引用关系，当下一次垃圾回收机制执行时，这块内存就会被释放掉。</p><p>设想一下，如果我们要拷贝的对象非常庞大时，使用<code>Map</code>会对内存造成非常大的额外消耗，而且我们需要手动清除<code>Map</code>的属性才能释放这块内存，而<code>WeakMap</code>会帮我们巧妙化解这个问题。</p><p>我也经常在某些代码中看到有人使用<code>WeakMap</code>来解决循环引用问题，但是解释都是模棱两可的，当你不太了解<code>WeakMap</code>的真正作用时。我建议你也不要在面试中写这样的代码，结果只能是给自己挖坑，即使是准备面试，你写的每一行代码也都是需要经过深思熟虑并且非常明白的。</p><p>能考虑到循环引用的问题，你已经向面试官展示了你考虑问题的全面性，如果还能用<code>WeakMap</code>解决问题，并很明确的向面试官解释这样做的目的，那么你的代码在面试官眼里应该算是合格了。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>在上面的代码中，我们遍历数组和对象都使用了<code>for in</code>这种方式，实际上<code>for in</code>在遍历时效率是非常低的，我们来对比下常见的三种循环<code>for、while、for in</code>的执行效率：</p><p><img src="https://i.loli.net/2019/08/29/1ydBJ63LntlvZWO.jpg" alt></p><p>可以看到，<code>while</code>的效率是最好的，所以，我们可以想办法把<code>for in</code>遍历改变为<code>while</code>遍历。</p><p>我们先使用<code>while</code>来实现一个通用的<code>forEach</code>遍历，<code>iteratee</code>是遍历的回掉函数，他可以接收每次遍历的<code>value</code>和<code>index</code>两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">        iteratee(array[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对我们的<code>cloen</code>函数进行改写：当遍历数组时，直接使用<code>forEach</code>进行遍历，当遍历对象时，使用<code>Object.keys</code>取出所有的<code>key</code>进行遍历，然后在遍历时把<code>forEach</code>会调函数的<code>value</code>当作<code>key</code>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray(target);</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = isArray ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> keys = isArray ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line">        forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">                key = value;</span><br><span class="line">            &#125;</span><br><span class="line">            cloneTarget[key] = clone2(target[key], map);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们执行测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    f: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123;&#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">target.target = target;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> result = clone1(target);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> result2 = clone2(target);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2019/08/31/ZhMxNjFE9KYqH7l.jpg" alt></p><p>很明显，我们的性能优化是有效的。</p><p>到这里，你已经向面试官展示了，在写代码的时候你会考虑程序的运行效率，并且你具有通用函数的抽象能力。</p><h2 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h2><p>在上面的代码中，我们其实只考虑了普通的<code>object</code>和<code>array</code>两种数据类型，实际上所有的引用类型远远不止这两个，还有很多，下面我们先尝试获取对象准确的类型。</p><h3 id="合理的判断引用类型"><a href="#合理的判断引用类型" class="headerlink" title="合理的判断引用类型"></a>合理的判断引用类型</h3><p>首先，判断是否为引用类型，我们还需要考虑<code>function</code>和<code>null</code>两种特殊的数据类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> target;</span><br><span class="line">    <span class="keyword">return</span> target !== <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="获取数据类型"><a href="#获取数据类型" class="headerlink" title="获取数据类型"></a>获取数据类型</h3><p>我们可以使用<code>toString</code>来获取准确的引用类型：</p><blockquote><p>每一个引用类型都有<code>toString</code>方法，默认情况下，<code>toString()</code>方法被每个<code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，t<code>oString()</code> 返回 <code>&quot;[object type]&quot;</code>，其中type是对象的类型。</p></blockquote><p>注意，上面提到了如果此方法在自定义对象中未被覆盖，<code>toString</code>才会达到预想的效果，事实上，大部分引用类型比如<code>Array、Date、RegExp</code>等都重写了<code>toString</code>方法。</p><p>我们可以直接调用<code>Object</code>原型上未被覆盖的<code>toString()</code>方法，使用<code>call</code>来改变<code>this</code>指向来达到我们想要的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/09/01/wvJgxWe17RdaEHY.jpg" alt></p><p>下面我们抽离出一些常用的数据类型以便后面使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapTag = <span class="string">'[object Map]'</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">'[object Set]'</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">'[object Array]'</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">'[object Object]'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">'[object Boolean]'</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">'[object Date]'</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">'[object Error]'</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">'[object Number]'</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">'[object RegExp]'</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">'[object String]'</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">'[object Symbol]'</span>;</span><br></pre></td></tr></table></figure><p>在上面的集中类型中，我们简单将他们分为两类：</p><ul><li>可以继续遍历的类型</li><li>不可以继续遍历的类型</li></ul><p>我们分别为它们做不同的拷贝。</p><h3 id="可继续遍历的类型"><a href="#可继续遍历的类型" class="headerlink" title="可继续遍历的类型"></a>可继续遍历的类型</h3><p>上面我们已经考虑的<code>object</code>、<code>array</code>都属于可以继续遍历的类型，因为它们内存都还可以存储其他数据类型的数据，另外还有<code>Map</code>，<code>Set</code>等都是可以继续遍历的类型，这里我们只考虑这四种，如果你有兴趣可以继续探索其他类型。</p><p>有序这几种类型还需要继续进行递归，我们首先需要获取它们的初始化数据，例如上面的<code>[]</code>和<code>{}</code>，我们可以通过拿到<code>constructor</code>的方式来通用的获取。</p><p>例如：<code>const target = {}</code>就是<code>const target = new Object()</code>的语法糖。另外这种方法还有一个好处：因为我们还使用了原对象的构造方法，所以它可以保留对象原型上的数据，如果直接使用普通的<code>{}</code>，那么原型必然是丢失了的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInit</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ctor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们改写<code>clone</code>函数，对可继续遍历的数据类型进行处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆原始类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">const</span> type = getType(target);</span><br><span class="line">    <span class="keyword">let</span> cloneTarget;</span><br><span class="line">    <span class="keyword">if</span> (deepTag.includes(type)) &#123;</span><br><span class="line">        cloneTarget = getInit(target, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(target);</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆set</span></span><br><span class="line">    <span class="keyword">if</span> (type === setTag) &#123;</span><br><span class="line">        target.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.add(clone(value,map));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆map</span></span><br><span class="line">    <span class="keyword">if</span> (type === mapTag) &#123;</span><br><span class="line">        target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.set(key, clone(value,map));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆对象和数组</span></span><br><span class="line">    <span class="keyword">const</span> keys = type === arrayTag ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line">    forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">            key = value;</span><br><span class="line">        &#125;</span><br><span class="line">        cloneTarget[key] = clone(target[key], map);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    empty: <span class="literal">null</span>,</span><br><span class="line">    map,</span><br><span class="line">    <span class="keyword">set</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2019/09/01/dQ7hGjYirkRlN3s.jpg" alt></p><p>没有问题，里大功告成又进一步，下面我们继续处理其他类型：</p><h3 id="不可继续遍历的类型"><a href="#不可继续遍历的类型" class="headerlink" title="不可继续遍历的类型"></a>不可继续遍历的类型</h3><p>其他剩余的类型我们把它们统一归类成不可处理的数据类型，我们依次进行处理：</p><p><code>Bool</code>、<code>Number</code>、<code>String</code>、<code>String</code>、<code>Date</code>、<code>Error</code>这几种类型我们都可以直接用构造函数和原始数据创建一个新对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneOtherType</span>(<span class="params">targe, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = targe.constructor;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> boolTag:</span><br><span class="line">        <span class="keyword">case</span> numberTag:</span><br><span class="line">        <span class="keyword">case</span> stringTag:</span><br><span class="line">        <span class="keyword">case</span> errorTag:</span><br><span class="line">        <span class="keyword">case</span> dateTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ctor(targe);</span><br><span class="line">        <span class="keyword">case</span> regexpTag:</span><br><span class="line">            <span class="keyword">return</span> cloneReg(targe);</span><br><span class="line">        <span class="keyword">case</span> symbolTag:</span><br><span class="line">            <span class="keyword">return</span> cloneSymbol(targe);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>克隆<code>Symbol</code>类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">targe</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(targe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">克隆正则：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneReg</span>(<span class="params">targe</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class="line">    result.lastIndex = targe.lastIndex;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上还有很多数据类型我这里没有写到，有兴趣的话可以继续探索实现一下。</p><p>能写到这里，面试官已经看到了你考虑问题的严谨性，你对变量和类型的理解，对<code>JS API</code>的熟练程度，相信面试官已经开始对你刮目相看了。</p><h3 id="克隆函数"><a href="#克隆函数" class="headerlink" title="克隆函数"></a>克隆函数</h3><p>最后，我把克隆函数单独拎出来了，实际上克隆函数是没有实际应用场景的，两个对象使用一个在内存中处于同一个地址的函数也是没有任何问题的，我特意看了下<code>lodash</code>对函数的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value == <span class="string">'function'</span></span><br><span class="line"><span class="keyword">if</span> (isFunc || !cloneableTags[tag]) &#123;</span><br><span class="line">       <span class="keyword">return</span> object ? value : &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见这里如果发现是函数的话就会直接返回了，没有做特殊的处理，但是我发现不少面试官还是热衷于问这个问题的，而且据我了解能写出来的少之又少。。。</p><p>实际上这个方法并没有什么难度，主要就是考察你对基础的掌握扎实不扎实。</p><p>首先，我们可以通过<code>prototype</code>来区分下箭头函数和普通函数，箭头函数是没有<code>prototype</code>的。</p><p>我们可以直接使用<code>eval</code>和函数字符串来重新生成一个箭头函数，注意这种方法是不适用于普通函数的。</p><p>我们可以使用正则来处理普通函数：</p><p>分别使用正则取出函数体和函数参数，然后使用<code>new Function ([arg1[, arg2[, ...argN]],] functionBody)</code>构造函数重新构造一个新的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneFunction</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">    <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">    <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">    <span class="keyword">if</span> (func.prototype) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'普通函数'</span>);</span><br><span class="line">        <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">        <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">        <span class="keyword">if</span> (body) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'匹配到函数体：'</span>, body[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (param) &#123;</span><br><span class="line">                <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">','</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'匹配到参数：'</span>, paramArr);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(funcString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们再来执行测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line">map.set(<span class="string">'ConardLi'</span>, <span class="string">'code秘密花园'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add('ConardLi');</span><br><span class="line"><span class="keyword">set</span>.add('code秘密花园');</span><br><span class="line"></span><br><span class="line">const target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    empty: <span class="literal">null</span>,</span><br><span class="line">    map,</span><br><span class="line">    <span class="keyword">set</span>,</span><br><span class="line">    bool: new Boolean(true),</span><br><span class="line">    num: new Number(2),</span><br><span class="line">    str: new String(2),</span><br><span class="line">    symbol: Object(Symbol(1)),</span><br><span class="line">    date: new Date(),</span><br><span class="line">    reg: /\d+/,</span><br><span class="line">    error: new Error(),</span><br><span class="line">    func1: () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'code秘密花园'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2019/09/01/3tsUZR561FYOuQc.jpg" alt></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>为了更好的阅读，我们用一张图来展示上面所有的代码：</p><p><img src="https://i.loli.net/2019/08/30/9lfDPCXBagE8rQY.jpg" alt></p><p>可见，一个小小的深拷贝还是隐藏了很多的知识点的。</p><p>千万不要以最低的要求来要求自己，如果你只是为了应付面试中的一个题目，那么你可能只会去准备上面最简陋的深拷贝的方法。</p><p>但是面试官考察你的目的是全方位的考察你的思维能力，如果你写出上面的代码，可以体现你多方位的能力：</p><ul><li>基本实现<ul><li>递归能力</li></ul></li><li>循环引用<ul><li>考虑问题的全面性</li><li>理解weakmap的真正意义</li></ul></li><li>多种类型<ul><li>考虑问题的严谨性</li><li>创建各种引用类型的方法，JS API的熟练程度</li><li>准确的判断数据类型，对数据类型的理解程度</li></ul></li><li>通用遍历：<ul><li>写代码可以考虑性能优化</li><li>了解集中遍历的效率</li><li>代码抽象能力</li></ul></li><li>拷贝函数：<ul><li>箭头函数和普通函数的区别</li><li>正则表达式熟练程度</li></ul></li></ul><p>看吧，一个小小的深拷贝能考察你这么多的能力，如果面试官看到这样的代码，怎么能够不惊艳呢？</p><p>其实面试官出的所有题目你都可以用这样的思路去考虑。不要为了应付面试而去背一些代码，这样在有经验的面试官面前会都会暴露出来。你写的每一段代码都要经过深思熟虑，为什么要这样用，还能怎么优化…这样才能给面试官展现一个最好的你。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank" rel="noopener">WeakMap</a></li><li><a href="https://lodash.com/" target="_blank" rel="noopener">lodash</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望看完本篇文章能对你有如下帮助：</p><ul><li>理解深浅拷贝的真正意义</li><li>能整我深拷贝的各个要点，对问题进行深入分析</li><li>可以手写一个比较完整的深拷贝</li></ul><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;最近经常看到很多&lt;code&gt;JavaScript&lt;/code&gt;手写代码的文章总结，里面提供了很多&lt;code&gt;JavaScript Api&lt;/code&gt;的手写实现。&lt;/p&gt;
&lt;p&gt;里面的题目实现大多类似，而且说实话很多代码在我看来是非常简陋的，如果我作为面试官，看到这样的代码，在我心里是不会合格的，本篇文章我拿最简单的深拷贝来讲一讲。&lt;/p&gt;
&lt;p&gt;看本文之前先问自己三个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;你真的理解什么是深拷贝吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在面试官眼里，什么样的深拷贝才算合格？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么样的深拷贝能让面试官感到惊艳？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文由浅入深，带你一步一步实现一个惊艳面试官的深拷贝。&lt;/p&gt;
&lt;h2 id=&quot;深拷贝和浅拷贝的定义&quot;&gt;&lt;a href=&quot;#深拷贝和浅拷贝的定义&quot; class=&quot;headerlink&quot; title=&quot;深拷贝和浅拷贝的定义&quot;&gt;&lt;/a&gt;深拷贝和浅拷贝的定义&lt;/h2&gt;&lt;p&gt;深拷贝已经是一个老生常谈的话题了，也是现在前端面试的高频题目，但是令我吃惊的是有很多同学还没有搞懂深拷贝和浅拷贝的区别和定义。例如前几天给我提&lt;code&gt;issue&lt;/code&gt;的同学：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/30/8U5e2I6lmzBHcW9.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;很明显这位同学把拷贝和赋值搞混了，如果你还对赋值、对象在内存中的存储、变量和类型等等有什么疑问，可以看看我这篇文章：&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/5cec1bcff265da1b8f1aa08f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5cec1bcff265da1b8f1aa08f&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;你只要少搞明白&lt;code&gt;拷贝&lt;/code&gt;和&lt;code&gt;赋值&lt;/code&gt;的区别。&lt;/p&gt;
&lt;p&gt;我们来明确一下深拷贝和浅拷贝的定义：&lt;/p&gt;
&lt;p&gt;浅拷贝：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/30/N3CB7obYhn5Lvxz.jpg&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/tags/JavaScript/"/>
    
      <category term="面试" scheme="https://youdaily.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配总结（二）应用篇</title>
    <link href="https://youdaily.github.io/posts/3fe27fe1/"/>
    <id>https://youdaily.github.io/posts/3fe27fe1/</id>
    <published>2019-05-27T07:28:41.000Z</published>
    <updated>2019-12-10T02:04:42.504Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="五、1px问题"><a href="#五、1px问题" class="headerlink" title="五、1px问题"></a>五、1px问题</h2><p>为了适配各种屏幕，我们写代码时一般使用设备独立像素来对页面进行布局。</p><p>而在设备像素比大于<code>1</code>的屏幕上，我们写的<code>1px</code>实际上是被多个物理像素渲染，这就会出现<code>1px</code>在有些屏幕上看起来很粗的现象。</p><h3 id="5-1-border-image"><a href="#5-1-border-image" class="headerlink" title="5.1 border-image"></a>5.1 border-image</h3><p>基于<code>media</code>查询判断不同的设备像素比给定不同的<code>border-image</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">         <span class="attribute">border-bottom</span>: none;</span><br><span class="line">         <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span>;</span><br><span class="line">         <span class="attribute">border-image</span>: <span class="built_in">url</span>(../img/1pxline.png) <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> stretch;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-background-image"><a href="#5-2-background-image" class="headerlink" title="5.2 background-image"></a>5.2 background-image</h3><p>和<code>border-image</code>类似，准备一张符合条件的边框背景图，模拟在背景上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">         <span class="attribute">background</span>: <span class="built_in">url</span>(../img/1pxline.png) repeat-x left bottom;</span><br><span class="line">         <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">1px</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面两种都需要单独准备图片，而且圆角不是很好处理，但是可以应对大部分场景。</p><a id="more"></a><h3 id="5-3-伪类-transform"><a href="#5-3-伪类-transform" class="headerlink" title="5.3 伪类 + transform"></a>5.3 伪类 + transform</h3><p>基于<code>media</code>查询判断不同的设备像素比对线条进行缩放：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">   <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">   <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0%</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">         <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(0.5);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">3</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">         <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(0.33);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种方式可以满足各种场景，如果需要满足圆角，只需要给伪类也加上<code>border-radius</code>即可。</p><h3 id="5-4-svg"><a href="#5-4-svg" class="headerlink" title="5.4 svg"></a>5.4 svg</h3><p>上面我们<code>border-image</code>和<code>background-image</code>都可以模拟<code>1px</code>边框，但是使用的都是位图，还需要外部引入。</p><p>借助<code>PostCSS</code>的<code>postcss-write-svg</code>我们能直接使用<code>border-image</code>和<code>background-image</code>创建<code>svg</code>的<code>1px</code>边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">svg</span> border_1px &#123; </span><br><span class="line">  <span class="selector-tag">height</span>: 2<span class="selector-tag">px</span>; </span><br><span class="line">  @<span class="keyword">rect</span> &#123; </span><br><span class="line">    <span class="selector-tag">fill</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--color</span>, <span class="selector-tag">black</span>); </span><br><span class="line">    <span class="selector-tag">width</span>: 100%; </span><br><span class="line">    <span class="selector-tag">height</span>: 50%; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"><span class="selector-class">.example</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid transparent; <span class="attribute">border-image</span>: <span class="built_in">svg</span>(border_1px param(--color #00b1ff)) <span class="number">2</span> <span class="number">2</span> stretch; &#125;</span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid transparent; <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' height='2px'%3E%3Crect fill='%2300b1ff' width='100%25' height='50%25'/%3E%3C/svg%3E"</span>) <span class="number">2</span> <span class="number">2</span> stretch; &#125;</span><br></pre></td></tr></table></figure><p>上面的方案是大漠在他的文章中推荐使用的，基本可以满足所有场景，而且不需要外部引入，这是我个人比较喜欢的一种方案。</p><h3 id="5-5-设置viewport"><a href="#5-5-设置viewport" class="headerlink" title="5.5 设置viewport"></a>5.5 设置viewport</h3><p>通过设置缩放，让<code>CSS</code>像素等于真正的物理像素。</p><p>例如：当设备像素比为<code>3</code>时，我们将页面缩放<code>1/3</code>倍，这时<code>1px</code>等于一个真正的屏幕像素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="keyword">const</span> viewport = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>);</span><br><span class="line"><span class="keyword">if</span> (!viewport) &#123;</span><br><span class="line">    viewport = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>);</span><br><span class="line">    viewport.setAttribute(<span class="string">'name'</span>, <span class="string">'viewport'</span>);</span><br><span class="line">    <span class="built_in">window</span>.document.head.appendChild(viewport);</span><br><span class="line">&#125;</span><br><span class="line">viewport.setAttribute(<span class="string">'content'</span>, <span class="string">'width=device-width,user-scalable=no,initial-scale='</span> + scale + <span class="string">',maximum-scale='</span> + scale + <span class="string">',minimum-scale='</span> + scale);</span><br></pre></td></tr></table></figure><p>实际上，上面这种方案是早先<code>flexible</code>采用的方案。</p><p>当然，这样做是要付出代价的，这意味着你页面上所有的布局都要按照物理像素来写。这显然是不现实的，这时，我们可以借助<code>flexible</code>或<code>vw、vh</code>来帮助我们进行适配。</p><h2 id="六、移动端适配方案"><a href="#六、移动端适配方案" class="headerlink" title="六、移动端适配方案"></a>六、移动端适配方案</h2><p>尽管我们可以使用设备独立像素来保证各个设备在不同手机上显示的效果类似，但这并不能保证它们显示完全一致，我们需要一种方案来让设计稿得到更完美的适配。</p><h3 id="6-1-flexible方案"><a href="#6-1-flexible方案" class="headerlink" title="6.1 flexible方案"></a>6.1 flexible方案</h3><p><code>flexible</code>方案是阿里早期开源的一个移动端适配解决方案，引用<code>flexible</code>后，我们在页面上统一使用<code>rem</code>来布局。</p><p>它的核心代码非常简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set 1rem = viewWidth / 10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRemUnit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rem = docEl.clientWidth / <span class="number">10</span></span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">'px'</span></span><br><span class="line">&#125;</span><br><span class="line">setRemUnit();</span><br></pre></td></tr></table></figure><p><code>rem</code> 是相对于<code>html</code>节点的<code>font-size</code>来做计算的。</p><p>我们通过设置<code>document.documentElement.style.fontSize</code>就可以统一整个页面的布局标准。</p><p>上面的代码中，将<code>html</code>节点的<code>font-size</code>设置为页面<code>clientWidth</code>(布局视口)的<code>1/10</code>，即<code>1rem</code>就等于页面布局视口的<code>1/10</code>，这就意味着我们后面使用的<code>rem</code>都是按照页面比例来计算的。</p><p>这时，我们只需要将<code>UI</code>出的图转换为<code>rem</code>即可。</p><p>以<code>iPhone6</code>为例：布局视口为<code>375px</code>，则<code>1rem = 37.5px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 37.5 = 2rem</code>。</p><p>当然，每个布局都要计算非常繁琐，我们可以借助<code>PostCSS</code>的<code>px2rem</code>插件来帮助我们完成这个过程。</p><p>下面的代码可以保证在页面大小变化时，布局可以自适应，当触发了<code>window</code>的<code>resize</code>和<code>pageShow</code>事件之后自动调整<code>html</code>的<code>fontSize</code>大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// reset rem unit on page resize</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, setRemUnit)<span class="built_in">window</span>.addEventListener(<span class="string">'pageshow'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">      setRemUnit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于<code>viewport</code>单位得到众多浏览器的兼容，上面这种方案现在已经被官方弃用：</p><blockquote><p>lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。</p></blockquote><p>下面我们来看看现在最流行的<code>vh、vw</code>方案。</p><h3 id="6-2-vh、vw方案"><a href="#6-2-vh、vw方案" class="headerlink" title="6.2 vh、vw方案"></a>6.2 vh、vw方案</h3><p><code>vh、vw</code>方案即将视觉视口宽度 <code>window.innerWidth</code>和视觉视口高度 <code>window.innerHeight</code> 等分为 100 份。</p><p>上面的<code>flexible</code>方案就是模仿这种方案，因为早些时候<code>vw</code>还没有得到很好的兼容。</p><ul><li><code>vw(Viewport&#39;s width)</code>：<code>1vw</code>等于视觉视口的<code>1%</code></li><li><code>vh(Viewport&#39;s height)</code> :<code>1vh</code> 为视觉视口高度的<code>1%</code></li><li><code>vmin</code> :  <code>vw</code> 和 <code>vh</code> 中的较小值</li><li><code>vmax</code> : 选取 <code>vw</code> 和 <code>vh</code> 中的较大值</li></ul><p><img src="https://i.loli.net/2019/05/17/5cddf1f0e18bb53584.png" alt></p><p>如果视觉视口为<code>375px</code>，那么<code>1vw = 3.75px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 3.75 = 20vw</code>。</p><p>这里的比例关系我们也不用自己换算，我们可以使用<code>PostCSS</code>的 <code>postcss-px-to-viewport</code> 插件帮我们完成这个过程。写代码时，我们只需要根据<code>UI</code>给的设计图写<code>px</code>单位即可。</p><p>当然，没有一种方案是十全十美的，<code>vw</code>同样有一定的缺陷：</p><ul><li><code>px</code>转换成<code>vw</code>不一定能完全整除，因此有一定的像素差。</li><li>比如当容器使用<code>vw</code>，<code>margin</code>采用<code>px</code>时，很容易造成整体宽度超过<code>100vw</code>，从而影响布局效果。当然我们也是可以避免的，例如使用<code>padding</code>代替<code>margin</code>，结合<code>calc()</code>函数使用等等…</li></ul><h2 id="七、适配iPhoneX"><a href="#七、适配iPhoneX" class="headerlink" title="七、适配iPhoneX"></a>七、适配iPhoneX</h2><p><code>iPhoneX</code>的出现将手机的颜值带上了一个新的高度，它取消了物理按键，改成了底部的小黑条，但是这样的改动给开发者适配移动端又增加了难度。</p><h3 id="7-1-安全区域"><a href="#7-1-安全区域" class="headerlink" title="7.1 安全区域"></a>7.1 安全区域</h3><p>在<code>iPhoneX</code>发布后，许多厂商相继推出了具有边缘屏幕的手机。</p><p><img src="https://i.loli.net/2019/05/17/5cddf1e78a7c870328.png" alt></p><p>这些手机和普通手机在外观上无外乎做了三个改动：圆角（<code>corners</code>）、刘海（<code>sensor housing</code>）和小黑条（<code>Home Indicator</code>）。为了适配这些手机，安全区域这个概念变诞生了：安全区域就是一个不受上面三个效果的可视窗口范围。</p><p>为了保证页面的显示效果，我们必须把页面限制在安全范围内，但是不影响整体效果。</p><h3 id="7-2-viewport-fit"><a href="#7-2-viewport-fit" class="headerlink" title="7.2 viewport-fit"></a>7.2 viewport-fit</h3><p><code>viewport-fit</code>是专门为了适配<code>iPhoneX</code>而诞生的一个属性，它用于限制网页如何在安全区域内进行展示。</p><p><img src="https://i.loli.net/2019/05/17/5cddf1a74a74578018.png" alt></p><p><code>contain</code>: 可视窗口完全包含网页内容</p><p><code>cover</code>：网页内容完全覆盖可视窗口</p><p>默认情况下或者设置为<code>auto</code>和<code>contain</code>效果相同。</p><h3 id="7-3-env、constant"><a href="#7-3-env、constant" class="headerlink" title="7.3 env、constant"></a>7.3 env、constant</h3><p><img src="https://i.loli.net/2019/05/17/5cddf1b63010c69640.png" alt></p><p>我们需要将顶部和底部合理的摆放在安全区域内，<code>iOS11</code>新增了两个<code>CSS</code>函数<code>env、constant</code>，用于设定安全区域与边界的距离。</p><p>函数内部可以是四个常量：</p><ul><li><code>safe-area-inset-left</code>：安全区域距离左边边界距离</li><li><code>safe-area-inset-right</code>：安全区域距离右边边界距离</li><li><code>safe-area-inset-top</code>：安全区域距离顶部边界距离</li><li><code>safe-area-inset-bottom</code>：安全区域距离底部边界距离</li></ul><p>注意：我们必须指定<code>viweport-fit</code>后才能使用这两个函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"viewport-fit=cover"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>constant</code>在<code>iOS &lt; 11.2</code>的版本中生效，<code>env</code>在<code>iOS &gt;= 11.2</code>的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用底部固定导航栏时，我们要为他们设置<code>padding</code>值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、横屏适配"><a href="#八、横屏适配" class="headerlink" title="八、横屏适配"></a>八、横屏适配</h2><p><img src="https://i.loli.net/2019/05/17/5cddf20178d8c32612.png" alt></p><p>很多视口我们要对横屏和竖屏显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式：</p><h3 id="8-1-JavaScript检测横屏"><a href="#8-1-JavaScript检测横屏" class="headerlink" title="8.1 JavaScript检测横屏"></a>8.1 JavaScript检测横屏</h3><p><code>window.orientation</code>:获取屏幕旋转方向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.orientation === <span class="number">180</span> || <span class="built_in">window</span>.orientation === <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// 正常方向或屏幕旋转180度</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'竖屏'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.orientation === <span class="number">90</span> || <span class="built_in">window</span>.orientation === <span class="number">-90</span> )&#123; </span><br><span class="line">       <span class="comment">// 屏幕顺时钟旋转90度或屏幕逆时针旋转90度</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'横屏'</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8-2-CSS检测横屏"><a href="#8-2-CSS检测横屏" class="headerlink" title="8.2 CSS检测横屏"></a>8.2 CSS检测横屏</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (orientation: portrait) &#123;</span><br><span class="line">  <span class="comment">/*竖屏...*/</span></span><br><span class="line">&#125; </span><br><span class="line">@media screen and (orientation: landscape) &#123;</span><br><span class="line">  <span class="comment">/*横屏...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、图片模糊问题"><a href="#九、图片模糊问题" class="headerlink" title="九、图片模糊问题"></a>九、图片模糊问题</h2><h3 id="9-1-产生原因"><a href="#9-1-产生原因" class="headerlink" title="9.1 产生原因"></a>9.1 产生原因</h3><p>我们平时使用的图片大多数都属于位图（<code>png、jpg...</code>），位图由一个个像素点构成的，每个像素都具有特定的位置和颜色值：</p><p><img src="https://i.loli.net/2019/05/17/5cddf1ea88e2190952.png" alt></p><p>理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果。</p><p>而在<code>dpr &gt; 1</code>的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确的分配上对应位图像素的颜色，只能取近似值，所以相同的图片在<code>dpr &gt; 1</code>的屏幕上就会模糊:</p><p><img src="https://i.loli.net/2019/05/17/5cddf1ebd33ce27972.jpg" alt></p><h3 id="9-2-解决方案"><a href="#9-2-解决方案" class="headerlink" title="9.2 解决方案"></a>9.2 解决方案</h3><p>为了保证图片质量，我们应该尽可能让一个屏幕像素来渲染一个图片像素，所以，针对不同<code>DPR</code>的屏幕，我们需要展示不同分辨率的图片。</p><p>如：在<code>dpr=2</code>的屏幕上展示两倍图<code>(@2x)</code>，在<code>dpr=3</code>的屏幕上展示三倍图<code>(@3x)</code>。</p><p><img src="https://i.loli.net/2019/05/17/5cddf1ee82d2b57483.png" alt></p><h3 id="9-3-media查询"><a href="#9-3-media查询" class="headerlink" title="9.3 media查询"></a>9.3 media查询</h3><p>使用<code>media</code>查询判断不同的设备像素比来显示不同精度的图片：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span>&#123;</span><br><span class="line">     <span class="attribute">background-image</span>: <span class="built_in">url</span>(conardLi_1x.png);</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.avatar</span>&#123;</span><br><span class="line">         <span class="attribute">background-image</span>: <span class="built_in">url</span>(conardLi_2x.png);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">3</span>)&#123;</span><br><span class="line">     <span class="selector-class">.avatar</span>&#123;</span><br><span class="line">         <span class="attribute">background-image</span>: <span class="built_in">url</span>(conardLi_3x.png);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>只适用于背景图</p></blockquote><h3 id="9-4-image-set"><a href="#9-4-image-set" class="headerlink" title="9.4 image-set"></a>9.4 image-set</h3><p>使用<code>image-set</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">-webkit-image-set</span>( <span class="string">"conardLi_1x.png"</span> 1x, <span class="string">"conardLi_2x.png"</span> 2x );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只适用于背景图</p></blockquote><h3 id="9-5-srcset"><a href="#9-5-srcset" class="headerlink" title="9.5 srcset"></a>9.5 srcset</h3><p>使用<code>img</code>标签的<code>srcset</code>属性，浏览器会自动根据像素密度匹配最佳显示图片：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"conardLi_1x.png"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">srcset</span>=<span class="string">" conardLi_2x.png 2x, conardLi_3x.png 3x"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-6-JavaScript拼接图片url"><a href="#9-6-JavaScript拼接图片url" class="headerlink" title="9.6 JavaScript拼接图片url"></a>9.6 JavaScript拼接图片url</h3><p>使用<code>window.devicePixelRatio</code>获取设备像素比，遍历所有图片，替换图片地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="keyword">const</span> images =  <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>);</span><br><span class="line">images.forEach(<span class="function">(<span class="params">img</span>)=&gt;</span>&#123;</span><br><span class="line">  img.src.replace(<span class="string">"."</span>, <span class="string">`@<span class="subst">$&#123;dpr&#125;</span>x.`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="9-7-使用svg"><a href="#9-7-使用svg" class="headerlink" title="9.7 使用svg"></a>9.7 使用svg</h3><p><code>SVG</code>的全称是可缩放矢量图（<code>Scalable Vector Graphics</code>）。不同于位图的基于像素，<code>SVG</code> 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。</p><p><img src="https://i.loli.net/2019/05/17/5cddf1f59b24a71558.png" alt></p><p>除了我们手动在代码中绘制<code>svg</code>，我们还可以像使用位图一样使用<code>svg</code>图片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"conardLi.svg"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">"data:image/svg+xml;base64,[data]"</span>&gt;</span><br><span class="line"></span><br><span class="line">.avatar &#123;</span><br><span class="line">  background: url(conardLi.svg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.w3cplus.com/css/vw-for-layout.html" target="_blank" rel="noopener">https://www.w3cplus.com/css/vw-for-layout.html</a></li><li><a href="https://aotu.io/notes/2017/11/27/iphonex/index.html" target="_blank" rel="noopener">https://aotu.io/notes/2017/11/27/iphonex/index.html</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p><ul><li>理清移动端适配常用概念</li><li>理解移动端适配问题产生的原理，至少掌握一种解决方案</li></ul><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;五、1px问题&quot;&gt;&lt;a href=&quot;#五、1px问题&quot; class=&quot;headerlink&quot; title=&quot;五、1px问题&quot;&gt;&lt;/a&gt;五、1px问题&lt;/h2&gt;&lt;p&gt;为了适配各种屏幕，我们写代码时一般使用设备独立像素来对页面进行布局。&lt;/p&gt;
&lt;p&gt;而在设备像素比大于&lt;code&gt;1&lt;/code&gt;的屏幕上，我们写的&lt;code&gt;1px&lt;/code&gt;实际上是被多个物理像素渲染，这就会出现&lt;code&gt;1px&lt;/code&gt;在有些屏幕上看起来很粗的现象。&lt;/p&gt;
&lt;h3 id=&quot;5-1-border-image&quot;&gt;&lt;a href=&quot;#5-1-border-image&quot; class=&quot;headerlink&quot; title=&quot;5.1 border-image&quot;&gt;&lt;/a&gt;5.1 border-image&lt;/h3&gt;&lt;p&gt;基于&lt;code&gt;media&lt;/code&gt;查询判断不同的设备像素比给定不同的&lt;code&gt;border-image&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.border_1px&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attribute&quot;&gt;border-bottom&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1px&lt;/span&gt; solid &lt;span class=&quot;number&quot;&gt;#000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; @&lt;span class=&quot;keyword&quot;&gt;media&lt;/span&gt; only screen and (-webkit-min-device-pixel-ratio:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;selector-class&quot;&gt;.border_1px&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attribute&quot;&gt;border-bottom&lt;/span&gt;: none;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attribute&quot;&gt;border-width&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attribute&quot;&gt;border-image&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;url&lt;/span&gt;(../img/1pxline.png) &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; stretch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;5-2-background-image&quot;&gt;&lt;a href=&quot;#5-2-background-image&quot; class=&quot;headerlink&quot; title=&quot;5.2 background-image&quot;&gt;&lt;/a&gt;5.2 background-image&lt;/h3&gt;&lt;p&gt;和&lt;code&gt;border-image&lt;/code&gt;类似，准备一张符合条件的边框背景图，模拟在背景上。&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.border_1px&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attribute&quot;&gt;border-bottom&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1px&lt;/span&gt; solid &lt;span class=&quot;number&quot;&gt;#000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; @&lt;span class=&quot;keyword&quot;&gt;media&lt;/span&gt; only screen and (-webkit-min-device-pixel-ratio:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;selector-class&quot;&gt;.border_1px&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;url&lt;/span&gt;(../img/1pxline.png) repeat-x left bottom;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attribute&quot;&gt;background-size&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;100%&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面两种都需要单独准备图片，而且圆角不是很好处理，但是可以应对大部分场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配总结（一）原理篇</title>
    <link href="https://youdaily.github.io/posts/f2db7507/"/>
    <id>https://youdaily.github.io/posts/f2db7507/</id>
    <published>2019-05-22T07:26:14.000Z</published>
    <updated>2019-12-10T02:04:51.408Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>移动端适配，是我们在开发中经常会遇到的，这里面可能会遇到非常多的问题：</p><ul><li><code>1px</code>问题</li><li><code>UI</code>图完美适配方案</li><li><code>iPhoneX</code>适配方案</li><li>横屏适配</li><li>高清屏图片模糊问题</li><li>…</li></ul><p>上面这些问题可能我们在开发中已经知道如何解决，但是问题产生的原理，以及解决方案的原理可能会模糊不清。在解决这些问题的过程中，我们往往会遇到非常多的概念：像素、分辨率、<code>PPI</code>、<code>DPI</code>、<code>DP</code>、<code>DIP</code>、<code>DPR</code>、视口等等，你真的能分清这些概念的意义吗？</p><p>本文将从移动端适配的基础概念出发，探究移动端适配各种问题的解决方案和实现原理。</p><h2 id="一、英寸"><a href="#一、英寸" class="headerlink" title="一、英寸"></a>一、英寸</h2><p>一般用英寸描述屏幕的物理大小，如电脑显示器的<code>17</code>、<code>22</code>，手机显示器的<code>4.8</code>、<code>5.7</code>等使用的单位都是英寸。</p><p>需要注意，上面的尺寸都是屏幕对角线的长度：</p><p><img src="https://i.loli.net/2019/05/17/5cddefa632f3247082.png" alt></p><p>英寸(<code>inch</code>,缩写为<code>in</code>)在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。</p><p>英寸和厘米的换算：<code>1英寸 = 2.54 厘米</code></p><h2 id="二、分辨率"><a href="#二、分辨率" class="headerlink" title="二、分辨率"></a>二、分辨率</h2><h3 id="2-1-像素"><a href="#2-1-像素" class="headerlink" title="2.1 像素"></a>2.1 像素</h3><p>像素即一个小方块，它具有特定的位置和颜色。</p><p>图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。</p><p>像素可以作为图片或电子屏幕的最小组成单位。</p><p>下面我们使用<code>sketch</code>打开一张图片：</p><p><img src="https://i.loli.net/2019/05/17/5cddefd18987943848.png" alt></p><p>将这些图片放大即可看到这些像素点：</p><p><img src="https://i.loli.net/2019/05/17/5cddefb8d84ab76156.png" alt></p><a id="more"></a><p>通常我们所说的分辨率有两种，屏幕分辨率和图像分辨率。</p><h3 id="2-2-屏幕分辨率"><a href="#2-2-屏幕分辨率" class="headerlink" title="2.2 屏幕分辨率"></a>2.2 屏幕分辨率</h3><p>屏幕分辨率指一个屏幕具体由多少个像素点组成。</p><p>下面是<code>apple</code>的官网上对手机分辨率的描述：</p><p><img src="https://i.loli.net/2019/05/17/5cddefb520e2929179.png" alt></p><p><code>iPhone XS Max</code> 和 <code>iPhone SE</code>的分辨率分别为<code>2688 x 1242</code>和<code>1136 x 640</code>。这表示手机分别在垂直和水平上所具有的像素点数。</p><p>当然分辨率高不代表屏幕就清晰，屏幕的清晰程度还与尺寸有关。</p><h3 id="2-3-图像分辨率"><a href="#2-3-图像分辨率" class="headerlink" title="2.3 图像分辨率"></a>2.3 图像分辨率</h3><p>我们通常说的<code>图片分辨率</code>其实是指图片含有的<code>像素数</code>，比如一张图片的分辨率为<code>800 x 400</code>。这表示图片分别在垂直和水平上所具有的像素点数为<code>800</code>和<code>400</code>。</p><p>同一尺寸的图片，分辨率越高，图片越清晰。</p><p><img src="https://i.loli.net/2019/05/17/5cddefb19aeaa99756.png" alt></p><h3 id="2-4-PPI"><a href="#2-4-PPI" class="headerlink" title="2.4 PPI"></a>2.4 PPI</h3><p><code>PPI(Pixel Per Inch)</code>：每英寸包括的像素数。</p><p><code>PPI</code>可以用于描述屏幕的清晰度以及一张图片的质量。</p><p>使用<code>PPI</code>描述图片时，<code>PPI</code>越高，图片质量越高，使用<code>PPI</code>描述屏幕时，<code>PPI</code>越高，屏幕越清晰。</p><p>在上面描述手机分辨率的图片中，我们可以看到：<code>iPhone XS Max</code> 和 <code>iPhone SE</code>的<code>PPI</code>分别为<code>458</code>和<code>326</code>，这足以证明前者的屏幕更清晰。</p><p>由于手机尺寸为手机对角线的长度，我们通常使用如下的方法计算<code>PPI</code>:</p><script type="math/tex; mode=display">\frac{\sqrt{水平像素点数^2+垂直像素点数^2}}{尺寸}</script><p><code>iPhone 6</code>的<code>PPI</code>为 $ \frac{\sqrt{1334^2+750^2}}{4.7}=325.6$，那它每英寸约含有<code>326</code>个物理像素点。</p><h3 id="2-5-DPI"><a href="#2-5-DPI" class="headerlink" title="2.5 DPI"></a>2.5 DPI</h3><p><code>DPI(Dot Per Inch)</code>：即每英寸包括的点数。</p><p>这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点也可以是打印机的墨点。</p><p>平时你可能会看到使用<code>DPI</code>来描述图片和屏幕，这时的<code>DPI</code>应该和<code>PPI</code>是等价的，<code>DPI</code>最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。</p><p>一张图片在屏幕上显示时，它的像素点数是规则排列的，每个像素点都有特定的位置和颜色。</p><p>当使用打印机进行打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是<code>DPI</code>所描述的：打印点的密度。</p><p><img src="https://i.loli.net/2019/05/17/5cddf09abd86b34406.png" alt></p><p>在上面的图像中我们可以清晰的看到，打印机是如何使用墨点来打印一张图像。</p><p>所以，打印机的<code>DPI</code>越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。</p><h2 id="三、设备独立像素"><a href="#三、设备独立像素" class="headerlink" title="三、设备独立像素"></a>三、设备独立像素</h2><p>实际上，上面我们描述的像素都是<code>物理像素</code>，即设备上真实的物理单元。</p><p>下面我们来看看<code>设备独立像素</code>究竟是如何产生的：</p><p>智能手机发展非常之快，在几年之前，我们还用着分辨率非常低的手机，比如下面左侧的白色手机，它的分辨率是<code>320x480</code>，我们可以在上面浏览正常的文字、图片等等。</p><p>但是，随着科技的发展，低分辨率的手机已经不能满足我们的需求了。很快，更高分辨率的屏幕诞生了，比如下面的黑色手机，它的分辨率是<code>640x940</code>，正好是白色手机的两倍。</p><p>理论上来讲，在白色手机上相同大小的图片和文字，在黑色手机上会被缩放一倍，因为它的分辨率提高了一倍。这样，岂不是后面出现更高分辨率的手机，页面元素会变得越来越小吗？</p><p><img src="https://i.loli.net/2019/05/17/5cddf09f48f0a33102.png" alt></p><p>然而，事实并不是这样的，我们现在使用的智能手机，不管分辨率多高，他们所展示的界面比例都是基本类似的。乔布斯在<code>iPhone4</code>的发布会上首次提出了<code>Retina Display</code>(视网膜屏幕)的概念，它正是解决了上面的问题，这也使它成为一款跨时代的手机。</p><p><img src="https://i.loli.net/2019/05/17/5cddf0897062b36552.png" alt></p><p>在<code>iPhone4</code>使用的视网膜屏幕中，把<code>2x2</code>个像素当<code>1</code>个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变。</p><p><img src="https://i.loli.net/2019/05/17/5cddf09af318944420.png" alt></p><p>如果黑色手机使用了视网膜屏幕的技术，那么显示结果应该是下面的情况，比如列表的宽度为<code>300</code>个像素，那么在一条水平线上，白色手机会用<code>300</code>个物理像素去渲染它，而黑色手机实际上会用<code>600</code>个物理像素去渲染它。</p><p>我们必须用一种单位来同时告诉不同分辨率的手机，它们在界面上显示元素的大小是多少，这个单位就是设备独立像素(<code>Device Independent Pixels</code>)简称<code>DIP</code>或<code>DP</code>。上面我们说，列表的宽度为<code>300</code>个像素，实际上我们可以说：列表的宽度为<code>300</code>个设备独立像素。</p><p><img src="https://i.loli.net/2019/05/17/5cddf08cd614e72602.png" alt></p><p>打开<code>chrome</code>的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如<code>iPhone X</code>显示的尺寸是<code>375x812</code>，实际<code>iPhone X</code>的分辨率会比这高很多，这里显示的就是设备独立像素。</p><p><img src="https://i.loli.net/2019/05/17/5cddf0955ea4541111.png" alt></p><h3 id="3-1-设备像素比"><a href="#3-1-设备像素比" class="headerlink" title="3.1 设备像素比"></a>3.1 设备像素比</h3><p>设备像素比<code>device pixel ratio</code>简称<code>dpr</code>，即物理像素和设备独立像素的比值。</p><p>在<code>web</code>中，浏览器为我们提供了<code>window.devicePixelRatio</code>来帮助我们获取<code>dpr</code>。</p><p>在<code>css</code>中，可以使用媒体查询<code>min-device-pixel-ratio</code>，区分<code>dpr</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> (-webkit-min-device-pixel-ratio: <span class="number">2</span>), (min-device-pixel-ratio: <span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>React Native</code>中，我们也可以使用<code>PixelRatio.get()</code>来获取<code>DPR</code>。</p><p>当然，上面的规则也有例外，<code>iPhone 6、7、8 Plus</code>的实际物理像素是<code>1080 x 1920</code>，在开发者工具中我们可以看到：它的设备独立像素是<code>414 x 736</code>，设备像素比为<code>3</code>，设备独立像素和设备像素比的乘积并不等于<code>1080 x 1920</code>，而是等于<code>1242 x 2208</code>。</p><p>实际上，手机会自动把<code>1242 x 2208</code>个像素点塞进<code>1080 * 1920</code>个物理像素点来渲染，我们不用关心这个过程，而<code>1242 x 2208</code>被称为屏幕的<code>设计像素</code>。我们开发过程中也是以这个<code>设计像素</code>为准。</p><p>实际上，从苹果提出视网膜屏幕开始，才出现设备像素比这个概念，因为在这之前，移动设备都是直接使用物理像素来进行展示。</p><p>紧接着，<code>Android</code>同样使用了其他的技术方案来实现<code>DPR</code>大于<code>1</code>的屏幕，不过原理是类似的。由于<code>Android</code>屏幕尺寸非常多、分辨率高低跨度非常大，不像苹果只有它自己的几款固定设备、尺寸。所以，为了保证各种设备的显示效果，<code>Android</code>按照设备的像素密度将设备分成了几个区间：</p><p><img src="https://i.loli.net/2019/05/17/5cddf152a707694983.png" alt></p><p>当然，所有的<code>Android</code>设备不一定严格按照上面的分辨率，每个类型可能对应几种不同分辨率，所以，每个<code>Android</code>手机都能根据给定的区间范围，确定自己的<code>DPR</code>，从而拥有类似的显示。当然，仅仅是类似，由于各个设备的尺寸、分辨率上的差异，设备独立像素也不会完全相等，所以各种<code>Android</code>设备仍然不能做到在展示上完全相等。</p><h3 id="3-2-移动端开发"><a href="#3-2-移动端开发" class="headerlink" title="3.2 移动端开发"></a>3.2 移动端开发</h3><p>在<code>iOS</code>、<code>Android</code>和<code>React Native</code>开发中样式单位其实都使用的是设备独立像素。</p><p><code>iOS</code>的尺寸单位为<code>pt</code>，<code>Android</code>的尺寸单位为<code>dp</code>，<code>React Native</code>中没有指定明确的单位，它们其实都是设备独立像素<code>dp</code>。</p><p>在使用<code>React Native</code>开发<code>App</code>时，<code>UI</code>给我们的原型图一般是基于<code>iphone6</code>的像素给定的。</p><p>为了适配所有机型，我们在写样式时需要把物理像素转换为设备独立像素：例如：如果给定一个元素的高度为<code>200px</code>(这里的<code>px</code>指物理像素，非<code>CSS</code>像素)，<code>iphone6</code>的设备像素比为<code>2</code>，我们给定的<code>height</code>应为<code>200px/2=100dp</code>。</p><p>当然，最好的是，你可以和设计沟通好，所有的<code>UI</code>图都按照设备独立像素来出。</p><p>我们还可以在代码(<code>React Native</code>)中进行<code>px</code>和<code>dp</code>的转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PixelRatio &#125; <span class="keyword">from</span> <span class="string">"react-native"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dpr = PixelRatio.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * px转换为dp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pxConvertTodp</span>(<span class="params">px</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> px / dpr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp转换为px</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dpConvertTopx</span>(<span class="params">dp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PixelRatio.getPixelSizeForLayoutSize(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-WEB-端开发"><a href="#3-3-WEB-端开发" class="headerlink" title="3.3 WEB 端开发"></a>3.3 WEB 端开发</h3><p>在写<code>CSS</code>时，我们用到最多的单位是<code>px</code>，即<code>CSS像素</code>，当页面缩放比例为<code>100%</code>时，一个<code>CSS像素</code>等于一个设备独立像素。</p><p>但是<code>CSS像素</code>是很容易被改变的，当用户对浏览器进行了放大，<code>CSS像素</code>会被放大，这时一个<code>CSS像素</code>会跨越更多的物理像素。</p><p><code>页面的缩放系数 = CSS像素 / 设备独立像素</code>。</p><h3 id="3-4-关于屏幕"><a href="#3-4-关于屏幕" class="headerlink" title="3.4 关于屏幕"></a>3.4 关于屏幕</h3><p>这里多说两句<code>Retina</code>屏幕，因为我在很多文章中看到对<code>Retina</code>屏幕的误解。</p><p><code>Retina</code>屏幕只是苹果提出的一个营销术语：</p><blockquote><p>在普通的使用距离下，人的肉眼无法分辨单个的像素点。</p></blockquote><p>为什么强调<code>普通的使用距离下</code>呢？我们来看一下它的计算公式：</p><script type="math/tex; mode=display">a=2arctan(h/2d)</script><p><code>a</code>代表人眼视角，<code>h</code>代表像素间距，<code>d</code>代表肉眼与屏幕的距离，符合以上条件的屏幕可以使肉眼看不见单个物理像素点。</p><p>它不能单纯的表达分辨率和<code>PPI</code>，只能一种表达视觉效果。</p><p>让多个物理像素渲染一个独立像素只是<code>Retina</code>屏幕为了达到效果而使用的一种技术。而不是所有<code>DPR &gt; 1</code>的屏幕就是<code>Retina</code>屏幕。</p><p>比如：给你一块超大尺寸的屏幕，即使它的<code>PPI</code>很高，<code>DPR</code>也很高，在近距离你也能看清它的像素点，这就不算<code>Retina</code>屏幕。</p><p><img src="https://i.loli.net/2019/05/17/5cddf1510035720584.jpg" alt></p><p>我们经常见到用<code>K</code>和<code>P</code>这个单位来形容屏幕：</p><p><code>P</code>代表的就是屏幕纵向的像素个数，<code>1080P</code>即纵向有<code>1080</code>个像素，分辨率为<code>1920X1080</code>的屏幕就属于<code>1080P</code>屏幕。</p><p>我们平时所说的高清屏其实就是屏幕的物理分辨率达到或超过<code>1920X1080</code>的屏幕。</p><p><code>K</code>代表屏幕横向有几个<code>1024</code>个像素，一般来讲横向像素超过<code>2048</code>就属于<code>2K</code>屏，横向像素超过<code>4096</code>就属于<code>4K</code>屏。</p><h2 id="四、视口"><a href="#四、视口" class="headerlink" title="四、视口"></a>四、视口</h2><p>视口(<code>viewport</code>)代表当前可见的计算机图形区域。在<code>Web</code>浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的<code>UI</code>， 菜单栏等——即指你正在浏览的文档的那一部分。</p><p>一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。</p><h3 id="4-1-布局视口"><a href="#4-1-布局视口" class="headerlink" title="4.1 布局视口"></a>4.1 布局视口</h3><p><img src="https://i.loli.net/2019/05/17/5cddf1581489419627.png" alt></p><p>布局视口(<code>layout viewport</code>)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。</p><p>所以，布局视口是网页布局的基准窗口，在<code>PC</code>浏览器上，布局视口就等于当前浏览器的窗口大小（不包括<code>borders</code> 、<code>margins</code>、滚动条）。</p><p>在移动端，布局视口被赋予一个默认值，大部分为<code>980px</code>，这保证<code>PC</code>的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。</p><p>我们可以通过调用<code>document.documentElement.clientWidth / clientHeight</code>来获取布局视口大小。</p><h3 id="4-2-视觉视口"><a href="#4-2-视觉视口" class="headerlink" title="4.2 视觉视口"></a>4.2 视觉视口</h3><p><img src="https://i.loli.net/2019/05/17/5cddf1554295a45164.png" alt></p><p>视觉视口(<code>visual viewport</code>)：用户通过屏幕真实看到的区域。</p><p>视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。</p><p>当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小。</p><p>例如：用户将浏览器窗口放大了<code>200%</code>，这时浏览器窗口中的<code>CSS像素</code>会随着视觉视口的放大而放大，这时一个<code>CSS</code>像素会跨越更多的物理像素。</p><p>所以，布局视口会限制你的<code>CSS</code>布局而视觉视口决定用户具体能看到什么。</p><p>我们可以通过调用<code>window.innerWidth / innerHeight</code>来获取视觉视口大小。</p><h3 id="4-3-理想视口"><a href="#4-3-理想视口" class="headerlink" title="4.3 理想视口"></a>4.3 理想视口</h3><p><img src="https://i.loli.net/2019/05/17/5cddf0955ea4541111.png" alt></p><p>布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(<code>ideal viewport</code>)就诞生了：网站页面在移动端展示的理想大小。</p><p>如上图，我们在描述设备独立像素时曾使用过这张图，在浏览器调试移动端时页面上给定的像素大小就是理想视口大小，它的单位正是设备独立像素。</p><p>上面在介绍<code>CSS像素时</code>曾经提到<code>页面的缩放系数 = CSS像素 / 设备独立像素</code>，实际上说<code>页面的缩放系数 = 理想视口宽度 / 视觉视口宽度</code>更为准确。</p><p>所以，当页面缩放比例为<code>100%</code>时，<code>CSS像素 = 设备独立像素</code>，<code>理想视口 = 视觉视口</code>。</p><p>我们可以通过调用<code>screen.width / height</code>来获取理想视口大小。</p><h3 id="4-4-Meta-viewport"><a href="#4-4-Meta-viewport" class="headerlink" title="4.4 Meta viewport"></a>4.4 Meta viewport</h3><p><code>&lt;meta&gt;</code> 元素表示那些不能由其它<code>HTML</code>元相关元素之一表示的任何元数据信息，它可以告诉浏览器如何解析页面。</p><p>我们可以借助<code>&lt;meta&gt;</code>元素的<code>viewport</code>来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>上面是<code>viewport</code>的一个配置，我们来看看它们的具体含义：</p><div class="table-container"><table><thead><tr><th><code>Value</code></th><th>可能值</th><th>描述</th></tr></thead><tbody><tr><td><code>width</code></td><td>正整数或<code>device-width</code></td><td>以<code>pixels</code>（像素）为单位， 定义布局视口的宽度。</td></tr><tr><td><code>height</code></td><td>正整数或<code>device-height</code></td><td>以<code>pixels</code>（像素）为单位， 定义布局视口的高度。</td></tr><tr><td><code>initial-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义页面初始缩放比率。</td></tr><tr><td><code>minimum-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义缩放的最小值；必须小于或等于<code>maximum-scale</code>的值。</td></tr><tr><td><code>maximum-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义缩放的最大值；必须大于或等于<code>minimum-scale</code>的值。</td></tr><tr><td><code>user-scalable</code></td><td>一个布尔值（<code>yes</code>或者<code>no</code>）</td><td>如果设置为 <code>no</code>，用户将不能放大或缩小网页。默认值为 yes。</td></tr></tbody></table></div><h3 id="4-5-移动端适配"><a href="#4-5-移动端适配" class="headerlink" title="4.5 移动端适配"></a>4.5 移动端适配</h3><p>为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。</p><p><code>device-width</code>就等于理想视口的宽度，所以设置<code>width=device-width</code>就相当于让布局视口等于理想视口。</p><p>由于<code>initial-scale = 理想视口宽度 / 视觉视口宽度</code>，所以我们设置<code>initial-scale=1;</code>就相当于让视觉视口等于理想视口。</p><p>这时，1 个<code>CSS</code>像素就等于 1 个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。</p><h3 id="4-6-缩放"><a href="#4-6-缩放" class="headerlink" title="4.6 缩放"></a>4.6 缩放</h3><p>上面提到<code>width</code>可以决定布局视口的宽度，实际上它并不是布局视口的唯一决定性因素，设置<code>initial-scale</code>也有肯能影响到布局视口，因为布局视口宽度取的是<code>width</code>和视觉视口宽度的最大值。</p><p>例如：若手机的理想视口宽度为<code>400px</code>，设置<code>width=device-width</code>，<code>initial-scale=2</code>，此时<code>视觉视口宽度 = 理想视口宽度 / initial-scale</code>即<code>200px</code>，布局视口取两者最大值即<code>device-width</code> <code>400px</code>。</p><p>若设置<code>width=device-width</code>，<code>initial-scale=0.5</code>，此时<code>视觉视口宽度 = 理想视口宽度 / initial-scale</code>即<code>800px</code>，布局视口取两者最大值即<code>800px</code>。</p><h3 id="4-7-获取浏览器大小"><a href="#4-7-获取浏览器大小" class="headerlink" title="4.7 获取浏览器大小"></a>4.7 获取浏览器大小</h3><p>浏览器为我们提供的获取窗口大小的<code>API</code>有很多，下面我们再来对比一下：</p><p><img src="https://i.loli.net/2019/05/17/5cddf1b5bc92295065.png" alt></p><ul><li><code>window.innerHeight</code>：获取浏览器视觉视口高度（包括垂直滚动条）。</li><li><code>window.outerHeight</code>：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。</li><li><code>window.screen.Height</code>：获取获屏幕取理想视口高度，这个数值是固定的，<code>设备的分辨率/设备像素比</code></li><li><code>window.screen.availHeight</code>：浏览器窗口可用的高度。</li><li><code>document.documentElement.clientHeight</code>：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。</li><li><code>document.documentElement.offsetHeight</code>：包括内边距、滚动条、边框和外边距。</li><li><code>document.documentElement.scrollHeight</code>：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与<code>clientHeight</code>相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。</li></ul><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;移动端适配，是我们在开发中经常会遇到的，这里面可能会遇到非常多的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1px&lt;/code&gt;问题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UI&lt;/code&gt;图完美适配方案&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iPhoneX&lt;/code&gt;适配方案&lt;/li&gt;
&lt;li&gt;横屏适配&lt;/li&gt;
&lt;li&gt;高清屏图片模糊问题&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面这些问题可能我们在开发中已经知道如何解决，但是问题产生的原理，以及解决方案的原理可能会模糊不清。在解决这些问题的过程中，我们往往会遇到非常多的概念：像素、分辨率、&lt;code&gt;PPI&lt;/code&gt;、&lt;code&gt;DPI&lt;/code&gt;、&lt;code&gt;DP&lt;/code&gt;、&lt;code&gt;DIP&lt;/code&gt;、&lt;code&gt;DPR&lt;/code&gt;、视口等等，你真的能分清这些概念的意义吗？&lt;/p&gt;
&lt;p&gt;本文将从移动端适配的基础概念出发，探究移动端适配各种问题的解决方案和实现原理。&lt;/p&gt;
&lt;h2 id=&quot;一、英寸&quot;&gt;&lt;a href=&quot;#一、英寸&quot; class=&quot;headerlink&quot; title=&quot;一、英寸&quot;&gt;&lt;/a&gt;一、英寸&lt;/h2&gt;&lt;p&gt;一般用英寸描述屏幕的物理大小，如电脑显示器的&lt;code&gt;17&lt;/code&gt;、&lt;code&gt;22&lt;/code&gt;，手机显示器的&lt;code&gt;4.8&lt;/code&gt;、&lt;code&gt;5.7&lt;/code&gt;等使用的单位都是英寸。&lt;/p&gt;
&lt;p&gt;需要注意，上面的尺寸都是屏幕对角线的长度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/17/5cddefa632f3247082.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;英寸(&lt;code&gt;inch&lt;/code&gt;,缩写为&lt;code&gt;in&lt;/code&gt;)在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。&lt;/p&gt;
&lt;p&gt;英寸和厘米的换算：&lt;code&gt;1英寸 = 2.54 厘米&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、分辨率&quot;&gt;&lt;a href=&quot;#二、分辨率&quot; class=&quot;headerlink&quot; title=&quot;二、分辨率&quot;&gt;&lt;/a&gt;二、分辨率&lt;/h2&gt;&lt;h3 id=&quot;2-1-像素&quot;&gt;&lt;a href=&quot;#2-1-像素&quot; class=&quot;headerlink&quot; title=&quot;2.1 像素&quot;&gt;&lt;/a&gt;2.1 像素&lt;/h3&gt;&lt;p&gt;像素即一个小方块，它具有特定的位置和颜色。&lt;/p&gt;
&lt;p&gt;图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。&lt;/p&gt;
&lt;p&gt;像素可以作为图片或电子屏幕的最小组成单位。&lt;/p&gt;
&lt;p&gt;下面我们使用&lt;code&gt;sketch&lt;/code&gt;打开一张图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/17/5cddefd18987943848.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;将这些图片放大即可看到这些像素点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/17/5cddefb8d84ab76156.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用JS开发桌面应用（五）终篇</title>
    <link href="https://youdaily.github.io/posts/83385321/"/>
    <id>https://youdaily.github.io/posts/83385321/</id>
    <published>2019-05-17T07:23:28.000Z</published>
    <updated>2019-12-10T02:05:12.776Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="十一、扩展能力"><a href="#十一、扩展能力" class="headerlink" title="十一、扩展能力"></a>十一、扩展能力</h2><p><img src="http://www.conardli.top/img/electron/el_4_iot.jpg" alt></p><p>在很多情况下，你的应用程序要和外部设备进行交互，一般情况下厂商会为你提供硬件设备的开发包，这些开发包基本上都是通过<code>C++</code> 编写，在使用<code>electron</code>开发的情况下，我们并不具备直接调用<code>C++</code>代码的能力，我们可以利用<code>node-ffi</code>来实现这一功能。</p><p><code>node-ffi</code>提供了一组强大的工具，用于在<code>Node.js</code>环境中使用纯<code>JavaScript</code>调用动态链接库接口。它可以用来为库构建接口绑定，而不需要使用任何<code>C++</code>代码。</p><blockquote><p>注意<code>node-ffi</code>并不能直接调用<code>C++</code>代码，你需要将<code>C++</code>代码编译为动态链接库：在 <code>Windows</code>下是 <code>Dll</code> ，在 <code>Mac OS</code>下是 <code>dylib</code> <code>，Linux</code> 是 <code>so</code> 。</p><p><code>node-ffi</code> 加载 <code>Library</code>是有限制的，只能处理 <code>C</code>风格的 <code>Library</code>。 </p></blockquote><p>下面是一个简单的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ffi = <span class="built_in">require</span>(<span class="string">'ffi'</span>);</span><br><span class="line"><span class="keyword">const</span> ref = <span class="built_in">require</span>(<span class="string">'ref'</span>);</span><br><span class="line"><span class="keyword">const</span> SHORT_CODE = ref.refType(<span class="string">'short'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DLL = <span class="keyword">new</span> ffi.Library(<span class="string">'test.dll'</span>, &#123;</span><br><span class="line">    Test_CPP_Method: [<span class="string">'int'</span>, [<span class="string">'string'</span>,SHORT_CODE]], </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">testCppMethod(str: <span class="built_in">String</span>, <span class="attr">num</span>: number): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result: any = DLL.Test_CPP_Method(str, num);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'调用失败～'</span>,error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.testCppMethod(<span class="string">'ConardLi'</span>,<span class="number">123</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面的代码中，我们用<code>ffi</code>包装<code>C++</code>接口生成的动态链接库<code>test.dll</code>，并使用<code>ref</code>进行一些类型映射。</p><p>使用<code>JavaScript</code>调用这些映射方法时，推荐使用<code>TypeScript</code>来约定参数类型，因为弱类型的<code>JavaScript</code>在调用强类型语言的接口时可能会带来意想不到的风险。</p><p>借助这一能力，前端开发工程师也可以在<code>IOT</code>领域一展身手了😎～</p><h2 id="十二、环境选择"><a href="#十二、环境选择" class="headerlink" title="十二、环境选择"></a>十二、环境选择</h2><p>一般情况下，我们的应用程序可能运行在多套环境下（<code>production</code>、<code>beta</code>、<code>uat</code>、<code>moke</code>、<code>development</code>…），不同的开发环境可能对应不同的后端接口或者其他配置，我们可以在客户端程序中内置一个简单的环境选择功能来帮助我们更高效的开发。</p><p><img src="http://www.conardli.top/img/electron/el_14_env.png" alt></p><p>具体策略如下：</p><p><img src="http://www.conardli.top/img/electron/el_15_env.png" alt></p><ul><li>在开发环境中，我们直接进入环境选择页面，读取到选择的环境后进行响应的重定向操作</li><li>在菜单保留环境选择入口，以便在开发过程中切换</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> envList = [<span class="string">"moke"</span>, <span class="string">"beta"</span>, <span class="string">"development"</span>, <span class="string">"production"</span>];</span><br><span class="line">exports.envList = envList;</span><br><span class="line"><span class="keyword">const</span> urlBeta = <span class="string">'https://wwww.xxx-beta.com'</span>;</span><br><span class="line"><span class="keyword">const</span> urlDev = <span class="string">'https://wwww.xxx-dev.com'</span>;</span><br><span class="line"><span class="keyword">const</span> urlProp = <span class="string">'https://wwww.xxx-prop.com'</span>;</span><br><span class="line"><span class="keyword">const</span> urlMoke = <span class="string">'https://wwww.xxx-moke.com'</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(path.resolve(global.__dirname, <span class="string">'package.json'</span>));</span><br><span class="line"><span class="keyword">const</span> build = pkg[<span class="string">'build-config'</span>];</span><br><span class="line">exports.handleEnv = &#123;</span><br><span class="line">  build,</span><br><span class="line">  currentEnv: <span class="string">'moke'</span>,</span><br><span class="line">  setEnv: <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentEnv = env</span><br><span class="line">  &#125;,</span><br><span class="line">  getUrl: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'env:'</span>, build.env);</span><br><span class="line">    <span class="keyword">if</span> (build.env === <span class="string">'production'</span> || <span class="keyword">this</span>.currentEnv === <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlProp;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.currentEnv === <span class="string">'moke'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlMoke;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.currentEnv === <span class="string">'development'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlDev;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.currentEnv === <span class="string">"beta"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlBeta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isDebugger: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build.env === <span class="string">'development'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十三、打包"><a href="#十三、打包" class="headerlink" title="十三、打包"></a>十三、打包</h2><p>最后也是最重要的一步，将写好的代码打包成可运行的<code>.app</code>或<code>.exe</code>可执行文件。</p><p>这里我把打包氛围两部分来做，渲染进程打包和主进程打包。</p><h3 id="13-1-渲染进程打包和升级"><a href="#13-1-渲染进程打包和升级" class="headerlink" title="13.1 渲染进程打包和升级"></a>13.1 渲染进程打包和升级</h3><p>一般情况下，我们的大部分业务逻辑代码是在渲染进程完成的，在大部分情况下我们仅仅需要对渲染进程进行更新和升级而不需要改动主进程代码，我们渲染进程的打包实际上和一般的<code>web</code>项目打包没有太大差别，使用<code>webpack</code>打包即可。</p><p>这里我说说渲染进程单独打包的好处：</p><p>打包完成的<code>html</code>和<code>js</code>文件，我们一般要上传到我们的前端静态资源服务器下，然后告知服务端我们的渲染进程有代码更新，这里可以说成渲染进程单独的升级。</p><p>注意，和壳的升级不同，渲染进程的升级仅仅是静态资源服务器上<code>html</code>和<code>js</code>文件的更新，而不需要重新下载更新客户端，这样我们每次启动程序的时候检测到离线包有更新，即可直接刷新读取最新版本的静态资源文件，即使在程序运行过程中要强制更新，我们的程序只需要强制刷新页面读取最新的静态资源即可，这样的升级对用户是非常友好的。</p><p>这里注意，一旦我们这样配置，就意味着渲染进程和主进程打包升级的完全分离，我们在启动主窗口时读取的文件就不应该再是本地文件，而是打包完成后放在静态资源服务器的文件。</p><p>为了方便开发，这里我们可以区分本地和线上加载不同的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVersion</span> (<span class="params">mac,current</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 根据设备mac和当前版本获取最新版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (build.env === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> version = getVersion (mac,current);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'https://www.xxxserver.html/electron-react/index_'</span>+version+<span class="string">'.html'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url.format(&#123;</span><br><span class="line">    protocol: <span class="string">'file:'</span>,</span><br><span class="line">    pathname: path.join(__dirname, <span class="string">'env/environment.html'</span>),</span><br><span class="line">    slashes: <span class="literal">true</span>,</span><br><span class="line">    query: &#123; <span class="attr">debugger</span>: build.env === <span class="string">"development"</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的<code>webpack</code>配置这里就不再贴出。</p><p>这里需要注意，在开发环境下我们可以结合<code>webpack</code>的<code>devServer</code>和<code>electron</code>命令来启动<code>app</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: <span class="string">'./assets/'</span>,</span><br><span class="line">  historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  port: PORT,</span><br><span class="line">  noInfo: <span class="literal">false</span>,</span><br><span class="line">  stats: &#123;</span><br><span class="line">    colors: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    spawn(</span><br><span class="line">      <span class="string">'electron'</span>,</span><br><span class="line">      [<span class="string">'.'</span>],</span><br><span class="line">      &#123;</span><br><span class="line">        shell: <span class="literal">true</span>,</span><br><span class="line">        stdio: <span class="string">'inherit'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      .on(<span class="string">'close'</span>, () =&gt; process.exit(<span class="number">0</span>))</span><br><span class="line">      .on(<span class="string">'error'</span>, e =&gt; <span class="built_in">console</span>.error(e));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,<span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="13-2-主进程打包"><a href="#13-2-主进程打包" class="headerlink" title="13.2 主进程打包"></a>13.2 主进程打包</h3><p> 主进程，即将整个程序打包成可运行的客户端程序，常用的打包方案一般有两种，<code>electron-packager</code>和<code>electron-builder</code>。</p><p> <code>electron-packager</code>在打包配置上我觉得有些繁琐，而且它只能将应用直接打包为可执行程序。</p><p> 这里我推荐使用<code>electron-builder</code>，它不仅拥有方便的配置 <code>protocol</code> 的功能、内置的 <code>Auto Update</code>、简单的配置 <code>package.json</code> 便能完成整个打包工作，用户体验非常不错。而且<code>electron-builder</code>不仅能直接将应用打包成<code>exe app</code>等可执行程序，还能打包成<code>msi dmg</code>等安装包格式。</p><p> 你可以在<code>package.json</code>方便的进行各种配置：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build"</span>: &#123;</span><br><span class="line">  <span class="string">"productName"</span>: <span class="string">"electron-react"</span>, <span class="comment">// app中文名称</span></span><br><span class="line">  <span class="string">"appId"</span>: <span class="string">"electron-react"</span>,<span class="comment">// app标识</span></span><br><span class="line">  <span class="string">"directories"</span>: &#123; <span class="comment">// 打包后输出的文件夹</span></span><br><span class="line">    <span class="string">"buildResources"</span>: <span class="string">"resources"</span>,</span><br><span class="line">    <span class="string">"output"</span>: <span class="string">"dist/"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"files"</span>: [ <span class="comment">// 打包后依然保留的源文件</span></span><br><span class="line">    <span class="string">"main_process/"</span>,</span><br><span class="line">    <span class="string">"render_process/"</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"mac"</span>: &#123; <span class="comment">// mac打包配置</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"dmg"</span>,</span><br><span class="line">    <span class="string">"icon"</span>: <span class="string">"icon.ico"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"win"</span>: &#123; <span class="comment">// windows打包配置</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"nsis"</span>,</span><br><span class="line">    <span class="string">"icon"</span>: <span class="string">"icon.ico"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"dmg"</span>: &#123; <span class="comment">// dmg文件打包配置</span></span><br><span class="line">    <span class="string">"artifactName"</span>: <span class="string">"electron_react.dmg"</span>,</span><br><span class="line">    <span class="string">"contents"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="string">"path"</span>: <span class="string">"/Applications"</span>,</span><br><span class="line">        <span class="string">"x"</span>: <span class="number">410</span>,</span><br><span class="line">        <span class="string">"y"</span>: <span class="number">150</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"file"</span>,</span><br><span class="line">        <span class="string">"x"</span>: <span class="number">130</span>,</span><br><span class="line">        <span class="string">"y"</span>: <span class="number">150</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"nsis"</span>: &#123; <span class="comment">// nsis文件打包配置</span></span><br><span class="line">    <span class="string">"oneClick"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"allowToChangeInstallationDirectory"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"shortcutName"</span>: <span class="string">"electron-react"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 执行<code>electron-builder</code>打包命令时，可指定参数进行打包。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--mac, -m, -o, --macos   macOS打包</span><br><span class="line">--linux, -l              Linux打包</span><br><span class="line">--win, -w, --windows     Windows打包</span><br><span class="line">--mwl                    同时为macOS，Windows和Linux打包</span><br><span class="line">--x64                    x64 (<span class="number">64</span>位安装包)</span><br><span class="line">--ia32                   ia32(<span class="number">32</span>位安装包)</span><br></pre></td></tr></table></figure><p> 关于主进程的更新你可以使用<code>electron-builder</code>自带的<code>Auto Update</code>模块，在<code>electron-react</code>也实现了手动更新的模块。</p><h3 id="13-3-打包优化"><a href="#13-3-打包优化" class="headerlink" title="13.3 打包优化"></a>13.3 打包优化</h3><p><code>electron-builder</code>打包出来的<code>App</code>要比相同功能的原生客户端应用体积大很多，即使是空的应用，体积也要在<code>100mb</code>以上。原因有很多：</p><p>第一点；为了达到跨平台的效果，每个<code>Electron</code>应用都包含了整个<code>V8</code>引擎和<code>Chromium</code>内核。</p><p>第二点：打包时会将整个<code>node_modules</code>打包进去，大家都知道一个应用的<code>node_module</code>体积是非常庞大的，这也是使得<code>Electron</code>应用打包后的体积较大的原因。</p><p>第一点我们无法改变，我们可以从第二点对应用体积进行优化：<code>Electron</code>在打包时只会将<code>denpendencies</code>的依赖打包进去，而不会将 <code>devDependencies</code> 中的依赖进行打包。所以我们应尽可能的减少<code>denpendencies</code>中的依赖。在上面的进程中，我们使用<code>webpack</code>对渲染进程进行打包，所以渲染进程的依赖全部都可以移入<code>devDependencies</code>。</p><p>另外，我们还可以使用双<code>packajson.json</code>的方式来进行优化，把只在开发环境中使用到的依赖放在整个项目的根目录的<code>package.json</code>下，将与平台相关的或者运行时需要的依赖装在<code>app</code>目录下。具体详见<a href="https://www.electron.build/tutorials/two-package-structure" target="_blank" rel="noopener">two-package-structure</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://electronjs.org/docs" target="_blank" rel="noopener">https://electronjs.org/docs</a></li><li><a href="http://jlord.us/essential-electron/" target="_blank" rel="noopener">http://jlord.us/essential-electron/</a></li><li><a href="https://imweb.io/topic/5b9f500cc2ec8e6772f34d79" target="_blank" rel="noopener">https://imweb.io/topic/5b9f500cc2ec8e6772f34d79</a></li><li><a href="https://www.jianshu.com/p/1ece6fd7a80c" target="_blank" rel="noopener">https://www.jianshu.com/p/1ece6fd7a80c</a></li><li><a href="https://zhuanlan.zhihu.com/p/52991793" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52991793</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p><ul><li>了解<code>Electron</code>的基本运行原理</li><li>掌握<code>Electron</code>开发的核心基础知识</li><li>了解<code>Electron</code>关于弹框、打印、保护、打包等功能的基本使用</li></ul><hr><p>欢迎大家到公众号: <code>you的日常</code> 阅读，体验更好哦。</p><p><img src="https://i.loli.net/2019/12/09/VhvX5WilLEOIwGN.jpg" alt="youDaily.jpg"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "17107-1575958378269-553",        "name": "you的日常",        "qrcode": "https://i.loli.net/2019/12/10/YzmMvgyAIXeuS8F.jpg",        "keyword": "vip"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;十一、扩展能力&quot;&gt;&lt;a href=&quot;#十一、扩展能力&quot; class=&quot;headerlink&quot; title=&quot;十一、扩展能力&quot;&gt;&lt;/a&gt;十一、扩展能力&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.conardli.top/img/electron/el_4_iot.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;在很多情况下，你的应用程序要和外部设备进行交互，一般情况下厂商会为你提供硬件设备的开发包，这些开发包基本上都是通过&lt;code&gt;C++&lt;/code&gt; 编写，在使用&lt;code&gt;electron&lt;/code&gt;开发的情况下，我们并不具备直接调用&lt;code&gt;C++&lt;/code&gt;代码的能力，我们可以利用&lt;code&gt;node-ffi&lt;/code&gt;来实现这一功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node-ffi&lt;/code&gt;提供了一组强大的工具，用于在&lt;code&gt;Node.js&lt;/code&gt;环境中使用纯&lt;code&gt;JavaScript&lt;/code&gt;调用动态链接库接口。它可以用来为库构建接口绑定，而不需要使用任何&lt;code&gt;C++&lt;/code&gt;代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意&lt;code&gt;node-ffi&lt;/code&gt;并不能直接调用&lt;code&gt;C++&lt;/code&gt;代码，你需要将&lt;code&gt;C++&lt;/code&gt;代码编译为动态链接库：在 &lt;code&gt;Windows&lt;/code&gt;下是 &lt;code&gt;Dll&lt;/code&gt; ，在 &lt;code&gt;Mac OS&lt;/code&gt;下是 &lt;code&gt;dylib&lt;/code&gt; &lt;code&gt;，Linux&lt;/code&gt; 是 &lt;code&gt;so&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node-ffi&lt;/code&gt; 加载 &lt;code&gt;Library&lt;/code&gt;是有限制的，只能处理 &lt;code&gt;C&lt;/code&gt;风格的 &lt;code&gt;Library&lt;/code&gt;。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是一个简单的实例：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; ffi = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ffi&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; ref = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ref&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SHORT_CODE = ref.refType(&lt;span class=&quot;string&quot;&gt;&#39;short&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; DLL = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ffi.Library(&lt;span class=&quot;string&quot;&gt;&#39;test.dll&#39;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Test_CPP_Method: [&lt;span class=&quot;string&quot;&gt;&#39;int&#39;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&#39;string&#39;&lt;/span&gt;,SHORT_CODE]], &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testCppMethod(str: &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;num&lt;/span&gt;: number): &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; result: any = DLL.Test_CPP_Method(str, num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;调用失败～&#39;&lt;/span&gt;,error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.testCppMethod(&lt;span class=&quot;string&quot;&gt;&#39;ConardLi&#39;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="https://youdaily.github.io/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://youdaily.github.io/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="https://youdaily.github.io/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
