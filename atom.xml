<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>You的日常</title>
  
  <subtitle>You的日常，我们的日常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-22T08:29:45.847Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>You的日常</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6 实现自己的 Promise</title>
    <link href="http://yoursite.com/2019/11/22/2017-04-01-Programing-JavaScript-drive-promise-in-ES6/"/>
    <id>http://yoursite.com/2019/11/22/2017-04-01-Programing-JavaScript-drive-promise-in-ES6/</id>
    <published>2019-11-22T08:14:31.000Z</published>
    <updated>2019-11-22T08:29:45.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JavaScript-异步编程背景"><a href="#一、JavaScript-异步编程背景" class="headerlink" title="一、JavaScript 异步编程背景"></a>一、JavaScript 异步编程背景</h2><p>​ 从去年 ES2015 发布至今，已经过去了一年多，ES2015 发布的新的语言特性中最为流行的也就莫过于 Promise 了，Promise 使得如今 JavaScript 异步编程如此轻松惬意，甚至慢慢遗忘了曾经那不堪回首的痛楚。</p><p>其实从 JavaScript 诞生，JavaScript 中的异步编程就已经出现，例如点击鼠标、敲击键盘这些事件的处理函数都是异步的，时间到了 2009 年，Node.js 横空出世，在整个 Node.js 的实现中，将回调模式的异步编程机制发挥的淋漓尽致，Node 的流行也是的越来越多的 JavaScripter 开始了异步编程，但是回调模式的副作用也慢慢展现在人们眼前，错误处理不够优雅以及嵌套回调带来的“回调地狱”。</p><p>这些副作用使得人们从回调模式的温柔乡中慢慢清醒过来，开始寻找更为优雅的异步编程模式，路漫漫其修远兮、吾将上下而求索。时间到了 2015 年，Promise 拯救那些苦苦探索的先驱。行使它历史使命的时代似乎已经到来。</p><p>​每个事物的诞生有他的历史使命，更有其历史成因，促进其被那些探索的先驱们所发现。<br>了解 nodejs 或者熟悉浏览器的人都知道，JavaScript 引擎是基于事件循环或单线程这两个特性的。更为甚者在浏览器中，更新 UI(也就是浏览器重绘、重拍页面布局)和执行 JavaScript 代码也在一个单线程中，可想而知，一个线程就相当于只有一条马路，如果一辆马车抛锚在路上了阻塞了马路，那么别的马车也就拥堵在了那儿，这个单线程容易被阻塞是一个道理，单线程也只能允许某一时间点只能够执行一段代码。<br>同时，JavaScript 没有想它的哥哥姐姐们那么财大气粗，像 Java 或者 C++，一个线程不够，那么再加一个线程，这样就能够同时执行多段代码了，但是这样就会带来的隐患就是状态不容易维护，JavaScript 选择了单线程非阻塞式的方式，也就是异步编程的方式，就像上面的马车抛锚在了路上，那么把马车推到路边的维修站，让其他马车先过去，等马车修好了再回到马路上继续行驶，这就是单线程非阻塞方式。正如 Promise 的工作方式一样，通过 Promise 去向服务器发起一个请求，毕竟请求有网络开销，不可能马上就返回请求结果的，这个时候 Promise 就处于 pending 状态，但是其并不会阻塞其他代码的执行，当请求返回时，修改 Promise 状态为 fulfilled 或者 rejected（失败请求）。同时执行绑定到这两个状态上面的“处理函数”。这就是异步编程的模式，也就是 Promise 兢兢业业的工作方式，在下面一个部分将详细讨论 Promise。</p><h2 id="二、Promise-基础"><a href="#二、Promise-基础" class="headerlink" title="二、Promise 基础"></a>二、Promise 基础</h2><p>​ 怎么一句话解释 Promise 呢？Promise 可以代指那些尚未完成的一些操作，但是其在未来的某个时间会返回某一特定的结果。</p><p>​ 当创建一个 Promise 实例后，其代表一个未知的值，在将来的某个时间会返回一个成功的返回值，或者失败的返回值，我们可以为这些返回值添加处理函数，当值返回时，处理函数被调用。Promise 总是处于下面三种状态之一：</p><ul><li>pending： Promise 的初始状态，也就是未被 fulfilled 或者 rejected 的状态。</li><li>fulfilled： 意味着 promise 代指的操作已经成功完成。</li><li>rejected：意味着 promise 代指的操作由于某些原因失败。</li></ul><p>一个处于 pending 状态的 promise 可能由于某个成功返回值而发展为 fulfilled 状态，也有可能因为某些错误而进入 rejected 状态，无论是进入 fulfilled 状态或者 rejected 状态，绑定到这两种状态上面的处理函数就会被执行。并且进入 fulfilled 或者 rejected 状态也就不能再返回 pending 状态了。</p><a id="more"></a><h2 id="三、边学边写"><a href="#三、边学边写" class="headerlink" title="三、边学边写"></a>三、边学边写</h2><p>上面说了那么多，其实都是铺垫。接下来我们就开始实现自己的 Promise 对象。go go go！！！</p><h3 id="第一步：Promise-构造函数"><a href="#第一步：Promise-构造函数" class="headerlink" title="第一步：Promise 构造函数"></a>第一步：Promise 构造函数</h3><p>Promise 有三种状态，pending、fulfilled、rejected。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span> <span class="comment">// Promise 的 初始状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span> <span class="comment">// Promise 成功返回后的状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span> <span class="comment">// Promise 失败后的状态</span></span><br></pre></td></tr></table></figure><p>有了三种状态后，那么我们怎么创建一个 Promise 实例呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(executor) <span class="comment">// 创建 Promise 的语法</span></span><br></pre></td></tr></table></figure><p>通过上面生成 promise 语法我们知道，Promise 实例是调用 Promise 构造函数通过 new 操作符生成的。这个构造函数我们可以先这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING <span class="comment">// 创建一个 promise 时，首先进行状态初始化。pending</span></span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span> <span class="comment">// result 属性用来缓存 promise 的返回结果，可以是成功的返回结果，或失败的返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到上面构造函数接受的参数 executor。它是一个函数，并且接受其他两个函数（resolve 和 reject）作为参数，当 resolve 函数调用后，promise 的状态转化为 fulfilled，并且执行成功返回的处理函数（不用着急后面会说到怎么添加处理函数）。当 reject 函数调用后，promise 状态转化为 rejected，并且执行失败返回的处理函数。</p><p>现在我们的代码大概是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING</span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    executor(<span class="function"><span class="params">data</span> =&gt;</span> resolveProvider(<span class="keyword">this</span>, data), err =&gt; rejectProvider(<span class="keyword">this</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveProvider</span>(<span class="params">promise, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = FULFILLED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejectProvider</span>(<span class="params">promise, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = FULFILLED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dont Repeat Yourselt！！！我们可以看到上面代码后面两个函数基本相同，其实我们可以把它整合成一个函数，在结合高阶函数的使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = status</span><br><span class="line">    promise.result = data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">        executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们的代码就看上去简洁多了。</p><h3 id="第二步：为-Promise-添加处理函数"><a href="#第二步：为-Promise-添加处理函数" class="headerlink" title="第二步：为 Promise 添加处理函数"></a>第二步：为 Promise 添加处理函数</h3><p>其实通过 new Promise(executor)已经可以生成一个 Promise 实例了，甚至我们可以通过传递到 executor 中的 resolve 和 reject 方法来改变 promise 状态，但是！现在的 promise 依然没啥卵用！！！因为我们并没有给它添加成功和失败返回的处理函数。</p><p>首先我们需要给我们的 promise 增加两个属性，successListener 和 failureListener 用来分别缓存成功处理函数和失败处理函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING</span><br><span class="line">        <span class="keyword">this</span>.successListener = []</span><br><span class="line">        <span class="keyword">this</span>.failureListener = []</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">        executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么添加处理函数呢？ECMASCRIPT 标准中说到，我们可以通过 promise 原型上面的 then 方法为 promise 添加成功处理函数和失败处理函数，可以通过 catch 方法为 promise 添加失败处理函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    promise.status = status</span><br><span class="line">    promise.result = data</span><br><span class="line">    <span class="keyword">switch</span>(status) &#123;</span><br><span class="line">        <span class="keyword">case</span> FULFILLED: <span class="keyword">return</span> promise.successListener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line">        <span class="keyword">case</span> REJECTED: <span class="keyword">return</span> promise.failurelistener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING</span><br><span class="line">        <span class="keyword">this</span>.successListener = []</span><br><span class="line">        <span class="keyword">this</span>.failurelistener = []</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">        executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Promise 原型上面的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    then(...args) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">            <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">                <span class="keyword">this</span>.successListener.push(args[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">this</span>.failurelistener.push(args[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">                args[<span class="number">0</span>](<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">                args[<span class="number">1</span>](<span class="keyword">this</span>.result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在的 Promise 基本初具雏形了。甚至可以运用到一些简单的场景中了。举个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个延时 resolve 的 pormise*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">5</span>), <span class="number">2000</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">/* 创建一个及时 resolve 的 promise*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="number">5</span>)).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">/* 链式调用 then 方法还不能够使用！*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span> resolve(<span class="number">5</span>)).then(<span class="function"><span class="params">data</span> =&gt;</span> data).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read property 'then' of undefined</span></span><br></pre></td></tr></table></figure><h3 id="第三步：Promise-的链式调用"><a href="#第三步：Promise-的链式调用" class="headerlink" title="第三步：Promise 的链式调用"></a>第三步：Promise 的链式调用</h3><p>Promise 需要实现链式调用，我们需要再次回顾下 then 方法的定义：</p><p>then 方法为 pormise 添加成功和失败的处理函数，同时 then 方法返回一个新的 promise 对象，这个新的 promise 对象 resolve 处理函数的返回值，或者当没有提供处理函数时直接 resolve 原始的值。</p><p>可以看出，promise 能够链式调用归功于 then 方法返回一个全新的 promise，并且 resolve 处理函数的返回值，当然，如果 then 方法的处理函数本身就返回一个 promise，那么久不用我们自己手动生成一个 promise 了。了解了这些，就开始动手写代码了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isPromise = <span class="function"><span class="params">object</span> =&gt;</span> object &amp;&amp; object.then &amp;&amp; <span class="keyword">typeof</span> object.then === <span class="string">'function'</span></span><br><span class="line"><span class="keyword">const</span> noop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 同上面代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line"><span class="comment">// 同上面代码</span></span><br><span class="line">&#125;</span><br><span class="line">then(...args) &#123;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(noop)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> handler = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = fn(data)</span><br><span class="line">                <span class="keyword">if</span> (isPromise(result)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> successHandler = child.successListener[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">const</span> errorHandler = child.failureListener[<span class="number">0</span>]</span><br><span class="line">        result</span><br><span class="line">        .then(successHandler, errorHandler)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    statusProvider(child, FULFILLED)(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!fn) &#123;</span><br><span class="line">                statusProvider(child, <span class="keyword">this</span>.status)(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">            <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">                <span class="keyword">this</span>.successListener.push(handler(args[<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">this</span>.failureListener.push(handler(args[<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">                handler(args[<span class="number">0</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">                handler(args[<span class="number">1</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, arg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先我们写了一个 isPromise 方法，用于判断一个对象是否是 promise。就是判断对象是否有一个 then 方法，免责声明为了实现上的简单，我们不区分 thenable 和 promise 的区别，但是我们应该是知道。所有的 promise 都是 thenable 的，而并不是所有的 thenable 对象都是 promise。（thenable 对象是指带有一个 then 方法的对象，该 then 方法其实就是一个 executor。）isPromise 的作用就是用于判断 then 方法返回值是否是一个 promise，如果是 promise，就直接返回该 promise，如果不是，就新生成一个 promise 并返回该 promise。</p><p>​由于需要链式调用，我们对 successListener 和 failureListener 中处理函数进行了重写，并不是直接 push 进去 then 方法接受的参数函数了，因为 then 方法需要返回一个 promise，所以当 then 方法里面的处理函数被执行的同时，我们也需要对 then 方法返回的这个 promise 进行处理，要么 resolve，要么 reject 掉。当然，大部分情况都是需要 resolve 掉的，只有当 then 方法没有添加第二个参数函数，同时调用 then 方法的 promise 就是 rejected 的时候，才需要把 then 方法返回的 pormise 进行 reject 处理，也就是调用 statusProvider(child, REJECTED)(data).</p><p>Promise 实现的完整代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span> <span class="comment">// Promise 的 初始状态</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span> <span class="comment">// Promise 成功返回后的状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span> <span class="comment">// Promise 失败后的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isPromise = <span class="function"><span class="params">object</span> =&gt;</span> object &amp;&amp; object.then &amp;&amp; <span class="keyword">typeof</span> object.then === <span class="string">'function'</span></span><br><span class="line"><span class="keyword">const</span> noop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> statusProvider = <span class="function">(<span class="params">promise, status</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (promise.status !== PENDING) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">promise.status = status</span><br><span class="line">promise.result = data</span><br><span class="line"><span class="keyword">switch</span>(status) &#123;</span><br><span class="line"><span class="keyword">case</span> FULFILLED: <span class="keyword">return</span> promise.successListener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line"><span class="keyword">case</span> REJECTED: <span class="keyword">return</span> promise.failureListener.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING</span><br><span class="line">    <span class="keyword">this</span>.successListener = []</span><br><span class="line">    <span class="keyword">this</span>.failureListener = []</span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">undefined</span></span><br><span class="line">    executor(statusProvider(<span class="keyword">this</span>, FULFILLED), statusProvider(<span class="keyword">this</span>, REJECTED))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Promise 原型上面的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    then(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(noop)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> handler = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = fn(data)</span><br><span class="line">                <span class="keyword">if</span> (isPromise(result)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> successHandler = child.successListener[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> errorHandler = child.failureListener[<span class="number">0</span>]</span><br><span class="line">    result</span><br><span class="line">    .then(successHandler, errorHandler)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    statusProvider(child, FULFILLED)(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!fn) &#123;</span><br><span class="line">                statusProvider(child, <span class="keyword">this</span>.status)(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.status) &#123;</span><br><span class="line">            <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">                <span class="keyword">this</span>.successListener.push(handler(args[<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">this</span>.failurelistener.push(handler(args[<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">                handler(args[<span class="number">0</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">                handler(args[<span class="number">1</span>])(<span class="keyword">this</span>.result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、怎么让我们的-toy-Promise-变强健"><a href="#四、怎么让我们的-toy-Promise-变强健" class="headerlink" title="四、怎么让我们的 toy Promise 变强健"></a>四、怎么让我们的 toy Promise 变强健</h3><p>在 ECMAScript 标准中，Promise 构造函数上面还提供了一些静态方法，比如 Promise.resolve、Promise.reject、Promsie.all、Promise.race。当我们有了上面的基础实现后，为我们的 toy Promise 添加上面这些新的功能一定能让其更加实用。</p><p>在我们的基本实现中，我们并没有区分 thenable 对象，其实 Promise.resolve 和 then 方法都可以接受一个 thenable 对象，并把该 thenable 对象转化为一个 promise 对象，如果想让我们的 toy Promise 用于生产的话，这也是要考虑的。</p><p>为了让我们的 toy Promise 变得更强壮，我们需要拥有强健的错误处理机制，比如验证 executor 必须是一个函数、then 方法的参数只能是函数或者 undefined 或 null，又比如 executor 和 then 方法中抛出的错误并不能够被 window.onerror 监测到，而只能够通过错误处理函数来处理，这也是需要考虑的因素。</p><p>如果我们的 <code>Promise polyfill</code> 是考虑支持多平台，那么首要考虑的就是浏览器环境或 Node.js 环境，其实在这两个平台，原生 Promise 都是支持两个事件的。就拿浏览器端举例：</p><p>unhandledrejection: 在一个事件循环中，如果我们没有对 promise 返回的错误进行处理，那么就会在 window 对象上面触发该事件。<br>rejectionhandled:如果在一个事件循环后，我们才去对 promise 返回的错误进行处理，那么就会在 window 对象上面监听到此事件。<br>关于这两个事件以及 node.js 平台上面类似的事件请参考 Nicholas C. Zakas 新书</p><p>Promise 能够很棒的处理异步编程，要想学好它我认为最好的方法就是亲自动手去实现一个自己的 Promise。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、JavaScript-异步编程背景&quot;&gt;&lt;a href=&quot;#一、JavaScript-异步编程背景&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript 异步编程背景&quot;&gt;&lt;/a&gt;一、JavaScript 异步编程背景&lt;/h2&gt;&lt;p&gt;​ 从去年 ES2015 发布至今，已经过去了一年多，ES2015 发布的新的语言特性中最为流行的也就莫过于 Promise 了，Promise 使得如今 JavaScript 异步编程如此轻松惬意，甚至慢慢遗忘了曾经那不堪回首的痛楚。&lt;/p&gt;
&lt;p&gt;其实从 JavaScript 诞生，JavaScript 中的异步编程就已经出现，例如点击鼠标、敲击键盘这些事件的处理函数都是异步的，时间到了 2009 年，Node.js 横空出世，在整个 Node.js 的实现中，将回调模式的异步编程机制发挥的淋漓尽致，Node 的流行也是的越来越多的 JavaScripter 开始了异步编程，但是回调模式的副作用也慢慢展现在人们眼前，错误处理不够优雅以及嵌套回调带来的“回调地狱”。&lt;/p&gt;
&lt;p&gt;这些副作用使得人们从回调模式的温柔乡中慢慢清醒过来，开始寻找更为优雅的异步编程模式，路漫漫其修远兮、吾将上下而求索。时间到了 2015 年，Promise 拯救那些苦苦探索的先驱。行使它历史使命的时代似乎已经到来。&lt;/p&gt;
&lt;p&gt;​每个事物的诞生有他的历史使命，更有其历史成因，促进其被那些探索的先驱们所发现。&lt;br&gt;了解 nodejs 或者熟悉浏览器的人都知道，JavaScript 引擎是基于事件循环或单线程这两个特性的。更为甚者在浏览器中，更新 UI(也就是浏览器重绘、重拍页面布局)和执行 JavaScript 代码也在一个单线程中，可想而知，一个线程就相当于只有一条马路，如果一辆马车抛锚在路上了阻塞了马路，那么别的马车也就拥堵在了那儿，这个单线程容易被阻塞是一个道理，单线程也只能允许某一时间点只能够执行一段代码。&lt;br&gt;同时，JavaScript 没有想它的哥哥姐姐们那么财大气粗，像 Java 或者 C++，一个线程不够，那么再加一个线程，这样就能够同时执行多段代码了，但是这样就会带来的隐患就是状态不容易维护，JavaScript 选择了单线程非阻塞式的方式，也就是异步编程的方式，就像上面的马车抛锚在了路上，那么把马车推到路边的维修站，让其他马车先过去，等马车修好了再回到马路上继续行驶，这就是单线程非阻塞方式。正如 Promise 的工作方式一样，通过 Promise 去向服务器发起一个请求，毕竟请求有网络开销，不可能马上就返回请求结果的，这个时候 Promise 就处于 pending 状态，但是其并不会阻塞其他代码的执行，当请求返回时，修改 Promise 状态为 fulfilled 或者 rejected（失败请求）。同时执行绑定到这两个状态上面的“处理函数”。这就是异步编程的模式，也就是 Promise 兢兢业业的工作方式，在下面一个部分将详细讨论 Promise。&lt;/p&gt;
&lt;h2 id=&quot;二、Promise-基础&quot;&gt;&lt;a href=&quot;#二、Promise-基础&quot; class=&quot;headerlink&quot; title=&quot;二、Promise 基础&quot;&gt;&lt;/a&gt;二、Promise 基础&lt;/h2&gt;&lt;p&gt;​ 怎么一句话解释 Promise 呢？Promise 可以代指那些尚未完成的一些操作，但是其在未来的某个时间会返回某一特定的结果。&lt;/p&gt;
&lt;p&gt;​ 当创建一个 Promise 实例后，其代表一个未知的值，在将来的某个时间会返回一个成功的返回值，或者失败的返回值，我们可以为这些返回值添加处理函数，当值返回时，处理函数被调用。Promise 总是处于下面三种状态之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pending： Promise 的初始状态，也就是未被 fulfilled 或者 rejected 的状态。&lt;/li&gt;
&lt;li&gt;fulfilled： 意味着 promise 代指的操作已经成功完成。&lt;/li&gt;
&lt;li&gt;rejected：意味着 promise 代指的操作由于某些原因失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个处于 pending 状态的 promise 可能由于某个成功返回值而发展为 fulfilled 状态，也有可能因为某些错误而进入 rejected 状态，无论是进入 fulfilled 状态或者 rejected 状态，绑定到这两种状态上面的处理函数就会被执行。并且进入 fulfilled 或者 rejected 状态也就不能再返回 pending 状态了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>今日一文：妈妈的手套</title>
    <link href="http://yoursite.com/2019/11/20/2019-11-20_Life-Wenxin-wen/"/>
    <id>http://yoursite.com/2019/11/20/2019-11-20_Life-Wenxin-wen/</id>
    <published>2019-11-20T08:38:49.000Z</published>
    <updated>2019-11-22T06:42:42.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>昨天晚上给妈妈打电话的时候，妈妈说预报里面说：明天家里要下雪了，你那边冷吗？你要多穿点衣服，不要冻着啦！</p><h2 id="妈妈的手套"><a href="#妈妈的手套" class="headerlink" title="妈妈的手套"></a>妈妈的手套</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-fed24a8c6ace4bf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手套"></p><blockquote><p>图文无关</p></blockquote><p>记得那年冬天，我上初二，学校周末放假了，我和弟弟两个人闹矛盾，然后我的手不小心被刀划伤了。小时候的我们，都不是让母亲省心的孩子。弟弟那时还小，把我划伤后就和其它的小伙伴出去玩了。妈妈听到了我的哭声，从地里回来，带着我去村上的医疗室包扎伤口。医生仔细检查完伤口，进行了消毒包扎，然后对妈妈说：现在天冷，注意手不要冻着了，不然会很麻烦的。</p><p>回家后，妈妈让我坐在椅子上烤火看电视，然后自己又到田里去忙了。我在家里看着电视，听着外面呼呼的风声，心想天可真冷啊。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-afdea73a422163cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="北风吹"></p><a id="more"></a><p>第二天是周一，我们要一大早就去学校上课，并且我要在学习住校，周末才能回家。一大早，妈妈帮我收拾好东西，临出门的时候妈妈从房间拿出来一个很 <code>丑</code> 的 <code>手套</code>，递给我然后说道：这几点带着这个，天冷了主要别冻着了。我看着手里的手套，那是一个很大的<code>手套</code>，完全不符合我现在手的尺寸;  <code>手套</code> 腕部的地方很长，手指的部分除了大拇指有一个手指外，其它的几个手指都 是一个整体、并且没有封口; 看着就像是现在我们常用的护腕，只是多了大拇指那一点；<code>手套</code> 是使用的灰色的毛线织成的。妈妈看我不太情愿，拿起 <code>手套</code> 准备套在我受伤的手上。我把手往后缩了缩，妈妈顿了顿，一把抓过我的手，边小心地往受伤的手上套边说道：不想带就别受伤啊。我突然就哭了起来，但还是任由妈妈套上了手套，期间有几次妈妈碰到了伤口，我哭的更厉害了。妈妈没有安慰我，套完手套就进屋去了，我看着外面在等我的同学，我抹了抹眼泪和他们一起到学校去了。</p><p>一离开妈妈的视线，我就尝试 <code>扯</code> 下手套，但是试了几次，单手不太方便、伤口被碰了几次，最后还是放弃了。</p><p>到学校后，受伤的手给我的生活带来了很多的不便，原来能够很快完成的事情，现在很慢才能完成，例如扣衣服、上厕所完了提裤子。</p><p>比起生活上的不便，我更在意的是同学对我 <code>手套</code> 的评论。有些同学，会问怎么回事？有些同学会直接说：手套真丑，剩下的大部分同学都选择了忽视。我还是尝试要拿掉手套，但是终究还是没成功，本来最后一次都要成功了，忽然想到了医生那句：冻坏了就麻烦了，只得作罢。之后，我把受伤的手，放在桌子下面、衣服兜里、用手护着，反正就是减少被同学看到的机会。</p><p>终于又到了回家的日子。回到家后，我没看看妈妈，在上小学的弟弟说妈妈到田里去忙了，弟弟对我说道：哥哥，对不起，我不是故意弄伤你的。你也不要怪妈妈，那个手套是妈妈那天晚上花了一晚上织成的，毛线是妈妈从爸爸的毛衣上面拆下来的。那天你走了后，妈妈在家里哭了好久。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-1964f27924a42e33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="妈妈不哭"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>天冷了，你那边冷吗？你要多穿点衣服，不要冻着啦！</p><hr><p>图片来源于网络，侵删。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;昨天晚上给妈妈打电话的时候，妈妈说预报里面说：明天家里要下雪了，你那边冷吗？你要多穿点衣服，不要冻着啦！&lt;/p&gt;
&lt;h2 id=&quot;妈妈的手套&quot;&gt;&lt;a href=&quot;#妈妈的手套&quot; class=&quot;headerlink&quot; title=&quot;妈妈的手套&quot;&gt;&lt;/a&gt;妈妈的手套&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-fed24a8c6ace4bf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;手套&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图文无关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记得那年冬天，我上初二，学校周末放假了，我和弟弟两个人闹矛盾，然后我的手不小心被刀划伤了。小时候的我们，都不是让母亲省心的孩子。弟弟那时还小，把我划伤后就和其它的小伙伴出去玩了。妈妈听到了我的哭声，从地里回来，带着我去村上的医疗室包扎伤口。医生仔细检查完伤口，进行了消毒包扎，然后对妈妈说：现在天冷，注意手不要冻着了，不然会很麻烦的。&lt;/p&gt;
&lt;p&gt;回家后，妈妈让我坐在椅子上烤火看电视，然后自己又到田里去忙了。我在家里看着电视，听着外面呼呼的风声，心想天可真冷啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-afdea73a422163cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;北风吹&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="天冷了" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E5%A4%A9%E5%86%B7%E4%BA%86/"/>
    
    
      <category term="日常生活" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="天冷了" scheme="http://yoursite.com/tags/%E5%A4%A9%E5%86%B7%E4%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>今日一文：国足又输球了</title>
    <link href="http://yoursite.com/2019/11/18/2019-11-18_Life-Wenxin-wen/"/>
    <id>http://yoursite.com/2019/11/18/2019-11-18_Life-Wenxin-wen/</id>
    <published>2019-11-18T08:26:14.000Z</published>
    <updated>2019-11-22T06:42:28.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>11 月 14 日晚，中国男足又输球了。</p><h2 id="比赛相关"><a href="#比赛相关" class="headerlink" title="比赛相关"></a>比赛相关</h2><p>11 月 14 日晚，2022 年世界杯亚洲区预选赛预赛阶段（四十强赛）A组的一场关键战役在此间打响，中国男足和叙利亚队伍的比赛正式上演。此前，中国队已踢过三场小组赛，分别以 <strong>5:0</strong> 和 <strong>7:0</strong> 战胜了马尔代夫和关岛，以 <strong>0:0</strong> 踢平菲律宾队。</p><p>比赛中中国男足在上半场扳平比分后，下半场因为一粒乌龙球以 <strong>1:2</strong> 遗憾负于小组最强对手叙利亚队，目前在小组中仅以净胜球优势排在第二位。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-11f7aa4a650f9008?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足比分"></p><p>在 <strong>1:2</strong> 不敌叙利亚队，再一次，将出线主动权拱手让出。本场战罢，中国队 2 胜 1 平 1 负积 7 分，以净胜球优势领先菲律宾队排在四十强赛 A 组的第二位，叙利亚队则以四战全胜积 12 分排名第一。依照“四十强赛”的规则，总共 40 支球队分成 8 个小组参加世界杯亚洲区的预选赛，8 个小组的第一名以及 4 个表现最佳的第二名球队也得以参加预选赛下一轮的比赛。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-9eb2079921b316e7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分组"></p><p>中国队唯一一次入围世界杯是在 2002 年的日韩世界杯，当时中国队输掉了所有三场比赛，并且未进一球。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/1940331-5509e9a7619401a0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足比赛经过"></p><p>根据亚足联安排，国足在四十强赛A组的下一轮比赛定于 2020 年 3 月 26 日举行，届时国足将在主场迎战马尔代夫队。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-76d171ffee9dcfe1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足新赛程"></p><p>在赛后新闻发布会上中国男足主教练里皮宣布辞职并承担输球责任。“我们今晚输球了，我的年薪收入非常高，这场输球我承担全部责任，所以我向大家宣布现在辞职，不再担任中国队主教练。”，没等翻译讲完，里皮便离开了新闻发布会，留下一脸茫然的记者和工作人员。对于这位拿着2300万欧元年薪、全球收入最高国家队主教练来说，他和国足的缘分，真的到头了。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-f3470af85020cae7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="里皮辞职"></p><p>11 月 15 日早上，足协官方微博上发表声明对国家队失利”深表歉意”。声明称：“接受里皮的辞职请求。并表示接下来“将会深刻反思，重组男足国家队，打好接下来的四十强赛”。”</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-ef20fb7f3ed632ee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足协道歉"></p><h2 id="中国女足的世界杯之旅"><a href="#中国女足的世界杯之旅" class="headerlink" title="中国女足的世界杯之旅"></a>中国女足的世界杯之旅</h2><p>上面是中国男足的情况，那作为另一个极端的中国女足的情况呢？</p><p>2019年法国女足世界杯上，中国女足先是 1:0 不敌德国队，后以 1:0 战胜南非队，在最后一轮则与西班牙队战平，最终以小组第三的成绩出线。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-211119c43021cb6d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="女足比赛日程"></p><p>但是在1/8决赛中 0-2 不敌意大利女足，无缘 8 强。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-a966191a7aff8ce8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="女足比赛日程"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>世界杯的比赛暂时告一段落，男足主教练“银狐”也离开了，中足协也道歉了，广大球迷也吐槽了，事件的热点也慢慢地退去了。但是，作为中国的足球事业却是刚刚起步，很多的问题需要解决。有人说是球员问题，有人说是教练问题，有人说是体制问题。其实对于广大的 “吃瓜群众” 来说，是谁的问题并不重要，重要的是什么时候才能真正的赢一场呢？</p><p>中国足球加油，中国加油…</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-71ce94dc3aff39e9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中国加油"></p><hr><p>图片来源于网络，侵删。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;11 月 14 日晚，中国男足又输球了。&lt;/p&gt;
&lt;h2 id=&quot;比赛相关&quot;&gt;&lt;a href=&quot;#比赛相关&quot; class=&quot;headerlink&quot; title=&quot;比赛相关&quot;&gt;&lt;/a&gt;比赛相关&lt;/h2&gt;&lt;p&gt;11 月 14 日晚，2022 年世界杯亚洲区预选赛预赛阶段（四十强赛）A组的一场关键战役在此间打响，中国男足和叙利亚队伍的比赛正式上演。此前，中国队已踢过三场小组赛，分别以 &lt;strong&gt;5:0&lt;/strong&gt; 和 &lt;strong&gt;7:0&lt;/strong&gt; 战胜了马尔代夫和关岛，以 &lt;strong&gt;0:0&lt;/strong&gt; 踢平菲律宾队。&lt;/p&gt;
&lt;p&gt;比赛中中国男足在上半场扳平比分后，下半场因为一粒乌龙球以 &lt;strong&gt;1:2&lt;/strong&gt; 遗憾负于小组最强对手叙利亚队，目前在小组中仅以净胜球优势排在第二位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-11f7aa4a650f9008?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;国足比分&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;1:2&lt;/strong&gt; 不敌叙利亚队，再一次，将出线主动权拱手让出。本场战罢，中国队 2 胜 1 平 1 负积 7 分，以净胜球优势领先菲律宾队排在四十强赛 A 组的第二位，叙利亚队则以四战全胜积 12 分排名第一。依照“四十强赛”的规则，总共 40 支球队分成 8 个小组参加世界杯亚洲区的预选赛，8 个小组的第一名以及 4 个表现最佳的第二名球队也得以参加预选赛下一轮的比赛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-9eb2079921b316e7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;分组&quot;&gt;&lt;/p&gt;
&lt;p&gt;中国队唯一一次入围世界杯是在 2002 年的日韩世界杯，当时中国队输掉了所有三场比赛，并且未进一球。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="世界杯" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
    
    
      <category term="日常生活" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="世界杯" scheme="http://yoursite.com/tags/%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>今日一文：三罢对香港经济的影响</title>
    <link href="http://yoursite.com/2019/11/15/2019-11-15_Life-Wenxin-wen/"/>
    <id>http://yoursite.com/2019/11/15/2019-11-15_Life-Wenxin-wen/</id>
    <published>2019-11-15T08:26:14.000Z</published>
    <updated>2019-11-22T06:42:14.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我们都知道，最近香港的局势不太稳定，暴徒们恶意破坏的行径，已经严重影响到香港居民的方方面面。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-41ab7b2376308e2c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一条满是砖块垃圾的马路"></p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-c28106337cf53a62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在沙田，一列火车因抗议者的扰乱而暂停服务，乘客被迫下车"></p><p>我们都知道，动荡的社会环境中，社会生产活动肯定会受到影响，这些影响最后将以经济数据的形式呈现出来。8 月份开始的 “三罢（罢工、罢课、罢市）” 活动，更是将对经济的影响放大了。这篇文章里，我们将尝试从香港政府已经公布的经济数据中，去发现暴力活动对香港经济造成的影响。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-20fdf6abb39bee30?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><blockquote><p>因为经济数据，具有一定的延后性，我们这里只从现有的数据出发，去分析问题。至于当下实际的情况，只能通过后续更新的数据再去分析啦。</p></blockquote><a id="more"></a><hr><h2 id="三罢对香港经济的影响"><a href="#三罢对香港经济的影响" class="headerlink" title="三罢对香港经济的影响"></a>三罢对香港经济的影响</h2><p>三罢（罢工、罢课、罢市）对经济的影响对经济的影响是巨大的。</p><p>香港私人消费总额的年度变化在今年第三季罕有地出现负增长。虽然背后的最大成因仍需科学验证，但初步认为与全球经济衰退、美中贸易战和香港的社会动荡和罢市行动有关。而私人消费 (Private Consumption) 是香港的经济产值(GDP)中占最大份额组成，2018年的占比比高达68.3% (图1)，因此每当私人消费下跌，经常伴随经济衰退。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-fa7bd48162dceffa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1 香港各项经济环节佔经济产值的百分比，2018年。资料来源：贸易发展局 (2019) [1]"></p><p>但到底是经济衰退带动私人消费下跌，还是其他外在因素引发私人消费下跌，从而令GDP下跌？这里有两种不同的说法<br>说法一：由于通胀和人口增长等因素，私人消费一般长期持续正增长，但当经济衰退，预期和实际失业人数增加，打击私人消费信心，导致私人消费下跌；<br>说法二：当外在因素如罢市行动或支持节约消费行动生效，私人消费下跌，因而造成经济衰退。</p><p>在过去大半年的香港却同时出现以上两种情况，消费下跌的真正原因仍有待进一步研究。</p><p>数据方面，私人消费的年度增长率由今年第二季的 +1.3% 转为第三季的 -3.5%，虽然跌幅比其他组别为细，但由于占比巨大，对GDP增长的影响举足轻重 (图2)：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-d20d0dfb20690132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2 香港生产总值各项分项的年度增长率，2019年第二及第三季比较，资料来源：香港统计处[2]"></p><p>私人消费的组成以「零售总值」和「食肆收益」两项最具代表，图3是过去一年零售总值的每月年度变化率，自今年2月起至最新的9月份数字均是负数，而且有持续扩大迹象，最新8、9月份的跌幅更急跌两成多，打破了过去十几年的记录。但由于早自2月份已经出现双位数跌幅，远早于罢市行动，反映部份原因与罢市和社会动动荡等近期本地因素无关。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-b364e626da46cc57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3 香港零售总值年度变化2018年9月-2019年9月。资料来源：Trading Economics"></p><p>但零售数据较难分析成因，因为随着网络科技和智能手机的普及，愈来愈多的购物是透过网购完成，而零售总值的统计仍然只限于实体零售，网购未有定期统计数据 (事实上亦较难准确统计，尤其是二手货网购平台和非本地网购等)，因此部份零售总值的下跌可能源于愈来愈多消费者由实体店购物改为网购而已，同时，当社会动荡，经常变相戒严，亦会鼓励更多消费者改为网购，因此零售总值数据对反映私人消费变化有重大缺点。</p><p>食肆收益数据亦出现类似情况，不外出用餐可改为在家用餐，但如此一来已直接造成GDP减少 (因为GDP是不计算家庭成员的家务工作产出价值)，二来也影响商用物业租用，间接影响GDP数据。</p><p>图4显示食肆收益价值指数及其年度变化，过去十年持续正增长，平均年增长4%，但自今年4月起已经出现负值 (若以收益数量指数计算，更早在2月起已经变负)，最新9月份的跌幅高达13.1%，比2009年国际金融风暴时的跌幅还要大得多。</p><p>图4 香港食肆收益价值指数及其年度变化 2009 - 2019年9月。资料来源：香港统计处 [3]</p><p>其中各类餐饮均出现大幅下跌，只有快餐继续上升，这通常反映消费信心疲弱，减少在高级食肆消费，转食较经济的快餐。</p><p>图5显示中式餐饮自2月起已经出现下跌，但6月起跌幅扩大至双位数，最新9月份跌幅更达-20.3%；非中式餐馆的收益下跌相比没有中式的严重，9月份的跌幅为-14.5%，而且负增长由4月起才出现；酒吧的收益下跌最突然，由6月起突然由正转负，且一跌就跌双位数，9月份跌幅为-18.8%，可能与旅游警示、游客减少有关。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-447a5ecf51a117ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5 香港四类食肆的收益价值指数年度变化 2009 - 2019年9月。资料来源：香港统计处 [3]"></p><p>各类私人消费自6月起均有较明显的下跌，反映6月起市场出现突变，但由于同期美中贸易谈判曾经破裂，直到10月中美之间才再次开启了新一轮的和谈，但因为10月份的数据还没有对外公布，需待下个月数据出台再作分析。</p><p>参考：</p><p>[1]  香港贸易发展局 (2019) 香港经济概况，10月25日。<br><a href="http://hong-kong-economy-research.hktdc.com/business-news/article/%E5%B8%82%E5%A0%B4%E7%92%B0%E5%A2%83/%E9%A6%99%E6%B8%AF%E7%B6%93%E8%B2%BF%E6%A6%82%E6%B3%81/etihk/tc/1/1X000000/1X09OVUL.htm" target="_blank" rel="noopener">http://hong-kong-economy-research.hktdc.com/business-news/article/%E5%B8%82%E5%A0%B4%E7%92%B0%E5%A2%83/%E9%A6%99%E6%B8%AF%E7%B6%93%E8%B2%BF%E6%A6%82%E6%B3%81/etihk/tc/1/1X000000/1X09OVUL.htm</a></p><p>[2] 香港统计处 (2019) 二零一九年第三季本地生产总值预先估计数字，香港政府 10月31日。<br><a href="https://www.censtatd.gov.hk/press_release/pressReleaseDetail.jsp?charsetID=2&amp;pressRID=4506" target="_blank" rel="noopener">https://www.censtatd.gov.hk/press_release/pressReleaseDetail.jsp?charsetID=2&amp;pressRID=4506</a></p><p>[3] 香港统计处 (2019) 表E088：按食肆类别划分的食肆收益，香港政府 11月5日。<br><a href="https://www.censtatd.gov.hk/hkstat/sub/sp320_tc.jsp?productCode=D5600088" target="_blank" rel="noopener">https://www.censtatd.gov.hk/hkstat/sub/sp320_tc.jsp?productCode=D5600088</a></p><hr><p>PS: 图片来源于互联网，侵删。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;我们都知道，最近香港的局势不太稳定，暴徒们恶意破坏的行径，已经严重影响到香港居民的方方面面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-41ab7b2376308e2c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;一条满是砖块垃圾的马路&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-c28106337cf53a62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;在沙田，一列火车因抗议者的扰乱而暂停服务，乘客被迫下车&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们都知道，动荡的社会环境中，社会生产活动肯定会受到影响，这些影响最后将以经济数据的形式呈现出来。8 月份开始的 “三罢（罢工、罢课、罢市）” 活动，更是将对经济的影响放大了。这篇文章里，我们将尝试从香港政府已经公布的经济数据中，去发现暴力活动对香港经济造成的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-20fdf6abb39bee30?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为经济数据，具有一定的延后性，我们这里只从现有的数据出发，去分析问题。至于当下实际的情况，只能通过后续更新的数据再去分析啦。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="香港" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E9%A6%99%E6%B8%AF/"/>
    
    
      <category term="日常生活" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="香港" scheme="http://yoursite.com/tags/%E9%A6%99%E6%B8%AF/"/>
    
  </entry>
  
  <entry>
    <title>今日一文-矛盾的日本人</title>
    <link href="http://yoursite.com/2019/11/14/2019-11-14_Life-Wenxin-wen/"/>
    <id>http://yoursite.com/2019/11/14/2019-11-14_Life-Wenxin-wen/</id>
    <published>2019-11-14T08:26:14.000Z</published>
    <updated>2019-11-22T06:41:54.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>早上的时候，因为工作需要和日本的客户开了个会，就是我们作为方案提供方，想客户推广公司的产品，我基本全程 <code>打酱油</code>，主讲的另外的两个同事。主要通过英语进行讲解，日本那边有一个英语翻译，复杂将双方的意思进行传达。会议讲述的内容是已经在很多场合下讲过很多次了，客户也没有问特别深奥的问题，整个过程下来感觉也没有给客户留下特别的印象。</p><p>会上的一件小事，却让我感到有点吃惊。</p><p>既然是推广，那肯定会有答疑环节，日方的翻译和同事就一个问题讨论了几分钟了，突然有个声音出现，说着日语，然后那个翻译很快地就用几句话结束了交谈。</p><p>我还在郁闷，这是怎么回事呢？怎么突然就结束啦。正当我还在疑惑的时候，旁边的同事说道：“1个小时过的真快，这就结束了”。</p><p>然后同事有顺口提到：日本人也真是的，说一小时就一小时，多一分钟都不行。我们约的一个小时的会议，我们 10 点 55 开始的会议，现在刚11：54 就结束了会议。</p><p>会后，我对这个话题比较的感兴趣，就去搜索了相关的内容。这一搜，发现了一个重要的事实：日本人对待时间这件事情上就是一个 <code>矛盾</code> 的混合体。一方面，日本人有很重的时间观念，对于 <code>守时</code> 这件事情上的表现近乎刻板。另一方面，日本人也是“加班狂人”。为什么会出现这种看似 <code>矛盾</code> 的现象呢，这背后的原因是什么呢？</p><p>顺着这个思路，来展开我们今天的话题。</p><a id="more"></a><h2 id="日本人-守时-到什么程度呢？"><a href="#日本人-守时-到什么程度呢？" class="headerlink" title="日本人 守时 到什么程度呢？"></a>日本人 <code>守时</code> 到什么程度呢？</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-52e923987fe896e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>和日本人有过接触经验的人，都对日本人的 <code>守时</code> 的时间观念印象深刻。</p><p>日本人开会从来不迟到，也不会无故延长会议时间。就想我们今天遇到的这样，说是 1 个小时的会员，一定不会开到 1 小时零 1 分。日本人守时的习惯，尤其是“不迟到”这点更是多数日本人天生养成的习惯。比如在企业、公共机构或与他人会面的方方面面，必定“正确守时”即便是准时到达也会视为“迟到”，这已成为常识。关系亲密的人之间也有迟到的，不过也会事先邮件通知。</p><p>日本人不光在私人小事上，做到守时，在很复杂的系统上也能做到守时。</p><p>日本的新干线列车的晚点时间是以分钟计算延迟的，就是说延迟 1 分钟以上就算是延迟了。作为对比，在其他国家，如意大利定为 15 分钟、英国为 10 分钟、连号称规矩严谨与日本不相上下的德国也只定为 5 分钟。几年前的一个道歉事件，曾经被广泛报道。经营日本筑波快线（Tsukuba Express）的日本首都圈新都市铁道公司原定于 11 月 14 日上午 9 点 44 分 40 秒发出，但由于操作员的失误，结果列车没有按照原定计划，在 9 点 44 分 20 秒提前 20 秒发了车。令人意想不到的是，铁路公司竟然郑重其事的在网页上发布了如下的道歉声明。日本铁路公司的电车只要晚1分钟，车内必定播放道歉的广播。而新干线的到达和出发时刻是以15秒为单位设定的。</p><p>日本的机场在守时上也不输铁路，OAG 发布的最新准点率统计表明，<code>大阪国际机场</code> 在全球小型机场中准点率排名第一，<code>东京羽田机场</code> 在名列大型机场准点排行第一。准点率是衡量一个机场成熟度的重要指标。</p><p>铁路和机场，这样复杂的系统都没有阻止日本人守时的脚步，这些复杂系统做到这么 <code>精确</code> 的守时背后，是许许多多的小个体守时的缩影，可以说，<code>守时</code> 观念已经深入了日本人的骨髓。</p><h2 id="日本人独特的-“加班文化”"><a href="#日本人独特的-“加班文化”" class="headerlink" title="日本人独特的 “加班文化”"></a>日本人独特的 “加班文化”</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-075be3d4d4be32f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果说日本人 <code>不迟到</code> 是一个特色，那与之相关的一定是另一个特色—- <code>加班文化</code>。</p><p>在日本，加班对于每一个职场人士来说是“家常便饭”，乃至于“过劳死”成为日本加班文化的一个显著特征。日本是出名的“加班大国”，在日文中有“超勤文化”的表述，有时被说成“过劳文化”。日本人以加班为荣，对他们来说加班才是常态，晚上写字楼里的灯光也有个专有名词——“劳工之光”。对不少日本男性来说，“朝6晚11”的工作模式相当普遍，这比之前国内的“996”，似乎还要厉害一点。清早从家乘地铁到公司，上班然后“例行”加班后，再和同事酌酒交际到深夜，便是正常一天的工作行程。日本妻子也大多习惯了丈夫早出晚归，甚至在很多日本女人的观念里，丈夫如果每天正常下班回家是一种在职场上无能的表现。</p><p>那是什么原因让日本的加班文化如此盛行呢？</p><p>首先，由于连年的经济不景气，日本公司不断地缩减人工规模，员工随时可能被裁员，剩下的员工不得不处理大量的工作任务来减少自己被裁的可能性，从而导致加班不可避免。</p><p>第二，日本的终身雇佣制度使得就业市场缺乏活力，员工很难跳槽寻找更好的工作，被迫工作更长时间。</p><p>第三，日本企业大多实行终身雇佣制和工龄薪酬制度，工作时间更长意味着更易获得成功，每周多工作几个小时的员工被提升到管理岗位的机会更大，同时也可以获得更多的薪酬。</p><p>第四，日本独特的职场文化：强调不带条件的服从和忠诚，以集体主义为最高目标，个人在集体中只有义务，个人的需求会被自动忽视。</p><p>第五点，日本人内向拘谨，不愿给别人添麻烦，因此，他们工作勤奋、守规则、敬业心强、对企业忠诚。</p><p>与加班文化同时伴生的一个问题是：工作效率低下。2013年日本每小时劳动生产价值为41.3美元，不到挪威的一半，在34个经合组织国家中排名20位，“日本人以工作努力闻名，但效率低下和官僚作风同样有名”，一家英国的每天曾经这样评价日本的加班文化。</p><h2 id="其实这就是真实的日本人"><a href="#其实这就是真实的日本人" class="headerlink" title="其实这就是真实的日本人"></a>其实这就是真实的日本人</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-6001b03e5fd58a72?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>近乎苛责的 <code>守时</code>  和独特的 <code>加班文化</code> 夹杂在一起的日本人，就是一对矛盾的集合体，同时，这也是最真实的日本人。</p><p>好消息是，情况正在向好的方向发展。最近几届的日本政府都在积极推动“禁止加班”，通过立法的手段来禁止 日益加剧的 <code>加班文化</code> 。同时企业也通过内部改革来减少加班文化的土壤，例如减少时薪。最近看到的消息说：微软日本公司，已经实现每周休假 3  天的制度。</p><p>没有谁的生活是容易的，简单生活，才能更好的享受生活。</p><hr><p>PS: 图片来源于互联网，侵删。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;早上的时候，因为工作需要和日本的客户开了个会，就是我们作为方案提供方，想客户推广公司的产品，我基本全程 &lt;code&gt;打酱油&lt;/code&gt;，主讲的另外的两个同事。主要通过英语进行讲解，日本那边有一个英语翻译，复杂将双方的意思进行传达。会议讲述的内容是已经在很多场合下讲过很多次了，客户也没有问特别深奥的问题，整个过程下来感觉也没有给客户留下特别的印象。&lt;/p&gt;
&lt;p&gt;会上的一件小事，却让我感到有点吃惊。&lt;/p&gt;
&lt;p&gt;既然是推广，那肯定会有答疑环节，日方的翻译和同事就一个问题讨论了几分钟了，突然有个声音出现，说着日语，然后那个翻译很快地就用几句话结束了交谈。&lt;/p&gt;
&lt;p&gt;我还在郁闷，这是怎么回事呢？怎么突然就结束啦。正当我还在疑惑的时候，旁边的同事说道：“1个小时过的真快，这就结束了”。&lt;/p&gt;
&lt;p&gt;然后同事有顺口提到：日本人也真是的，说一小时就一小时，多一分钟都不行。我们约的一个小时的会议，我们 10 点 55 开始的会议，现在刚11：54 就结束了会议。&lt;/p&gt;
&lt;p&gt;会后，我对这个话题比较的感兴趣，就去搜索了相关的内容。这一搜，发现了一个重要的事实：日本人对待时间这件事情上就是一个 &lt;code&gt;矛盾&lt;/code&gt; 的混合体。一方面，日本人有很重的时间观念，对于 &lt;code&gt;守时&lt;/code&gt; 这件事情上的表现近乎刻板。另一方面，日本人也是“加班狂人”。为什么会出现这种看似 &lt;code&gt;矛盾&lt;/code&gt; 的现象呢，这背后的原因是什么呢？&lt;/p&gt;
&lt;p&gt;顺着这个思路，来展开我们今天的话题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="矛盾" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E7%9F%9B%E7%9B%BE/"/>
    
    
      <category term="日常生活" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="矛盾" scheme="http://yoursite.com/tags/%E7%9F%9B%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>副业赚钱？ 我用自己的教训来给你指路</title>
    <link href="http://yoursite.com/2019/11/13/2019-11-13_Life-Wenxin-wen/"/>
    <id>http://yoursite.com/2019/11/13/2019-11-13_Life-Wenxin-wen/</id>
    <published>2019-11-13T08:36:39.000Z</published>
    <updated>2019-11-22T06:45:14.999Z</updated>
    
    <content type="html"><![CDATA[<p><code>副业赚钱</code>, 是每个人读梦寐以求的，毕竟 <code>躺着就能把钱挣了</code> 还是很舒服的。</p><p>最近在不断的总结和反思着一个多月以来的 <code>折腾之旅</code> , 得到了下面的几点教训。这里分享出来给大家参考。</p><h2 id="涉及的东西太多"><a href="#涉及的东西太多" class="headerlink" title="涉及的东西太多"></a>涉及的东西太多</h2><p>自从 9 月份开始说要开始自己的折腾之旅开始，先后试过下面平台及方向。</p><div class="table-container"><table><thead><tr><th>平台</th><th>内容、方向</th></tr></thead><tbody><tr><td>简书</td><td>书写、技术付费文章</td><td></td></tr><tr><td>公众号</td><td>书写、图片转载</td></tr><tr><td>头条号</td><td>图片转载</td></tr><tr><td>悟空问答</td><td>影视领域认证</td></tr><tr><td>抖音</td><td>视频搬运</td></tr><tr><td>TiTok</td><td>视频搬运</td></tr><tr><td>微视</td><td>视频搬运</td></tr><tr><td>好看视频</td><td>视频搬运</td></tr><tr><td>Youtobe</td><td>视频搬运</td></tr><tr><td>Gitbook</td><td>技术付费文章</td></tr><tr><td>小专栏</td><td>技术付费专栏</td></tr></tbody></table></div><p>还有很多就试过一两次的，然后觉得不靠谱的就不再列出来了，如果列出来这份清单会很长很长。</p><p>上面的这些内容，大部分都在上班时间抽空来完成的。质量可定也好不到哪里去，基本上可以说大部分的内容都是拼凑完成的，另外一些内容，虽然加入了自己的一些东西，但是大部分都不是太深入。</p><a id="more"></a><h2 id="没有明确的方向"><a href="#没有明确的方向" class="headerlink" title="没有明确的方向"></a>没有明确的方向</h2><p>上面的那份清单里面，已经列出来了，目前试过的方向包括</p><ul><li>技术付费文章</li><li>视频搬运</li><li>图片转载</li></ul><p>上面的每个领域，都是很大的领域，在其中的领域如果做的好，都可以做的很成功。但是毫无疑问，每个领域的成功都需要投入很多的精力，包括但不限于：时间，金钱。</p><blockquote><p>为什么是为了赚钱的，怎么还需要投入金钱呢？这里解释下原因：很多领域开始赚钱前是需要一个“门槛”的，有些门槛对新人来说感觉很高，此时适当的金钱投入，是可以帮我们快速跨过这个门槛的。</p></blockquote><h2 id="无法持续的输出"><a href="#无法持续的输出" class="headerlink" title="无法持续的输出"></a>无法持续的输出</h2><p>上面的那份清单里面的每一个，都需要持续不断的 <code>原创</code> 输出，才有可能成功。如果只是 <code>转载</code>、<code>搬运</code>、<code>洗稿</code>，成功的可能性基本没有。</p><blockquote><p>这里为什么不把话说满呢？因为现实中的的确确出现一些，<code>山寨货</code> 最后逆袭 <code>正版货</code> 的故事。福建莆田的鞋类生产就是一个很好的例子。</p></blockquote><p>为什么我们一定要坚持原创呢？因为原创是制约你走的更远的决定性条件。在刚开始的时候，你 <code>搬运</code> 了，没人会关注到你，因为你太小了。如果有一天你长大了，很多人都可以看到你的时候，你的所有问题都会暴露在众人面前，一旦发生了问题，众人的 <code>口水</code> 真的就把你淹没了,然后就真的没有然后了。</p><blockquote><p>大家可以参看下 <code>李现ins点赞</code> 的 <code>故事</code>。</p></blockquote><p>可能走的越远，越能体会到 <code>人言可畏</code> 这句话的真正威力吧。</p><hr><p>上面的内容是对自己这一段时间的复盘，下面来简短的写下自己接下来的计划。</p><h2 id="精简自己的内容"><a href="#精简自己的内容" class="headerlink" title="精简自己的内容"></a>精简自己的内容</h2><div class="table-container"><table><thead><tr><th>平台</th><th>内容、方向</th></tr></thead><tbody><tr><td>简书</td><td>书写、技术付费文章</td></tr><tr><td>公众号</td><td>书写、技术付费文章</td></tr><tr><td>Gitbook</td><td>技术付费文章</td></tr></tbody></table></div><p>之所以这么选择，理由如下：</p><ul><li><code>技术文章</code> 基本就是自己平时工作、学习的再记录。把学到的东西分享出去，不仅可以促进自己不断的学习，还能把自己的知识分享给更多的人，这是多方共赢的。</li><li><code>书写</code> 主要的目的是记录平时生活、工作，同时系统化的构建自己的知识体系。</li></ul><p>下面对着3个平台的功能进行下区分，</p><ul><li><code>简书</code> 上面是所有的内容的整合地，类似于目录的作用。</li><li><code>公众号</code> 上面主要是日常生活的中的见闻分享。通过日常的一个点，去发散开来，理论上不设任何的领域限制。</li><li><code>Gitbook</code> 上面主要是</li></ul><h2 id="持续原创输出"><a href="#持续原创输出" class="headerlink" title="持续原创输出"></a>持续原创输出</h2><p>上面提到的两个方向都是需要持续不断的更新内容，才能看到后来的光明。<br>其实对于各个行业都需要持续不断的的产出，才有可能成功。坚持下来，才有可能看到阳光；如果不坚持，一定就看不到阳光。</p><p>即使 <code>强</code> 如李佳琦也会有翻船的时候。</p><blockquote><p>具体事件可以参见这篇文章 <a href="https://new.qq.com/rain/a/20191105A0PNQX00" target="_blank" rel="noopener">https://new.qq.com/rain/a/20191105A0PNQX00</a></p></blockquote><p>虽然李佳琦带货会翻车，但是不可否认李佳琦的带货能力，毕竟他是曾经打败过 <code>马爸爸</code> 的男人。</p><p>上面写就是我这一段时间来的总结，是一个悲伤的故事，说出来让大家笑一笑。</p><p>最后附上我的微信公众号，欢迎大家关注。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-9b2b8d44ef7010f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" &quot;you的日常&quot; 公众号 "></p><blockquote><p>有需要的朋友，请到评论区留言吧，我们来互相关注啊。</p></blockquote><p>希望大家都能够早日通过 “副业” 赚到钱。</p><p>加油…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;副业赚钱&lt;/code&gt;, 是每个人读梦寐以求的，毕竟 &lt;code&gt;躺着就能把钱挣了&lt;/code&gt; 还是很舒服的。&lt;/p&gt;
&lt;p&gt;最近在不断的总结和反思着一个多月以来的 &lt;code&gt;折腾之旅&lt;/code&gt; , 得到了下面的几点教训。这里分享出来给大家参考。&lt;/p&gt;
&lt;h2 id=&quot;涉及的东西太多&quot;&gt;&lt;a href=&quot;#涉及的东西太多&quot; class=&quot;headerlink&quot; title=&quot;涉及的东西太多&quot;&gt;&lt;/a&gt;涉及的东西太多&lt;/h2&gt;&lt;p&gt;自从 9 月份开始说要开始自己的折腾之旅开始，先后试过下面平台及方向。&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;平台&lt;/th&gt;
&lt;th&gt;内容、方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;简书&lt;/td&gt;
&lt;td&gt;书写、技术付费文章&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;公众号&lt;/td&gt;
&lt;td&gt;书写、图片转载&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;头条号&lt;/td&gt;
&lt;td&gt;图片转载&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;悟空问答&lt;/td&gt;
&lt;td&gt;影视领域认证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;抖音&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TiTok&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;微视&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;好看视频&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Youtobe&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gitbook&lt;/td&gt;
&lt;td&gt;技术付费文章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;小专栏&lt;/td&gt;
&lt;td&gt;技术付费专栏&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;还有很多就试过一两次的，然后觉得不靠谱的就不再列出来了，如果列出来这份清单会很长很长。&lt;/p&gt;
&lt;p&gt;上面的这些内容，大部分都在上班时间抽空来完成的。质量可定也好不到哪里去，基本上可以说大部分的内容都是拼凑完成的，另外一些内容，虽然加入了自己的一些东西，但是大部分都不是太深入。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="副业" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E5%89%AF%E4%B8%9A/"/>
    
    
      <category term="日常生活" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="副业" scheme="http://yoursite.com/tags/%E5%89%AF%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>Python-高级-使用MongoDB</title>
    <link href="http://yoursite.com/2018/11/03/2018-11-03_Programing-Python-Advanced-use-mongoDB/"/>
    <id>http://yoursite.com/2018/11/03/2018-11-03_Programing-Python-Advanced-use-mongoDB/</id>
    <published>2018-11-03T06:34:06.000Z</published>
    <updated>2019-11-22T06:21:32.031Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Python使用MongoDB"><a href="#Python使用MongoDB" class="headerlink" title="Python使用MongoDB"></a>Python使用MongoDB</h2><p>MongoDB相对于传统的关系型数据库，可以存储JSON数据，非常适合存储数据抓取返回的JSON数据。<br>今天主要学习的是使用Python连接MongoDB，并进行增删改查的操作。</p><blockquote><p>MongoDB 的安装及使用，请参照官方文档。<br><a href="https://api.mongodb.com/python/current/installation.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/installation.html</a></p></blockquote><p>在连接MongoDB前 首先要安装的是Python包：PyMongo，包的安装非常的简单。<br>只需执行 <code>pip install pymongo</code> 即可使用。</p><h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>在安装完PyMongo以后，使用Python连接MongoDB变得异常简单。具体方式为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"> </span><br><span class="line">client = MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br></pre></td></tr></table></figure><br>或使用如下方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"> </span><br><span class="line">client = MongoClient(<span class="string">'mongodb://localhost:27017'</span>)</span><br></pre></td></tr></table></figure><br>如果连接含有账号密码等，请参考：<br><a href="https://api.mongodb.com/python/current/api/pymongo/mongo_client.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/api/pymongo/mongo_client.html</a></p><a id="more"></a><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>连接数据库的操作也非常的简单，最为重要的是，在你连接数据库之前无需先创建数据库，如果数据库存在则直接连接，如果数据库不存在则会创建新的库。具体方式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">db = client.pymongo_test</span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">db = client[<span class="string">'pymongo_test'</span>]</span><br></pre></td></tr></table></figure><p>以上两种方式任选一种即可。</p><h3 id="Collection概念"><a href="#Collection概念" class="headerlink" title="Collection概念"></a>Collection概念</h3><p>在MongoDB中存在一个Collection的概念，我将其理解为命名空间，类似其他数据库中Scheme的概念，Collection可以理解为一些表的集合。Collection可以使用也可以不使用，具体看你是否要给库下的表分类。相关的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法一：</span></span><br><span class="line">collection = db.test_collection</span><br><span class="line"><span class="comment">#方法二</span></span><br><span class="line">collection = db[<span class="string">'test-collection'</span>]</span><br></pre></td></tr></table></figure><br>需要知晓的是，collection的创建是在第一张表创建时才会创建。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入数据的方式的凡是非常的简单，最长使用的方法是，<code>insert_one()</code>和<code>inert_many()</code>方法，从字面上就可以看出来一个是插入一条数据，另外一个是插入多条数据，示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"> </span><br><span class="line">client = MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br><span class="line">db = client.testdb</span><br><span class="line">posts = db.posts</span><br><span class="line"> </span><br><span class="line">post_1 = &#123;</span><br><span class="line">    <span class="string">'title'</span>: <span class="string">'Python and MongoDB'</span>,</span><br><span class="line">    <span class="string">'content'</span>: <span class="string">'PyMongo is fun'</span>,</span><br><span class="line">    <span class="string">'author'</span>: <span class="string">'saul'</span></span><br><span class="line">&#125;</span><br><span class="line">post_2 = &#123;</span><br><span class="line">    <span class="string">'title'</span>: <span class="string">'Virtual Environments'</span>,</span><br><span class="line">    <span class="string">'content'</span>: <span class="string">'Use virtual environments'</span>,</span><br><span class="line">    <span class="string">'author'</span>: <span class="string">'Scott'</span></span><br><span class="line">&#125;</span><br><span class="line">post_3 = &#123;</span><br><span class="line">    <span class="string">'title'</span>: <span class="string">'Learning Python'</span>,</span><br><span class="line">    <span class="string">'content'</span>: <span class="string">'Learn Python, it is easy'</span>,</span><br><span class="line">    <span class="string">'author'</span>: <span class="string">'Bill'</span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">#每次插入一条数据</span></span><br><span class="line">posts.insert_one(post_1)</span><br><span class="line">posts.insert_one(post_2)</span><br><span class="line">posts.insert_one(post_3)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#一次插入多条数据</span></span><br><span class="line">posts.insert_many([post_1, post_2, post_3])</span><br></pre></td></tr></table></figure></p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>和插入数据一样，查询数据的时候，提供查询一条或多条数据的方法，方法分别为<code>find_one()</code>和<code>find()</code>。示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询一条数据</span></span><br><span class="line">bills_post = posts.find_one(&#123;<span class="string">'author'</span>: <span class="string">'Bill'</span>&#125;)</span><br><span class="line">print(bills_post)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查询多条数据</span></span><br><span class="line">scotts_posts = posts.find(&#123;<span class="string">'author'</span>: <span class="string">'Scott'</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> post <span class="keyword">in</span> scotts_posts:</span><br><span class="line">    print(post)</span><br></pre></td></tr></table></figure><br>另外，查询多条时，可以设定返回的数量或其他限定条件：<br><a href="https://api.mongodb.com/python/current/api/pymongo/collection.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/api/pymongo/collection.html</a></p><p>另外条件中如需支持类似的关系数据库中的WHERE条件，需要使用特定的关键词。示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = datetime.datetime(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">for</span> post <span class="keyword">in</span> posts.find(&#123;<span class="string">"date"</span>: &#123;<span class="string">"$lt"</span>: d&#125;&#125;).sort(<span class="string">"author"</span>):</span><br><span class="line">    pprint.pprint(post)</span><br></pre></td></tr></table></figure></p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除数据同样非常的简单，主要用到的方法为：<code>delete_one()</code>和<code>delete_many()</code>。</p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>更新数据的主要方法是，<code>update_one()</code>和<code>update_many()</code>，除此之外，还有一个<code>replace_one()</code>方法用来替换，由于用的不多，具体看文档。</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>pyMongo还支持创建索引，可以进一步提升查询的性能，示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = db.profiles.create_index([(<span class="string">'user_id'</span>, pymongo.ASCENDING)],unique=<span class="literal">True</span>)</span><br><span class="line">sorted(list(db.profiles.index_information()))</span><br></pre></td></tr></table></figure><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://api.mongodb.com/python/current/tutorial.html" target="_blank" rel="noopener">https://api.mongodb.com/python/current/tutorial.html</a><br><a href="https://docs.mongodb.com/manual/indexes/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/indexes/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;Python使用MongoDB&quot;&gt;&lt;a href=&quot;#Python使用MongoDB&quot; class=&quot;headerlink&quot; title=&quot;Python使用MongoDB&quot;&gt;&lt;/a&gt;Python使用MongoDB&lt;/h2&gt;&lt;p&gt;MongoDB相对于传统的关系型数据库，可以存储JSON数据，非常适合存储数据抓取返回的JSON数据。&lt;br&gt;今天主要学习的是使用Python连接MongoDB，并进行增删改查的操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MongoDB 的安装及使用，请参照官方文档。&lt;br&gt;&lt;a href=&quot;https://api.mongodb.com/python/current/installation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://api.mongodb.com/python/current/installation.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在连接MongoDB前 首先要安装的是Python包：PyMongo，包的安装非常的简单。&lt;br&gt;只需执行 &lt;code&gt;pip install pymongo&lt;/code&gt; 即可使用。&lt;/p&gt;
&lt;h3 id=&quot;创建连接&quot;&gt;&lt;a href=&quot;#创建连接&quot; class=&quot;headerlink&quot; title=&quot;创建连接&quot;&gt;&lt;/a&gt;创建连接&lt;/h3&gt;&lt;p&gt;在安装完PyMongo以后，使用Python连接MongoDB变得异常简单。具体方式为：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; pymongo &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; MongoClient&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;client = MongoClient(&lt;span class=&quot;string&quot;&gt;&#39;localhost&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27017&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;或使用如下方式：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; pymongo &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; MongoClient&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;client = MongoClient(&lt;span class=&quot;string&quot;&gt;&#39;mongodb://localhost:27017&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;如果连接含有账号密码等，请参考：&lt;br&gt;&lt;a href=&quot;https://api.mongodb.com/python/current/api/pymongo/mongo_client.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://api.mongodb.com/python/current/api/pymongo/mongo_client.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python-高级-聊一聊 Flask 的 jsonify</title>
    <link href="http://yoursite.com/2018/07/07/2018-07-07_Programing-Python-Advanced-jsonify-in-Flask/"/>
    <id>http://yoursite.com/2018/07/07/2018-07-07_Programing-Python-Advanced-jsonify-in-Flask/</id>
    <published>2018-07-07T05:52:49.000Z</published>
    <updated>2019-11-22T06:23:20.171Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们来看一段 Python 代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 python_mastery 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/python_mastery'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 pythonml 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/pythonml'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: tasks&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>在这段代码里面，我们看到了今天的主角 <code>jsonify</code>。</p><p>Flask 框架里，可以用 <code>jsonify</code> 返回 json 数据，但是为什么不用 <code>Python</code> 自带的 <code>json</code> 模块返回 JSON 数据呢？</p><a id="more"></a><hr><h2 id="其实是一样"><a href="#其实是一样" class="headerlink" title="其实是一样"></a>其实是一样</h2><p>其实，<code>jsonify</code> 在处理数据过程中，对数据做 JSON 序列化处理时，用的是 <code>itsdangerous</code> 模块里的 JSON ，让我们看一下，这个模块里的 JSON 是如何引入的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> simplejson <span class="keyword">as</span> json</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><p>它会先尝试引入<code>simplejson</code>，如果没有安装这个模块，则引入 Python 原生模。</p><p>在Flask框架中，引入过程如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> json <span class="keyword">as</span> _json</span><br></pre></td></tr></table></figure><p>对于数据的序列化处理，用的正是 <code>_json</code>.</p><hr><h2 id="Content-Type-的差别"><a href="#Content-Type-的差别" class="headerlink" title="Content-Type 的差别"></a>Content-Type 的差别</h2><p>前面讲到，<code>jsonify</code> 和 <code>json</code> 是殊途同归，那么为什么要费周折绕这么一圈呢?</p><p>肯定存在一个合理的原因让 <code>jsonify</code>存在的有意义。</p><p>这个原因就是 <code>Content-Type</code></p><p>看下面两段代码</p><p><strong>第一段代码</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  jsonify</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/json')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json</span><span class="params">()</span>:</span></span><br><span class="line">    data = &#123;<span class="string">'name'</span>: <span class="string">'lilei'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(data)</span><br><span class="line"></span><br><span class="line">app.run(host=<span class="string">"0.0.0.0"</span>, port=<span class="number">9877</span>)</span><br></pre></td></tr></table></figure></p><p>在浏览器里输入<a href="http://127.0.0.1:9877/json," target="_blank" rel="noopener">http://127.0.0.1:9877/json</a>， 得到的结果是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"age"</span>:<span class="number">30</span>,<span class="string">"name"</span>:<span class="string">"lilei"</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>第二段代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## json</span><br><span class="line">import json</span><br><span class="line">from flask import Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/json&apos;)</span><br><span class="line">def test_json():</span><br><span class="line">    data = &#123;&apos;name&apos;: &apos;lilei&apos;, &apos;age&apos;: 30&#125;</span><br><span class="line">    return json.dumps(data)</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;, port=9877)</span><br></pre></td></tr></table></figure></p><p>在浏览器里输入<a href="http://127.0.0.1:9877/json," target="_blank" rel="noopener">http://127.0.0.1:9877/json</a>， 得到的结果是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>: <span class="string">"lilei"</span>, <span class="string">"age"</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><p>从内容上看，两种方法没有区别。<br>但是使用  <code>jsonify</code> 时，返回的 <code>http response</code>  的 <code>Content-Type</code> 是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p>而使用json.dumps时，Content-Type则是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure><p>既然返回的是 json 数据，那么自然要指明 <code>Content-Type</code> 是 <code>application/json</code> ， 这样做是符合 HTTP 协议的规定的，这就是使用 <code>jsonify</code> 的原因之一。</p><hr><h2 id="减小数据量"><a href="#减小数据量" class="headerlink" title="减小数据量"></a>减小数据量</h2><p>使用 <code>jsonify</code> 除了让返回的 `http response符合 HTTP 协议，同时也对数据做了压缩处理，让数据体积更小。</p><p>仔细比较上面两种方法返回的数据，虽然内容相同，但 <code>jsonify</code> 返回的数据，每个 <code>key-value</code> 对之间的逗号，和每个 <code>key</code> 与 <code>value</code> 之间的冒号后面都是没有空格的，而 <code>json.dumps</code> 返回的数据里，却在逗号和冒号后面存在空格，因此即便内容相同，<code>jsonify</code> 返回的数据体积更小，更节省流量。</p><p>其实，<code>json.dumps</code> 也可以将这些不必要的空格去掉，看下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">'name'</span>: <span class="string">'lilei'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">print(json.dumps(data, separators=(<span class="string">','</span>, <span class="string">':'</span>)))</span><br><span class="line">print(json.dumps(data))</span><br></pre></td></tr></table></figure><p>输出结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;lilei&quot;,&quot;age&quot;:30&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;lilei&quot;, &quot;age&quot;: 30&#125;</span><br></pre></td></tr></table></figure></p><p>只需要在 <code>dumps</code> 参数里指定   <code>separators</code> 即可，其实在 <code>jsonify</code> 里就是这么干的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们来看一段 Python 代码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Flask, jsonify&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app = Flask(__name__)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tasks = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;id&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;title&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;u&#39;订阅 python_mastery 专栏&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;description&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;u&#39;专栏Link： https://xiaozhuanlan.com/python_mastery&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;id&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;title&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;u&#39;订阅 pythonml 专栏&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;description&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;u&#39;专栏Link： https://xiaozhuanlan.com/pythonml&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@app.route(&#39;/api/v1.0/tasks&#39;, methods=[&#39;GET&#39;])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_tasks&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; jsonify(&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;tasks&#39;&lt;/span&gt;: tasks&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&#39;__main__&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    app.run(debug=&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这段代码里面，我们看到了今天的主角 &lt;code&gt;jsonify&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Flask 框架里，可以用 &lt;code&gt;jsonify&lt;/code&gt; 返回 json 数据，但是为什么不用 &lt;code&gt;Python&lt;/code&gt; 自带的 &lt;code&gt;json&lt;/code&gt; 模块返回 JSON 数据呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Web 应用加速</title>
    <link href="http://yoursite.com/2018/04/29/2018-04-29-Programing-Java-Spring-Boot-App-speeded-up/"/>
    <id>http://yoursite.com/2018/04/29/2018-04-29-Programing-Java-Spring-Boot-App-speeded-up/</id>
    <published>2018-04-29T07:22:40.000Z</published>
    <updated>2019-11-22T07:26:47.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-Web-应用加速"><a href="#Spring-Boot-Web-应用加速" class="headerlink" title="Spring Boot Web 应用加速"></a>Spring Boot Web 应用加速</h1><p>默认情况下，Spring Boot Web 应用会装配一些功能组件 Bean。</p><p>在大多数 Web 应用场景下，可以选择性地关闭一下自动装配的Spring 组件 Bean，以达到提升性能的目的。</p><h2 id="配置项优化"><a href="#配置项优化" class="headerlink" title="配置项优化"></a>配置项优化</h2><h3 id="Spring-Boot-Web-应用加速-完整配置项"><a href="#Spring-Boot-Web-应用加速-完整配置项" class="headerlink" title="Spring Boot Web 应用加速 完整配置项"></a>Spring Boot Web 应用加速 完整配置项</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">management.add-application-context-header</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">spring.mvc.formcontent.putfilter.enabled</span> = <span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure><h3 id="配置项汇总"><a href="#配置项汇总" class="headerlink" title="配置项汇总"></a>配置项汇总</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration,\</span></span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="关闭-Web-请求跟踪-自动装配"><a href="#关闭-Web-请求跟踪-自动装配" class="headerlink" title="关闭 Web 请求跟踪 自动装配"></a>关闭 Web 请求跟踪 自动装配</h3><h4 id="org-springframework-boot-actuate-autoconfigure-TraceWebFilterAutoConfiguration"><a href="#org-springframework-boot-actuate-autoconfigure-TraceWebFilterAutoConfiguration" class="headerlink" title="org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration"></a><code>org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration</code></h4><p>顾名思义，该自动装配用跟踪 Web 请求，通过Servlet Filter <code>org.springframework.boot.actuate.trace.WebRequestTraceFilter</code> 记录请求的信息（如：请求方法、请求头以及请求路径等），其计算的过程存在一定的开销，使用场景罕见，故可选择关闭。</p><ul><li>配置项</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure><h4 id="org-springframework-boot-actuate-autoconfigure-TraceRepositoryAutoConfiguration"><a href="#org-springframework-boot-actuate-autoconfigure-TraceRepositoryAutoConfiguration" class="headerlink" title="org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration"></a><code>org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration</code></h4><p>当<code>org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration</code>关闭后，其请求信息存储介质<code>org.springframework.boot.actuate.trace.TraceRepository</code>没有存在的必要，故可选择关闭。</p><ul><li>配置项</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration</span></span><br></pre></td></tr></table></figure><h3 id="关闭-Web-请求结果指标-自动装配"><a href="#关闭-Web-请求结果指标-自动装配" class="headerlink" title="关闭 Web 请求结果指标 自动装配"></a>关闭 Web 请求结果指标 自动装配</h3><h4 id="org-springframework-boot-actuate-autoconfigure-MetricFilterAutoConfiguration"><a href="#org-springframework-boot-actuate-autoconfigure-MetricFilterAutoConfiguration" class="headerlink" title="org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration"></a><code>org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</code></h4><p>该组件将自动装配<code>org.springframework.boot.actuate.autoconfigure.MetricsFilter</code>，该 Filter</p><p>主要记录Web 请求结果指标（如：相应状态码、请求方法执行时间等），该信息一定程度上与反向代理服务器（nginx）功能重叠，故可选择关闭。</p><ul><li>配置项</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.autoconfigure.exclude</span> = <span class="string">org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration</span></span><br></pre></td></tr></table></figure><h3 id="可关闭-Servlet-Web-组件"><a href="#可关闭-Servlet-Web-组件" class="headerlink" title="可关闭 Servlet Web 组件"></a>可关闭 Servlet Web 组件</h3><h4 id="org-springframework-web-filter-HttpPutFormContentFilter"><a href="#org-springframework-web-filter-HttpPutFormContentFilter" class="headerlink" title="org.springframework.web.filter.HttpPutFormContentFilter"></a><code>org.springframework.web.filter.HttpPutFormContentFilter</code></h4><ul><li>引入版本</li></ul><p><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 由 Spring<br>Framework 3.1 版本引入，分发在 <code>org.springframework:spring-web</code> 中。</p><ul><li>使用场景</li></ul><p>通常 Web 场景中，浏览器通过 HTTP <code>GET</code> 或者 <code>POST</code> 请求 提交 Form 数据，而非浏览<br>器客户端（如应用程序）可能通过 HTTP <code>PUT</code> 请求来实现。</p><p>当 HTTP 请求头<code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 时<br>，Form 数据被 encoded。而 Servlet 规范中， <code>ServletRequest.getParameter*()</code><br>方法仅对 HTTP <code>POST</code> 方法支持请求参数的获取，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> intetfacce ServletRequest &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name);</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故 以上方法无法支持 HTTP <code>PUT</code> 或 HTTP <code>PATCH</code> 请求方法（请求头<code>Content-Type</code><br>为<code>application/x-www-form-urlencoded</code>）。</p><p><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 正是这种场景的解<br>决方案。</p><p>Spring Boot 默认场景下，将<br><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 被<br><code>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration</code> 自动<br>装配，以下为 Spring Boot 1.4.1.RELEASE 以及更好版本定义（可能存在一定的差异）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span>, <span class="title">WebMvcConfigurerAdapter</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">WebMvcConfigurationSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureOrder</span>(<span class="title">Ordered</span>.<span class="title">HIGHEST_PRECEDENCE</span> + 10)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HttpPutFormContentFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.mvc.formcontent.putfilter"</span>, name = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderedHttpPutFormContentFilter <span class="title">httpPutFormContentFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderedHttpPutFormContentFilter();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，<code>org.springframework.web.filter.HttpPutFormContentFilter</code> 在绝大<br>多数 Web 使用场景下为非必须组件。</p><ul><li>配置项</li></ul><p>如果应用依赖 Spring Boot 版本 为 1.4.1.RELEASE 以及更高的版本，可通过如下配置，<br>进行将 <code>org.springframework.web.filter.HttpPutFormContentFilter</code> 关闭：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mvc.formcontent.putfilter.enabled</span> = <span class="string">false</span></span><br></pre></td></tr></table></figure><h4 id="org-springframework-web-filter-HiddenHttpMethodFilter"><a href="#org-springframework-web-filter-HiddenHttpMethodFilter" class="headerlink" title="org.springframework.web.filter.HiddenHttpMethodFilter"></a><code>org.springframework.web.filter.HiddenHttpMethodFilter</code></h4><ul><li>引入版本</li></ul><p><code>org.springframework.web.filter.HiddenHttpMethodFilter</code> 由 Spring<br>Framework 3.0 版本引入，分发在 <code>org.springframework:spring-web</code> 中。</p><ul><li>使用场景</li></ul><p>当 Web 服务端同一资源（URL）提供了多请求方法的实现，例如 URI ：/update 提供了<br>HTTP <code>POST</code> 以及 HTTP <code>PUT</code> 实现），通常 Web 场景中，浏览器仅支持 HTTP <code>GET</code><br>或者 <code>POST</code> 请求方法，这样的话，浏览器无法发起 HTTP <code>PUT</code> 请求。</p><p>为了浏览器可以消费 HTTP <code>PUT</code> 资源， 需要在服务端将 HTTP <code>POST</code> 转化成<br>HTTP <code>PUT</code> 请求，为了解决这类问题，Spring 引入<br><code>org.springframework.web.filter.HiddenHttpMethodFilter</code> Web 组件。</p><p>当浏览器 发起 HTTP <code>POST</code> 请求时，可通过增加请求参数（默认参数名称：”_method”）<br>的方式，进行HTTP 请求方法切换，<br><code>org.springframework.web.filter.HiddenHttpMethodFilter</code> 获取参数”_method”<br>值后，将参数值作为 <code>HttpServletRequest#getMethod()</code>的返回值，给后续 <code>Servlet</code><br>实现使用。</p><p>出于通用性的考虑，<code>org.springframework.web.filter.HiddenHttpMethodFilter</code><br>通过调用 <code>#setMethodParam(String)</code> 方法，来修改转换请求方法的参数名称。</p><p>Spring Boot 默认场景下，将<br><code>org.springframework.web.filter.HttpPutFormContentFilter</code> 被<br><code>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration</code> 自动<br>装配，以下为 Spring Boot 1.4.1.RELEASE 以及更好版本定义（可能存在一定的差异）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span>, <span class="title">WebMvcConfigurerAdapter</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">WebMvcConfigurationSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureOrder</span>(<span class="title">Ordered</span>.<span class="title">HIGHEST_PRECEDENCE</span> + 10)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>,<span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(HiddenHttpMethodFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">OrderedHiddenHttpMethodFilter</span> <span class="title">hiddenHttpMethodFilter</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，<code>org.springframework.web.filter.HiddenHttpMethodFilter</code> 也是特殊<br>场景下所需，故可以关闭之。</p><ul><li>配置项</li></ul><p>按目前最新的 Spring Boot 1.5.2.RELEASE 版本中实现，也没有提供类似<br><code>spring.mvc.formcontent.putfilter.enabled</code> 这样的配置项关闭，无法关闭。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-Boot-Web-应用加速&quot;&gt;&lt;a href=&quot;#Spring-Boot-Web-应用加速&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot Web 应用加速&quot;&gt;&lt;/a&gt;Spring Boot Web 应用加速&lt;/h1&gt;&lt;p&gt;默认情况下，Spring Boot Web 应用会装配一些功能组件 Bean。&lt;/p&gt;
&lt;p&gt;在大多数 Web 应用场景下，可以选择性地关闭一下自动装配的Spring 组件 Bean，以达到提升性能的目的。&lt;/p&gt;
&lt;h2 id=&quot;配置项优化&quot;&gt;&lt;a href=&quot;#配置项优化&quot; class=&quot;headerlink&quot; title=&quot;配置项优化&quot;&gt;&lt;/a&gt;配置项优化&lt;/h2&gt;&lt;h3 id=&quot;Spring-Boot-Web-应用加速-完整配置项&quot;&gt;&lt;a href=&quot;#Spring-Boot-Web-应用加速-完整配置项&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot Web 应用加速 完整配置项&quot;&gt;&lt;/a&gt;Spring Boot Web 应用加速 完整配置项&lt;/h3&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;management.add-application-context-header&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;spring.mvc.formcontent.putfilter.enabled&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;spring.autoconfigure.exclude&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;配置项汇总&quot;&gt;&lt;a href=&quot;#配置项汇总&quot; class=&quot;headerlink&quot; title=&quot;配置项汇总&quot;&gt;&lt;/a&gt;配置项汇总&lt;/h3&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;spring.autoconfigure.exclude&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration,\&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Java/"/>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Java/Spring-Boot/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 注解驱动</title>
    <link href="http://yoursite.com/2017/11/28/2017-12-28-Programing-Java-Dubbo-Annotation-Driven/"/>
    <id>http://yoursite.com/2017/11/28/2017-12-28-Programing-Java-Dubbo-Annotation-Driven/</id>
    <published>2017-11-28T07:28:13.000Z</published>
    <updated>2019-11-22T07:40:49.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo-注解驱动（Annotation-Driven）"><a href="#Dubbo-注解驱动（Annotation-Driven）" class="headerlink" title="Dubbo 注解驱动（Annotation-Driven）"></a>Dubbo 注解驱动（Annotation-Driven）</h1><h2 id="注解驱动（Annotation-Driven）"><a href="#注解驱动（Annotation-Driven）" class="headerlink" title="注解驱动（Annotation-Driven）"></a>注解驱动（Annotation-Driven）</h2><h3 id="DubboComponentScan"><a href="#DubboComponentScan" class="headerlink" title="@DubboComponentScan"></a><code>@DubboComponentScan</code></h3><h4 id="起始版本：-2-5-7"><a href="#起始版本：-2-5-7" class="headerlink" title="起始版本： 2.5.7"></a>起始版本： <code>2.5.7</code></h4><h4 id="lt-dubbo-annotation-gt-历史遗留问题"><a href="#lt-dubbo-annotation-gt-历史遗留问题" class="headerlink" title="&lt;dubbo:annotation&gt;历史遗留问题"></a><code>&lt;dubbo:annotation&gt;</code>历史遗留问题</h4><h5 id="1-注解支持不充分"><a href="#1-注解支持不充分" class="headerlink" title="1. 注解支持不充分"></a>1. 注解支持不充分</h5><p>在 Dubbo <code>2.5.7</code>之前的版本 ，Dubbo 提供了两个核心注解 <code>@Service</code> 以及 <code>@Reference</code>，分别用于 Dubbo 服务提供和 Dubbo 服务引用。</p><p>其中，<code>@Service</code> 作为 XML 元素 <code>&lt;dubbo:service&gt;</code>的替代注解，与 Spring Framework <code>@org.springframework.stereotype.Service</code> 类似，用于服务提供方 Dubbo 服务暴露。与之相对应的<code>@Reference</code>，则是替代<code>&lt;dubbo:reference</code> 元素，类似于 Spring 中的 <code>@Autowired</code>。</p><p><code>2.5.7</code> 之前的 Dubbo，与早期的 Spring Framework 2.5 存在类似的不足，即注解支持不够充分。注解需要和 XML 配置文件配合使用，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"annotation-provider"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"127.0.0.1:4548"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.alibaba.dubbo.config.spring.annotation.provider"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="2-Service-Bean-不支持-Spring-AOP"><a href="#2-Service-Bean-不支持-Spring-AOP" class="headerlink" title="2. @Service Bean 不支持 Spring AOP"></a>2. <code>@Service</code> Bean 不支持 Spring AOP</h5><p>同时，使用 <code>&lt;dubbo:annotation&gt;</code> 方式扫描后的 Dubbo <code>@Service</code> ，在 Spring 代理方面存在问题，如 GitHub 上的 issue <a href="https://github.com/alibaba/dubbo/issues/794：" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/794：</a></p><blockquote><p>关于 dubbo @Service 注解生成 ServiceBean 时, interface 获取成 spring 的代理对象的 bug</p><blockquote><p>在项目里， 我使用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@com</span>.alibaba.dubbo.config.annotation.Service</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SUserJpushServiceImp</span></span></span><br></pre></td></tr></table></figure><p>的形式， 来暴露服务。但是在发布服务的时候， interface class 是通过<br><code>serviceConfig.setInterface(bean.getClass().getInterfaces()[0]);</code><br>的形式获取， 刚好， 我的 service 都使用了@Transactional 注解， 对象被代理了。所以获取到的 interface 是 Spring 的代理接口…</p></blockquote></blockquote><p>不少热心的小伙伴不仅发现这个历史遗留问题，而且提出了一些修复方案。同时，为了更好地适配 Spring 生命周期以及将 Dubbo 完全向注解驱动编程模型过渡，因此，引入了全新 Dubbo 组件扫描注解 - <code>@DubboComponentScan</code>。</p><blockquote><p>注： <code>&lt;dubbo:annotation&gt;</code> Spring AOP 问题将在 <code>2.5.9</code> 中修复：<a href="https://github.com/alibaba/dubbo/issues/1125" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/1125</a></p></blockquote><h5 id="3-Reference-不支持字段继承性"><a href="#3-Reference-不支持字段继承性" class="headerlink" title="3. @Reference 不支持字段继承性"></a>3. @Reference 不支持字段继承性</h5><p>假设有一个 Spring Bean <code>AnnotationAction</code> 直接通过字段<code>annotationService</code> 标记 <code>@Reference</code> 引用 <code>AnnotationService</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.examples.annotation.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.examples.annotation.api.AnnotationService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"annotationAction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>AnnotationAction</code> 被 XML 元素 <code>&lt;dubbo:annotation&gt;</code> 扫描后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">"com.alibaba.dubbo.examples.annotation.action"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>字段 <code>annotationService</code> 能够引用到 <code>AnnotationService</code>，执行 <code>doSayHello</code> 方法能够正常返回。</p><p>如果将字段<code>annotationService</code> 抽取到<code>AnnotationAction</code> 的父类<code>BaseAction</code> 后，<code>AnnotationService</code> 无法再被引用，改造如下所示：</p><p><code>AnnotationAction.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"annotationAction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAction</span> <span class="keyword">extends</span> <span class="title">BaseAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAnnotationService().sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BaseAction.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> AnnotationService annotationService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AnnotationService <span class="title">getAnnotationService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> annotationService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造后，再次执行 <code>doSayHello</code> 方法，<code>NullPointerException</code> 将会被抛出。说明<code>&lt;dubbo:annotation&gt;</code> 并不支持<code>@Reference</code> 字段继承性。</p><p>了解了历史问题，集合整体愿景，下面介绍<code>@DubboComponentScan</code> 的设计原则。</p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>Spring Framework 3.1 引入了新 Annotation - <code>@ComponentScan</code> ， 完全替代了 XML 元素 <code>&lt;context:component-scan&gt;</code> 。同样， <code>@DubboComponentScan</code> 作为 Dubbo <code>2.5.7</code> 新增的 Annotation，也是 XML 元素 <code>&lt;dubbo:annotation&gt;</code> 的替代方案。</p><p>在命名上（类名以及属性方法），为了简化使用和关联记忆，Dubbo 组件扫描 Annotation <code>@DubboComponentScan</code>，借鉴了 Spring Boot 1.3 引入的 <code>@ServletComponentScan</code>。定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DubboComponentScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise annotation</span></span><br><span class="line"><span class="comment">     * declarations e.g.: &#123;<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>("org.my.pkg")&#125; instead of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>(basePackages="org.my.pkg")&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base packages to scan for annotated <span class="doctag">@Service</span> classes. &#123;<span class="doctag">@link</span> #value()&#125; is an</span></span><br><span class="line"><span class="comment">     * alias for (and mutually exclusive with) this attribute.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Use &#123;<span class="doctag">@link</span> #basePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment">     * package names.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment">     * scan for annotated <span class="doctag">@Service</span> classes. The package of each class specified will be</span></span><br><span class="line"><span class="comment">     * scanned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> classes from the base packages to scan</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>basePackages()</code> 和 <code>value()</code> 均能支持占位符（placeholder）指定的包名</p></blockquote><p>在职责上，<code>@DubboComponentScan</code> 相对于 Spring Boot <code>@ServletComponentScan</code> 更为繁重，原因在于处理 Dubbo <code>@Service</code> 类暴露 Dubbo 服务外，还有帮助 Spring Bean <code>@Reference</code>字段或者方法注入 Dubbo 服务代理。</p><p>在场景上，Spring Framework <code>@ComponentScan</code> 组件扫描逻辑更为复杂。而在 <code>@DubboComponentScan</code> 只需关注 <code>@Service</code> 和 <code>@Reference</code> 处理。</p><p>在功能上， <code>@DubboComponentScan</code> 不但需要提供完整 Spring AOP 支持的能力，而且还得具备<code>@Reference</code> 字段可继承性的能力。</p><p>了解基本设计原则后，下面通过完整的示例，简介<code>@DubboComponentScan</code> 使用方法以及注意事项。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>后续通过服务提供方（<code>@Serivce</code>）以及服务消费方（<code>@Reference</code>）两部分来介绍<code>@DubboComponentScan</code> 使用方法。</p><p>假设，服务提供方和服务消费分均依赖服务接口<code>DemoService</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务提供方（-Serivce）"><a href="#服务提供方（-Serivce）" class="headerlink" title="服务提供方（@Serivce）"></a>服务提供方（<code>@Serivce</code>）</h5><h6 id="实现-DemoService"><a href="#实现-DemoService" class="headerlink" title="实现 DemoService"></a>实现 <code>DemoService</code></h6><p>服务提供方实现<code>DemoService</code> - <code>AnnotationDemoService</code> ，同时标注 Dubbo <code>@Service</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation &#123;<span class="doctag">@link</span> DemoService&#125; 实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello , "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="服务提供方-Annotation-配置"><a href="#服务提供方-Annotation-配置" class="headerlink" title="服务提供方 Annotation 配置"></a>服务提供方 Annotation 配置</h6><p>将 <code>AnnotationDemoService</code> 暴露成 Dubbo 服务，需要依赖 Spring Bean：<code>AplicationConfig</code>、<code>ProtocolConfig</code> 以及 <code>RegistryConfig</code> 。这三个 Spring Bean 过去可通过 XML 文件方式组装 Spring Bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当前应用信息配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-annotation-provider"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 连接注册中心配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"my-registry"</span> <span class="attr">address</span>=<span class="string">"N/A"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"12345"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上装配方式不予推荐，推荐使用 Annotation 配置，因此可以换成 Spring <code>@Configuration</code> Bean 的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProtocolConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供方配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span>(<span class="string">"com.alibaba.dubbo.demo.provider"</span>) <span class="comment">// 扫描 Dubbo 组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前应用配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dubbo-annotation-provider"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-annotation-provider"</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"my-registry"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setAddress(<span class="string">"N/A"</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dubbo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">        protocolConfig.setName(<span class="string">"dubbo"</span>);</span><br><span class="line">        protocolConfig.setPort(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">return</span> protocolConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="服务提供方引导类"><a href="#服务提供方引导类" class="headerlink" title="服务提供方引导类"></a>服务提供方引导类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.bootstrap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ProviderConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供方引导类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册配置 Bean</span></span><br><span class="line">        context.register(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 启动上下文</span></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 获取 DemoService Bean</span></span><br><span class="line">        DemoService demoService = context.getBean(DemoService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行 sayHello 方法</span></span><br><span class="line">        String message = demoService.sayHello(<span class="string">"World"</span>);</span><br><span class="line">        <span class="comment">// 控制台输出信息</span></span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ProviderBootstrap</code> 启动并执行后，控制输出与预期一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello , World</span><br></pre></td></tr></table></figure><p>以上直接结果说明 <code>@DubboComponentScan(&quot;com.alibaba.dubbo.demo.provider&quot;)</code> 扫描后，标注 Dubbo <code>@Service</code> 的 <code>AnnotationDemoService</code> 被注册成 Spring Bean，可从 Spring ApplicationContext 自由获取。</p><h5 id="服务消费方（-Reference）"><a href="#服务消费方（-Reference）" class="headerlink" title="服务消费方（@Reference）"></a>服务消费方（<code>@Reference</code>）</h5><h6 id="服务-DemoService"><a href="#服务-DemoService" class="headerlink" title="服务 DemoService"></a>服务 <code>DemoService</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation 驱动 &#123;<span class="doctag">@link</span> DemoService&#125; 消费方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoServiceConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span>(url = <span class="string">"dubbo://127.0.0.1:12345"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHell</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="服务消费方-Annotation-配置"><a href="#服务消费方-Annotation-配置" class="headerlink" title="服务消费方 Annotation 配置"></a>服务消费方 Annotation 配置</h6><p>与服务提供方配置类似，服务消费方也许 Dubbo 相关配置 Bean - <code>ConsumerConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.consumer.AnnotationDemoServiceConsumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务消费方配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前应用配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-annotation-consumer"</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setAddress(<span class="string">"N/A"</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 AnnotationDemoServiceConsumer，<span class="doctag">@DubboComponentScan</span> 将处理其中 <span class="doctag">@Reference</span> 字段。</span></span><br><span class="line"><span class="comment">     * 如果 AnnotationDemoServiceConsumer 非 Spring Bean 的话，</span></span><br><span class="line"><span class="comment">     * 即使 <span class="doctag">@DubboComponentScan</span> 指定 package 也不会进行处理，与 Spring <span class="doctag">@Autowired</span> 同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnotationDemoServiceConsumer <span class="title">annotationDemoServiceConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationDemoServiceConsumer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="服务消费方引导类"><a href="#服务消费方引导类" class="headerlink" title="服务消费方引导类"></a>服务消费方引导类</h6><p>服务消费方需要先引导服务提供方，下面的实例将会启动两个 Spring 应用上下文，首先引导服务提供方 Spring 应用上下文，同时，需要复用前面 Annotation 配置 <code>ProviderConfiguration</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动服务提供方上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startProviderContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Annotation 配置上下文</span></span><br><span class="line">    AnnotationConfigApplicationContext providerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    <span class="comment">// 注册配置 Bean</span></span><br><span class="line">    providerContext.register(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 启动服务提供方上下文</span></span><br><span class="line">    providerContext.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后引导服务消费方 Spring 应用上下文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动并且返回服务消费方上下文</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> AnnotationConfigApplicationContext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext <span class="title">startConsumerContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务消费方 Annotation 配置上下文</span></span><br><span class="line">    AnnotationConfigApplicationContext consumerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    <span class="comment">// 注册服务消费方配置 Bean</span></span><br><span class="line">    consumerContext.register(ConsumerConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 启动服务消费方上下文</span></span><br><span class="line">    consumerContext.refresh();</span><br><span class="line">    <span class="comment">// 返回服务消费方 Annotation 配置上下文</span></span><br><span class="line">    <span class="keyword">return</span> consumerContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的引导类实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.bootstrap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ConsumerConfiguration;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ProviderConfiguration;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.consumer.AnnotationDemoServiceConsumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务消费端引导类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:mercyblitz@gmail.com"&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动服务提供方上下文</span></span><br><span class="line">        startProviderContext();</span><br><span class="line">        <span class="comment">// 启动并且返回服务消费方上下文</span></span><br><span class="line">        ApplicationContext consumerContext = startConsumerContext();</span><br><span class="line">        <span class="comment">// 获取 AnnotationDemoServiceConsumer Bean</span></span><br><span class="line">        AnnotationDemoServiceConsumer consumer = consumerContext.getBean(AnnotationDemoServiceConsumer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行 doSayHello 方法</span></span><br><span class="line">        String message = consumer.doSayHello(<span class="string">"World"</span>);</span><br><span class="line">        <span class="comment">// 输出执行结果</span></span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动并且返回服务消费方上下文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AnnotationConfigApplicationContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext <span class="title">startConsumerContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务消费方 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext consumerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册服务消费方配置 Bean</span></span><br><span class="line">        consumerContext.register(ConsumerConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 启动服务消费方上下文</span></span><br><span class="line">        consumerContext.refresh();</span><br><span class="line">        <span class="comment">// 返回服务消费方 Annotation 配置上下文</span></span><br><span class="line">        <span class="keyword">return</span> consumerContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务提供方上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startProviderContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext providerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册配置 Bean</span></span><br><span class="line">        providerContext.register(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 启动服务提供方上下文</span></span><br><span class="line">        providerContext.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>ConsumerBootstrap</code>结果，仍然符合期望，<code>AnnotationDemoServiceConsumer</code> 输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello , World</span><br></pre></td></tr></table></figure><h4 id="Spring-AOP-支持"><a href="#Spring-AOP-支持" class="headerlink" title="Spring AOP 支持"></a>Spring AOP 支持</h4><p>前面提到 <code>&lt;dubbo:annotation&gt;</code> 注册 Dubbo <code>@Service</code> 组件后，在 Spring AOP 支持方面存在问题。事务作为 Spring AOP 的功能扩展，自然也会在 <code>&lt;dubbo:annotation&gt;</code>中不支持。</p><p><code>@DubboComponentScan</code> 针对以上问题，实现了对 Spring AOP 是完全兼容。将上述服务提供方 Annotation 配置做出一定的调整，标注<code>@EnableTransactionManagement</code> 以及自定义实现<code>PlatformTransactionManager</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span>(<span class="string">"com.alibaba.dubbo.demo.provider"</span>) <span class="comment">// 扫描 Dubbo 组件</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 激活事务管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略其他配置 Bean 定义</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义事务管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PlatformTransactionManager() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"get transaction ..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SimpleTransactionStatus();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"commit transaction ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"rollback transaction ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时调整 <code>AnnotationDemoService</code> - 增加<code>@Transactional</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略实现，保持不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行<code>ConsumerBootstrap</code> , 观察控制台输出内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get transaction ...</span><br><span class="line">commit transaction ...</span><br><span class="line">Hello , World</span><br></pre></td></tr></table></figure><p>输入内容中多处了两行，说明自定义 <code>PlatformTransactionManager</code> <code>getTransaction(TransactionDefinition)</code> 以及 <code>commit(TransactionStatus)</code> 方法被执行，进而说明 <code>AnnotationDemoService</code> 的<code>sayHello(String)</code> 方法执行时，事务也伴随执行。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><code>ConsumerConfiguration</code> 上的 <code>@DubboComponentScan</code> 并没有指定 <code>basePackages</code> 扫描，这种情况会将<code>ConsumerConfiguration</code> 当做 <code>basePackageClasses</code> ，即扫描<code>ConsumerConfiguration</code> 所属的 package <code>com.alibaba.dubbo.demo.config</code> 以及子 package。由于当前示例中，不存在标注 Dubbo <code>@Service</code>的类，因此在运行时日志（如果开启的话）会输出警告信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN :  [DUBBO] No Spring Bean annotating Dubbo&apos;s @Service was found in Spring BeanFactory, dubbo version: 2.0.0, current host: 127.0.0.1</span><br></pre></td></tr></table></figure><p>以上信息大可不必担忧，因为 <code>@DubboComponentScan</code> 除了扫描 Dubbo <code>@Service</code> 组件以外，还将处理 <code>@Reference</code>字段注入。然而读者特别关注<code>@Reference</code>字段注入的规则。</p><p>以上实现为例，<code>AnnotationDemoServiceConsumer</code> 必须申明为 Spring <code>@Bean</code> 或者 <code>@Component</code>（或者其派生注解），否则 <code>@DubboComponentScan</code> 不会主动将标注 <code>@Reference</code>字段所在的声明类提成为 Spring Bean，换句话说，如果 <code>@Reference</code>字段所在的声明类不是 Spring Bean 的话， <code>@DubboComponentScan</code> 不会处理<code>@Reference</code>注入，其原理与 Spring <code>@Autowired</code> 一致。</p><p>以上使用不当可能会导致相关问题，如 GitHub 上曾有小伙伴提问：<a href="https://github.com/alibaba/dubbo/issues/825" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/825</a></p><blockquote><p><strong>li362692680</strong> 提问：</p><blockquote><p>@DubboComponentScan 注解在消费端扫描包时扫描的是 @Service 注解？？不是@Reference 注解？？<br>启动时报<br>DubboComponentScanRegistrar-85]-[main]-[INFO] 0 annotated @Service Components { [] }</p></blockquote><p>笔者(<strong>mercyblitz</strong>)回复：</p><blockquote><p><code>@Reference</code> 类似于 <code>@Autowired</code> 一样，首先其申明的类必须被 Spring 上下文当做一个 Bean，因此，Dubbo 并没有直接将 <code>@Reference</code> 字段所在的类提升成 Bean。</p><p>综上所述，这并不是一个问题，而是用法不当！</p></blockquote></blockquote><h4 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h4><p>最新发布的 Dubbo <code>2.5.8</code> 中，<code>@DubboComponentScan</code> 在以下特殊场景下存在 Spring <code>@Service</code> 不兼容情况：</p><blockquote><p>假设有两个服务实现类 <code>A</code> 和 <code>B</code>，同时存放在<code>com.acme</code> 包下：</p><ul><li><code>A</code> 标注 Dubbo <code>@Service</code></li><li><code>B</code> 标注 Dubbo <code>@Service</code> 和 Spring <code>@Service</code></li></ul><p>当 Spring <code>@ComponentScan</code> 先扫描<code>com.acme</code> 包时，<code>B</code> 被当做 Spring Bean 的候选类。随后，<code>@DubboComponentScan</code> 也扫描相同的包。当应用启动时，<code>A</code> 和 <code>B</code> 虽然都是 Spring Bean，可仅 <code>A</code> 能够暴露 Dubbo 服务，<code>B</code> 则丢失。</p></blockquote><p>问题版本：<code>2.5.7</code>、<code>2.5.8</code></p><p>问题详情：<a href="https://github.com/alibaba/dubbo/issues/1120" target="_blank" rel="noopener">https://github.com/alibaba/dubbo/issues/1120</a></p><p>修复版本：<code>2.5.9</code>（下个版本）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dubbo-注解驱动（Annotation-Driven）&quot;&gt;&lt;a href=&quot;#Dubbo-注解驱动（Annotation-Driven）&quot; class=&quot;headerlink&quot; title=&quot;Dubbo 注解驱动（Annotation-Driven）&quot;&gt;&lt;/a&gt;Dubbo 注解驱动（Annotation-Driven）&lt;/h1&gt;&lt;h2 id=&quot;注解驱动（Annotation-Driven）&quot;&gt;&lt;a href=&quot;#注解驱动（Annotation-Driven）&quot; class=&quot;headerlink&quot; title=&quot;注解驱动（Annotation-Driven）&quot;&gt;&lt;/a&gt;注解驱动（Annotation-Driven）&lt;/h2&gt;&lt;h3 id=&quot;DubboComponentScan&quot;&gt;&lt;a href=&quot;#DubboComponentScan&quot; class=&quot;headerlink&quot; title=&quot;@DubboComponentScan&quot;&gt;&lt;/a&gt;&lt;code&gt;@DubboComponentScan&lt;/code&gt;&lt;/h3&gt;&lt;h4 id=&quot;起始版本：-2-5-7&quot;&gt;&lt;a href=&quot;#起始版本：-2-5-7&quot; class=&quot;headerlink&quot; title=&quot;起始版本： 2.5.7&quot;&gt;&lt;/a&gt;起始版本： &lt;code&gt;2.5.7&lt;/code&gt;&lt;/h4&gt;&lt;h4 id=&quot;lt-dubbo-annotation-gt-历史遗留问题&quot;&gt;&lt;a href=&quot;#lt-dubbo-annotation-gt-历史遗留问题&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;dubbo:annotation&amp;gt;历史遗留问题&quot;&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;dubbo:annotation&amp;gt;&lt;/code&gt;历史遗留问题&lt;/h4&gt;&lt;h5 id=&quot;1-注解支持不充分&quot;&gt;&lt;a href=&quot;#1-注解支持不充分&quot; class=&quot;headerlink&quot; title=&quot;1. 注解支持不充分&quot;&gt;&lt;/a&gt;1. 注解支持不充分&lt;/h5&gt;&lt;p&gt;在 Dubbo &lt;code&gt;2.5.7&lt;/code&gt;之前的版本 ，Dubbo 提供了两个核心注解 &lt;code&gt;@Service&lt;/code&gt; 以及 &lt;code&gt;@Reference&lt;/code&gt;，分别用于 Dubbo 服务提供和 Dubbo 服务引用。&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;@Service&lt;/code&gt; 作为 XML 元素 &lt;code&gt;&amp;lt;dubbo:service&amp;gt;&lt;/code&gt;的替代注解，与 Spring Framework &lt;code&gt;@org.springframework.stereotype.Service&lt;/code&gt; 类似，用于服务提供方 Dubbo 服务暴露。与之相对应的&lt;code&gt;@Reference&lt;/code&gt;，则是替代&lt;code&gt;&amp;lt;dubbo:reference&lt;/code&gt; 元素，类似于 Spring 中的 &lt;code&gt;@Autowired&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2.5.7&lt;/code&gt; 之前的 Dubbo，与早期的 Spring Framework 2.5 存在类似的不足，即注解支持不够充分。注解需要和 XML 配置文件配合使用，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;xmlns:xsi&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;       &lt;span class=&quot;attr&quot;&gt;xmlns:dubbo&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://code.alibabatech.com/schema/dubbo&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;       &lt;span class=&quot;attr&quot;&gt;xmlns&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;       &lt;span class=&quot;attr&quot;&gt;xsi:schemaLocation&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;string&quot;&gt;	http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dubbo:application&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;annotation-provider&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dubbo:registry&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;address&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1:4548&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dubbo:annotation&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;package&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;com.alibaba.dubbo.config.spring.annotation.provider&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Java/"/>
    
      <category term="Dubbo" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Java/Dubbo/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础-日期和时间</title>
    <link href="http://yoursite.com/2017/11/22/2017-11-22_Programing-Python-Basic-date-time-intro/"/>
    <id>http://yoursite.com/2017/11/22/2017-11-22_Programing-Python-Basic-date-time-intro/</id>
    <published>2017-11-22T05:47:33.000Z</published>
    <updated>2019-11-22T06:21:01.974Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Python程序可以通过多种方式来处理日期和时间。<br>日期格式之间的转换是计算机的一个共同核心。Python的时间和日历模块能够帮助我们跟踪的日期和时间。</p><h2 id="什么是刻度？"><a href="#什么是刻度？" class="headerlink" title="什么是刻度？"></a>什么是刻度？</h2><p>时间间隔以秒为单位的浮点数。特别是在时间瞬间在自1970年1月1日(纪元)12点的表示。</p><p>在Python提供一个流行时间 time 模块，提供时间的的 函数功能，并可转换表示。函数 <code>time.time()</code>返回当前系统时间，从1970年1月1日12点起来的秒数。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time;  <span class="comment"># This is required to include time module.</span></span><br><span class="line"></span><br><span class="line">ticks = time.time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Number of ticks since 12:00am, January 1, 1970:"</span>, ticks)</span><br></pre></td></tr></table></figure><p>将产生一个结果，如下 -<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number of ticks since <span class="number">12</span>:<span class="number">00</span>am, January <span class="number">1</span>, <span class="number">1970</span>: <span class="number">1568018748.2947338</span></span><br></pre></td></tr></table></figure></p><p>日期计算使用刻度线是很容易做到的。<br>然而，新纪元日期之前不能以这种形式表示。在未来的一个日期也不能表示这种方式, 分界点是在某个时候，在 UNIX和Windows上为 2038年。</p><a id="more"></a><h2 id="什么是TimeTuple？"><a href="#什么是TimeTuple？" class="headerlink" title="什么是TimeTuple？"></a>什么是TimeTuple？</h2><p>Python时间的函数处理时间9个数字的元组，如下图所示</p><div class="table-container"><table><thead><tr><th>序号</th><th>字段</th><th>值</th></tr></thead><tbody><tr><td>0</td><td>4-digit year</td><td>2019</td></tr><tr><td>1</td><td>Month</td><td>1 to 12</td></tr><tr><td>2</td><td>Day</td><td>1 to 31</td></tr><tr><td>3</td><td>Hour</td><td>0 to 23</td></tr><tr><td>4</td><td>Minute</td><td>0 to 59</td></tr><tr><td>5</td><td>Second</td><td>0 to 61 (60 or 61 are leap-seconds)</td></tr><tr><td>6</td><td>Day of Week</td><td>0 to 6 (0 is Monday)</td></tr><tr><td>7</td><td>Day of year</td><td>1 to 366 (Julian day)</td></tr><tr><td>8</td><td>Daylight savings</td><td>-1, 0, 1, -1 means library determines DST</td></tr></tbody></table></div><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (time.localtime())</span><br></pre></td></tr></table></figure><p>这将产生一个结果如下 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.struct_time(tm_year=<span class="number">2019</span>, tm_mon=<span class="number">9</span>, tm_mday=<span class="number">9</span>, tm_hour=<span class="number">10</span>, tm_min=<span class="number">51</span>, tm_sec=<span class="number">9</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">252</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上述元组相当于struct_time结构。这种结构具有以下属性 -</p><div class="table-container"><table><thead><tr><th>序号</th><th>属性</th><th>值</th></tr></thead><tbody><tr><td>0</td><td>tm_year</td><td>2019</td></tr><tr><td>1</td><td>tm_mon</td><td>1 to 12</td></tr><tr><td>2</td><td>tm_mday</td><td>1 to 31</td></tr><tr><td>3</td><td>tm_hour</td><td>1 to 23</td></tr><tr><td>4</td><td>tm_min</td><td>1 to 59</td></tr><tr><td>5</td><td>tm_sec</td><td>0 to 61 (60 or 61 are leap-seconds)</td></tr><tr><td>6</td><td>tm_wday</td><td>0 to 6 (0 is Monday)</td></tr><tr><td>7</td><td>tm_yday</td><td>1 to 366 (Julian day)</td></tr><tr><td>8</td><td>tm_isdst</td><td>-1, 0, 1, -1 means library determines DST</td></tr></tbody></table></div><h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><p>划时代浮点值从秒时刻转换生成为时间元组，浮点值传递给一个函数返回时间的元组并带上所有九个项目无效(例如，本地时间)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">localtime = time.localtime(time.time())</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Local current time :"</span>, localtime)</span><br></pre></td></tr></table></figure><p>这将产生以下结果，这可能会在任何其他像样形式被格式化.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Local current time : time.struct_time(tm_year=<span class="number">2019</span>, tm_mon=<span class="number">9</span>, tm_mday=<span class="number">9</span>, tm_hour=<span class="number">16</span>, tm_min=<span class="number">51</span>, tm_sec=<span class="number">9</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">252</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="获取格式化时间"><a href="#获取格式化时间" class="headerlink" title="获取格式化时间"></a>获取格式化时间</h2><p>可以在格式化任何时候按您的要求，但用来获得时间可读格式的简单方法是asctime() -</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">localtime = time.asctime( time.localtime(time.time()) )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Local current time :"</span>, localtime)</span><br></pre></td></tr></table></figure><p>这将产生以下结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Local current time : Mon Sep  <span class="number">9</span> <span class="number">16</span>:<span class="number">57</span>:<span class="number">48</span> <span class="number">2019</span></span><br></pre></td></tr></table></figure></p><h2 id="获取一个月份的日历"><a href="#获取一个月份的日历" class="headerlink" title="获取一个月份的日历"></a>获取一个月份的日历</h2><p>日历模块提供各种各样年度和月度的日历方法。在这里，我们将打印给定月份(2008年1月)的日历 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"></span><br><span class="line">cal = calendar.month(<span class="number">2019</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Here is the calendar:"</span>)</span><br><span class="line"><span class="keyword">print</span> (cal)</span><br></pre></td></tr></table></figure><p>这将产生以下结果 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Here <span class="keyword">is</span> the calendar:</span><br><span class="line">   February <span class="number">2019</span></span><br><span class="line">Mo Tu We Th Fr Sa Su</span><br><span class="line">             <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span></span><br><span class="line"><span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span></span><br></pre></td></tr></table></figure><h3 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h3><p>Python提供一个流行时间模块，为时间和表示之间转换提供了相应函数。<br>这里是所有可用方法的列表<br>|序号|函数|描述|<br>|—-|—-|—-|<br>|1|time.altzone |如果定义则在当地的DST时区偏移，在UTC西部秒数。这是负值，如果当地的MST时区是UTC以东 (在西欧，包括英国).只使用这个，如果白天不为零。|<br>|2|time.asctime([tupletime]) |接受时间元组，并返回一个可读24个字符的字符串，如 ‘Tue Dec 11 18:07:14 2008’.|<br>|3|time.clock( ) |返回当前CPU时间为几秒钟的浮点数。要测量计算成本的不同的方法，time.clock()的值比time.time更有用。|<br>|4|time.ctime([secs])|类似 asctime(localtime(secs))和不带参数的 ctime()函数|<br>|5|time.gmtime([secs]) |接受从新纪元用秒表示瞬间和返回用UTC表示时间元组t。注: t.tm_isdst 总是为 0|<br>|6|time.localtime([secs]) |接受从新纪元用秒表示瞬间和返回本地时间的时间元组t(t.tm_isdst 为 0 或 1, 根据DST是否通过局部规则适用于时刻秒)|<br>|7|time.mktime(tupletime) |接受表示为本地时间的时间元组并返回从新纪元以秒表示瞬间的一个浮点值|<br>|8|time.sleep(secs) |线程暂停secs秒调用|<br>|9|time.strftime(fmt[,tupletime]) |接受表示为本地时间的时间元组瞬间，并返回表示由字符串指定 fmt 瞬间的字符串 |<br>|10|time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’) |解析 str 按照格式字符串格式化并返回时间元组格式的时间|<br>|11|time.time( ) |返回当前时刻，从新纪元以来的秒的浮点数|<br>|12|time.tzset() |通过重置库例程使用时间转换规则。 环境变量TZ指定如何做到这一点 |下列是时间模块提供两个重要属性：</p><p>下列是时间模块提供两个重要属性：<br>|序号|属性及说明|<br>|—-|—-|<br>|1|time.timezone |属性time.timezone是在本地时区以UTC的秒偏移量(不包括DST) |<br>|2|time.tzname |属性time.tzname是一对区域设置相关的字符串|</p><h2 id="calendar-日历模块"><a href="#calendar-日历模块" class="headerlink" title="calendar 日历模块"></a>calendar 日历模块</h2><p>calendar 模块提供日历相关的功能，包括函数用来打印给定月份或年份文本日历。默认情况下，日历采用星期一作为一周的第一天，周日是最后一个。如要改变这种情况，调用calendar.setfirstweekday()函数。这里是 calendar 模块可用的函数列表：</p><div class="table-container"><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>calendar.calendar(year,w=2,l=1,c=6)</td><td>返回一个多行字符串使用格式化成用c空格分隔的三列逐年的日历</td></tr><tr><td>2</td><td>calendar.firstweekday( )</td><td>返回每周工作日开始的当前设置。默认情况下，当日历被首次导入是0，这意味着星期一</td></tr><tr><td>3</td><td>calendar.isleap(year)</td><td>如果 year 是闰年返回True;否则为false</td></tr><tr><td>4</td><td>calendar.leapdays(y1,y2)</td><td>返回跨越润年在范围内(y1,y2)的总数</td></tr><tr><td>5</td><td>calendar.month(year,month,w=2,l=1)</td><td>返回一个多行字符串以及逐年月月份的日历，每周一行加上两个标题行。</td></tr><tr><td>6</td><td>calendar.monthcalendar(year,month)</td><td>返回列表的列表整数。</td></tr><tr><td>7</td><td>calendar.monthrange(year,month)</td><td>返回两个整数。</td></tr><tr><td>8</td><td>calendar.prcal(year,w=2,l=1,c=6)</td><td>类似打印 calendar.calendar(year,w,l,c).</td></tr><tr><td>9</td><td>calendar.prmonth(year,month,w=2,l=1)</td><td>类似打印 calendar.month(year,month,w,l).</td></tr><tr><td>10</td><td>calendar.setfirstweekday(weekday)</td><td>设定每个星期的第一天工作日代码。工作日代码是0(星期一)至6(星期日)</td></tr><tr><td>11</td><td>calendar.timegm(tupletime)</td><td>time.gmtime反转：接受时间元组形式的时刻，并返回同一时刻作为自新纪元以来秒的浮点数</td></tr><tr><td>12</td><td>calendar.weekday(year,month,day)</td><td>返回给定日期是星期几代码。 工作日代码是0(星期一)至60(星期日);月数是1(1月)到12(12月)</td></tr></tbody></table></div><h2 id="其它模块和功能："><a href="#其它模块和功能：" class="headerlink" title="其它模块和功能："></a>其它模块和功能：</h2><p>如果你有兴趣，那么在这里你会发现其他重要的模块和功能的列表，包括在Python日期和时间的使用：</p><p>datetime模块<br><a href="https://docs.python.org/3/library/datetime.html#module-datetime" target="_blank" rel="noopener">https://docs.python.org/3/library/datetime.html#module-datetime</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;Python程序可以通过多种方式来处理日期和时间。&lt;br&gt;日期格式之间的转换是计算机的一个共同核心。Python的时间和日历模块能够帮助我们跟踪的日期和时间。&lt;/p&gt;
&lt;h2 id=&quot;什么是刻度？&quot;&gt;&lt;a href=&quot;#什么是刻度？&quot; class=&quot;headerlink&quot; title=&quot;什么是刻度？&quot;&gt;&lt;/a&gt;什么是刻度？&lt;/h2&gt;&lt;p&gt;时间间隔以秒为单位的浮点数。特别是在时间瞬间在自1970年1月1日(纪元)12点的表示。&lt;/p&gt;
&lt;p&gt;在Python提供一个流行时间 time 模块，提供时间的的 函数功能，并可转换表示。函数 &lt;code&gt;time.time()&lt;/code&gt;返回当前系统时间，从1970年1月1日12点起来的秒数。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time;  &lt;span class=&quot;comment&quot;&gt;# This is required to include time module.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ticks = time.time()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;Number of ticks since 12:00am, January 1, 1970:&quot;&lt;/span&gt;, ticks)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将产生一个结果，如下 -&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Number of ticks since &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;am, January &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1970&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1568018748.2947338&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;日期计算使用刻度线是很容易做到的。&lt;br&gt;然而，新纪元日期之前不能以这种形式表示。在未来的一个日期也不能表示这种方式, 分界点是在某个时候，在 UNIX和Windows上为 2038年。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础-常用术语对照表</title>
    <link href="http://yoursite.com/2017/11/19/2017-11-19_Programing-Python-Basic-Common-Terms-table/"/>
    <id>http://yoursite.com/2017/11/19/2017-11-19_Programing-Python-Basic-Common-Terms-table/</id>
    <published>2017-11-19T02:27:05.000Z</published>
    <updated>2019-11-22T06:23:05.787Z</updated>
    
    <content type="html"><![CDATA[<hr><p>下面内容主要摘抄自<code>python</code> 官网，<a href="https://docs.python.org/3.7/glossary.html#glossary" target="_blank" rel="noopener">https://docs.python.org/3.7/glossary.html#glossary</a>，部分内容有删减。</p><h3 id="2to3"><a href="#2to3" class="headerlink" title="2to3"></a>2to3</h3><p>一个将 <code>Python</code> 2.x 代码转换为 <code>Python</code> 3.x 代码的工具，能够处理大部分通过解析源码并遍历解析树可检测到的不兼容问题。</p><p>2to3 包含在标准库中，模块名为 lib2to3；并提供一个独立入口点 Tools/scripts/2to3。参见 2to3 - 自动将 <code>Python</code> 2 代码转为 <code>Python</code> 3 代码。</p><p>因为官方将在2020年不再支持 <code>Python</code> 2.x, 在遇到没有<code>Python</code> 2.X 版本 的code 的时候，可以尝试使用这个工具将代码转化成Python 的版本。</p><h3 id="abstract-base-class-—-抽象基类"><a href="#abstract-base-class-—-抽象基类" class="headerlink" title="abstract base class — 抽象基类"></a>abstract base class — 抽象基类</h3><p>抽象基类简称 ABC，是对 duck-typing 的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如 hasattr() 显得过于笨拙或有微妙错误（例如使用 魔术方法）。ABC 引入了虚拟子类，这种类并非继承自其他类，但却仍能被 isinstance() 和 issubclass() 所认可；详见 abc 模块文档。<code>Python</code> 自带许多内置的 ABC 用于实现数据结构（在 collections.abc 模块中）、数字（在 numbers 模块中）、流（在 io 模块中）、导入查找器和加载器（在 importlib.abc 模块中）。你可以使用 abc 模块来创建自己的 ABC。</p><h3 id="argument-—-参数"><a href="#argument-—-参数" class="headerlink" title="argument — 参数"></a>argument — 参数</h3><p>在调用函数时传给 function （或 method ）的值。参数分为两种：</p><ul><li>关键字参数: 在函数调用中前面带有标识符（例如 name=）或者作为包含在前面带有 ** 的字典里的值传入。<br>  举例来说，3 和 5 在以下对 complex() 的调用中均属于关键字参数:  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">complex(real=<span class="number">3</span>, imag=<span class="number">5</span>)</span><br><span class="line">complex(**&#123;<span class="string">'real'</span>: <span class="number">3</span>, <span class="string">'imag'</span>: <span class="number">5</span>&#125;)</span><br></pre></td></tr></table></figure></li><li>位置参数: 不属于关键字参数的参数。位置参数可出现于参数列表的开头以及/或者作为前面带有 * 的 iterable 里的元素被传入。<br>  举例来说，3 和 5 在以下调用中均属于位置参数:  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">complex(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">complex(*(<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>参数会被赋值给函数体中对应的局部变量。有关赋值规则参见 调用 一节。根据语法，任何表达式都可用来表示一个参数；最终算出的值会被赋给对应的局部变量。</li></ul><p>另参见 parameter 术语表条目，常见问题中 参数与形参的区别 以及 PEP 362。</p><a id="more"></a><h3 id="asynchronous-context-manager-—-异步上下文管理器"><a href="#asynchronous-context-manager-—-异步上下文管理器" class="headerlink" title="asynchronous context manager — 异步上下文管理器"></a>asynchronous context manager — 异步上下文管理器</h3><p>此种对象通过定义 <strong>aenter</strong>() 和 <strong>aexit</strong>() 方法来对 async with 语句中的环境进行控制。由 PEP 492 引入。</p><h3 id="asynchronous-generator-—-异步生成器"><a href="#asynchronous-generator-—-异步生成器" class="headerlink" title="asynchronous generator — 异步生成器"></a>asynchronous generator — 异步生成器</h3><p>返回值为 asynchronous generator iterator 的函数。它与使用 async def 定义的协程函数很相似，不同之处在于它包含 yield 表达式以产生一系列可在 async for 循环中使用的值。</p><p>此术语通常是指异步生成器函数，但在某些情况下则可能是指 异步生成器迭代器。如果需要清楚表达具体含义，请使用全称以避免歧义。</p><p>一个异步生成器函数可能包含 await 表达式或者 async for 以及 async with 语句。</p><h3 id="attribute-—-属性"><a href="#attribute-—-属性" class="headerlink" title="attribute — 属性"></a>attribute — 属性</h3><p>关联到一个对象的值，可以使用点号表达式通过其名称来引用。例如，如果一个对象 o 具有一个属性 a，就可以用 o.a 来引用它。</p><h3 id="BDFL"><a href="#BDFL" class="headerlink" title="BDFL"></a>BDFL</h3><p>“终身仁慈独裁者”的英文缩写，即 Guido van Rossum，<code>Python</code> 的创造者。</p><h3 id="binary-file-—-二进制文件"><a href="#binary-file-—-二进制文件" class="headerlink" title="binary file — 二进制文件"></a>binary file — 二进制文件</h3><p>file object 能够读写 字节类对象。二进制文件的例子包括以二进制模式（’rb’, ‘wb’ or ‘rb+’）打开的文件、sys.stdin.buffer、sys.stdout.buffer 以及 io.BytesIO 和 gzip.GzipFile 的实例。</p><p>另请参见 text file 了解能够读写 str 对象的文件对象。</p><h3 id="bytes-like-object-—-字节类对象"><a href="#bytes-like-object-—-字节类对象" class="headerlink" title="bytes-like object — 字节类对象"></a>bytes-like object — 字节类对象</h3><p>支持 缓冲协议 并且能导出 C-contiguous 缓冲的对象。这包括所有 bytes、bytearray 和 array.array 对象，以及许多普通 memoryview 对象。字节类对象可在多种二进制数据操作中使用；这些操作包括压缩、保存为二进制文件以及通过套接字发送等。</p><p>某些操作需要可变的二进制数据。这种对象在文档中常被称为“可读写字节类对象”。可变缓冲对象的例子包括 bytearray 以及 bytearray 的 memoryview。其他操作要求二进制数据存放于不可变对象 (“只读字节类对象”)；这种对象的例子包括 bytes 以及 bytes 对象的 memoryview。</p><h3 id="bytecode-—-字节码"><a href="#bytecode-—-字节码" class="headerlink" title="bytecode — 字节码"></a>bytecode — 字节码</h3><p><code>Python</code> 源代码会被编译为字节码，即 C<code>Python</code> 解释器中表示 <code>Python</code> 程序的内部代码。字节码还会缓存在 .pyc 文件中，这样第二次执行同一文件时速度更快（可以免去将源码重新编译为字节码）。这种 “中间语言” 运行在根据字节码执行相应机器码的 virtual machine 之上。请注意不同 <code>Python</code> 虚拟机上的字节码不一定通用，也不一定能在不同 <code>Python</code> 版本上兼容。</p><h3 id="class-—-类"><a href="#class-—-类" class="headerlink" title="class — 类"></a>class — 类</h3><p>用来创建用户定义对象的模板。类定义通常包含对该类的实例进行操作的方法定义。</p><h3 id="class-variable-—-类变量"><a href="#class-variable-—-类变量" class="headerlink" title="class variable — 类变量"></a>class variable — 类变量</h3><p>在类中定义的变量，并且仅限在类的层级上修改 (而不是在类的实例中修改)。</p><h3 id="coercion-—-强制类型转换"><a href="#coercion-—-强制类型转换" class="headerlink" title="coercion — 强制类型转换"></a>coercion — 强制类型转换</h3><p>在包含两个相同类型参数的操作中，一种类型的实例隐式地转换为另一种类型。例如，int(3.15) 是将原浮点数转换为整型数 3，但在 3+4.5 中，参数的类型不一致（一个是 int, 一个是 float），两者必须转换为相同类型才能相加，否则将引发 TypeError。如果没有强制类型转换机制，程序员必须将所有可兼容参数归一化为相同类型，例如要写成 float(3)+4.5 而不是 3+4.5。</p><p>coroutine — 协程<br>协程是子例程的更一般形式。子例程可以在某一点进入并在另一点退出。协程则可以在许多不同的点上进入、退出和恢复。它们可通过 async def 语句来实现。参见 PEP 492。</p><p>coroutine function — 协程函数<br>返回一个 coroutine 对象的函数。协程函数可通过 async def 语句来定义，并可能包含 await、async for 和 async with 关键字。这些特性是由 PEP 492 引入的。</p><h3 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h3><p><code>Python</code> 编程语言的规范实现，在 <code>python</code>.org 上发布。<code>CPython</code> 一词用于在必要时将此实现与其他实现例如 <code>Jython</code> 或 <code>IronPython</code> 相区别。</p><h3 id="decorator-—-装饰器"><a href="#decorator-—-装饰器" class="headerlink" title="decorator — 装饰器"></a>decorator — 装饰器</h3><p>返回值为另一个函数的函数，通常使用 @wrapper 语法形式来进行函数变换。 装饰器的常见例子包括 classmethod() 和 staticmethod()。</p><p>装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(...)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">f = staticmethod(f)</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(...)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>同的样概念也适用于类，但通常较少这样使用。有关装饰器的详情可参见 函数定义 和 类定义 的文档。</p><h3 id="dictionary-—-字典"><a href="#dictionary-—-字典" class="headerlink" title="dictionary — 字典"></a>dictionary — 字典</h3><p>一个关联数组，其中的任意键都映射到相应的值。键可以是任何具有 <strong>hash</strong>() 和 <strong>eq</strong>() 方法的对象。在 Perl 语言中称为 hash。</p><h3 id="EAFP"><a href="#EAFP" class="headerlink" title="EAFP"></a>EAFP</h3><p>“求原谅比求许可更容易”的英文缩写。这种 <code>Python</code> 常用代码编写风格会假定所需的键或属性存在，并在假定错误时捕获异常。这种简洁快速风格的特点就是大量运用 try 和 except 语句。于其相对的则是所谓 LBYL 风格，常见于 C 等许多其他语言。</p><h3 id="expression-—-表达式"><a href="#expression-—-表达式" class="headerlink" title="expression — 表达式"></a>expression — 表达式</h3><p>可以求出某个值的语法单元。 换句话说，一个表达式就是表达元素例如字面值、名称、属性访问、运算符或函数调用的汇总，它们最终都会返回一个值。 与许多其他语言不同，并非所有语言构件都是表达式。 还存在不能被用作表达式的 statement，例如 while。 赋值也是属于语句而非表达式。</p><p>extension module — 扩展模块<br>以 C 或 C++ 编写的模块，使用 <code>Python</code> 的 C API 来与语言核心以及用户代码进行交互。</p><h3 id="file-object-—-文件对象"><a href="#file-object-—-文件对象" class="headerlink" title="file object — 文件对象"></a>file object — 文件对象</h3><p>对外提供面向文件 API 以使用下层资源的对象（带有 read() 或 write() 这样的方法）。<br>根据其创建方式的不同，文件对象可以处理对真实磁盘文件，对其他类型存储，或是对通讯设备的访问（例如标准输入/输出、内存缓冲区、套接字、管道等等）。<br>文件对象也被称为 <code>文件类对象</code> 或 <code>流</code>。</p><p>实际上共有三种类别的文件对象: <code>原始二进制文件</code>, <code>缓冲二进制文件</code> 以及 <code>文本文件</code>。它们的接口定义均在 io 模块中。<br>创建文件对象的规范方式是使用 open() 函数。</p><h3 id="floor-division-—-向下取整除法"><a href="#floor-division-—-向下取整除法" class="headerlink" title="floor division — 向下取整除法"></a>floor division — 向下取整除法</h3><p>向下舍入到最接近的整数的数学除法。向下取整除法的运算符是 // 。例如，表达式 11 // 4 的计算结果是 2 ，而与之相反的是浮点数的真正除法返回 2.75 。注意 (-11) // 4 会返回 -3 因为这是 -2.75 向下 舍入得到的结果。见 PEP 238 。</p><h3 id="function-—-函数"><a href="#function-—-函数" class="headerlink" title="function — 函数"></a>function — 函数</h3><p>可以向调用者返回某个值的一组语句。还可以向其传入零个或多个 参数 并在函数体执行中被使用。另见 parameter, method 和 函数定义 等节。</p><h3 id="future"><a href="#future" class="headerlink" title="future"></a><strong>future</strong></h3><p>一种伪模块，可被程序员用来启用与当前解释器不兼容的新语言特性。</p><p>通过导入 <strong>future</strong> 模块并对其中的变量求值，你可以查看新特性何时首次加入语言以及何时成为默认:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> __future__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__future__.division</span><br><span class="line">_Feature((<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="string">'alpha'</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'alpha'</span>, <span class="number">0</span>), <span class="number">8192</span>)</span><br></pre></td></tr></table></figure></p><h3 id="garbage-collection-—-垃圾回收"><a href="#garbage-collection-—-垃圾回收" class="headerlink" title="garbage collection — 垃圾回收"></a>garbage collection — 垃圾回收</h3><p>释放不再被使用的内存空间的过程。<br><code>Python</code> 是通过引用计数和一个能够检测和打破循环引用的循环垃圾回收器来执行垃圾回收的。<br>可以使用 gc 模块来控制垃圾回收器。</p><h3 id="global-interpreter-lock-—-全局解释器锁"><a href="#global-interpreter-lock-—-全局解释器锁" class="headerlink" title="global interpreter lock — 全局解释器锁"></a>global interpreter lock — 全局解释器锁</h3><p>C<code>Python</code> 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 <code>Python</code> bytecode。此机制通过设置对象模型（包括 dict 等重要内置类型）针对并发访问的隐式安全简化了 C<code>Python</code> 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性。</p><p>不过，某些标准库或第三方库的扩展模块被设计为在执行计算密集型任务如压缩或哈希时释放 GIL。此外，在执行 I/O 操作时也总是会释放 GIL。</p><p>创建一个（以更精细粒度来锁定共享数据的）“自由线程”解释器的努力从未获得成功，因为这会牺牲在普通单处理器情况下的性能。据信克服这种性能问题的措施将导致实现变得更复杂，从而更难以维护。</p><h3 id="IDLE"><a href="#IDLE" class="headerlink" title="IDLE"></a>IDLE</h3><p><code>Python</code> 的 IDE，“集成开发与学习环境”的英文缩写。是 <code>Python</code> 标准发行版附带的基本编程器和解释器环境。</p><h3 id="import-path-—-导入路径"><a href="#import-path-—-导入路径" class="headerlink" title="import path — 导入路径"></a>import path — 导入路径</h3><p>由多个位置（或 路径条目）组成的列表，会被模块的 path based finder 用来查找导入目标。在导入时，此位置列表通常来自 sys.path，但对次级包来说也可能来自上级包的 <strong>path</strong> 属性。</p><h3 id="iterable-—-可迭代对象"><a href="#iterable-—-可迭代对象" class="headerlink" title="iterable — 可迭代对象"></a>iterable — 可迭代对象</h3><p>能够逐一返回其成员项的对象。可迭代对象的例子包括所有序列类型（例如 list、str 和 tuple）以及某些非序列类型例如 dict、文件对象 以及定义了 <strong>iter</strong>() 方法或是实现了 Sequence 语义的 <strong>getitem</strong>() 方法的任意自定义类对象。</p><p>可迭代对象被可用于 for 循环以及许多其他需要一个序列的地方（zip()、map() …）。当一个可迭代对象作为参数传给内置函数 iter() 时，它会返回该对象的迭代器。这种迭代器适用于对值集合的一次性遍历。在使用可迭代对象时，你通常不需要调用 iter() 或者自己处理迭代器对象。for 语句会为你自动处理那些操作，创建一个临时的未命名变量用来在循环期间保存迭代器。参见 iterator、sequence 以及 generator。</p><h3 id="iterator-—-迭代器"><a href="#iterator-—-迭代器" class="headerlink" title="iterator — 迭代器"></a>iterator — 迭代器</h3><p>用来表示一连串数据流的对象。重复调用迭代器的 <strong>next</strong>() 方法（或将其传给内置函数 next()）将逐个返回流中的项。当没有数据可用时则将引发 StopIteration 异常。到这时迭代器对象中的数据项已耗尽，继续调用其 <strong>next</strong>() 方法只会再次引发 StopIteration 异常。迭代器必须具有 <strong>iter</strong>() 方法用来返回该迭代器对象自身，因此迭代器必定也是可迭代对象，可被用于其他可迭代对象适用的大部分场合。一个显著的例外是那些会多次重复访问迭代项的代码。容器对象（例如 list）在你每次向其传入 iter() 函数或是在 for 循环中使用它时都会产生一个新的迭代器。如果在此情况下你尝试用迭代器则会返回在之前迭代过程中被耗尽的同一迭代器对象，使其看起来就像是一个空容器。</p><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>由一个单独 expression 构成的匿名内联函数，表达式会在调用时被求值。<br>创建 lambda 函数的句法为 <code>lambda [parameters]: expression</code>。</p><h3 id="list-—-列表"><a href="#list-—-列表" class="headerlink" title="list — 列表"></a>list — 列表</h3><p><code>Python</code> 内置的一种 sequence。虽然名为列表，但更类似于其他语言中的数组而非链接列表，因为访问元素的时间复杂度为 O(1)。</p><h3 id="mapping-—-映射"><a href="#mapping-—-映射" class="headerlink" title="mapping — 映射"></a>mapping — 映射</h3><p>一种支持任意键查找并实现了 Mapping 或 MutableMapping 抽象基类 中所规定方法的容器对象。<br>此类对象的例子包括 <code>dict</code>, c<code>ollections.defaultdict</code>, <code>collections.OrderedDict</code> 以及 <code>collections.Counter</code>。</p><h3 id="metaclass-—-元类"><a href="#metaclass-—-元类" class="headerlink" title="metaclass — 元类"></a>metaclass — 元类</h3><p>一种用于创建类的类。类定义包含类名、类字典和基类列表。元类负责接受上述三个参数并创建相应的类。大部分面向对象的编程语言都会提供一个默认实现。<code>Python</code> 的特别之处在于可以创建自定义元类。大部分用户永远不需要这个工具，但当需要出现时，元类可提供强大而优雅的解决方案。它们已被用于记录属性访问日志、添加线程安全性、跟踪对象创建、实现单例，以及其他许多任务。</p><h3 id="method-—-方法"><a href="#method-—-方法" class="headerlink" title="method — 方法"></a>method — 方法</h3><p>在类内部定义的函数。如果作为该类的实例的一个属性来调用，方法将会获取实例对象作为其第一个 argument (通常命名为 self)。参见 <code>function</code> 。</p><h3 id="module-—-模块"><a href="#module-—-模块" class="headerlink" title="module — 模块"></a>module — 模块</h3><p>此对象是 <code>Python</code> 代码的一种组织单位。各模块具有独立的<code>命名空间</code>，可包含任意 <code>Python</code> 对象。模块可通过 importing 操作被加载到 <code>Python</code> 中。</p><p>另见 package。</p><h3 id="namespace-—-命名空间"><a href="#namespace-—-命名空间" class="headerlink" title="namespace — 命名空间"></a>namespace — 命名空间</h3><p>命名空间是存放变量的场所。命名空间有局部、全局和内置的，还有对象中的嵌套命名空间（在方法之内）。<br>命名空间通过防止命名冲突来支持模块化。例如，函数 <code>builtins.open</code> 与 <code>os.open()</code> 可通过各自的命名空间来区分。命名空间还通过明确哪个模块实现那个函数来帮助提高可读性和可维护性。<br>例如，<code>`random.seed() 或</code>itertools.islice()` 这种写法明确了这些函数是由 random 与 itertools 模块分别实现的。</p><h3 id="namespace-package-—-命名空间包"><a href="#namespace-package-—-命名空间包" class="headerlink" title="namespace package — 命名空间包"></a>namespace package — 命名空间包</h3><p>PEP 420 所引入的一种仅被用作子包的容器的 package，命名空间包可以没有实体表示物，其描述方式与 regular package 不同，因为它们没有 <code>__init__.py</code> 文件。</p><p>另可参见 module。</p><h3 id="object-—-对象"><a href="#object-—-对象" class="headerlink" title="object — 对象"></a>object — 对象</h3><p>任何具有状态（属性或值）以及预定义行为（方法）的数据。object 也是任何 new-style class 的最顶层基类名。</p><h3 id="package-—-包"><a href="#package-—-包" class="headerlink" title="package — 包"></a>package — 包</h3><p>一种可包含子模块或递归地包含子包的 <code>Python</code> module。从技术上说，包是带有 <strong>path</strong> 属性的 <code>Python</code> 模块。</p><p>另参见 regular package 和 namespace package。</p><h3 id="parameter-—-形参"><a href="#parameter-—-形参" class="headerlink" title="parameter — 形参"></a>parameter — 形参</h3><p>function （或方法）定义中的命名实体，它指定函数可以接受的一个 argument （或在某些情况下，多个实参）。有五种形参：</p><ul><li>positional-or-keyword：位置或关键字，指定一个可以作为 位置参数 传入也可以作为 关键字参数 传入的实参。<br>  这是默认的形参类型，例如下面的 foo 和 bar:  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(foo, bar=None)</span>:</span> ...</span><br></pre></td></tr></table></figure></li><li><p>positional-only：仅限位置，指定一个只能按位置传入的参数。<code>Python</code> 中没有定义仅限位置形参的语法。但是一些内置函数有仅限位置形参（比如 <code>abs()</code>）。</p></li><li><p>keyword-only：仅限关键字，指定一个只能通过关键字传入的参数。<br>仅限关键字形参可通过在函数定义的形参列表中包含单个可变位置形参或者在多个可变位置形参之前放一个 * 来定义，例如下面的 kw_only1 和 kw_only2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg, *, kw_only1, kw_only2)</span>:</span> ...</span><br></pre></td></tr></table></figure></li><li>var-positional：可变位置，指定可以提供由一个任意数量的位置参数构成的序列（附加在其他形参已接受的位置参数之后）。这种形参可通过在形参名称前加缀 * 来定义。<br>例如下面的 args:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span> ...</span><br></pre></td></tr></table></figure></li><li>var-keyword：可变关键字，指定可以提供任意数量的关键字参数（附加在其他形参已接受的关键字参数之后）。这种形参可通过在形参名称前加缀 ** 来定义，例如上面的 kwargs。</li></ul><p>形参可以同时指定可选和必选参数，也可以为某些可选参数指定默认值。</p><h3 id="path-entry-—-路径入口"><a href="#path-entry-—-路径入口" class="headerlink" title="path entry — 路径入口"></a>path entry — 路径入口</h3><p>import path 中的一个单独位置，会被 path based finder 用来查找要导入的模块。</p><h3 id="PEP"><a href="#PEP" class="headerlink" title="PEP"></a>PEP</h3><p>“<code>Python</code> 增强提议”的英文缩写。<br>一个 PEP 就是一份设计文档，用来向 <code>Python</code> 社区提供信息，或描述一个 <code>Python</code> 的新增特性及其进度或环境。PEP 应当提供精确的技术规格和所提议特性的原理说明。</p><p>PEP 应被作为提出主要新特性建议、收集社区对特定问题反馈以及为必须加入 <code>Python</code> 的设计决策编写文档的首选机制。PEP 的作者有责任在社区内部建立共识，并应将不同意见也记入文档。</p><p>参见 PEP 1。</p><h3 id="sequence-—-序列"><a href="#sequence-—-序列" class="headerlink" title="sequence — 序列"></a>sequence — 序列</h3><p>一种 iterable，它支持通过 <strong>getitem</strong>() 特殊方法来使用整数索引进行高效的元素访问，并定义了一个返回序列长度的 <strong>len</strong>() 方法。<br>内置的序列类型有 list、str、tuple 和 bytes。注意虽然 dict 也支持   <code>__getitem__()</code> 和 <code>__len__()</code>，但它被认为属于映射而非序列，因为它查找时使用任意的 immutable 键而非整数。</p><p>collections.abc.Sequence 抽象基类定义了一个更丰富的接口，它超越了<code>__getitem__()</code> 和<code>__len__()</code>，添加了 <code>count()</code>, <code>index()</code>, <code>__contains__()</code> 和 <code>__reversed__()</code> 。 可以使用 <code>register()</code> 显式注册实现此扩展接口的类型。</p><h3 id="slice-—-切片"><a href="#slice-—-切片" class="headerlink" title="slice — 切片"></a>slice — 切片</h3><p>通常只包含了特定 sequence 的一部分的对象。<br>切片是通过使用下标标记来创建的，在 [] 中给出几个以冒号分隔的数字，例如 variable_name[1:3:5]。方括号（下标）标记在内部使用 slice 对象。</p><h3 id="statement-—-语句"><a href="#statement-—-语句" class="headerlink" title="statement — 语句"></a>statement — 语句</h3><p>语句是程序段（一个代码“块”）的组成单位。<br>一条语句可以是一个 expression 或某个带有关键字的结构，例如 if、while 或 for。</p><h3 id="text-encoding-—-文本编码"><a href="#text-encoding-—-文本编码" class="headerlink" title="text encoding — 文本编码"></a>text encoding — 文本编码</h3><p>用于将Unicode字符串编码为字节串的编码器。</p><h3 id="type-—-类型"><a href="#type-—-类型" class="headerlink" title="type — 类型"></a>type — 类型</h3><p>类型决定一个 <code>Python</code> 对象属于什么种类；每个对象都具有一种类型。<br>要知道对象的类型，可以访问它的 <code>__class__</code> 属性，或是通过 type(obj) 来获取。</p><p>type hint — 类型提示<br>annotation 为变量、类属性、函数的形参或返回值指定预期的类型。</p><p>类型提示属于可选项，<code>Python</code> 不要求提供，但其可对静态类型分析工具起作用，并可协助 IDE 实现代码补全与重构。</p><p>全局变量、类属性和函数的类型提示可以使用 typing.get_type_hints() 来访问，但局部变量则不可以。</p><p>参见 typing 和 PEP 484，其中有对此功能的详细描述。</p><h3 id="universal-newlines-—-通用换行"><a href="#universal-newlines-—-通用换行" class="headerlink" title="universal newlines — 通用换行"></a>universal newlines — 通用换行</h3><p>一种解读文本流的方式，将以下所有符号都识别为行结束标志：Unix 的行结束约定 ‘\n’、Windows 的约定 ‘\r\n’ 以及旧版 Macintosh 的约定 ‘\r’。<br>参见 PEP 278 和 PEP 3116 和 bytes.splitlines() 了解更多用法说明。</p><h3 id="virtual-machine-—-虚拟机"><a href="#virtual-machine-—-虚拟机" class="headerlink" title="virtual machine — 虚拟机"></a>virtual machine — 虚拟机</h3><p>一台完全通过软件定义的计算机。<br><code>Python</code> 虚拟机可执行字节码编译器所生成的 bytecode。</p><h3 id="Zen-of-Python-—-Python-之禅"><a href="#Zen-of-Python-—-Python-之禅" class="headerlink" title="Zen of Python — Python 之禅"></a>Zen of <code>Python</code> — <code>Python</code> 之禅</h3><p>列出 <code>Python</code> 设计的原则与哲学，有助于理解与使用这种语言。<br>定义在PEP 8 中。<br>每个版本的具体内容，可能会有差。查看当前版本的具体内容可在交互模式提示符中输入 “import this”。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;下面内容主要摘抄自&lt;code&gt;python&lt;/code&gt; 官网，&lt;a href=&quot;https://docs.python.org/3.7/glossary.html#glossary&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/3.7/glossary.html#glossary&lt;/a&gt;，部分内容有删减。&lt;/p&gt;
&lt;h3 id=&quot;2to3&quot;&gt;&lt;a href=&quot;#2to3&quot; class=&quot;headerlink&quot; title=&quot;2to3&quot;&gt;&lt;/a&gt;2to3&lt;/h3&gt;&lt;p&gt;一个将 &lt;code&gt;Python&lt;/code&gt; 2.x 代码转换为 &lt;code&gt;Python&lt;/code&gt; 3.x 代码的工具，能够处理大部分通过解析源码并遍历解析树可检测到的不兼容问题。&lt;/p&gt;
&lt;p&gt;2to3 包含在标准库中，模块名为 lib2to3；并提供一个独立入口点 Tools/scripts/2to3。参见 2to3 - 自动将 &lt;code&gt;Python&lt;/code&gt; 2 代码转为 &lt;code&gt;Python&lt;/code&gt; 3 代码。&lt;/p&gt;
&lt;p&gt;因为官方将在2020年不再支持 &lt;code&gt;Python&lt;/code&gt; 2.x, 在遇到没有&lt;code&gt;Python&lt;/code&gt; 2.X 版本 的code 的时候，可以尝试使用这个工具将代码转化成Python 的版本。&lt;/p&gt;
&lt;h3 id=&quot;abstract-base-class-—-抽象基类&quot;&gt;&lt;a href=&quot;#abstract-base-class-—-抽象基类&quot; class=&quot;headerlink&quot; title=&quot;abstract base class — 抽象基类&quot;&gt;&lt;/a&gt;abstract base class — 抽象基类&lt;/h3&gt;&lt;p&gt;抽象基类简称 ABC，是对 duck-typing 的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如 hasattr() 显得过于笨拙或有微妙错误（例如使用 魔术方法）。ABC 引入了虚拟子类，这种类并非继承自其他类，但却仍能被 isinstance() 和 issubclass() 所认可；详见 abc 模块文档。&lt;code&gt;Python&lt;/code&gt; 自带许多内置的 ABC 用于实现数据结构（在 collections.abc 模块中）、数字（在 numbers 模块中）、流（在 io 模块中）、导入查找器和加载器（在 importlib.abc 模块中）。你可以使用 abc 模块来创建自己的 ABC。&lt;/p&gt;
&lt;h3 id=&quot;argument-—-参数&quot;&gt;&lt;a href=&quot;#argument-—-参数&quot; class=&quot;headerlink&quot; title=&quot;argument — 参数&quot;&gt;&lt;/a&gt;argument — 参数&lt;/h3&gt;&lt;p&gt;在调用函数时传给 function （或 method ）的值。参数分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字参数: 在函数调用中前面带有标识符（例如 name=）或者作为包含在前面带有 ** 的字典里的值传入。&lt;br&gt;  举例来说，3 和 5 在以下对 complex() 的调用中均属于关键字参数:  &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;complex(real=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, imag=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;complex(**&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;real&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;imag&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;位置参数: 不属于关键字参数的参数。位置参数可出现于参数列表的开头以及/或者作为前面带有 * 的 iterable 里的元素被传入。&lt;br&gt;  举例来说，3 和 5 在以下调用中均属于位置参数:  &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;complex(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;complex(*(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
参数会被赋值给函数体中对应的局部变量。有关赋值规则参见 调用 一节。根据语法，任何表达式都可用来表示一个参数；最终算出的值会被赋给对应的局部变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另参见 parameter 术语表条目，常见问题中 参数与形参的区别 以及 PEP 362。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>非科班出身，如何成为程序员？</title>
    <link href="http://yoursite.com/2017/11/16/2017-11-16-Programing-becomer-a-coder-from-others/"/>
    <id>http://yoursite.com/2017/11/16/2017-11-16-Programing-becomer-a-coder-from-others/</id>
    <published>2017-11-16T08:09:52.000Z</published>
    <updated>2019-11-22T08:28:21.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非科班出身，如何成为程序员"><a href="#非科班出身，如何成为程序员" class="headerlink" title="非科班出身，如何成为程序员"></a>非科班出身，如何成为程序员</h2><blockquote><p>本文是知乎的一篇回答</p></blockquote><p>身边有很多非科班出身的程序员，比如 sofish、粽神。当然我也是，所以决定结合自身经历强答一波。</p><h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><p>我本科学习的是「生物科学」，大学四年无非就是拿着 eppendorf 的实验枪，在超净台旁养着各种知名或不知名的微生物，有广为人知的「海拉细胞」有很多人没有听过的「毕赤酵母」，每逢寒暑假可能还会去山里或者某个海滨城市实习，在鸟巢旁边装一个微型摄像头，记录下喂食雏鸟的频率，去海边抓一些招潮蟹或者海月水母，也算乐在其中。我很享受大学这段时光，因为毕竟是我儿时的梦想，成为一个生物学家。</p><p>毕业后，进入了北京水产科学研究所，主要工作是「养鱼」，每天固定时间给「小西伯利亚鲟」喂点吃的，给鱼缸换水。很不幸…，在一次换水的过程中水龙头我忘关了，结果水沿着鱼缸溢了出来，小鲟鱼也在想「外面的世界那么大，我想去看看」，都顺着鱼缸溢出的水推力，游到了鱼缸外面，等我发现时，这些小生命都散落在鱼缸周围，也不跳了。主任没有批评我把一缸鱼都养死了，但是也再让我去喂鱼了，给了我一份新的差事，通过毕赤酵母来表达出促性腺激素，促进鲟鱼快速性成熟。实验做了大概一年，有一些成果，毕竟在一年中成功过一次。后来觉得愧对这份工作，就跟主任请辞了，主任就介绍了上海的一份工作给我，去欧莱雅研发中心做实验。现在想想主任真是难得的人生导师。</p><p>在欧莱雅工作了三年，每天也是重复相同的工作，工作内容只是从以前的养各种微生物变成了养「人造皮肤」，然后再把化妆品涂在人造皮肤上，看看化妆品对皮肤的效果，其实和大学拿老鼠、兔子做实验没什么区别，只是欧洲那边不让在活体上做化妆品实验。在欧莱雅的三年，慢慢消磨了我对「生物科学」的热情，重复的工作让我麻痹了我的思想。我决定做一些改变，那是2014年，我已经27了。</p><h3 id="学习编程的动机"><a href="#学习编程的动机" class="headerlink" title="学习编程的动机"></a>学习编程的动机</h3><p>还得从 13 年年底说起，在欧莱雅工作期间，命运多舛，出了一次车祸，右胫腓骨粉碎骨折，当时还是女朋友的老婆放弃了东京的工作回国来照顾我，在床上躺了三四个月，老婆回上海后也找了一份广告公司的工作，做 SEM。到了14年，腿伤基本恢复，我重新回到欧莱雅工作，经历了人生变故（车祸），住院期间把这一生中的生离死别都看完了，开始思考起人生，更加热爱生命。</p><a id="more"></a><p>老婆是做 SEM 工作的，其中很大一部分工作是做 SEO，也就是搜索引擎优化，文科出生的她（日语系）自然对 HTML标记语言、JS代码感到陌生，学习起来也有些吃苦，在区分 CSS 属性 color 和 background 也会疑惑。出于对她回国照顾我的感恩，以及责任。我从图书馆借了一本书「15天掌握HTML\CSS\JS」，开始学习起前端来，那时候我还不知道有前端这个职业，也不是为了转行做前端，仅仅是想自己学会了，然后帮她解决问题。</p><p>也许看了这本书，让我对当时欧莱雅的工作有了更深入的思考，在欧莱雅，我每天工作内容相同，做实验、处理实验数据，写 report。实验之余看看 paper。而学习 HTML\CSS\JS 可以创造不同网站，然后分享给世界各地浏览你网站的人。写网站比做实验似乎更能够给我带来成就感和满足感。于是我决定正式学习 web development，成为一个前端工程师，那是2014年八月，我已经27岁了。</p><h3 id="非科班出身怎么学习编程"><a href="#非科班出身怎么学习编程" class="headerlink" title="非科班出身怎么学习编程"></a>非科班出身怎么学习编程</h3><p>才发现，写到这儿才进入正题，正式开始学习编程是在2014年九月，我并没有辞掉当时的工作，我是白天工作，晚上回家学习，周一到周五每天大概学习5~6个小时左右，周末全天学习。我习惯每个月给自己制定一些任务和目标，然后按照自己的目标前进，比如下面是我2014年九月份制定的一些计划：</p><blockquote><p>九月份：《javascript》高级程序设计 + 慕课网练习（每天保证两小时coding）</p><p>十月份：学习 CSS2 和 CSS3，并对 javascript 的学习做个回顾，教材包括《精通CSS》，《javascript DOM编程艺术》，《javascript语言精粹》外加慕课网每天至少两小时coding！</p><p>十一月份：学习javascript库，jquery、prototype、html5。主要学习书籍《Javascript模式》、《锋利的jQuery》、《html5程序设计》、photoshop学习。</p><p>十二月份：主要任务是设计个人网站，主要书籍《精通javascript》、《编写可维护的Javascript》。</p></blockquote><p>这儿我并不是向大家推荐学习书籍，以及个人的计划，因为那是 2014 年制定的，可能已经不再适合现在入门学习者了，再者，推荐前端书籍的知乎问题不胜枚举。</p><p>周末的时候习惯带个电脑去普陀区图书馆，上海市的图书馆周末也挺多人的，所以不得不很早就去占座，突然又有了回到大学的感觉，关于电脑当时也是下了血本，游说当时还是女朋友的老婆，把他从日本带回来的十几万日元去中国银行换了人民币，然后买了一台 Macbook Pro。</p><p>2015年，我决定转行了，做一个前端工程师，那一年工作也忙了，学习的时间少了许多，为了找工作，我用 NodeJs + jQuery 搭建了一个多人博客系统，然后将自己的实现思路和技术栈连同博客地址发到了知乎和 NodeJs 社区，当然也附上了个人简历和邮箱地址，主要想看看以现在的水平，能不能够找到一份前端工作了。</p><p>那是15年八月，当时小鱼 sofish，推荐我去饿了么面试（估计是在 Nodejs 社区看到我发的帖子），但是由于知识体系的不健全，面试官可能觉得学习曲线会太陡，最终没有过初试，因为当时我还不知道 Promise，也不懂 Angular，更不会 Loopback。</p><p>于是我决定先找一份实习的工作，很幸运一家做 CRM 的公司愿意收留我，开的工资是4.5k，一下回到了刚毕业的水平，但是我很感谢这家公司，它给了我很大的学习空间，因为在这之前，我都是一个人在摸索，自学。甚至不知道真正的前端工程师到底做什么工作，而这家公司给了我机会，给我分配了导师，甚至在入职三个月内不用做任何业务，而是全身心学习。正是这三个月，我构建前自己的前端知识体系，从 JS 基础到 Angular 框架，从 HTML 到 CSS，从 Grunt 到 webpack，从NodeJs 到 Mongodb。在这三个月的学习期间，每天坚持早上九点到公司，晚上十点下班，每天坚持写周报，总结一天的学习，每个月完成一个小项目，三个月期间，自己写了一个所输及所得的 markdown 编辑器，写了一个 CSS selector 的 parser，通过 websocket 做了一个聊天工具。</p><p>当然，这三个月我也放弃了很多，因为刚入职，我放弃了和刚结婚老婆去度蜜月，两个人的蜜月，变成了她独自旅游。到现在也感到愧疚，争取明年补上。</p><p>三个月后，评级转正，当时的职级是 P5，我感到很欣慰，三个月的努力学习有了回报。和之前边工作边学习的离散学习完全不同，当然全职的效率更高，当然薪资也从4.5k 涨到了12k，说实话，对于刚入门的我，我很满意这薪资了。在这公司我工作了两年，合作和独立完成了几个项目，职级后来也再升了两级。在今年七月，我选择了离开，主要原因还是考虑个人发展，以及对饿了么的眷顾。</p><p>对的，我又参加了饿了么的面试，顺利入职饿了么前端工程师，感到很欣慰。好像实现了一个长久的夙愿。</p><h3 id="我为什么感到焦虑"><a href="#我为什么感到焦虑" class="headerlink" title="我为什么感到焦虑"></a>我为什么感到焦虑</h3><p>转行后，我无时不感到焦虑，毕竟是一个大龄转行程序员，身边的同事都是九零后甚至九五后，我无时不刻不在想我怎么规划我的职业，怎么做得更好，怎么缩短与科班出身的同事之间的差距。我没有后悔过转行，也没有后悔过那八年生物生涯（大学四年工作四年），毕竟那八年的生物学习，我快乐过，我不完整实现了儿时的梦想。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;非科班出身，如何成为程序员&quot;&gt;&lt;a href=&quot;#非科班出身，如何成为程序员&quot; class=&quot;headerlink&quot; title=&quot;非科班出身，如何成为程序员&quot;&gt;&lt;/a&gt;非科班出身，如何成为程序员&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文是知乎的一篇回答&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;身边有很多非科班出身的程序员，比如 sofish、粽神。当然我也是，所以决定结合自身经历强答一波。&lt;/p&gt;
&lt;h3 id=&quot;关于我&quot;&gt;&lt;a href=&quot;#关于我&quot; class=&quot;headerlink&quot; title=&quot;关于我&quot;&gt;&lt;/a&gt;关于我&lt;/h3&gt;&lt;p&gt;我本科学习的是「生物科学」，大学四年无非就是拿着 eppendorf 的实验枪，在超净台旁养着各种知名或不知名的微生物，有广为人知的「海拉细胞」有很多人没有听过的「毕赤酵母」，每逢寒暑假可能还会去山里或者某个海滨城市实习，在鸟巢旁边装一个微型摄像头，记录下喂食雏鸟的频率，去海边抓一些招潮蟹或者海月水母，也算乐在其中。我很享受大学这段时光，因为毕竟是我儿时的梦想，成为一个生物学家。&lt;/p&gt;
&lt;p&gt;毕业后，进入了北京水产科学研究所，主要工作是「养鱼」，每天固定时间给「小西伯利亚鲟」喂点吃的，给鱼缸换水。很不幸…，在一次换水的过程中水龙头我忘关了，结果水沿着鱼缸溢了出来，小鲟鱼也在想「外面的世界那么大，我想去看看」，都顺着鱼缸溢出的水推力，游到了鱼缸外面，等我发现时，这些小生命都散落在鱼缸周围，也不跳了。主任没有批评我把一缸鱼都养死了，但是也再让我去喂鱼了，给了我一份新的差事，通过毕赤酵母来表达出促性腺激素，促进鲟鱼快速性成熟。实验做了大概一年，有一些成果，毕竟在一年中成功过一次。后来觉得愧对这份工作，就跟主任请辞了，主任就介绍了上海的一份工作给我，去欧莱雅研发中心做实验。现在想想主任真是难得的人生导师。&lt;/p&gt;
&lt;p&gt;在欧莱雅工作了三年，每天也是重复相同的工作，工作内容只是从以前的养各种微生物变成了养「人造皮肤」，然后再把化妆品涂在人造皮肤上，看看化妆品对皮肤的效果，其实和大学拿老鼠、兔子做实验没什么区别，只是欧洲那边不让在活体上做化妆品实验。在欧莱雅的三年，慢慢消磨了我对「生物科学」的热情，重复的工作让我麻痹了我的思想。我决定做一些改变，那是2014年，我已经27了。&lt;/p&gt;
&lt;h3 id=&quot;学习编程的动机&quot;&gt;&lt;a href=&quot;#学习编程的动机&quot; class=&quot;headerlink&quot; title=&quot;学习编程的动机&quot;&gt;&lt;/a&gt;学习编程的动机&lt;/h3&gt;&lt;p&gt;还得从 13 年年底说起，在欧莱雅工作期间，命运多舛，出了一次车祸，右胫腓骨粉碎骨折，当时还是女朋友的老婆放弃了东京的工作回国来照顾我，在床上躺了三四个月，老婆回上海后也找了一份广告公司的工作，做 SEM。到了14年，腿伤基本恢复，我重新回到欧莱雅工作，经历了人生变故（车祸），住院期间把这一生中的生离死别都看完了，开始思考起人生，更加热爱生命。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="程序人生" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="程序人生" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础-时间控制</title>
    <link href="http://yoursite.com/2017/11/15/2017-11-15_Programing-Python-Basic-flow-control/"/>
    <id>http://yoursite.com/2017/11/15/2017-11-15_Programing-Python-Basic-flow-control/</id>
    <published>2017-11-15T05:50:33.000Z</published>
    <updated>2019-11-22T06:20:16.149Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这次主要介绍python 的基础流程控制。<br>包括 if 条件语句、for 循环 和 while 循环语句； continue 及 break 的用法等。<br>基本用法与 C 和 Java 差不多，无 switch 语句。</p><hr><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>语法：<code>if(...):</code>, 括号内为一表达式，当为<code>True</code>（即成立）时，执行对应的代码段。</p><blockquote><p>注意:所有条件语句后方都需加冒号 <code>:</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if 语句实例</span></span><br><span class="line"><span class="string">''' 判断用户输入的整数是几位数（暂不考虑用户输入非整数）</span></span><br><span class="line"><span class="string">    为0               输出     It's zero.</span></span><br><span class="line"><span class="string">    个位数             输出     It's a number below 10</span></span><br><span class="line"><span class="string">    两位数             输出     It's a two-digit number</span></span><br><span class="line"><span class="string">    三位数级以上        输出     It's digit is more than two</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">user_input = input(<span class="string">"Please input a number: "</span>)</span><br><span class="line"><span class="comment"># 用户输入的类型为字符串，转换为整数类型</span></span><br><span class="line">n = int(user_input)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span>):</span><br><span class="line">    print(<span class="string">"It's zero."</span>)</span><br><span class="line"><span class="keyword">elif</span> (n&lt;<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">"It's a number below 10"</span>)</span><br><span class="line"><span class="keyword">elif</span> (n&lt;<span class="number">100</span>):</span><br><span class="line">    print(<span class="string">"It's a two-digit number"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"It's digit is more than two"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>可能会有零到多个 elif 部分，else 是可选的。</p></blockquote><p>关键字 “ elif ” 是 “else if ” 的缩写，这个可以有效地避免过深的缩进。<code>if ... elif ... elif ...</code> 序列于替代其它语言中的switch case语句。</p><a id="more"></a><hr><h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><p>Python 中的 <code>for</code> 语句和 C Pascal 中的 有不同。通常的循环可能会由用户来定义迭代步骤和中止条件（如 C ），Python 的 <code>for</code> 语句依据任意序列（链表或字符串）中的子项，按它们在序列中的顺序来进行迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 语句实例</span></span><br><span class="line">string = <span class="string">"python"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">    <span class="comment"># 字符串处理</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">list = [<span class="string">"l"</span>,<span class="string">"i"</span>,<span class="string">"s"</span>,<span class="string">"t"</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">    <span class="comment"># 列表处理</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># range()函数，range(5) 表示 0 到 4 </span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><blockquote><p>上述示例仅感受下 for 语句的写法。</p><hr><h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><p><code>while(...)</code> 括号内表达式若为 <code>True</code>，则继续执行代码段；若为<code>False</code>，停止执行</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># while语句实例</span></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>需要注意错误代码导致的无限循环，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>):</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><hr><h2 id="break-、-continue"><a href="#break-、-continue" class="headerlink" title="break 、 continue"></a>break 、 continue</h2><p><code>break</code> 用法和 C 中的类似，直接跳出循环，执行循环后的语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>continue</code> 用法也是从C中借鉴来的，跳出当前循环，并执行下一次循环<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;这次主要介绍python 的基础流程控制。&lt;br&gt;包括 if 条件语句、for 循环 和 while 循环语句； continue 及 break 的用法等。&lt;br&gt;基本用法与 C 和 Java 差不多，无 switch 语句。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;if-语句&quot;&gt;&lt;a href=&quot;#if-语句&quot; class=&quot;headerlink&quot; title=&quot;if 语句&quot;&gt;&lt;/a&gt;if 语句&lt;/h2&gt;&lt;p&gt;语法：&lt;code&gt;if(...):&lt;/code&gt;, 括号内为一表达式，当为&lt;code&gt;True&lt;/code&gt;（即成立）时，执行对应的代码段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意:所有条件语句后方都需加冒号 &lt;code&gt;:&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# if 语句实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39; 判断用户输入的整数是几位数（暂不考虑用户输入非整数）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    为0               输出     It&#39;s zero.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    个位数             输出     It&#39;s a number below 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    两位数             输出     It&#39;s a two-digit number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    三位数级以上        输出     It&#39;s digit is more than two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;user_input = input(&lt;span class=&quot;string&quot;&gt;&quot;Please input a number: &quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 用户输入的类型为字符串，转换为整数类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n = int(user_input)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;It&#39;s zero.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; (n&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;It&#39;s a number below 10&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; (n&amp;lt;&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;It&#39;s a two-digit number&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;It&#39;s digit is more than two&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;可能会有零到多个 elif 部分，else 是可选的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键字 “ elif ” 是 “else if ” 的缩写，这个可以有效地避免过深的缩进。&lt;code&gt;if ... elif ... elif ...&lt;/code&gt; 序列于替代其它语言中的switch case语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-Basic-dirt_intro</title>
    <link href="http://yoursite.com/2017/11/14/2017-11-14_Programing-Python-Basic-dirt-intro/"/>
    <id>http://yoursite.com/2017/11/14/2017-11-14_Programing-Python-Basic-dirt-intro/</id>
    <published>2017-11-14T05:45:57.000Z</published>
    <updated>2019-11-22T06:20:30.408Z</updated>
    
    <content type="html"><![CDATA[<hr><p>每个键是从它的值由冒号(:)，即在项目之间用逗号隔开，整个东西是包含在大括号中。没有任何项目一个空字典只写两个大括号，就像这样：<code>{}</code>.</p><p>键在一个字典中是唯一的，而值则可以重复。字典的值可以是任何类型，但键必须是不可变的数据的类型，例如：字符串，数字或元组这样的类型。</p><h2 id="访问字典中的值"><a href="#访问字典中的值" class="headerlink" title="访问字典中的值"></a>访问字典中的值</h2><p>要访问字典元素，你可以使用方括号和对应键，以获得其对应的值。下面是一个简单的例子 -</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br><span class="line">print(<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br></pre></td></tr></table></figure><p>当执行上面的代码，它产生以下结果 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict[<span class="string">'Name'</span>]:  Saul</span><br><span class="line">dict[<span class="string">'Age'</span>]:  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>如果我们试图使用一个键，但这是不字典访问数据项的一部分，我们会得到一个错误如下 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;;</span><br><span class="line">print(<span class="string">"dict['Alice']: "</span>, dict[<span class="string">'Alice'</span>])</span><br></pre></td></tr></table></figure><p>当执行上面的代码，它产生以下结果 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict[<span class="string">'Saul'</span>]:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(<span class="string">"dict['Alice']: "</span>, dict[<span class="string">'Alice'</span>])</span><br><span class="line">KeyError: <span class="string">'Alice'</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="更新字典"><a href="#更新字典" class="headerlink" title="更新字典"></a>更新字典</h2><p>可以通过添加新条目或键值对，修改现有条目，或删除现有条目，更新词典的简单例子如下图所示 -</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># update existing entry</span></span><br><span class="line">dict[<span class="string">'Age'</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add new entry</span></span><br><span class="line">dict[<span class="string">'School'</span>] = <span class="string">"SPD School"</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dict['School']: "</span>, dict[<span class="string">'School'</span>])</span><br></pre></td></tr></table></figure><p>当执行上面的代码，它产生以下结果 -<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict[<span class="string">'Age'</span>]:  <span class="number">8</span></span><br><span class="line">dict[<span class="string">'School'</span>]:  SPD School</span><br></pre></td></tr></table></figure></p><h3 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h3><p>可以删除单个字典元素或清除字典的全部内容。也可以在一个单一的操作删除整个词典。</p><p>要明确删除整个词典，只要用 del 语句就可以做到。下面是一个简单的例子 -</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'Third'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove entry with key 'Name'</span></span><br><span class="line"><span class="keyword">del</span> dict[<span class="string">'Name'</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all entries in dict</span></span><br><span class="line">dict.clear()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># delete entire dictionary</span></span><br><span class="line"><span class="keyword">del</span> dict         </span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line">print(<span class="string">"dict['School']: "</span>, dict[<span class="string">'School'</span>])</span><br></pre></td></tr></table></figure><p>这将产生以下结果。请注意，将引发一个异常，因为执行 del dict 后字典不存在了-<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict[<span class="string">'Age'</span>]:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line">TypeError: <span class="string">'type'</span> object <span class="keyword">is</span> unsubscriptable</span><br></pre></td></tr></table></figure></p><blockquote><p>注： del() 方法是在后续部分讨论。</p></blockquote><h2 id="字典键的属性"><a href="#字典键的属性" class="headerlink" title="字典键的属性"></a>字典键的属性</h2><p>字典的值没有限制。它们可以是任意Python对象，无论是标准的对象或用户定义的对象。但是，键却不能这样使用。</p><p>还有要记住字典的键的重要两点 -</p><ul><li>每个键对应多个条目是不允许的。这意味着重复键是不允许的。当键分配过程中遇到重复，以最后分配的为准。例如 -</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Name'</span>: <span class="string">'Manli'</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br></pre></td></tr></table></figure><p>当执行上面的代码，它产生以下结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dict[<span class="string">'Name'</span>]:  Manli</span><br></pre></td></tr></table></figure></p><ul><li>键必须是不可变的。这意味着可以使用字符串，数字或元组作为字典的键，但是像[‘key’]是不允许的。下面是一个简单的例子：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>])</span><br></pre></td></tr></table></figure><p>当执行上面的代码，它产生以下结果 -</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Saul'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line">TypeError: list objects are unhashable</span><br></pre></td></tr></table></figure><h2 id="内置字典函数和方法"><a href="#内置字典函数和方法" class="headerlink" title="内置字典函数和方法"></a>内置字典函数和方法</h2><h3 id="Python包括以下字典函数"><a href="#Python包括以下字典函数" class="headerlink" title="Python包括以下字典函数"></a>Python包括以下字典函数</h3><div class="table-container"><table><thead><tr><th>序号</th><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>cmp(dict1, dict2)</td><td>比较这两个字典的元素。</td></tr><tr><td>2</td><td>len(dict)</td><td>计算字典的总长度。这等于字典中的项的数目。</td></tr><tr><td>3</td><td>str(dict)</td><td>产生字典的可打印字符串表示</td></tr><tr><td>4</td><td>type(variable)</td><td>返回传递变量的类型。如果传递变量是字典，那么它会返回一个字典类型。</td></tr></tbody></table></div><h3 id="Python中包括以下字典方法"><a href="#Python中包括以下字典方法" class="headerlink" title="Python中包括以下字典方法 -"></a>Python中包括以下字典方法 -</h3><div class="table-container"><table><thead><tr><th>序号</th><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>dict.clear()</td><td>删除字典 dict 中的所有元素</td></tr><tr><td>2</td><td>dict.copy()</td><td>返回字典 dict 的浅表副本</td></tr><tr><td>3</td><td>dict.fromkeys()</td><td>使用seq的键和值来设置创建新字典</td></tr><tr><td>4</td><td>dict.get(key, default=None)</td><td>对于键key，返回其值或default如果键不存在于字典中</td></tr><tr><td>5</td><td>dict.has_key(key)</td><td>返回true如果在字典dict有存在键key，否则为false</td></tr><tr><td>6</td><td>dict.items()</td><td>返回 dict (键，值)元组对的列表</td></tr><tr><td>7</td><td>dict.keys()</td><td>返回字典 dict 的键列表</td></tr><tr><td>8</td><td>dict.setdefault(key, default=None)</td><td>类似于get()方法，但会设定dict[key]=default，如果键不存在于dict中</td></tr><tr><td>9</td><td>dict.update(dict2)</td><td>添加字典dict2的键值对到dict</td></tr><tr><td>10</td><td>dict.values()</td><td>返回字典dict值列表</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;每个键是从它的值由冒号(:)，即在项目之间用逗号隔开，整个东西是包含在大括号中。没有任何项目一个空字典只写两个大括号，就像这样：&lt;code&gt;{}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;键在一个字典中是唯一的，而值则可以重复。字典的值可以是任何类型，但键必须是不可变的数据的类型，例如：字符串，数字或元组这样的类型。&lt;/p&gt;
&lt;h2 id=&quot;访问字典中的值&quot;&gt;&lt;a href=&quot;#访问字典中的值&quot; class=&quot;headerlink&quot; title=&quot;访问字典中的值&quot;&gt;&lt;/a&gt;访问字典中的值&lt;/h2&gt;&lt;p&gt;要访问字典元素，你可以使用方括号和对应键，以获得其对应的值。下面是一个简单的例子 -&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dict = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;Name&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Saul&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Age&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Class&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Third&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;dict[&#39;Name&#39;]: &quot;&lt;/span&gt;, dict[&lt;span class=&quot;string&quot;&gt;&#39;Name&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;dict[&#39;Age&#39;]: &quot;&lt;/span&gt;, dict[&lt;span class=&quot;string&quot;&gt;&#39;Age&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当执行上面的代码，它产生以下结果 &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dict[&lt;span class=&quot;string&quot;&gt;&#39;Name&#39;&lt;/span&gt;]:  Saul&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dict[&lt;span class=&quot;string&quot;&gt;&#39;Age&#39;&lt;/span&gt;]:  &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果我们试图使用一个键，但这是不字典访问数据项的一部分，我们会得到一个错误如下 &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dict = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;Name&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Saul&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Age&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Class&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;Third&#39;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;dict[&#39;Alice&#39;]: &quot;&lt;/span&gt;, dict[&lt;span class=&quot;string&quot;&gt;&#39;Alice&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当执行上面的代码，它产生以下结果 &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dict[&lt;span class=&quot;string&quot;&gt;&#39;Saul&#39;&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Traceback (most recent call last):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  File &lt;span class=&quot;string&quot;&gt;&quot;test.py&quot;&lt;/span&gt;, line &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;dict[&#39;Alice&#39;]: &quot;&lt;/span&gt;, dict[&lt;span class=&quot;string&quot;&gt;&#39;Alice&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;KeyError: &lt;span class=&quot;string&quot;&gt;&#39;Alice&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础- I/O 简介</title>
    <link href="http://yoursite.com/2017/11/13/2017-11-13_Programing-Python-Basic-IO-intro/"/>
    <id>http://yoursite.com/2017/11/13/2017-11-13_Programing-Python-Basic-IO-intro/</id>
    <published>2017-11-13T05:44:24.000Z</published>
    <updated>2019-11-22T06:19:49.308Z</updated>
    
    <content type="html"><![CDATA[<p>这里只讲述基本的 I/O 函数，更多函数请参考Python标准文档。</p><blockquote><p>Python 3.x I/O 标准文档位置  <a href="https://docs.python.org/3/library/io.html" target="_blank" rel="noopener">https://docs.python.org/3/library/io.html</a></p></blockquote><hr><h2 id="打印到屏幕"><a href="#打印到屏幕" class="headerlink" title="打印到屏幕"></a>打印到屏幕</h2><p>最简单的输出方法是用<code>print</code>函数，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></span><br><span class="line">print(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure><p>你的标准屏幕上会产生以下结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-e87780fd91230718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hello world"></p><h2 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h2><p>Python 3 提供了内置函数从标准输入读入一行文本，默认的标准输入是键盘。</p><a id="more"></a><h3 id="input-函数"><a href="#input-函数" class="headerlink" title="input 函数"></a>input 函数</h3><p><strong>input([prompt])</strong> 函数，<code>input</code> 可以接收一个Python表达式作为输入，并将运算结果返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></span><br><span class="line"> </span><br><span class="line">str = input(<span class="string">"请输入："</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"你输入的内容是: "</span>, str)</span><br></pre></td></tr></table></figure><p>这会产生如下的对应着输入的结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-7aaa0b67137263ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input"></p><hr><h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>现在，您已经可以向标准输入和输出进行读写。现在，来看看怎么读写实际的数据文件。</p><p>Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 <strong>file</strong> 对象做大部分的文件操作。</p><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h3><p>你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。</p><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file object = open(file_name [, access_mode][, buffering])</span><br></pre></td></tr></table></figure><p>各个参数的细节如下：</p><ul><li>file_name：<br>file_name变量是一个包含了你要访问的文件名称的字符串值。</li><li>access_mode：<br>access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li><li>buffering:<br>如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。</li></ul><p>不同模式打开文件的完全列表：</p><div class="table-container"><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>t</td><td>文本模式 (默认)。</td></tr><tr><td>x</td><td>写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td>b</td><td>二进制模式。</td></tr><tr><td>+</td><td>打开一个文件进行更新(可读可写)。</td></tr><tr><td>U</td><td>通用换行模式（不推荐）。</td></tr><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td>w</td><td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>w+</td><td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb+</td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>a</td><td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>a+</td><td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table></div><p>下图很好的总结了这几种模式：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-e33ee7e59b1f578c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不同模式打开文件"></p><div class="table-container"><table><thead><tr><th>模式</th><th>r</th><th>r+</th><th>w</th><th>w+</th><th>a</th><th>a+</th></tr></thead><tbody><tr><td>读</td><td>+</td><td>+</td><td></td><td>+</td><td></td><td>+</td></tr><tr><td>写</td><td></td><td>+</td><td>+</td><td>+</td><td>+</td><td>+</td></tr><tr><td>创建</td><td></td><td></td><td>+</td><td>+</td><td>+</td><td>+</td></tr><tr><td>覆盖</td><td></td><td></td><td>+</td><td>+</td><td></td><td></td></tr><tr><td>指针在开始</td><td>+</td><td>+</td><td>+</td><td>+</td><td></td><td></td></tr><tr><td>指针在结尾</td><td></td><td></td><td></td><td></td><td>+</td><td>+</td></tr></tbody></table></div><hr><h2 id="File对象的属性"><a href="#File对象的属性" class="headerlink" title="File对象的属性"></a>File对象的属性</h2><p>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。</p><p>以下是和file对象相关的所有属性的列表：</p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>file.closed</td><td>返回true如果文件已被关闭，否则返回false。</td></tr><tr><td>file.mode</td><td>返回被打开文件的访问模式。</td></tr><tr><td>file.name</td><td>返回文件的名称。</td></tr><tr><td>file.softspace</td><td>如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td></tr></tbody></table></div><p>如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"文件名: "</span>, fo.name)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"是否已关闭 : "</span>, fo.closed)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"访问模式 : "</span>, fo.mode)</span><br></pre></td></tr></table></figure><p>以上实例输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-6f26e4d45e1aadac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="close 文件"></p><h3 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h3><p>File 对象的 close()方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。</p><p>当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。</p><p>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.close()</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"文件名: "</span>, fo.name)</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure></p><p>以上实例输出结果：</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/34293a3ecaa0cb2f69d381ae0453bbef.png" alt="image.png"></p><p>读写文件：</p><p>file对象提供了一系列方法，能让我们的文件访问更轻松。来看看如何使用read()和write()方法来读取和写入文件。</p><h3 id="write-方法"><a href="#write-方法" class="headerlink" title="write()方法"></a>write()方法</h3><p><code>write()</code>方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。</p><p><code>write()</code>方法不会在字符串的结尾添加换行符(‘\n’)：</p><p>语法：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.write(string)</span><br></pre></td></tr></table></figure></p><p>在这里，被传递的参数是要写入到已打开文件的内容。</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">fo.write( <span class="string">"www.xiaozhuanlan.com!\nVery good site!\n"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure><p>上述方法会创建temp.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.xiaozhuanlan.com!  </span><br><span class="line">Very good site!</span><br></pre></td></tr></table></figure></p><h3 id="read-方法"><a href="#read-方法" class="headerlink" title="read()方法"></a>read()方法</h3><p><code>read()</code>方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。</p><p>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.read([count])</span><br></pre></td></tr></table></figure></p><p>在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。</p><p>这里我们用到以上创建的 foo.txt 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"temp.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">str = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"读取的字符串是 : "</span>, str)</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure><p>以上实例输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-bea32e445d75c946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="read file"></p><h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><ul><li><p>tell()方法<br>告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。</p></li><li><p>seek（offset [,from]）方法<br>改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。</p><p>如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。</p></li></ul><p>例子：</p><p>就用我们上面创建的文件temp.txt。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">str = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"读取的字符串是 : "</span>, str</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查找当前位置</span></span><br><span class="line">position = fo.tell()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"当前文件位置 : "</span>, position)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把指针再次重新定位到文件开头</span></span><br><span class="line">position = fo.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">str = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> （<span class="string">"重新读取字符串 : "</span>, str）</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-9dfe3cba7f0a9e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="重命名和删除文件"><a href="#重命名和删除文件" class="headerlink" title="重命名和删除文件"></a>重命名和删除文件</h2><p>Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。</p><p>要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。</p><p>rename()方法：</p><p>rename()方法需要两个参数，当前的文件名和新文件名。</p><p>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.rename(current_file_name, new_file_name)</span><br></pre></td></tr></table></figure></p><p>例子：</p><p>下例将重命名一个已经存在的文件 temp.txt。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重命名文件temp.txt到temp-1.txt。</span></span><br><span class="line">os.rename( <span class="string">"temp.txt"</span>, <span class="string">"temp-1.txt"</span> )</span><br></pre></td></tr></table></figure><h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h3><p>你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。</p><p>语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.remove(file_name)</span><br></pre></td></tr></table></figure></p><p>例子：</p><p>下例将删除一个已经存在的文件temp-1.txt。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除temp-1.txt。</span></span><br><span class="line">os.remove( <span class="string">"temp-1.txt"</span>)</span><br></pre></td></tr></table></figure></p><hr><h2 id="Python里的目录："><a href="#Python里的目录：" class="headerlink" title="Python里的目录："></a>Python里的目录：</h2><p>所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。</p><h3 id="mkdir-方法"><a href="#mkdir-方法" class="headerlink" title="mkdir()方法"></a>mkdir()方法</h3><p>可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。</p><p>语法：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.mkdir(<span class="string">"newdir"</span>)</span><br></pre></td></tr></table></figure><p>例子：</p><p>下例将在当前目录下创建一个新目录test。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建目录test</span></span><br><span class="line">os.mkdir(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><h3 id="chdir-方法"><a href="#chdir-方法" class="headerlink" title="chdir()方法"></a>chdir()方法</h3><p>可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。</p><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">"newdir"</span>)</span><br></pre></td></tr></table></figure><p>例子：</p><p>下例将进入”test”目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建目录test</span></span><br><span class="line">os.chdir(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure></p><p>getcwd()方法：</p><p>getcwd()方法显示当前的工作目录。</p><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure><p>例子：</p><p>下例给出当前目录：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给出当前的目录</span></span><br><span class="line"><span class="keyword">print</span> (os.getcwd())</span><br></pre></td></tr></table></figure></p><h3 id="rmdir-方法"><a href="#rmdir-方法" class="headerlink" title="rmdir()方法"></a>rmdir()方法</h3><p>rmdir()方法删除目录，目录名称以参数传递。在删除这个目录之前，它的所有内容应该先被清除。</p><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.rmdir()</span><br></pre></td></tr></table></figure><p>例子：</p><p>以下是删除” test”目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给出当前的目录</span></span><br><span class="line">os.rmdir(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure></p><hr><h2 id="文件、目录相关的方法"><a href="#文件、目录相关的方法" class="headerlink" title="文件、目录相关的方法"></a>文件、目录相关的方法</h2><p>File 对象和 OS 对象提供了很多文件与目录的操作方法，可以通过点击下面链接查看详情：</p><ul><li><a href="https://docs.python.org/3/tutorial/inputoutput.html" target="_blank" rel="noopener">File 对象方法</a>: file 对象提供了操作文件的一系列方法。</li><li><a href="https://docs.python.org/3/library/os.html" target="_blank" rel="noopener">OS 对象方法</a>: 提供了处理文件及目录的一系列方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里只讲述基本的 I/O 函数，更多函数请参考Python标准文档。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python 3.x I/O 标准文档位置  &lt;a href=&quot;https://docs.python.org/3/library/io.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/3/library/io.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;打印到屏幕&quot;&gt;&lt;a href=&quot;#打印到屏幕&quot; class=&quot;headerlink&quot; title=&quot;打印到屏幕&quot;&gt;&lt;/a&gt;打印到屏幕&lt;/h2&gt;&lt;p&gt;最简单的输出方法是用&lt;code&gt;print&lt;/code&gt;函数，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -*- coding: UTF-8 -*- &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你的标准屏幕上会产生以下结果：&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-e87780fd91230718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;hello world&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;读取键盘输入&quot;&gt;&lt;a href=&quot;#读取键盘输入&quot; class=&quot;headerlink&quot; title=&quot;读取键盘输入&quot;&gt;&lt;/a&gt;读取键盘输入&lt;/h2&gt;&lt;p&gt;Python 3 提供了内置函数从标准输入读入一行文本，默认的标准输入是键盘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础-`yeild` 关键字使用</title>
    <link href="http://yoursite.com/2017/11/12/2017-11-12_Programing-Python-Basic-use-yield/"/>
    <id>http://yoursite.com/2017/11/12/2017-11-12_Programing-Python-Basic-use-yield/</id>
    <published>2017-11-12T05:49:11.000Z</published>
    <updated>2019-11-22T06:19:16.082Z</updated>
    
    <content type="html"><![CDATA[<hr><p>大家在阅读 Python 代码时，经常遇到带有 <code>yield</code> 的函数，通常此时我们都需要去想想这个<code>yield</code> 是个什么东西？这一段代码在讲什么事情呢？</p><p>那我们这里就来好好讲讲这个 <code>yield</code>。</p><p><code>yield</code> 是 Python 设计之初就保留的关键字之一。</p><p>在 Python 中被称之为 <code>generator</code>(中文翻译是 <code>“生成器”</code>)，那什么是 <code>generator</code> 呢 ？</p><p>我们先抛开 <code>generator</code>，以一个常见的编程题目来展示 <code>yield</code> 的概念。</p><hr><h2 id="从生成斐波那契数列开始"><a href="#从生成斐波那契数列开始" class="headerlink" title="从生成斐波那契数列开始"></a>从生成斐波那契数列开始</h2><p>斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。</p><p>用计算机程序输出斐波那契数列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出斐波那契数列前 N 个数第一版</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">       print(b)</span><br><span class="line">       a, b = b, a + b</span><br><span class="line">       n = n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fab(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>将上面的内容保存为 <code>.py</code> 后缀的文件，然后执行 ，我们可以得到如下输出：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-03a4c82710ec33e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果1"></p><p>结果没有问题，但有经验的开发者会指出，直接在 fab 函数中用 print 打印数字会导致该函数可复用性较差，因为 fab 函数返回 None，其他函数无法获得该函数生成的数列。</p><p>要提高 fab 函数的可复用性，最好不要直接打印出数列，而是返回一个 List。</p><p>以下是 fab 函数改写后的第二个版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出斐波那契数列前 N 个数第二版</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span> </span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> </span><br><span class="line">    L = [] </span><br><span class="line">    <span class="keyword">while</span> n &lt; max: </span><br><span class="line">        L.append(b) </span><br><span class="line">        a, b = b, a + b </span><br><span class="line">        n = n + <span class="number">1</span> </span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure><p>执行 ，我们可以得到如下输出：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-4c63ee7aa08c18ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果2"></p><p>改写后的 fab 函数通过返回 List 能满足复用性的要求，但是更有经验的开发者会指出，该函数在运行中占用的内存会随着参数 max 的增大而增大，如果要控制内存占用，最好不要用 List</p><p>来保存中间结果，而是通过 iterable 对象来迭代。例如，在 Python 中，<code>range()</code> 不返回 List，而是返回一个 <code>iterable</code>(中文翻译 <code>“可迭代的对象”</code>) 对象。</p><p>例如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 iterable 对象来迭代</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>是在每次迭代中返回下一个数值，内存空间占用很小。</p><p>我们可以利用 <code>iterable</code> 的特性，把 fab 函数改写为一个支持 <code>iterable</code> 的 class，以下是第三个版本的 Fab：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出斐波那契数列前 N 个数第三版</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fab</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">       self.max = max</span><br><span class="line">       self.n, self.a, self.b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> self.n &lt; self.max:</span><br><span class="line">           r = self.b</span><br><span class="line">           self.a, self.b = self.b, self.a + self.b</span><br><span class="line">           self.n = self.n + <span class="number">1</span></span><br><span class="line">           <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">raise</span> StopIteration()</span><br><span class="line"><span class="comment"># Fab 类通过 next() 不断返回数列的下一个数，内存占用始终为常数：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> Fab(<span class="number">5</span>):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure><p>执行 ，我们可以得到如下输出：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-6f51a320b6673d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果3"></p><p>然而，使用 class 改写的这个版本，代码远远没有第一版的 fab 函数来得简洁。</p><p>如果我们想要保持第一版 fab 函数的简洁性，同时又要获得 <code>iterable</code> 的效果，<code>yield</code> 就派上用场了。</p><a id="more"></a><h2 id="使用-yield-生成斐波那契数列"><a href="#使用-yield-生成斐波那契数列" class="headerlink" title="使用 yield 生成斐波那契数列"></a>使用 <code>yield</code> 生成斐波那契数列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        <span class="comment"># print(b)</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure><p>第四个版本的 fab 和第一版相比，仅仅把 <code>print(b)</code> 改为了 <code>yield b</code> ，就在保持简洁性的同时获得了 <code>iterable</code> 的效果。</p><p>那么 <code>yield</code> 到底做了什么呢？</p><p>简单地讲，<code>yield</code> 的作用就是把一个函数变成一个 <code>generator</code>，带有 <code>yield</code> 的函数不再是一个普通函数，Python 解释器会将其视为一个 <code>generator</code>。</p><p>调用 <code>fab(5)</code> 不会执行 fab 函数，而是返回一个 <code>iterable</code> 对象！</p><p>在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 <code>yield b</code> 时，fab 函数就返回一个迭代值，下次迭代时，代码从 <code>yield b</code> 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 <code>yield</code>。</p><p>为了精通 <code>yield</code> ,你必须要理解：当你调用这个函数的时候，函数内部的代码并不立马执行 ，这个函数只是返回一个 <code>generator</code> 对象。</p><p>函数内的代码只有当你使用 <code>for</code> 进行迭代的时候(也就是 <code>for n in fab(5):</code> 这一句)。</p><p>现在到了关键点了！</p><p><strong>第一次迭代中你的函数会执行，从开始到达 yield 关键字，然后返回 yield 后的值作为第一次迭代的返回值. 然后，每次执行这个函数都会继续执行你在函数内部定义的那个循环的下一次，再返回那个值，直到没有可以返回的。</strong></p><p>如果 <code>generator</code> 内部没有定义 yield 关键字，那么这个 <code>generator</code> 被认为成空的。这种情况可能因为是循环进行没了，或者是没有满足 <code>if/else</code> 条件。</p><p>yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值，不仅代码简洁，而且执行流程异常清晰。</p><hr><h2 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h2><p>要注意区分 fab 和 fab(5)，fab 是一个 <code>generator function</code>，而 fab(5) 是调用 fab 返回的一个 <code>generator</code>，好比类的定义和类的实例的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类的定义和类的实例</span></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">print(isinstance(fab, types.GeneratorType))</span><br><span class="line"><span class="comment"># 将输出 False</span></span><br><span class="line">print(isinstance(fab(<span class="number">5</span>), types.GeneratorType))</span><br><span class="line"><span class="comment"># 将输出 True</span></span><br></pre></td></tr></table></figure><p>fab 是无法迭代的，而 fab(5) 是可迭代的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">print(isinstance(fab, Iterable)）</span><br><span class="line"><span class="comment"># 将输出 False</span></span><br><span class="line">print(isinstance(fab(<span class="number">5</span>), Iterable))</span><br><span class="line"><span class="comment"># 将输出 True</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="yield-的实际使用"><a href="#yield-的实际使用" class="headerlink" title="yield 的实际使用"></a><code>yield</code> 的实际使用</h2><p>下面我们通过一个实际的例子来再次回顾下 <code>yield</code> 的用法。</p><p>通过 <code>yield</code> 来进行文件读取。如果直接对文件对象调用 <code>read()</code> 方法，会导致不可预测的内存占用。</p><p>好的方法是利用固定长度的缓冲区来不断读取文件内容。通过 <code>yield</code>，我们不再需要编写读文件的迭代类，就可以轻松实现文件读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 yield 读取文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    BLOCK_SIZE = <span class="number">2048</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            block = f.read(BLOCK_SIZE)</span><br><span class="line">            <span class="keyword">if</span> block:</span><br><span class="line">                <span class="keyword">yield</span> block</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>以上内容介绍了 <code>yield</code> 的基本概念和用法。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;大家在阅读 Python 代码时，经常遇到带有 &lt;code&gt;yield&lt;/code&gt; 的函数，通常此时我们都需要去想想这个&lt;code&gt;yield&lt;/code&gt; 是个什么东西？这一段代码在讲什么事情呢？&lt;/p&gt;
&lt;p&gt;那我们这里就来好好讲讲这个 &lt;code&gt;yield&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yield&lt;/code&gt; 是 Python 设计之初就保留的关键字之一。&lt;/p&gt;
&lt;p&gt;在 Python 中被称之为 &lt;code&gt;generator&lt;/code&gt;(中文翻译是 &lt;code&gt;“生成器”&lt;/code&gt;)，那什么是 &lt;code&gt;generator&lt;/code&gt; 呢 ？&lt;/p&gt;
&lt;p&gt;我们先抛开 &lt;code&gt;generator&lt;/code&gt;，以一个常见的编程题目来展示 &lt;code&gt;yield&lt;/code&gt; 的概念。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;从生成斐波那契数列开始&quot;&gt;&lt;a href=&quot;#从生成斐波那契数列开始&quot; class=&quot;headerlink&quot; title=&quot;从生成斐波那契数列开始&quot;&gt;&lt;/a&gt;从生成斐波那契数列开始&lt;/h2&gt;&lt;p&gt;斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。&lt;/p&gt;
&lt;p&gt;用计算机程序输出斐波那契数列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 输出斐波那契数列前 N 个数第一版&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fab&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(max)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n, a, b = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; n &amp;lt; max:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       print(b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       a, b = b, a + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       n = n + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fab(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将上面的内容保存为 &lt;code&gt;.py&lt;/code&gt; 后缀的文件，然后执行 ，我们可以得到如下输出：&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-03a4c82710ec33e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;结果1&quot;&gt;&lt;/p&gt;
&lt;p&gt;结果没有问题，但有经验的开发者会指出，直接在 fab 函数中用 print 打印数字会导致该函数可复用性较差，因为 fab 函数返回 None，其他函数无法获得该函数生成的数列。&lt;/p&gt;
&lt;p&gt;要提高 fab 函数的可复用性，最好不要直接打印出数列，而是返回一个 List。&lt;/p&gt;
&lt;p&gt;以下是 fab 函数改写后的第二个版本：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 输出斐波那契数列前 N 个数第二版&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fab&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(max)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n, a, b = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    L = [] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; n &amp;lt; max: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        L.append(b) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a, b = b, a + b &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        n = n + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; L&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; n &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fab(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(n)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行 ，我们可以得到如下输出：&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-4c63ee7aa08c18ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;结果2&quot;&gt;&lt;/p&gt;
&lt;p&gt;改写后的 fab 函数通过返回 List 能满足复用性的要求，但是更有经验的开发者会指出，该函数在运行中占用的内存会随着参数 max 的增大而增大，如果要控制内存占用，最好不要用 List&lt;/p&gt;
&lt;p&gt;来保存中间结果，而是通过 iterable 对象来迭代。例如，在 Python 中，&lt;code&gt;range()&lt;/code&gt; 不返回 List，而是返回一个 &lt;code&gt;iterable&lt;/code&gt;(中文翻译 &lt;code&gt;“可迭代的对象”&lt;/code&gt;) 对象。&lt;/p&gt;
&lt;p&gt;例如下面的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 通过 iterable 对象来迭代&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;是在每次迭代中返回下一个数值，内存空间占用很小。&lt;/p&gt;
&lt;p&gt;我们可以利用 &lt;code&gt;iterable&lt;/code&gt; 的特性，把 fab 函数改写为一个支持 &lt;code&gt;iterable&lt;/code&gt; 的 class，以下是第三个版本的 Fab：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 输出斐波那契数列前 N 个数第三版&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Fab&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, max)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       self.max = max&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       self.n, self.a, self.b = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__iter__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__next__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; self.n &amp;lt; self.max:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           r = self.b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           self.a, self.b = self.b, self.a + self.b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           self.n = self.n + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; r&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; StopIteration()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Fab 类通过 next() 不断返回数列的下一个数，内存占用始终为常数：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; n &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; Fab(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(n)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行 ，我们可以得到如下输出：&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-6f51a320b6673d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;结果3&quot;&gt;&lt;/p&gt;
&lt;p&gt;然而，使用 class 改写的这个版本，代码远远没有第一版的 fab 函数来得简洁。&lt;/p&gt;
&lt;p&gt;如果我们想要保持第一版 fab 函数的简洁性，同时又要获得 &lt;code&gt;iterable&lt;/code&gt; 的效果，&lt;code&gt;yield&lt;/code&gt; 就派上用场了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Programing-Python-Basic-use_random</title>
    <link href="http://yoursite.com/2017/11/11/2017-11-11_Programing-Python-Basic-use-random/"/>
    <id>http://yoursite.com/2017/11/11/2017-11-11_Programing-Python-Basic-use-random/</id>
    <published>2017-11-11T08:03:23.000Z</published>
    <updated>2019-11-22T06:22:51.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-获得-a-b-之间的随机整数"><a href="#一-获得-a-b-之间的随机整数" class="headerlink" title="一 获得[a, b]之间的随机整数"></a>一 获得[a, b]之间的随机整数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(random.randint(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h2 id="二-从一个非空序列中随机挑选一个元素"><a href="#二-从一个非空序列中随机挑选一个元素" class="headerlink" title="二 从一个非空序列中随机挑选一个元素"></a>二 从一个非空序列中随机挑选一个元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(random.choice([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><a id="more"></a><p>或<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从0～9中随机取一整数</span></span><br><span class="line">print(random.choice(range(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure></p><h2 id="三-按指定基数递增的集合中获取随机数"><a href="#三-按指定基数递增的集合中获取随机数" class="headerlink" title="三 按指定基数递增的集合中获取随机数"></a>三 按指定基数递增的集合中获取随机数</h2><p>基数缺省值为1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># randrange([start,]stop[,step]) 取不到stop对应的值</span></span><br><span class="line">print(random.randrange(<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><h2 id="四-随机打乱列表的元素"><a href="#四-随机打乱列表的元素" class="headerlink" title="四 随机打乱列表的元素"></a>四 随机打乱列表的元素</h2><p>就地修改，返回值为None<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">random.shuffle(lst)</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-获得-a-b-之间的随机整数&quot;&gt;&lt;a href=&quot;#一-获得-a-b-之间的随机整数&quot; class=&quot;headerlink&quot; title=&quot;一 获得[a, b]之间的随机整数&quot;&gt;&lt;/a&gt;一 获得[a, b]之间的随机整数&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; random&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(random.randint(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;二-从一个非空序列中随机挑选一个元素&quot;&gt;&lt;a href=&quot;#二-从一个非空序列中随机挑选一个元素&quot; class=&quot;headerlink&quot; title=&quot;二 从一个非空序列中随机挑选一个元素&quot;&gt;&lt;/a&gt;二 从一个非空序列中随机挑选一个元素&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; random&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(random.choice([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础-PEP 是什么？</title>
    <link href="http://yoursite.com/2017/11/05/2017-11-05_Programing-Python-Basic-what-is-PEP/"/>
    <id>http://yoursite.com/2017/11/05/2017-11-05_Programing-Python-Basic-what-is-PEP/</id>
    <published>2017-11-05T05:56:46.000Z</published>
    <updated>2019-11-22T06:18:32.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PEP-是什么？"><a href="#PEP-是什么？" class="headerlink" title="PEP 是什么？"></a>PEP 是什么？</h2><p>Python的 PEP 文档是一组不断发展的标准文档，PEP是 <code>Python Enhancement Proposal</code>的首字母缩写。就像TCPIP协议使用RFC来组织起不断发展的通信标准一样，PEP也是类似的用于发展Python的一组文档。</p><p>PEP的全称是Python Enhancement Proposals，其中Enhancement是增强改进的意思，Proposals则可译为提案或建议书，所以合起来，比较常见的翻译是 Python 增强提案或 Python 改进建议书。Python 核心开发者主要通过邮件列表讨论问题、提议、计划等，PEP 通常是汇总了多方信息，经过了部分核心开发者 review 和认可，最终形成的正式文档，起到了对外公示的作用。</p><p>PEP文档越多，说明 Python 社区越活跃，发展良好。</p><h2 id="PEP-的类型"><a href="#PEP-的类型" class="headerlink" title="PEP 的类型"></a>PEP 的类型</h2><p>每个PEP都有对应的类型（PEP Status Key）：</p><p>A – Accepted (Standards Track only) or Active proposal 已接受（仅限标准跟踪）或有效提案<br>D – Deferred proposal延期提案<br>F – Final proposal 最终提案<br>P – Provisional proposal 暂定提案<br>R – Rejected proposal 拒绝提案<br>S – Superseded proposal 被取代的提案<br>W – Withdrawn proposal 撤回提案</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-ffd775233a9043a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PEP Status"></p><h2 id="几个特殊的PEP"><a href="#几个特殊的PEP" class="headerlink" title="几个特殊的PEP"></a>几个特殊的PEP</h2><h3 id="PEP-0"><a href="#PEP-0" class="headerlink" title="PEP 0"></a>PEP 0</h3><p><a href="https://www.python.org/dev/peps/" target="_blank" rel="noopener">https://www.python.org/dev/peps/</a></p><p>这个文档是属于Information类的PEP文档，是所有PEP文档的索引。</p><h3 id="PEP-1"><a href="#PEP-1" class="headerlink" title="PEP 1"></a>PEP 1</h3><p><a href="https://www.python.org/dev/peps/pep-0001/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0001/</a></p><p>这个文档讲了PEP的目的和指引。</p><p>在PEP 1中的开头，就说明了PEP文档分成3个类型：</p><ol><li>标准，当然是Python语言的标准；</li><li>信息类；</li><li>过程类，记录Python语言发展过程中的一些信息。</li></ol><h3 id="PEP-8"><a href="#PEP-8" class="headerlink" title="PEP 8"></a>PEP 8</h3><p><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></p><p>PEP 8号文档，是Python官方出的编程规范.</p><a id="more"></a><h3 id="PEP-20"><a href="#PEP-20" class="headerlink" title="PEP 20"></a>PEP 20</h3><p><a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0020/</a><br>Python 之禅，就是我们在python 解释器中输入</p><p>每次Python官方发布新版本，新版本的New Features都有相应的PEP文档支撑，比如3.7.0版本，PEP文档成了Python发展的需求管理工具。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-4e51d36b3d821fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Python 3.7.0版本关联的PEP"></p><p>Python新版本的New Features都有相应的PEP文档支撑</p><p>详见：<a href="https://www.python.org/downloads/release/python-370/" target="_blank" rel="noopener">https://www.python.org/downloads/release/python-370/</a></p><h3 id="其它需要重点关注的PEP"><a href="#其它需要重点关注的PEP" class="headerlink" title="其它需要重点关注的PEP"></a>其它需要重点关注的PEP</h3><ul><li>PEP 7 — Style Guide for C Code，C扩展</li><li>PEP 202 — List Comprehensions，列表生成式</li><li>PEP 274 — Dict Comprehensions，字典生成式</li><li>PEP 234 — Iterators，迭代器</li><li>PEP 257 — Docstring Conventions，文档注释规范</li><li>PEP 279 — The enumerate() built-in function，enumerate枚举</li><li>PEP 282 — A Logging System，日志模块</li><li>PEP 285 — Adding a bool type，布尔值</li><li>PEP 289 — Generator Expressions，生成器表达式</li><li>PEP 318 — Decorators for Functions and Methods，装饰器</li><li>PEP 342 — Coroutines via Enhanced Generators，协程</li><li>PEP 343 — The “with” Statement，with语句</li><li>PEP 380 — Syntax for Delegating to a Subgenerator，yield from语法</li><li>PEP 405 — Python Virtual Environments，虚拟环境</li><li>PEP 471 — os.scandir() function，遍历目录</li><li>PEP 484 — Type Hints，类型约束</li><li>PEP 492 — Coroutines with async and await syntax，async/await语法</li><li>PEP 498 — Literal String Interpolation Python，字面字符串插值</li><li>PEP 525 — Asynchronous Generators，异步生成器</li><li>PEP 572 — Assignment Expressions，表达式内赋值</li><li>PEP 3105 — Make print a function，print改为函数</li><li>PEP 3115 — Metaclasses in Python 3000，元类</li><li>PEP 3120 — Using UTF-8 as the default source encoding，默认UTF-8</li><li>PEP 3333 — Python Web Server Gateway Interface v1.0.1，Web开发</li><li>PEP 8000 — Python Language Governance Proposal Overview，GvR老爹推出决策层后，事关新决策方案</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PEP-是什么？&quot;&gt;&lt;a href=&quot;#PEP-是什么？&quot; class=&quot;headerlink&quot; title=&quot;PEP 是什么？&quot;&gt;&lt;/a&gt;PEP 是什么？&lt;/h2&gt;&lt;p&gt;Python的 PEP 文档是一组不断发展的标准文档，PEP是 &lt;code&gt;Python Enhancement Proposal&lt;/code&gt;的首字母缩写。就像TCPIP协议使用RFC来组织起不断发展的通信标准一样，PEP也是类似的用于发展Python的一组文档。&lt;/p&gt;
&lt;p&gt;PEP的全称是Python Enhancement Proposals，其中Enhancement是增强改进的意思，Proposals则可译为提案或建议书，所以合起来，比较常见的翻译是 Python 增强提案或 Python 改进建议书。Python 核心开发者主要通过邮件列表讨论问题、提议、计划等，PEP 通常是汇总了多方信息，经过了部分核心开发者 review 和认可，最终形成的正式文档，起到了对外公示的作用。&lt;/p&gt;
&lt;p&gt;PEP文档越多，说明 Python 社区越活跃，发展良好。&lt;/p&gt;
&lt;h2 id=&quot;PEP-的类型&quot;&gt;&lt;a href=&quot;#PEP-的类型&quot; class=&quot;headerlink&quot; title=&quot;PEP 的类型&quot;&gt;&lt;/a&gt;PEP 的类型&lt;/h2&gt;&lt;p&gt;每个PEP都有对应的类型（PEP Status Key）：&lt;/p&gt;
&lt;p&gt;A – Accepted (Standards Track only) or Active proposal 已接受（仅限标准跟踪）或有效提案&lt;br&gt;D – Deferred proposal延期提案&lt;br&gt;F – Final proposal 最终提案&lt;br&gt;P – Provisional proposal 暂定提案&lt;br&gt;R – Rejected proposal 拒绝提案&lt;br&gt;S – Superseded proposal 被取代的提案&lt;br&gt;W – Withdrawn proposal 撤回提案&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-ffd775233a9043a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;PEP Status&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;几个特殊的PEP&quot;&gt;&lt;a href=&quot;#几个特殊的PEP&quot; class=&quot;headerlink&quot; title=&quot;几个特殊的PEP&quot;&gt;&lt;/a&gt;几个特殊的PEP&lt;/h2&gt;&lt;h3 id=&quot;PEP-0&quot;&gt;&lt;a href=&quot;#PEP-0&quot; class=&quot;headerlink&quot; title=&quot;PEP 0&quot;&gt;&lt;/a&gt;PEP 0&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.python.org/dev/peps/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个文档是属于Information类的PEP文档，是所有PEP文档的索引。&lt;/p&gt;
&lt;h3 id=&quot;PEP-1&quot;&gt;&lt;a href=&quot;#PEP-1&quot; class=&quot;headerlink&quot; title=&quot;PEP 1&quot;&gt;&lt;/a&gt;PEP 1&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0001/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.python.org/dev/peps/pep-0001/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个文档讲了PEP的目的和指引。&lt;/p&gt;
&lt;p&gt;在PEP 1中的开头，就说明了PEP文档分成3个类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标准，当然是Python语言的标准；&lt;/li&gt;
&lt;li&gt;信息类；&lt;/li&gt;
&lt;li&gt;过程类，记录Python语言发展过程中的一些信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;PEP-8&quot;&gt;&lt;a href=&quot;#PEP-8&quot; class=&quot;headerlink&quot; title=&quot;PEP 8&quot;&gt;&lt;/a&gt;PEP 8&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.python.org/dev/peps/pep-0008/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PEP 8号文档，是Python官方出的编程规范.&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java数组定义、使用、以及数组内存分析详解</title>
    <link href="http://yoursite.com/2017/09/22/2017-09-22_Programing-Java-Basic-Java-array-user-guide/"/>
    <id>http://yoursite.com/2017/09/22/2017-09-22_Programing-Java-Basic-Java-array-user-guide/</id>
    <published>2017-09-22T09:14:40.000Z</published>
    <updated>2019-11-22T06:22:18.778Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是从容器概念到数组概念再到数组的三种定义以及各种情况的数组内存分析，以及一些数组常用的遍历以及反转、取最大值等操作。旨在全面性了解java数组。</p><h2 id="1、什么是容器"><a href="#1、什么是容器" class="headerlink" title="1、什么是容器"></a>1、什么是容器</h2><p>在讲数组之前，很有必要来谈谈容器的概念 所谓容器就是将多个数据存储到一起，每个数据称为该容器的元素。</p><blockquote><p>生活中的容器：水杯，衣柜，教室</p></blockquote><h2 id="2、什么是数组"><a href="#2、什么是数组" class="headerlink" title="2、什么是数组"></a>2、什么是数组</h2><p>所谓数组就是存储数据<strong>长度固定</strong>的<strong>容器</strong>，保证多个数据的<strong>数据类型一致</strong>。</p><h2 id="3、数组的三种定义"><a href="#3、数组的三种定义" class="headerlink" title="3、数组的三种定义"></a>3、数组的三种定义</h2><p>下面主要讲解下数组的三种定义方式。</p><h3 id="定义方式一"><a href="#定义方式一" class="headerlink" title="定义方式一"></a>定义方式一</h3><blockquote><p><code>数据类型[] 数组名字 = new 数据类型 [长度]</code> ;</p></blockquote><p>举例： 定义可以存储3个整数的数组容器，代码如： <code>int[] arr = new int[3]</code></p><h3 id="定义方式二"><a href="#定义方式二" class="headerlink" title="定义方式二"></a>定义方式二</h3><blockquote><p><code>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3...}</code>;</p></blockquote><p>举例： 定义存储1，2，3，4，5整数的数组容器。 <code>int[] arr = new int[]{1,2,3,4,5}</code>;</p><h3 id="定义方式三"><a href="#定义方式三" class="headerlink" title="定义方式三"></a>定义方式三</h3><blockquote><p><code>数据类型[] 数组名 = {元素1,元素2,元素3...};</code></p></blockquote><p>举例： 定义存储1，2，3，4，5整数的数组容器 <code>int[] arr = {1,2,3,4,5}</code>;</p><h2 id="4、数组的访问"><a href="#4、数组的访问" class="headerlink" title="4、数组的访问"></a>4、数组的访问</h2><p><strong>索引</strong>：从<code>0</code>开始，索引 (<code>index</code>)可以访问到数组中的元素。</p><p><strong>格式</strong>： <code>数组名[索引]</code></p><p><strong>数组长度属性</strong>： 数组长度是固定的，由于索引从0开始，所以数组的最大索引值为<code>数组名.length-1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="comment">//打印数组的属性，输出结果是5 </span></span><br><span class="line">System.out.println(arr.length); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、什么是内存"><a href="#5、什么是内存" class="headerlink" title="5、什么是内存"></a>5、什么是内存</h2><blockquote><p>在讲数组的原理内存前，必须了解的一个叫内存的概念。</p></blockquote><p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程 序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。 Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p><h3 id="5-1-Java虚拟机的内存划分"><a href="#5-1-Java虚拟机的内存划分" class="headerlink" title="5.1 Java虚拟机的内存划分"></a>5.1 Java虚拟机的内存划分</h3><p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。<br> <img src="https://upload-images.jianshu.io/upload_images/1940331-210e2332016efef9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java虚拟机的内存划分"></p><h3 id="5-2-数组在内存中的存储"><a href="#5-2-数组在内存中的存储" class="headerlink" title="5.2 数组在内存中的存储"></a>5.2 数组在内存中的存储</h3><h4 id="5-2-1-一个数组内存图"><a href="#5-2-1-一个数组内存图" class="headerlink" title="5.2.1 一个数组内存图"></a>5.2.1 一个数组内存图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">    System.out.println(arr);<span class="comment">//[I@5f150435 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上方法执行，输出的结果是<code>[I@5f150435</code>，这个是什么呢？是数组在内存中的地址。<code>new</code>出来的内容，都是在堆内存中存储的，而方法中的变量<code>arr</code>保存的是数组的地址。</p><p>输出<code>arr[0]</code>，就会输出arr保存的内存地址中数组中0索引上的元素，如没有具体确定值，则是类型的默认值！比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] arr=<span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">  System.out.println(arr);     <span class="comment">//  [Ljava.lang.String;@1b6d3586</span></span><br><span class="line">  System.out.println(arr[<span class="number">0</span>]);  <span class="comment">//  null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arrInt=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">  System.out.println(arrInt);    <span class="comment">// [I@1b6d3586</span></span><br><span class="line">  System.out.println(arrInt[<span class="number">0</span>]); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1940331-28da6c1f89b1227e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组内存图"></p><h6 id="5-2-2-两个数组内存图"><a href="#5-2-2-两个数组内存图" class="headerlink" title="5.2.2 两个数组内存图"></a>5.2.2 两个数组内存图</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">    <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; </span><br><span class="line">    System.out.println(arr); </span><br><span class="line">    System.out.println(arr2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1940331-93464f888eec949f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个数组内存图"></p><h6 id="5-2-3-两个变量指向一个数组"><a href="#5-2-3-两个变量指向一个数组" class="headerlink" title="5.2.3 两个变量指向一个数组"></a>5.2.3 两个变量指向一个数组</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 定义数组，存储3个元素 </span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">    <span class="comment">//数组索引进行赋值 </span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">5</span>; </span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">6</span>; </span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">7</span>; </span><br><span class="line">    <span class="comment">//输出3个索引上的元素值 </span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]); </span><br><span class="line">    <span class="comment">//定义数组变量arr2，将arr的地址赋值给arr2 </span></span><br><span class="line">    <span class="keyword">int</span>[] arr2 = arr; </span><br><span class="line">    arr2[<span class="number">1</span>] = <span class="number">9</span>; </span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1940331-42b2add666df2164?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个变量指向一个数组"></p><h2 id="6、数组常见的异常"><a href="#6、数组常见的异常" class="headerlink" title="6、数组常见的异常"></a>6、数组常见的异常</h2><p>数组常见的异常主要有<code>数组越界异常</code>以及<code>空指针异常</code>，这是非常基础的，就不多做介绍了，这里主要分析下空指针异常在内存的情况<br> <img src="https://upload-images.jianshu.io/upload_images/1940331-e3c2b44c058df851?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组常见的异常"></p><h2 id="7、-数组遍历【重点】"><a href="#7、-数组遍历【重点】" class="headerlink" title="7、 数组遍历【重点】"></a>7、 数组遍历【重点】</h2><p>所谓数组遍历 就是将数组中的每个元素分别获取出来，就是遍历。遍历数组<strong>非常重要</strong>！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]); </span><br><span class="line">    System.out.println(arr[<span class="number">4</span>]); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，我把这种方式叫做傻瓜式遍历，这种傻瓜式写法肯定不行，因此我们需要改 造成循环的写法。数组的索引是 <code>0</code> 到 <code>lenght-1</code> ，可以作为循环的条件出现。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i])</span><br><span class="line">       &#125; </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="8、数组获取最大值元素"><a href="#8、数组获取最大值元素" class="headerlink" title="8、数组获取最大值元素"></a>8、数组获取最大值元素</h2><blockquote><p>实现思路： 定义变量，保存数组0索引上的元素 遍历数组，获取出数组中的每个元素 将遍历到的元素和保存数组0索引上值的变量进行比较 如果数组元素的值大于了变量的值，变量记录住新的值 数组循环遍历结束，变量保存的就是数组中的最大值</p></blockquote><p><strong>真香警告</strong>：<strong>大家小心点，别被第一个和第二个婆娘给迷住了</strong> </p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-1643dd7d135be094?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组获取最大值元素"></p><p> 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">15</span>, <span class="number">2000</span>, <span class="number">10000</span>, <span class="number">100</span>, <span class="number">4000</span> &#125;; </span><br><span class="line">    <span class="comment">//定义变量，保存数组中0索引的元素 </span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>]; </span><br><span class="line">    <span class="comment">//遍历数组，取出每个元素 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; </span><br><span class="line">    <span class="comment">//遍历到的元素和变量max比较 </span></span><br><span class="line">    <span class="comment">//如果数组元素大于max </span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; max) &#123; </span><br><span class="line">    <span class="comment">//max记录住大值 </span></span><br><span class="line">    max = arr[i]; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">System.out.println(<span class="string">"数组最大值是： "</span> + max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、-数组反转"><a href="#9、-数组反转" class="headerlink" title="9、 数组反转"></a>9、 数组反转</h2><p>所谓反转就是把数组元素位置颠倒过来</p><blockquote><p>实现思想：数组最远端的元素互换位置 实现反转，就需要将数组最远端元素位置交换 定义两个变量，保存数组的最小索引和最大索引 两个索引上的元素交换位置 最小索引++，最大索引—，再次交换位置 最小索引超过了最大索引，数组反转操作结束</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1940331-ee48a8c6c306d894?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组反转"></p><p>具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </span><br><span class="line">    <span class="comment">/*循环中定义变量min=0最小索引 </span></span><br><span class="line"><span class="comment">    max=arr.length‐1最大索引 </span></span><br><span class="line"><span class="comment">    min++,max‐‐ */</span> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> min = <span class="number">0</span>, max = arr.length ‐ <span class="number">1</span>; min &lt;= max; min++, max‐‐)&#123;</span><br><span class="line">    <span class="comment">//利用第三方变量完成数组中的元素交换 </span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[min]; </span><br><span class="line">    arr[min] = arr[max]; </span><br><span class="line">    arr[max] = temp;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 反转后，遍历数组 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">     System.out.println(arr[i])</span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="10、数组作为方法参数和返回值"><a href="#10、数组作为方法参数和返回值" class="headerlink" title="10、数组作为方法参数和返回值"></a>10、数组作为方法参数和返回值</h2><p>首先明确一点：数组作为方法的返回值，返回的是数组的内存地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//调用方法，接收数组的返回值 </span></span><br><span class="line">     <span class="comment">//接收到的是数组的内存地址 </span></span><br><span class="line">     <span class="keyword">int</span>[] arr = getArray(); </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; </span><br><span class="line">     System.out.println(arr[i])</span><br><span class="line">        &#125; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 创建方法，返回值是数组类型创建方法，返回值是数组类型 </span></span><br><span class="line"><span class="comment">     return返回数组的地址 */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getArray() &#123; </span><br><span class="line">     <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">      <span class="comment">//返回数组的地址，返回到调用者</span></span><br><span class="line">     <span class="keyword">return</span> arr; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1940331-a80fb17676058804?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法栈、堆"></p><h2 id="11、方法的参数类型区别"><a href="#11、方法的参数类型区别" class="headerlink" title="11、方法的参数类型区别"></a>11、方法的参数类型区别</h2><blockquote><p><strong>方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.</strong></p></blockquote><p>分析下列程序代码，计算输出结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; <span class="keyword">int</span> b = <span class="number">2</span>; </span><br><span class="line">    System.out.println(a); </span><br><span class="line">    System.out.println(b); </span><br><span class="line">    change(a, b); </span><br><span class="line">    System.out.println(a); </span><br><span class="line">    System.out.println(b); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">    a = a + b; b = b + a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析下列程序代码，计算输出结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; </span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">    change(arr); </span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">200</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结: 方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.</p></blockquote><p>相信各位已经将上面的代码 copy 到 eclipse 或者 idea 中运行了，是不是结果很意外？而且对总结不是很理解？这位童靴，我估计你可能是忽略了这一点：数组是引用类型，数组本身元素类型没有影响的，就像数组元素全是int，数组依旧是引用类型！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要是从容器概念到数组概念再到数组的三种定义以及各种情况的数组内存分析，以及一些数组常用的遍历以及反转、取最大值等操作。旨在全面性了解java数组。&lt;/p&gt;
&lt;h2 id=&quot;1、什么是容器&quot;&gt;&lt;a href=&quot;#1、什么是容器&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Java/"/>
    
    
      <category term="基础技术" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
