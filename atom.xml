<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>You的日常</title>
  
  <subtitle>You的日常，我们的日常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-22T06:42:42.058Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>You的日常</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>今日一文：妈妈的手套</title>
    <link href="http://yoursite.com/2019/11/20/2019-11-20_Life-Wenxin-wen/"/>
    <id>http://yoursite.com/2019/11/20/2019-11-20_Life-Wenxin-wen/</id>
    <published>2019-11-20T08:38:49.000Z</published>
    <updated>2019-11-22T06:42:42.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>昨天晚上给妈妈打电话的时候，妈妈说预报里面说：明天家里要下雪了，你那边冷吗？你要多穿点衣服，不要冻着啦！</p><h2 id="妈妈的手套"><a href="#妈妈的手套" class="headerlink" title="妈妈的手套"></a>妈妈的手套</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-fed24a8c6ace4bf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手套"></p><blockquote><p>图文无关</p></blockquote><p>记得那年冬天，我上初二，学校周末放假了，我和弟弟两个人闹矛盾，然后我的手不小心被刀划伤了。小时候的我们，都不是让母亲省心的孩子。弟弟那时还小，把我划伤后就和其它的小伙伴出去玩了。妈妈听到了我的哭声，从地里回来，带着我去村上的医疗室包扎伤口。医生仔细检查完伤口，进行了消毒包扎，然后对妈妈说：现在天冷，注意手不要冻着了，不然会很麻烦的。</p><p>回家后，妈妈让我坐在椅子上烤火看电视，然后自己又到田里去忙了。我在家里看着电视，听着外面呼呼的风声，心想天可真冷啊。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-afdea73a422163cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="北风吹"></p><a id="more"></a><p>第二天是周一，我们要一大早就去学校上课，并且我要在学习住校，周末才能回家。一大早，妈妈帮我收拾好东西，临出门的时候妈妈从房间拿出来一个很 <code>丑</code> 的 <code>手套</code>，递给我然后说道：这几点带着这个，天冷了主要别冻着了。我看着手里的手套，那是一个很大的<code>手套</code>，完全不符合我现在手的尺寸;  <code>手套</code> 腕部的地方很长，手指的部分除了大拇指有一个手指外，其它的几个手指都 是一个整体、并且没有封口; 看着就像是现在我们常用的护腕，只是多了大拇指那一点；<code>手套</code> 是使用的灰色的毛线织成的。妈妈看我不太情愿，拿起 <code>手套</code> 准备套在我受伤的手上。我把手往后缩了缩，妈妈顿了顿，一把抓过我的手，边小心地往受伤的手上套边说道：不想带就别受伤啊。我突然就哭了起来，但还是任由妈妈套上了手套，期间有几次妈妈碰到了伤口，我哭的更厉害了。妈妈没有安慰我，套完手套就进屋去了，我看着外面在等我的同学，我抹了抹眼泪和他们一起到学校去了。</p><p>一离开妈妈的视线，我就尝试 <code>扯</code> 下手套，但是试了几次，单手不太方便、伤口被碰了几次，最后还是放弃了。</p><p>到学校后，受伤的手给我的生活带来了很多的不便，原来能够很快完成的事情，现在很慢才能完成，例如扣衣服、上厕所完了提裤子。</p><p>比起生活上的不便，我更在意的是同学对我 <code>手套</code> 的评论。有些同学，会问怎么回事？有些同学会直接说：手套真丑，剩下的大部分同学都选择了忽视。我还是尝试要拿掉手套，但是终究还是没成功，本来最后一次都要成功了，忽然想到了医生那句：冻坏了就麻烦了，只得作罢。之后，我把受伤的手，放在桌子下面、衣服兜里、用手护着，反正就是减少被同学看到的机会。</p><p>终于又到了回家的日子。回到家后，我没看看妈妈，在上小学的弟弟说妈妈到田里去忙了，弟弟对我说道：哥哥，对不起，我不是故意弄伤你的。你也不要怪妈妈，那个手套是妈妈那天晚上花了一晚上织成的，毛线是妈妈从爸爸的毛衣上面拆下来的。那天你走了后，妈妈在家里哭了好久。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-1964f27924a42e33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="妈妈不哭"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>天冷了，你那边冷吗？你要多穿点衣服，不要冻着啦！</p><hr><p>图片来源于网络，侵删。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;昨天晚上给妈妈打电话的时候，妈妈说预报里面说：明天家里要下雪了，你那边冷吗？你要多穿点衣服，不要冻着啦！&lt;/p&gt;
&lt;h2 id=&quot;妈妈的手套&quot;&gt;&lt;a href=&quot;#妈妈的手套&quot; class=&quot;headerlink&quot; title=&quot;妈妈的手套&quot;&gt;&lt;/a&gt;妈妈的手套&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-fed24a8c6ace4bf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;手套&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图文无关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记得那年冬天，我上初二，学校周末放假了，我和弟弟两个人闹矛盾，然后我的手不小心被刀划伤了。小时候的我们，都不是让母亲省心的孩子。弟弟那时还小，把我划伤后就和其它的小伙伴出去玩了。妈妈听到了我的哭声，从地里回来，带着我去村上的医疗室包扎伤口。医生仔细检查完伤口，进行了消毒包扎，然后对妈妈说：现在天冷，注意手不要冻着了，不然会很麻烦的。&lt;/p&gt;
&lt;p&gt;回家后，妈妈让我坐在椅子上烤火看电视，然后自己又到田里去忙了。我在家里看着电视，听着外面呼呼的风声，心想天可真冷啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-afdea73a422163cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;北风吹&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="天冷了" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E5%A4%A9%E5%86%B7%E4%BA%86/"/>
    
    
      <category term="日常生活" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="天冷了" scheme="http://yoursite.com/tags/%E5%A4%A9%E5%86%B7%E4%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>今日一文：国足又输球了</title>
    <link href="http://yoursite.com/2019/11/18/2019-11-18_Life-Wenxin-wen/"/>
    <id>http://yoursite.com/2019/11/18/2019-11-18_Life-Wenxin-wen/</id>
    <published>2019-11-18T08:26:14.000Z</published>
    <updated>2019-11-22T06:42:28.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>11 月 14 日晚，中国男足又输球了。</p><h2 id="比赛相关"><a href="#比赛相关" class="headerlink" title="比赛相关"></a>比赛相关</h2><p>11 月 14 日晚，2022 年世界杯亚洲区预选赛预赛阶段（四十强赛）A组的一场关键战役在此间打响，中国男足和叙利亚队伍的比赛正式上演。此前，中国队已踢过三场小组赛，分别以 <strong>5:0</strong> 和 <strong>7:0</strong> 战胜了马尔代夫和关岛，以 <strong>0:0</strong> 踢平菲律宾队。</p><p>比赛中中国男足在上半场扳平比分后，下半场因为一粒乌龙球以 <strong>1:2</strong> 遗憾负于小组最强对手叙利亚队，目前在小组中仅以净胜球优势排在第二位。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-11f7aa4a650f9008?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足比分"></p><p>在 <strong>1:2</strong> 不敌叙利亚队，再一次，将出线主动权拱手让出。本场战罢，中国队 2 胜 1 平 1 负积 7 分，以净胜球优势领先菲律宾队排在四十强赛 A 组的第二位，叙利亚队则以四战全胜积 12 分排名第一。依照“四十强赛”的规则，总共 40 支球队分成 8 个小组参加世界杯亚洲区的预选赛，8 个小组的第一名以及 4 个表现最佳的第二名球队也得以参加预选赛下一轮的比赛。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-9eb2079921b316e7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分组"></p><p>中国队唯一一次入围世界杯是在 2002 年的日韩世界杯，当时中国队输掉了所有三场比赛，并且未进一球。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/1940331-5509e9a7619401a0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足比赛经过"></p><p>根据亚足联安排，国足在四十强赛A组的下一轮比赛定于 2020 年 3 月 26 日举行，届时国足将在主场迎战马尔代夫队。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-76d171ffee9dcfe1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足新赛程"></p><p>在赛后新闻发布会上中国男足主教练里皮宣布辞职并承担输球责任。“我们今晚输球了，我的年薪收入非常高，这场输球我承担全部责任，所以我向大家宣布现在辞职，不再担任中国队主教练。”，没等翻译讲完，里皮便离开了新闻发布会，留下一脸茫然的记者和工作人员。对于这位拿着2300万欧元年薪、全球收入最高国家队主教练来说，他和国足的缘分，真的到头了。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-f3470af85020cae7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="里皮辞职"></p><p>11 月 15 日早上，足协官方微博上发表声明对国家队失利”深表歉意”。声明称：“接受里皮的辞职请求。并表示接下来“将会深刻反思，重组男足国家队，打好接下来的四十强赛”。”</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-ef20fb7f3ed632ee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国足协道歉"></p><h2 id="中国女足的世界杯之旅"><a href="#中国女足的世界杯之旅" class="headerlink" title="中国女足的世界杯之旅"></a>中国女足的世界杯之旅</h2><p>上面是中国男足的情况，那作为另一个极端的中国女足的情况呢？</p><p>2019年法国女足世界杯上，中国女足先是 1:0 不敌德国队，后以 1:0 战胜南非队，在最后一轮则与西班牙队战平，最终以小组第三的成绩出线。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-211119c43021cb6d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="女足比赛日程"></p><p>但是在1/8决赛中 0-2 不敌意大利女足，无缘 8 强。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-a966191a7aff8ce8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="女足比赛日程"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>世界杯的比赛暂时告一段落，男足主教练“银狐”也离开了，中足协也道歉了，广大球迷也吐槽了，事件的热点也慢慢地退去了。但是，作为中国的足球事业却是刚刚起步，很多的问题需要解决。有人说是球员问题，有人说是教练问题，有人说是体制问题。其实对于广大的 “吃瓜群众” 来说，是谁的问题并不重要，重要的是什么时候才能真正的赢一场呢？</p><p>中国足球加油，中国加油…</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-71ce94dc3aff39e9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中国加油"></p><hr><p>图片来源于网络，侵删。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;11 月 14 日晚，中国男足又输球了。&lt;/p&gt;
&lt;h2 id=&quot;比赛相关&quot;&gt;&lt;a href=&quot;#比赛相关&quot; class=&quot;headerlink&quot; title=&quot;比赛相关&quot;&gt;&lt;/a&gt;比赛相关&lt;/h2&gt;&lt;p&gt;11 月 14 日晚，2022 年世界杯亚洲区预选赛预赛阶段（四十强赛）A组的一场关键战役在此间打响，中国男足和叙利亚队伍的比赛正式上演。此前，中国队已踢过三场小组赛，分别以 &lt;strong&gt;5:0&lt;/strong&gt; 和 &lt;strong&gt;7:0&lt;/strong&gt; 战胜了马尔代夫和关岛，以 &lt;strong&gt;0:0&lt;/strong&gt; 踢平菲律宾队。&lt;/p&gt;
&lt;p&gt;比赛中中国男足在上半场扳平比分后，下半场因为一粒乌龙球以 &lt;strong&gt;1:2&lt;/strong&gt; 遗憾负于小组最强对手叙利亚队，目前在小组中仅以净胜球优势排在第二位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-11f7aa4a650f9008?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;国足比分&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;1:2&lt;/strong&gt; 不敌叙利亚队，再一次，将出线主动权拱手让出。本场战罢，中国队 2 胜 1 平 1 负积 7 分，以净胜球优势领先菲律宾队排在四十强赛 A 组的第二位，叙利亚队则以四战全胜积 12 分排名第一。依照“四十强赛”的规则，总共 40 支球队分成 8 个小组参加世界杯亚洲区的预选赛，8 个小组的第一名以及 4 个表现最佳的第二名球队也得以参加预选赛下一轮的比赛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-9eb2079921b316e7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;分组&quot;&gt;&lt;/p&gt;
&lt;p&gt;中国队唯一一次入围世界杯是在 2002 年的日韩世界杯，当时中国队输掉了所有三场比赛，并且未进一球。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="世界杯" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
    
    
      <category term="日常生活" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="世界杯" scheme="http://yoursite.com/tags/%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>今日一文：三罢对香港经济的影响</title>
    <link href="http://yoursite.com/2019/11/15/2019-11-15_Life-Wenxin-wen/"/>
    <id>http://yoursite.com/2019/11/15/2019-11-15_Life-Wenxin-wen/</id>
    <published>2019-11-15T08:26:14.000Z</published>
    <updated>2019-11-22T06:42:14.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我们都知道，最近香港的局势不太稳定，暴徒们恶意破坏的行径，已经严重影响到香港居民的方方面面。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-41ab7b2376308e2c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一条满是砖块垃圾的马路"></p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-c28106337cf53a62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在沙田，一列火车因抗议者的扰乱而暂停服务，乘客被迫下车"></p><p>我们都知道，动荡的社会环境中，社会生产活动肯定会受到影响，这些影响最后将以经济数据的形式呈现出来。8 月份开始的 “三罢（罢工、罢课、罢市）” 活动，更是将对经济的影响放大了。这篇文章里，我们将尝试从香港政府已经公布的经济数据中，去发现暴力活动对香港经济造成的影响。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-20fdf6abb39bee30?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><blockquote><p>因为经济数据，具有一定的延后性，我们这里只从现有的数据出发，去分析问题。至于当下实际的情况，只能通过后续更新的数据再去分析啦。</p></blockquote><a id="more"></a><hr><h2 id="三罢对香港经济的影响"><a href="#三罢对香港经济的影响" class="headerlink" title="三罢对香港经济的影响"></a>三罢对香港经济的影响</h2><p>三罢（罢工、罢课、罢市）对经济的影响对经济的影响是巨大的。</p><p>香港私人消费总额的年度变化在今年第三季罕有地出现负增长。虽然背后的最大成因仍需科学验证，但初步认为与全球经济衰退、美中贸易战和香港的社会动荡和罢市行动有关。而私人消费 (Private Consumption) 是香港的经济产值(GDP)中占最大份额组成，2018年的占比比高达68.3% (图1)，因此每当私人消费下跌，经常伴随经济衰退。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-fa7bd48162dceffa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1 香港各项经济环节佔经济产值的百分比，2018年。资料来源：贸易发展局 (2019) [1]"></p><p>但到底是经济衰退带动私人消费下跌，还是其他外在因素引发私人消费下跌，从而令GDP下跌？这里有两种不同的说法<br>说法一：由于通胀和人口增长等因素，私人消费一般长期持续正增长，但当经济衰退，预期和实际失业人数增加，打击私人消费信心，导致私人消费下跌；<br>说法二：当外在因素如罢市行动或支持节约消费行动生效，私人消费下跌，因而造成经济衰退。</p><p>在过去大半年的香港却同时出现以上两种情况，消费下跌的真正原因仍有待进一步研究。</p><p>数据方面，私人消费的年度增长率由今年第二季的 +1.3% 转为第三季的 -3.5%，虽然跌幅比其他组别为细，但由于占比巨大，对GDP增长的影响举足轻重 (图2)：<br><img src="https://upload-images.jianshu.io/upload_images/1940331-d20d0dfb20690132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2 香港生产总值各项分项的年度增长率，2019年第二及第三季比较，资料来源：香港统计处[2]"></p><p>私人消费的组成以「零售总值」和「食肆收益」两项最具代表，图3是过去一年零售总值的每月年度变化率，自今年2月起至最新的9月份数字均是负数，而且有持续扩大迹象，最新8、9月份的跌幅更急跌两成多，打破了过去十几年的记录。但由于早自2月份已经出现双位数跌幅，远早于罢市行动，反映部份原因与罢市和社会动动荡等近期本地因素无关。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-b364e626da46cc57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3 香港零售总值年度变化2018年9月-2019年9月。资料来源：Trading Economics"></p><p>但零售数据较难分析成因，因为随着网络科技和智能手机的普及，愈来愈多的购物是透过网购完成，而零售总值的统计仍然只限于实体零售，网购未有定期统计数据 (事实上亦较难准确统计，尤其是二手货网购平台和非本地网购等)，因此部份零售总值的下跌可能源于愈来愈多消费者由实体店购物改为网购而已，同时，当社会动荡，经常变相戒严，亦会鼓励更多消费者改为网购，因此零售总值数据对反映私人消费变化有重大缺点。</p><p>食肆收益数据亦出现类似情况，不外出用餐可改为在家用餐，但如此一来已直接造成GDP减少 (因为GDP是不计算家庭成员的家务工作产出价值)，二来也影响商用物业租用，间接影响GDP数据。</p><p>图4显示食肆收益价值指数及其年度变化，过去十年持续正增长，平均年增长4%，但自今年4月起已经出现负值 (若以收益数量指数计算，更早在2月起已经变负)，最新9月份的跌幅高达13.1%，比2009年国际金融风暴时的跌幅还要大得多。</p><p>图4 香港食肆收益价值指数及其年度变化 2009 - 2019年9月。资料来源：香港统计处 [3]</p><p>其中各类餐饮均出现大幅下跌，只有快餐继续上升，这通常反映消费信心疲弱，减少在高级食肆消费，转食较经济的快餐。</p><p>图5显示中式餐饮自2月起已经出现下跌，但6月起跌幅扩大至双位数，最新9月份跌幅更达-20.3%；非中式餐馆的收益下跌相比没有中式的严重，9月份的跌幅为-14.5%，而且负增长由4月起才出现；酒吧的收益下跌最突然，由6月起突然由正转负，且一跌就跌双位数，9月份跌幅为-18.8%，可能与旅游警示、游客减少有关。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-447a5ecf51a117ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5 香港四类食肆的收益价值指数年度变化 2009 - 2019年9月。资料来源：香港统计处 [3]"></p><p>各类私人消费自6月起均有较明显的下跌，反映6月起市场出现突变，但由于同期美中贸易谈判曾经破裂，直到10月中美之间才再次开启了新一轮的和谈，但因为10月份的数据还没有对外公布，需待下个月数据出台再作分析。</p><p>参考：</p><p>[1]  香港贸易发展局 (2019) 香港经济概况，10月25日。<br><a href="http://hong-kong-economy-research.hktdc.com/business-news/article/%E5%B8%82%E5%A0%B4%E7%92%B0%E5%A2%83/%E9%A6%99%E6%B8%AF%E7%B6%93%E8%B2%BF%E6%A6%82%E6%B3%81/etihk/tc/1/1X000000/1X09OVUL.htm" target="_blank" rel="noopener">http://hong-kong-economy-research.hktdc.com/business-news/article/%E5%B8%82%E5%A0%B4%E7%92%B0%E5%A2%83/%E9%A6%99%E6%B8%AF%E7%B6%93%E8%B2%BF%E6%A6%82%E6%B3%81/etihk/tc/1/1X000000/1X09OVUL.htm</a></p><p>[2] 香港统计处 (2019) 二零一九年第三季本地生产总值预先估计数字，香港政府 10月31日。<br><a href="https://www.censtatd.gov.hk/press_release/pressReleaseDetail.jsp?charsetID=2&amp;pressRID=4506" target="_blank" rel="noopener">https://www.censtatd.gov.hk/press_release/pressReleaseDetail.jsp?charsetID=2&amp;pressRID=4506</a></p><p>[3] 香港统计处 (2019) 表E088：按食肆类别划分的食肆收益，香港政府 11月5日。<br><a href="https://www.censtatd.gov.hk/hkstat/sub/sp320_tc.jsp?productCode=D5600088" target="_blank" rel="noopener">https://www.censtatd.gov.hk/hkstat/sub/sp320_tc.jsp?productCode=D5600088</a></p><hr><p>PS: 图片来源于互联网，侵删。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;我们都知道，最近香港的局势不太稳定，暴徒们恶意破坏的行径，已经严重影响到香港居民的方方面面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-41ab7b2376308e2c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;一条满是砖块垃圾的马路&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-c28106337cf53a62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;在沙田，一列火车因抗议者的扰乱而暂停服务，乘客被迫下车&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们都知道，动荡的社会环境中，社会生产活动肯定会受到影响，这些影响最后将以经济数据的形式呈现出来。8 月份开始的 “三罢（罢工、罢课、罢市）” 活动，更是将对经济的影响放大了。这篇文章里，我们将尝试从香港政府已经公布的经济数据中，去发现暴力活动对香港经济造成的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1940331-20fdf6abb39bee30?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为经济数据，具有一定的延后性，我们这里只从现有的数据出发，去分析问题。至于当下实际的情况，只能通过后续更新的数据再去分析啦。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="香港" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E9%A6%99%E6%B8%AF/"/>
    
    
      <category term="日常生活" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="香港" scheme="http://yoursite.com/tags/%E9%A6%99%E6%B8%AF/"/>
    
  </entry>
  
  <entry>
    <title>今日一文-矛盾的日本人</title>
    <link href="http://yoursite.com/2019/11/14/2019-11-14_Life-Wenxin-wen/"/>
    <id>http://yoursite.com/2019/11/14/2019-11-14_Life-Wenxin-wen/</id>
    <published>2019-11-14T08:26:14.000Z</published>
    <updated>2019-11-22T06:41:54.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>早上的时候，因为工作需要和日本的客户开了个会，就是我们作为方案提供方，想客户推广公司的产品，我基本全程 <code>打酱油</code>，主讲的另外的两个同事。主要通过英语进行讲解，日本那边有一个英语翻译，复杂将双方的意思进行传达。会议讲述的内容是已经在很多场合下讲过很多次了，客户也没有问特别深奥的问题，整个过程下来感觉也没有给客户留下特别的印象。</p><p>会上的一件小事，却让我感到有点吃惊。</p><p>既然是推广，那肯定会有答疑环节，日方的翻译和同事就一个问题讨论了几分钟了，突然有个声音出现，说着日语，然后那个翻译很快地就用几句话结束了交谈。</p><p>我还在郁闷，这是怎么回事呢？怎么突然就结束啦。正当我还在疑惑的时候，旁边的同事说道：“1个小时过的真快，这就结束了”。</p><p>然后同事有顺口提到：日本人也真是的，说一小时就一小时，多一分钟都不行。我们约的一个小时的会议，我们 10 点 55 开始的会议，现在刚11：54 就结束了会议。</p><p>会后，我对这个话题比较的感兴趣，就去搜索了相关的内容。这一搜，发现了一个重要的事实：日本人对待时间这件事情上就是一个 <code>矛盾</code> 的混合体。一方面，日本人有很重的时间观念，对于 <code>守时</code> 这件事情上的表现近乎刻板。另一方面，日本人也是“加班狂人”。为什么会出现这种看似 <code>矛盾</code> 的现象呢，这背后的原因是什么呢？</p><p>顺着这个思路，来展开我们今天的话题。</p><a id="more"></a><h2 id="日本人-守时-到什么程度呢？"><a href="#日本人-守时-到什么程度呢？" class="headerlink" title="日本人 守时 到什么程度呢？"></a>日本人 <code>守时</code> 到什么程度呢？</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-52e923987fe896e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>和日本人有过接触经验的人，都对日本人的 <code>守时</code> 的时间观念印象深刻。</p><p>日本人开会从来不迟到，也不会无故延长会议时间。就想我们今天遇到的这样，说是 1 个小时的会员，一定不会开到 1 小时零 1 分。日本人守时的习惯，尤其是“不迟到”这点更是多数日本人天生养成的习惯。比如在企业、公共机构或与他人会面的方方面面，必定“正确守时”即便是准时到达也会视为“迟到”，这已成为常识。关系亲密的人之间也有迟到的，不过也会事先邮件通知。</p><p>日本人不光在私人小事上，做到守时，在很复杂的系统上也能做到守时。</p><p>日本的新干线列车的晚点时间是以分钟计算延迟的，就是说延迟 1 分钟以上就算是延迟了。作为对比，在其他国家，如意大利定为 15 分钟、英国为 10 分钟、连号称规矩严谨与日本不相上下的德国也只定为 5 分钟。几年前的一个道歉事件，曾经被广泛报道。经营日本筑波快线（Tsukuba Express）的日本首都圈新都市铁道公司原定于 11 月 14 日上午 9 点 44 分 40 秒发出，但由于操作员的失误，结果列车没有按照原定计划，在 9 点 44 分 20 秒提前 20 秒发了车。令人意想不到的是，铁路公司竟然郑重其事的在网页上发布了如下的道歉声明。日本铁路公司的电车只要晚1分钟，车内必定播放道歉的广播。而新干线的到达和出发时刻是以15秒为单位设定的。</p><p>日本的机场在守时上也不输铁路，OAG 发布的最新准点率统计表明，<code>大阪国际机场</code> 在全球小型机场中准点率排名第一，<code>东京羽田机场</code> 在名列大型机场准点排行第一。准点率是衡量一个机场成熟度的重要指标。</p><p>铁路和机场，这样复杂的系统都没有阻止日本人守时的脚步，这些复杂系统做到这么 <code>精确</code> 的守时背后，是许许多多的小个体守时的缩影，可以说，<code>守时</code> 观念已经深入了日本人的骨髓。</p><h2 id="日本人独特的-“加班文化”"><a href="#日本人独特的-“加班文化”" class="headerlink" title="日本人独特的 “加班文化”"></a>日本人独特的 “加班文化”</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-075be3d4d4be32f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果说日本人 <code>不迟到</code> 是一个特色，那与之相关的一定是另一个特色—- <code>加班文化</code>。</p><p>在日本，加班对于每一个职场人士来说是“家常便饭”，乃至于“过劳死”成为日本加班文化的一个显著特征。日本是出名的“加班大国”，在日文中有“超勤文化”的表述，有时被说成“过劳文化”。日本人以加班为荣，对他们来说加班才是常态，晚上写字楼里的灯光也有个专有名词——“劳工之光”。对不少日本男性来说，“朝6晚11”的工作模式相当普遍，这比之前国内的“996”，似乎还要厉害一点。清早从家乘地铁到公司，上班然后“例行”加班后，再和同事酌酒交际到深夜，便是正常一天的工作行程。日本妻子也大多习惯了丈夫早出晚归，甚至在很多日本女人的观念里，丈夫如果每天正常下班回家是一种在职场上无能的表现。</p><p>那是什么原因让日本的加班文化如此盛行呢？</p><p>首先，由于连年的经济不景气，日本公司不断地缩减人工规模，员工随时可能被裁员，剩下的员工不得不处理大量的工作任务来减少自己被裁的可能性，从而导致加班不可避免。</p><p>第二，日本的终身雇佣制度使得就业市场缺乏活力，员工很难跳槽寻找更好的工作，被迫工作更长时间。</p><p>第三，日本企业大多实行终身雇佣制和工龄薪酬制度，工作时间更长意味着更易获得成功，每周多工作几个小时的员工被提升到管理岗位的机会更大，同时也可以获得更多的薪酬。</p><p>第四，日本独特的职场文化：强调不带条件的服从和忠诚，以集体主义为最高目标，个人在集体中只有义务，个人的需求会被自动忽视。</p><p>第五点，日本人内向拘谨，不愿给别人添麻烦，因此，他们工作勤奋、守规则、敬业心强、对企业忠诚。</p><p>与加班文化同时伴生的一个问题是：工作效率低下。2013年日本每小时劳动生产价值为41.3美元，不到挪威的一半，在34个经合组织国家中排名20位，“日本人以工作努力闻名，但效率低下和官僚作风同样有名”，一家英国的每天曾经这样评价日本的加班文化。</p><h2 id="其实这就是真实的日本人"><a href="#其实这就是真实的日本人" class="headerlink" title="其实这就是真实的日本人"></a>其实这就是真实的日本人</h2><p><img src="https://upload-images.jianshu.io/upload_images/1940331-6001b03e5fd58a72?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>近乎苛责的 <code>守时</code>  和独特的 <code>加班文化</code> 夹杂在一起的日本人，就是一对矛盾的集合体，同时，这也是最真实的日本人。</p><p>好消息是，情况正在向好的方向发展。最近几届的日本政府都在积极推动“禁止加班”，通过立法的手段来禁止 日益加剧的 <code>加班文化</code> 。同时企业也通过内部改革来减少加班文化的土壤，例如减少时薪。最近看到的消息说：微软日本公司，已经实现每周休假 3  天的制度。</p><p>没有谁的生活是容易的，简单生活，才能更好的享受生活。</p><hr><p>PS: 图片来源于互联网，侵删。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;早上的时候，因为工作需要和日本的客户开了个会，就是我们作为方案提供方，想客户推广公司的产品，我基本全程 &lt;code&gt;打酱油&lt;/code&gt;，主讲的另外的两个同事。主要通过英语进行讲解，日本那边有一个英语翻译，复杂将双方的意思进行传达。会议讲述的内容是已经在很多场合下讲过很多次了，客户也没有问特别深奥的问题，整个过程下来感觉也没有给客户留下特别的印象。&lt;/p&gt;
&lt;p&gt;会上的一件小事，却让我感到有点吃惊。&lt;/p&gt;
&lt;p&gt;既然是推广，那肯定会有答疑环节，日方的翻译和同事就一个问题讨论了几分钟了，突然有个声音出现，说着日语，然后那个翻译很快地就用几句话结束了交谈。&lt;/p&gt;
&lt;p&gt;我还在郁闷，这是怎么回事呢？怎么突然就结束啦。正当我还在疑惑的时候，旁边的同事说道：“1个小时过的真快，这就结束了”。&lt;/p&gt;
&lt;p&gt;然后同事有顺口提到：日本人也真是的，说一小时就一小时，多一分钟都不行。我们约的一个小时的会议，我们 10 点 55 开始的会议，现在刚11：54 就结束了会议。&lt;/p&gt;
&lt;p&gt;会后，我对这个话题比较的感兴趣，就去搜索了相关的内容。这一搜，发现了一个重要的事实：日本人对待时间这件事情上就是一个 &lt;code&gt;矛盾&lt;/code&gt; 的混合体。一方面，日本人有很重的时间观念，对于 &lt;code&gt;守时&lt;/code&gt; 这件事情上的表现近乎刻板。另一方面，日本人也是“加班狂人”。为什么会出现这种看似 &lt;code&gt;矛盾&lt;/code&gt; 的现象呢，这背后的原因是什么呢？&lt;/p&gt;
&lt;p&gt;顺着这个思路，来展开我们今天的话题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="矛盾" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E7%9F%9B%E7%9B%BE/"/>
    
    
      <category term="日常生活" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="矛盾" scheme="http://yoursite.com/tags/%E7%9F%9B%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>副业赚钱？ 我用自己的教训来给你指路</title>
    <link href="http://yoursite.com/2019/11/13/2019-11-13_Life-Wenxin-wen/"/>
    <id>http://yoursite.com/2019/11/13/2019-11-13_Life-Wenxin-wen/</id>
    <published>2019-11-13T08:36:39.000Z</published>
    <updated>2019-11-22T06:45:14.999Z</updated>
    
    <content type="html"><![CDATA[<p><code>副业赚钱</code>, 是每个人读梦寐以求的，毕竟 <code>躺着就能把钱挣了</code> 还是很舒服的。</p><p>最近在不断的总结和反思着一个多月以来的 <code>折腾之旅</code> , 得到了下面的几点教训。这里分享出来给大家参考。</p><h2 id="涉及的东西太多"><a href="#涉及的东西太多" class="headerlink" title="涉及的东西太多"></a>涉及的东西太多</h2><p>自从 9 月份开始说要开始自己的折腾之旅开始，先后试过下面平台及方向。</p><div class="table-container"><table><thead><tr><th>平台</th><th>内容、方向</th></tr></thead><tbody><tr><td>简书</td><td>书写、技术付费文章</td><td></td></tr><tr><td>公众号</td><td>书写、图片转载</td></tr><tr><td>头条号</td><td>图片转载</td></tr><tr><td>悟空问答</td><td>影视领域认证</td></tr><tr><td>抖音</td><td>视频搬运</td></tr><tr><td>TiTok</td><td>视频搬运</td></tr><tr><td>微视</td><td>视频搬运</td></tr><tr><td>好看视频</td><td>视频搬运</td></tr><tr><td>Youtobe</td><td>视频搬运</td></tr><tr><td>Gitbook</td><td>技术付费文章</td></tr><tr><td>小专栏</td><td>技术付费专栏</td></tr></tbody></table></div><p>还有很多就试过一两次的，然后觉得不靠谱的就不再列出来了，如果列出来这份清单会很长很长。</p><p>上面的这些内容，大部分都在上班时间抽空来完成的。质量可定也好不到哪里去，基本上可以说大部分的内容都是拼凑完成的，另外一些内容，虽然加入了自己的一些东西，但是大部分都不是太深入。</p><a id="more"></a><h2 id="没有明确的方向"><a href="#没有明确的方向" class="headerlink" title="没有明确的方向"></a>没有明确的方向</h2><p>上面的那份清单里面，已经列出来了，目前试过的方向包括</p><ul><li>技术付费文章</li><li>视频搬运</li><li>图片转载</li></ul><p>上面的每个领域，都是很大的领域，在其中的领域如果做的好，都可以做的很成功。但是毫无疑问，每个领域的成功都需要投入很多的精力，包括但不限于：时间，金钱。</p><blockquote><p>为什么是为了赚钱的，怎么还需要投入金钱呢？这里解释下原因：很多领域开始赚钱前是需要一个“门槛”的，有些门槛对新人来说感觉很高，此时适当的金钱投入，是可以帮我们快速跨过这个门槛的。</p></blockquote><h2 id="无法持续的输出"><a href="#无法持续的输出" class="headerlink" title="无法持续的输出"></a>无法持续的输出</h2><p>上面的那份清单里面的每一个，都需要持续不断的 <code>原创</code> 输出，才有可能成功。如果只是 <code>转载</code>、<code>搬运</code>、<code>洗稿</code>，成功的可能性基本没有。</p><blockquote><p>这里为什么不把话说满呢？因为现实中的的确确出现一些，<code>山寨货</code> 最后逆袭 <code>正版货</code> 的故事。福建莆田的鞋类生产就是一个很好的例子。</p></blockquote><p>为什么我们一定要坚持原创呢？因为原创是制约你走的更远的决定性条件。在刚开始的时候，你 <code>搬运</code> 了，没人会关注到你，因为你太小了。如果有一天你长大了，很多人都可以看到你的时候，你的所有问题都会暴露在众人面前，一旦发生了问题，众人的 <code>口水</code> 真的就把你淹没了,然后就真的没有然后了。</p><blockquote><p>大家可以参看下 <code>李现ins点赞</code> 的 <code>故事</code>。</p></blockquote><p>可能走的越远，越能体会到 <code>人言可畏</code> 这句话的真正威力吧。</p><hr><p>上面的内容是对自己这一段时间的复盘，下面来简短的写下自己接下来的计划。</p><h2 id="精简自己的内容"><a href="#精简自己的内容" class="headerlink" title="精简自己的内容"></a>精简自己的内容</h2><div class="table-container"><table><thead><tr><th>平台</th><th>内容、方向</th></tr></thead><tbody><tr><td>简书</td><td>书写、技术付费文章</td></tr><tr><td>公众号</td><td>书写、技术付费文章</td></tr><tr><td>Gitbook</td><td>技术付费文章</td></tr></tbody></table></div><p>之所以这么选择，理由如下：</p><ul><li><code>技术文章</code> 基本就是自己平时工作、学习的再记录。把学到的东西分享出去，不仅可以促进自己不断的学习，还能把自己的知识分享给更多的人，这是多方共赢的。</li><li><code>书写</code> 主要的目的是记录平时生活、工作，同时系统化的构建自己的知识体系。</li></ul><p>下面对着3个平台的功能进行下区分，</p><ul><li><code>简书</code> 上面是所有的内容的整合地，类似于目录的作用。</li><li><code>公众号</code> 上面主要是日常生活的中的见闻分享。通过日常的一个点，去发散开来，理论上不设任何的领域限制。</li><li><code>Gitbook</code> 上面主要是</li></ul><h2 id="持续原创输出"><a href="#持续原创输出" class="headerlink" title="持续原创输出"></a>持续原创输出</h2><p>上面提到的两个方向都是需要持续不断的更新内容，才能看到后来的光明。<br>其实对于各个行业都需要持续不断的的产出，才有可能成功。坚持下来，才有可能看到阳光；如果不坚持，一定就看不到阳光。</p><p>即使 <code>强</code> 如李佳琦也会有翻船的时候。</p><blockquote><p>具体事件可以参见这篇文章 <a href="https://new.qq.com/rain/a/20191105A0PNQX00" target="_blank" rel="noopener">https://new.qq.com/rain/a/20191105A0PNQX00</a></p></blockquote><p>虽然李佳琦带货会翻车，但是不可否认李佳琦的带货能力，毕竟他是曾经打败过 <code>马爸爸</code> 的男人。</p><p>上面写就是我这一段时间来的总结，是一个悲伤的故事，说出来让大家笑一笑。</p><p>最后附上我的微信公众号，欢迎大家关注。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-9b2b8d44ef7010f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" &quot;you的日常&quot; 公众号 "></p><blockquote><p>有需要的朋友，请到评论区留言吧，我们来互相关注啊。</p></blockquote><p>希望大家都能够早日通过 “副业” 赚到钱。</p><p>加油…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;副业赚钱&lt;/code&gt;, 是每个人读梦寐以求的，毕竟 &lt;code&gt;躺着就能把钱挣了&lt;/code&gt; 还是很舒服的。&lt;/p&gt;
&lt;p&gt;最近在不断的总结和反思着一个多月以来的 &lt;code&gt;折腾之旅&lt;/code&gt; , 得到了下面的几点教训。这里分享出来给大家参考。&lt;/p&gt;
&lt;h2 id=&quot;涉及的东西太多&quot;&gt;&lt;a href=&quot;#涉及的东西太多&quot; class=&quot;headerlink&quot; title=&quot;涉及的东西太多&quot;&gt;&lt;/a&gt;涉及的东西太多&lt;/h2&gt;&lt;p&gt;自从 9 月份开始说要开始自己的折腾之旅开始，先后试过下面平台及方向。&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;平台&lt;/th&gt;
&lt;th&gt;内容、方向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;简书&lt;/td&gt;
&lt;td&gt;书写、技术付费文章&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;公众号&lt;/td&gt;
&lt;td&gt;书写、图片转载&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;头条号&lt;/td&gt;
&lt;td&gt;图片转载&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;悟空问答&lt;/td&gt;
&lt;td&gt;影视领域认证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;抖音&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TiTok&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;微视&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;好看视频&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Youtobe&lt;/td&gt;
&lt;td&gt;视频搬运&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gitbook&lt;/td&gt;
&lt;td&gt;技术付费文章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;小专栏&lt;/td&gt;
&lt;td&gt;技术付费专栏&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;还有很多就试过一两次的，然后觉得不靠谱的就不再列出来了，如果列出来这份清单会很长很长。&lt;/p&gt;
&lt;p&gt;上面的这些内容，大部分都在上班时间抽空来完成的。质量可定也好不到哪里去，基本上可以说大部分的内容都是拼凑完成的，另外一些内容，虽然加入了自己的一些东西，但是大部分都不是太深入。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="副业" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%85%AC%E4%BC%97%E5%8F%B7/%E5%89%AF%E4%B8%9A/"/>
    
    
      <category term="日常生活" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="公众号" scheme="http://yoursite.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="副业" scheme="http://yoursite.com/tags/%E5%89%AF%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>2019-10-18-Programing-Python-Advanded-use-Flask-create-RESTful-API-Services</title>
    <link href="http://yoursite.com/2019/10/18/2019-10-18-Programing-Python-Advanded-use-Flask-create-RESTful-API-Services/"/>
    <id>http://yoursite.com/2019/10/18/2019-10-18-Programing-Python-Advanded-use-Flask-create-RESTful-API-Services/</id>
    <published>2019-10-18T03:36:18.000Z</published>
    <updated>2019-11-25T03:37:18.807Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在工作学习中，我们经常会需要将自己的开发成果对外提供服务，此时的选择很多，但是什么才是最高效的呢？</p><p>想必聪明的你，已经想到了：通过 <code>API</code> 的方式对外提供服务。既然我们在学习 Python 过程中，那我们就使用 Python 来实现自己的 API 吧。</p><p>下面将从下面几个方面进行讲解：</p><ul><li>API 简介</li><li>RESTful API 简介</li><li>使用Python Flask 实现 RESTful API</li></ul><hr><h2 id="API-简介"><a href="#API-简介" class="headerlink" title="API 简介"></a>API 简介</h2><p>API 是英语 <code>Application Programming Interfaces</code> 的3个首字母组成的，翻译成中文即 <code>应用程序编程接口</code>。</p><p>API 通常是由服务器（Server）提供（服务器有各种各样的类型，一般我们浏览网页用到的是web server，即网络服务器），通过调用 API，本地计算机可以读取、编辑网站数据，就像人类可以加载网页、提交信息等。</p><p>通俗地，API可以理解为家用电器的插头，用户(本地电脑)只需要将插头插入插座的，不需要考虑电器内部(服务器)里面是如何运作的。通过提供 API, 将内部的实现细节封装了起来，对本地电脑简化的流程，同时减少了出错的可能。</p><p>另外一个角度上讲API是一套协议，规定了与外界的沟通方式：如何发送请求和接受响应。只有大家同遵循同样的方式，就可以很快速的接入我们的服务。</p><hr><h2 id="RESTful-API-简介"><a href="#RESTful-API-简介" class="headerlink" title="RESTful API 简介"></a>RESTful API 简介</h2><p>RESTful API 即满足 RESTful 风格设计的API，RESTful 表示的是一种互联网软件架构(以网络为基础的应用软件的架构设计)，如果一个架构符合 <code>REST</code> (Representational State Transfer的缩写，翻译成中文是 <code>&quot;表现层状态转化&quot;</code>.)原则，就称它为 RESTful 架构。</p><p>那什么是 <code>REST</code> 原则呢？<code>Representational State Transfer</code> 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，基本就理解了什么是 <code>REST</code> 设计原则。</p><p>从下面几个角度来分解这个问题。</p><blockquote><p>下面的部分内容可以忽略，可以直接跳到总结的部分。</p></blockquote><a id="more"></a><h3 id="资源（Resources）"><a href="#资源（Resources）" class="headerlink" title="资源（Resources）"></a>资源（Resources）</h3><p>REST 的名称”表现层状态转化”中，省略了主语。 <code>&quot;表现层&quot;</code> 其实指的是 <code>&quot;资源&quot;</code> （Resources）的 <code>&quot;表现层&quot;</code> 。</p><p>所谓 <code>&quot;资源&quot;</code> ，就是网络上的一个实体，或者说是网络上的一个具体信息。</p><p>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。<br>你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓 <code>上网</code>，就是与互联网上一系列的 <code>&quot;资源&quot;</code> 互动，调用它的URI。</p><h3 id="表现层（Representation）"><a href="#表现层（Representation）" class="headerlink" title="表现层（Representation）"></a>表现层（Representation）</h3><p><code>&quot;资源&quot;</code> 是一种信息实体，它可以有多种外在表现形式。我们把 <code>&quot;资源&quot;</code> 具体呈现出来的形式，叫做它的 <code>&quot;表现层&quot;</code> （Representation）。</p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对 <code>&quot;表现层&quot;</code> 的描述。</p><h3 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h3><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。</p><p>因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 <code>&quot;表现层状态转化&quot;</code>。</p><p>客户端用到的手段，只能是HTTP协议。</p><p>具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p><p>它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>RESTful 架构的特点：</p><ul><li>每一个URI代表一种资源；</li><li><p>客户端和服务器之间，传递这种资源的某种表现层；把 <code>&quot;资源&quot;</code> 具体呈现出来的形式，叫做它的 <code>&quot;表现层&quot;</code> （Representation）。</p><p>  比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p></li><li><p>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p><p>  四个表示操作方式的动词分别是：GET、POST、PUT、DELETE。</p><p>  它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p></li></ul><p>完整的 RESTful API 的简介在这里：</p><p><a href="https://www.restapitutorial.com/lessons/whatisrest.html" target="_blank" rel="noopener">https://www.restapitutorial.com/lessons/whatisrest.html</a> </p><blockquote><p>英文版，可能需要翻墙。</p></blockquote><p>简单总结下官方的介绍的内容：</p><ul><li>Client-Server：服务器端与客户端分离。</li><li>Stateless（无状态）：每次客户端请求必需包含完整的信息，换句话说，每一次请求都是独立的。</li><li>Cacheable（可缓存）：服务器端必需指定哪些请求是可以缓存的。</li><li>Layered System（分层结构）：服务器端与客户端通讯必需标准化，服务器的变更并不会影响客户端。</li><li>Uniform Interface（统一接口）：客户端与服务器端的通讯方法必需是统一的。</li><li>Code on demand（按需执行代码）：服务器端可以在上下文中执行代码或者脚本。</li></ul><hr><h2 id="使用Python-Flask-实现Restful-API"><a href="#使用Python-Flask-实现Restful-API" class="headerlink" title="使用Python Flask 实现Restful API"></a>使用Python Flask 实现Restful API</h2><p>前面啰嗦了这么久终于到这里了，这里才是我们实作的重头戏。</p><p>这部分将从下面的几个环节展开：</p><ul><li>Flask 框架简介</li><li>RESTful services 规划</li><li>Python 实现上面的规划</li><li>优化上面的实现</li></ul><p>下面让我们开始。</p><h3 id="Flask-框架简介"><a href="#Flask-框架简介" class="headerlink" title="Flask 框架简介"></a>Flask 框架简介</h3><p>我们在前面有几篇文章已经介绍过 Flask 框架。</p><p><strong>python-高级-Flask Hello World </strong><br><a href="https://xiaozhuanlan.com/topic/7256839401" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/7256839401</a></p><p><strong>Python-高级-Flask 路由</strong><br><a href="https://xiaozhuanlan.com/topic/0758412369" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/0758412369</a></p><p>里面介绍了 Flask 框架的相关基础知识，同时我们也介绍了关于 Flask 框架路由的知识，如果没看过，请移步到那里去看看。</p><p>在 <code>Python-高级-Flask Hello World</code> 里面，我们写了个最简单的 <code>Hello World</code> 的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, World!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>我们下面的内容，将基于这个例子进行扩展。</p><p>HTTP(与web应用会话的协议)有许多不同的访问URL方法。<br>默认情况下，<code>Flask</code> 路由只回应GET请求，但是通过 <code>route()</code> 装饰器传递 <code>method</code> s参数可以改变这个行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/login', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        do_the_login()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        show_the_login_form()</span><br></pre></td></tr></table></figure><p>HTTP 方法（通常也被叫做“谓词”，如上面code 里面的 <code>GET</code> 和 <code>POST</code> ）告知服务器，客户端想对请求的页面做些什么。</p><p>下面的都是非常常见的方法：</p><ul><li>GET(方法)浏览器告知服务器：只 获取 页面上的信息并发给我。这是最常用的方法。</li><li>POST(方法)浏览器告诉服务器：想在 URL 上发布新信息。并且，服务器必须确保 数据已存储且仅存储一次。这是 HTML 表单通常发送数据到服务器的方法。</li><li>PUT(方法)类似 POST 但是服务器可能触发了存储过程多次，多次覆盖掉旧值。你可能会问这有什么用，当然这是有原因的。考虑到传输中连接可能会丢失，这种情况下浏览器和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。因为 <code>POST</code> 它只触发一次，所以用 <code>POST</code> 是不可能的。</li><li>DELETE(方法)删除给定位置的信息。</li></ul><h3 id="RESTful-services-规划"><a href="#RESTful-services-规划" class="headerlink" title="RESTful services 规划"></a>RESTful services 规划</h3><p>经过上面知识的准备，我们开始来规划我们的RESTful services。</p><p>这里的规划，通常会与实际的需求有关系。所有的程序设计行为都是要与需求相关联的，如果做出来的东西不符合需求，那做得再好的程序也不是合格的程序。</p><p>回归到这里，我们假设我们的需求如下：写一个 <code>To Do List</code> 应用，并且设计一个web service, 方便使用中查看、添加、修改、删除 这些任务。</p><p><code>To Do List</code> 应用，通常长这样<br><img src="https://images.xiaozhuanlan.com/photo/2019/711398c10c7e7dee36a0e17a28efb00a.png" alt="`To Do List` 应用"></p><p>可能会比较简单，实际的需求会比这个复杂的多。这里举个简单的例子，只是起到 <code>抛砖引玉</code> 的作用。</p><p>我们将分下面几步走来规划这个。</p><h4 id="规划一个根URL"><a href="#规划一个根URL" class="headerlink" title="规划一个根URL"></a>规划一个根URL</h4><p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://[hostname]/todo/api/v1.0/</span><br></pre></td></tr></table></figure></p><p>上面的URL包括了应用程序的名称、API版本，这是十分有用的，既提供了命名空间的划分，同时又与其它系统区分开来。</p><p>版本号在升级新特性时十分有用，当一个新功能特性增加在新版本下面时，并不影响旧版本。</p><h4 id="规划资源的URL"><a href="#规划资源的URL" class="headerlink" title="规划资源的URL"></a>规划资源的URL</h4><p>这个例子十分简单，只有任务清单。</p><p>我们定义有以下字段：<br>|HTTP 方法|URL|作用|<br>|—-|—-|—-|<br>|GET|<a href="http://[hostname]/todo/api/v1.0/tasks|查看所有的任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks|查看所有的任务|</a><br>|GET|<a href="http://[hostname]/todo/api/v1.0/tasks/task_id|查看特定" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks/task_id|查看特定</a> id 的任务|<br>|PSOT|<a href="http://[hostname]/todo/api/v1.0/tasks|创建一个新的任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks|创建一个新的任务|</a><br>|PUT|<a href="http://[hostname]/todo/api/v1.0/tasks/task_id|更新一个已有的任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks/task_id|更新一个已有的任务|</a><br>|DELETE|<a href="http://[hostname]/todo/api/v1.0/tasks/task_id|删除一个任务|" target="_blank" rel="noopener">http://[hostname]/todo/api/v1.0/tasks/task_id|删除一个任务|</a></p><p>同时定义一条任务清单包含下面的几个字段：</p><div class="table-container"><table><thead><tr><th>id</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>task_id</td><td>唯一标识</td><td>整型</td></tr><tr><td>title</td><td>简短的任务描述</td><td>字符串型</td></tr><tr><td>description</td><td>完整的任务描述</td><td>文本型</td></tr><tr><td>done</td><td>任务完成状态</td><td>布尔值型</td></tr></tbody></table></div><p>到这里我们的service 规划就完成了，下面我们将使用 Python 来进行实现。</p><h3 id="Python-实现上面的规划"><a href="#Python-实现上面的规划" class="headerlink" title="Python 实现上面的规划"></a>Python 实现上面的规划</h3><p>我们先实现第一个web service的入口点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 python_mastery 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/python_mastery'</span>,</span><br><span class="line">        <span class="string">'done'</span>: <span class="literal">False</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">u'订阅 pythonml 专栏'</span>,</span><br><span class="line">        <span class="string">'description'</span>: <span class="string">u'专栏Link： https://xiaozhuanlan.com/pythonml'</span>,</span><br><span class="line">        <span class="string">'done'</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: tasks&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><blockquote><p>在这里我们看到 <code>jsonify</code> 模块，这个与标准的 <code>json</code> 库的差别，对于目前我们的使用来说，基本可以忽略不计，如果非要深究这个问题，请移步到这里：<a href="https://www.jianshu.com/p/a25357f2d930" target="_blank" rel="noopener">https://www.jianshu.com/p/a25357f2d930</a>.</p></blockquote><p>和最开始的例子相比，并没有改变太多代码。</p><p>我们将任务清单存储在 list 内（内存），list 存放两个非常简单的数组字典。每个实体就是我们上面定义的字段。</p><p>而 index 入口点有一个 <code>get_tasks</code> 函数与 <code>/todo/api/v1.0/tasks</code> URI关联，只接受 HTTP 的 <code>GET</code> 方法。</p><p>这个响应并非一般文本，而是 JSO N格式的数据，是经过 Flask 框架的 <code>jsonify</code> 模块格式化过的数据。</p><p>运行 app.py 。</p><p>使用浏览器去测试 web service 并不是一个好的办法，因为要创建不同种类的 HTTP 请求。这里我们选择第三方工具 <code>postman</code> 来进行验证。</p><p>如果没有安装 <code>postman</code> ，快点去安装一个。</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/93a094856a1e7c74ab3c92f4e180ba66.png" alt="GET `/todo/api/v1.0/tasks`"></p><p>这样就调用了一个RESTful service方法！</p><p>现在，我们写第二个版本的GET方法获取特定的任务。获取单个任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> abort</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_task</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    task = list(filter(<span class="keyword">lambda</span> t: t[<span class="string">'id'</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> len(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'task'</span>: task[<span class="number">0</span>]&#125;)</span><br></pre></td></tr></table></figure><p>第二个函数稍稍复杂了一些。任务的 id 包含在 URL 内，Flask 将 task_id 参数传入了函数内。</p><p>通过参数，检索 tasks 数组。如果参数传过来的 id 不存在于数组内，我们需要返回错误代码 404 ，按照 HTTP 的规定，404 意味着是 “Resource Not Found”，资源未找到。</p><p>如果找到任务在内存数组内，我们通过 <code>jsonify</code> 模块将字典打包成 JSON 格式，并发送响应到客户端上。就像处理一个实体字典一样。</p><p>试试 <code>postman</code> 来进行验证<br><img src="https://images.xiaozhuanlan.com/photo/2019/7216c0b416a349237ddec9b2a5cfcdf9.png" alt="请求 `#2 id` 的资源"></p><p>当我们请求 <code>#2 id</code> 的资源时，可以获取，但是当我们请求<code>#3</code> 的资源时返回了 <code>404</code> 错误。并且返回了一段奇怪的 HTML 错误，而不是我们期望的 JSON，这是因为 Flask 产生了默认的 404 响应。<br><img src="https://images.xiaozhuanlan.com/photo/2019/1efeaa08c6403904824c96b21b528b81.png" alt="默认的 404 响应"></p><p>客户端需要收到的都是 JSON 的响应，因此我们需要改进 404 错误处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> make_response</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_found</span><span class="params">(error)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> make_response(jsonify(&#123;<span class="string">'error'</span>: <span class="string">'Not found'</span>&#125;), <span class="number">404</span>)</span><br></pre></td></tr></table></figure><p>这样我们就得到了友好的API错误响应：<br><img src="https://images.xiaozhuanlan.com/photo/2019/fafa73efa68f6532801f92d4c1f9627c.png" alt="友好的API错误响应"></p><p>接下来我们实现 POST 方法，插入一个新的任务到数组中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json <span class="keyword">or</span> <span class="keyword">not</span> <span class="string">'title'</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    task = &#123;</span><br><span class="line">        <span class="string">'id'</span>: tasks[<span class="number">-1</span>][<span class="string">'id'</span>] + <span class="number">1</span>,</span><br><span class="line">        <span class="string">'title'</span>: request.json[<span class="string">'title'</span>],</span><br><span class="line">        <span class="string">'description'</span>: request.json.get(<span class="string">'description'</span>, <span class="string">""</span>),</span><br><span class="line">        <span class="string">'done'</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">    tasks.append(task)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'task'</span>: task&#125;), <span class="number">201</span></span><br></pre></td></tr></table></figure><p>request.json 里面包含请求数据，如果不是 JSON 或者里面没有包括 title 字段，将会返回 <code>400</code> 的错误代码。</p><p>当创建一个新的任务字典，使用最后一个任务 id 数值加 1 作为新的任务 id（最简单的方法产生一个唯一字段）。这里允许不带 description 字段，默认将 done 字段值为 <code>False</code> 。</p><p>将新任务附加到 tasks 数组里面，并且返回客户端 <code>201</code> 状态码和刚刚添加的任务内容。HTTP定义了 <code>201</code> 状态码为“Created”。</p><p>测试上面的新功能：<br><img src="https://images.xiaozhuanlan.com/photo/2019/672c558fba34aa19096446cfbc82dbb1.png" alt="创建一个新的任务"></p><p>其中 <code>postman</code> 上的设定：<br><img src="https://images.xiaozhuanlan.com/photo/2019/a637eb063fc96ceb8c483e74fe956f41.png" alt="header"><br><img src="https://images.xiaozhuanlan.com/photo/2019/b5fbbda40e05b9f774f245493f9f9e14.png" alt="body"></p><p>完成上面的事情，就可以看到更新之后的 list 数组内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"专栏Link： https://xiaozhuanlan.com/python_mastery"</span>,</span><br><span class="line">            <span class="attr">"done"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"订阅 python_mastery 专栏"</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"专栏Link： https://xiaozhuanlan.com/pythonml"</span>,</span><br><span class="line">            <span class="attr">"done"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"订阅 pythonml 专栏"</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"link https://xiaozhuanlan.com/topic/0758412369"</span>,</span><br><span class="line">            <span class="attr">"done"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Read 专栏文章"</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成剩下的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['PUT'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_task</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    task = list(filter(<span class="keyword">lambda</span> t: t[<span class="string">'id'</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> len(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'title'</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'description'</span> <span class="keyword">in</span> request.json:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'done'</span> <span class="keyword">in</span> request.json <span class="keyword">and</span> type(request.json[<span class="string">'done'</span>]) <span class="keyword">is</span> <span class="keyword">not</span> bool:</span><br><span class="line">        abort(<span class="number">400</span>)</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">'title'</span>] = request.json.get(<span class="string">'title'</span>, task[<span class="number">0</span>][<span class="string">'title'</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">'description'</span>] = request.json.get(<span class="string">'description'</span>, task[<span class="number">0</span>][<span class="string">'description'</span>])</span><br><span class="line">    task[<span class="number">0</span>][<span class="string">'done'</span>] = request.json.get(<span class="string">'done'</span>, task[<span class="number">0</span>][<span class="string">'done'</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'task'</span>: task[<span class="number">0</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['DELETE'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_task</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    task = list(filter(<span class="keyword">lambda</span> t: t[<span class="string">'id'</span>] == task_id, tasks))</span><br><span class="line">    <span class="keyword">if</span> len(task) == <span class="number">0</span>:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    tasks.remove(task[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'result'</span>: <span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure><p> <code>delete_task</code> 函数没什么太特别的。<br> <code>update_task</code> 函数需要检查所输入的参数，防止产生错误的 bug 。确保是预期的 JSON 格式写入数据库里面。</p><p>测试将任务 #2 的 <code>done</code> 字段变更为 <code>done</code> 状态：<br><img src="https://images.xiaozhuanlan.com/photo/2019/0c57c10023df70c913da73e3ad2bbbbf.png" alt=" `done` 状态"></p><p>其中 <code>postman</code> 上的设定：<br><img src="https://images.xiaozhuanlan.com/photo/2019/a637eb063fc96ceb8c483e74fe956f41.png" alt="header"><br><img src="https://images.xiaozhuanlan.com/photo/2019/9cf8ee53537e2369b88a0de7a18389c4.png" alt="body"></p><p>经过上面的操作，我们理论上已经完成了基本的开发任务了。虽我们的目前的service 还存在很多可以改进的地方，例如</p><ul><li>更方便的扩展</li><li>安全性验证</li><li>使用数据库</li><li>其它可优化的地方</li></ul><p>下面针对这3个点，来做具体分析，但是这也只是假设的情况，请实际根据需求来完成。</p><h3 id="优化上面的实现"><a href="#优化上面的实现" class="headerlink" title="优化上面的实现"></a>优化上面的实现</h3><h4 id="更方便的扩展"><a href="#更方便的扩展" class="headerlink" title="更方便的扩展"></a>更方便的扩展</h4><p>假设现在使用者想修改 一个任务的 <code>done</code> 为 <code>True</code>, 他需要自己组合请求的 URL, 那服务器端可以直接返回 API URL 吗？</p><p>答案是可以。</p><p>我们可以通过下面的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> url_for</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_public_task</span><span class="params">(task)</span>:</span></span><br><span class="line">    new_task = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> field <span class="keyword">in</span> task:</span><br><span class="line">        <span class="keyword">if</span> field == <span class="string">'id'</span>:</span><br><span class="line">            new_task[<span class="string">'uri'</span>] = url_for(<span class="string">'get_task'</span>, task_id=task[<span class="string">'id'</span>], _external=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_task[field] = task[field]</span><br><span class="line">    <span class="keyword">return</span> new_task</span><br></pre></td></tr></table></figure><p>通过 Flask 的 url_for 模块，获取任务时，将任务中的 id 字段替换成 uri 字段，并且把值改为 uri 值。</p><p>当我们返回包含任务的 list 时，通过这个函数处理后，返回完整的 uri 给客户端。</p><p>把之前的 <code>get_tasks()</code> 做一些简单的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: list(map(make_public_task, tasks))&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意变化是： <code>return jsonify({&#39;tasks&#39;: list(map(make_public_task, tasks))})</code></p></blockquote><p>检查下结果<br><img src="https://images.xiaozhuanlan.com/photo/2019/c401c2b24ac93baedb12910bb6f771db.png" alt="替换 URL "></p><p>这种办法拿到的是完整 <code>uri</code> 而不是一个 <code>id</code> 。</p><h4 id="安全性验证"><a href="#安全性验证" class="headerlink" title="安全性验证"></a>安全性验证</h4><p>我们已经基本完成了整个功能，但是我们还有一个问题: web service 任何人都可以访问的，在当前爬虫满地跑的年代。这可不行。</p><p>当前 service 是所有客户端都可以连接的，如果有别人知道了这个API就可以写个客户端随意修改数据了。这是个十分严重的问题。</p><p>那要怎么解决这个问题呢？</p><p>最简单的办法是在 web service 中，只允许用户名和密码验证通过的客户端连接。</p><p>在一个常规的web应用中，应该有登录表单提交去认证，同时服务器会创建一个会话过程去进行通讯。</p><p>这个会话过程id会被存储在客户端的cookie里面。不过这样就违返了我们REST中无状态的规则，因此，我们需求客户端每次都将他们的认证信息发送到服务器。</p><p>此我们有两种方法表单认证方法去做，分别是 Basic 和 Digest。</p><p>这个问题已经有很多大佬已经提供了完整的解决方案，我们只是拿来使用就可以了。Flask 插件中的 Flask-HTTPAuth 就可以满足这个功能。</p><p><a href="https://github.com/miguelgrinberg/flask-httpauth" target="_blank" rel="noopener">https://github.com/miguelgrinberg/flask-httpauth</a></p><p>老规矩，首先安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask_httpauth</span><br></pre></td></tr></table></figure><p>然后就是实现功能。假设web service只有用户 <code>python</code> 和密码为 <code>python_mastery</code> 的用户接入。下面就设置了一个Basic HTTP认证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask.ext.httpauth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line">auth = HTTPBasicAuth()</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.get_password</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_password</span><span class="params">(username)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">'python'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'python_mastery'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.error_handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unauthorized</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> make_response(jsonify(&#123;<span class="string">'error'</span>: <span class="string">'Unauthorized access'</span>&#125;), <span class="number">401</span>)</span><br></pre></td></tr></table></figure><p><code>get_password</code> 函数是一个回调函数，获取一个已知用户的密码。</p><blockquote><p>在实际的系统中，函数是需要到数据库中检查的，这里只是一个小示例。</p></blockquote><p>当发生认证错误之后，<code>error_handler</code> 回调函数会发送错误的代码给客户端。这里我们自定义一个错误代码 401，返回 JSON 数据，而不是 HTML 。</p><p>将 <code>@auth.login_required</code> 装饰器添加到需要验证的函数上面：</p><p>修改之前的函数实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/todo/api/v1.0/tasks', methods=['GET'])</span></span><br><span class="line"><span class="meta">@auth.login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tasks</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'tasks'</span>: tasks&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意这里的不同是：<code>@auth.login_required</code></p></blockquote><p><img src="https://images.xiaozhuanlan.com/photo/2019/e6dd4df100b1ac6b504726810dfa2646.png" alt="Unauthorized access"></p><p>这里表示了没通过验证，下面试着把用户名与密码一起带过去进行验证：</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/b749b5151105a428c450b07baa5de32f.png" alt="一起验证"></p><p>其中 <code>postman</code> 设定：<br><img src="https://images.xiaozhuanlan.com/photo/2019/2af3f6b1c73091f4c29c777df0ec06dc.png" alt="base_auth"></p><p>这个认证插件十分灵活，可以随指定需要验证的APIs。</p><h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><p>对于复杂的系统，使用数据库进行数据管理，那是基础条件。鉴于这是另外一个很大的主题，这里就不再深入讨论了。感兴趣的可以去阅读相关的文档及资料。</p><blockquote><p>刚发现，这个专栏里面也相关的入门文章。<br>如果感兴趣，请移步：<a href="https://xiaozhuanlan.com/topic/0789431562" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/0789431562</a></p></blockquote><h4 id="其它可优化的地方"><a href="#其它可优化的地方" class="headerlink" title="其它可优化的地方"></a>其它可优化的地方</h4><p>目前我们的系统基本实现了最简单的一个功能，一些复杂的功能，暂时还没有考虑进来。<br>例如：</p><ul><li>处理多用户。<br>  如果系统支持多用户认证，则任务清单也是对应多用户的。此时的问题复杂度就翻倍了，我们同时要提供用户信息的管理，同时要把用户的任务对应关联起来。</li><li>通过 GET 请求检索任务清单时，我们一次性的返回了所有的任务，但是在任务及用户巨量的时候，这是无法接受的。<br>  有很多办法可以进扩展。<ul><li>第一，添加分页参数，使客户端只请求一部份数据。</li><li>第二，添加筛选关键字等。所有这些元素可以添加到URL上面的参数。</li></ul></li></ul><p>上面就是这次分享的全部内容，谢谢大家的阅读。</p><p><strong>如果文章有帮助到你，请帮忙宣传，谢谢。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;在工作学习中，我们经常会需要将自己的开发成果对外提供服务，此时的选择很多，但是什么才是最高效的呢？&lt;/p&gt;
&lt;p&gt;想必聪明的你，已经想到了：通过 &lt;code&gt;API&lt;/code&gt; 的方式对外提供服务。既然我们在学习 Python 过程中，那我们就使用 Python 来实现自己的 API 吧。&lt;/p&gt;
&lt;p&gt;下面将从下面几个方面进行讲解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 简介&lt;/li&gt;
&lt;li&gt;RESTful API 简介&lt;/li&gt;
&lt;li&gt;使用Python Flask 实现 RESTful API&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;API-简介&quot;&gt;&lt;a href=&quot;#API-简介&quot; class=&quot;headerlink&quot; title=&quot;API 简介&quot;&gt;&lt;/a&gt;API 简介&lt;/h2&gt;&lt;p&gt;API 是英语 &lt;code&gt;Application Programming Interfaces&lt;/code&gt; 的3个首字母组成的，翻译成中文即 &lt;code&gt;应用程序编程接口&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;API 通常是由服务器（Server）提供（服务器有各种各样的类型，一般我们浏览网页用到的是web server，即网络服务器），通过调用 API，本地计算机可以读取、编辑网站数据，就像人类可以加载网页、提交信息等。&lt;/p&gt;
&lt;p&gt;通俗地，API可以理解为家用电器的插头，用户(本地电脑)只需要将插头插入插座的，不需要考虑电器内部(服务器)里面是如何运作的。通过提供 API, 将内部的实现细节封装了起来，对本地电脑简化的流程，同时减少了出错的可能。&lt;/p&gt;
&lt;p&gt;另外一个角度上讲API是一套协议，规定了与外界的沟通方式：如何发送请求和接受响应。只有大家同遵循同样的方式，就可以很快速的接入我们的服务。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;RESTful-API-简介&quot;&gt;&lt;a href=&quot;#RESTful-API-简介&quot; class=&quot;headerlink&quot; title=&quot;RESTful API 简介&quot;&gt;&lt;/a&gt;RESTful API 简介&lt;/h2&gt;&lt;p&gt;RESTful API 即满足 RESTful 风格设计的API，RESTful 表示的是一种互联网软件架构(以网络为基础的应用软件的架构设计)，如果一个架构符合 &lt;code&gt;REST&lt;/code&gt; (Representational State Transfer的缩写，翻译成中文是 &lt;code&gt;&amp;quot;表现层状态转化&amp;quot;&lt;/code&gt;.)原则，就称它为 RESTful 架构。&lt;/p&gt;
&lt;p&gt;那什么是 &lt;code&gt;REST&lt;/code&gt; 原则呢？&lt;code&gt;Representational State Transfer&lt;/code&gt; 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，基本就理解了什么是 &lt;code&gt;REST&lt;/code&gt; 设计原则。&lt;/p&gt;
&lt;p&gt;从下面几个角度来分解这个问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下面的部分内容可以忽略，可以直接跳到总结的部分。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python-高级-实用-操作 Excel</title>
    <link href="http://yoursite.com/2019/10/15/2019-10-15-Programing-Python-Advanded-Excel-operation-with-xlwings/"/>
    <id>http://yoursite.com/2019/10/15/2019-10-15-Programing-Python-Advanded-Excel-operation-with-xlwings/</id>
    <published>2019-10-15T03:31:13.000Z</published>
    <updated>2019-11-25T03:37:33.327Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Python-高级-实用-操作-Excel"><a href="#Python-高级-实用-操作-Excel" class="headerlink" title="Python-高级-实用-操作 Excel"></a>Python-高级-实用-操作 Excel</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>Excel 是我们日常工作学习中都会使用到的很重要的工具。但是处理过程中难免会遇到重复的操作，同时面对大量数据时手工操作也可能因为误操作导致错误发生。我们刚好在学习 Python, 那有没有办法通过 code 来读取 Excel 文件。</p><p>答案是肯定的，下面我们就使用 Python 来进行操作 Excel 文件。</p><h2 id="模块选择"><a href="#模块选择" class="headerlink" title="模块选择"></a>模块选择</h2><p>熟悉 Python 世界的读者，就会明白：在 Python 的世界里，做一件事情，官方建议只有一种方法。但是现实中，大佬太多，互相之间看不上别人做的东西，重复造轮子的现象比较严重。</p><p>如果百度或google 一下：“Python Excel”, 下面的几个第三方模块库常常出现在推荐列表中</p><ul><li>openpyxl</li><li>xlsxwriter</li><li>xlutils</li><li>xlwings</li></ul><p>经过实际的验证(验证过程略), 我挑选 <code>xlwings</code> 作为实际使用的模块。</p><h2 id="xlwings-简介"><a href="#xlwings-简介" class="headerlink" title="xlwings 简介"></a><code>xlwings</code> 简介</h2><p>众所周知，VBA 可以很高效的操作 Excel，提高办公效率。<br>在 Python 中，我们可以通过 pywin32 来调用 windows 系统的 API 来实现 VBA 的很多功能，但是写起来比较复杂。</p><p><code>xlwings</code> 是基于 BSD-licensed 的一个 Python 第三方的模块，对 <code>pywin32</code> 进行了封装，可以很方便的和 Excel 进行交互，它有以下优点：</p><ul><li>语法接近 VBA</li><li>可以用 Python 代码取代 VBA 编写宏</li><li>在 windows 可以用 Python 编写 Excel 用户自定义函数</li><li>全功能支持 Numpy Pandas matplotlib 等科学计算库</li><li>支持 Windows 和 MacOS</li><li>支持 Py3.3+</li></ul><a id="more"></a><p>官方地址： <a href="https://www.xlwings.org/" target="_blank" rel="noopener">https://www.xlwings.org/</a></p><h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="推荐的方式"><a href="#推荐的方式" class="headerlink" title="推荐的方式"></a>推荐的方式</h4><p>推荐使用 <code>Anaconda</code>  来安装，可以省去很多麻烦，</p><blockquote><p>Anaconda 是一个包含了Python 常用模块的第三方整合的包，里面包含了很多实用的工具及模块，是Python 快速学习及开发比较推荐的方式。同时他也提供命令行工具 <code>conda</code> 方便来对模块进行安装，其功能类似于Python 官方的 <code>pip</code> 工具。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install xlwings</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="自己手动安装"><a href="#自己手动安装" class="headerlink" title="自己手动安装"></a>自己手动安装</h4><p>当然自己手动安装也是可以的，下面是自己手动使用 <code>pip</code> 安装的过程。<br>使用 <code>pip</code> 安装，需要先手动安装 <code>pywin32</code> , 这是一个将 OS 的一些底层操作进行高级封装的模块，简化了对系统的复杂操作。 </p><p>下载地址:<br><a href="https://sourceforge.net/projects/pywin32/files/pywin32/" target="_blank" rel="noopener">https://sourceforge.net/projects/pywin32/files/pywin32/</a></p><p>安装 pywin32 后，使用 pip 安装 <code>xlwings</code>即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install xlwings</span><br></pre></td></tr></table></figure></p><p><code>xlwings</code>的 官方安装文档,<br><a href="https://docs.xlwings.org/en/stable/installation.html" target="_blank" rel="noopener">https://docs.xlwings.org/en/stable/installation.html</a></p><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>引入库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br></pre></td></tr></table></figure></p><p>打开Excel程序，默认设置：程序可见，只打开不新建工作薄<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app = xw.App(visible=True,add_book=False)</span><br><span class="line"># 新建工作簿 (如果不接下一条代码的话，Excel会一闪而过就走了）</span><br><span class="line"></span><br><span class="line">wb = app.books.add()</span><br></pre></td></tr></table></figure></p><p>打开已有工作簿（支持绝对路径和相对路径）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wb = app.books.open(<span class="string">'temp.xlsx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接使用下面这条</span></span><br><span class="line"><span class="comment">#wb = xw.Book('temp.xlsx')</span></span><br><span class="line"><span class="comment"># 这样的话就不会频繁打开新的Excel</span></span><br></pre></td></tr></table></figure></p><p>保存工作簿<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.save(<span class="string">'example.xlsx'</span>)</span><br></pre></td></tr></table></figure></p><p>退出工作簿（可省略）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.close()</span><br></pre></td></tr></table></figure></p><p>退出Excel<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.quit()</span><br></pre></td></tr></table></figure></p><p>引用Excel工作表，单元格<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 引用工作表</span></span><br><span class="line">sht = wb.sheets[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#sht = wb.sheets[第一个sheet名]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用单元格</span></span><br><span class="line">rng = sht.range(<span class="string">'a1'</span>)</span><br><span class="line"><span class="comment"># rng = sht['a1']</span></span><br><span class="line"><span class="comment"># rng = sht[0,0] 第一行的第一列即a1,相当于pandas的切片</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用区域</span></span><br><span class="line">rng = sht.range(<span class="string">'a1:a5'</span>)</span><br><span class="line"><span class="comment"># rng = sht['a1:a5']</span></span><br><span class="line"><span class="comment"># rng = sht[:5,0]</span></span><br></pre></td></tr></table></figure></p><h2 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h2><h3 id="一份完整的sample-代码"><a href="#一份完整的sample-代码" class="headerlink" title="一份完整的sample 代码"></a>一份完整的sample 代码</h3><p>我们把刚刚的过程，写到一起，再来回顾下函数的基础使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"><span class="comment"># 打开一个新的 workbook </span></span><br><span class="line">wb = xw.Book()</span><br><span class="line"><span class="comment"># 打开当前目录已经存在的一个 workbook </span></span><br><span class="line">wb = xw.Book(<span class="string">'temp.xlsx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入完整的路径打开一个 workbook </span></span><br><span class="line">FileName = <span class="string">"C:\\python\\to\\temp.xlsx"</span></span><br><span class="line"><span class="comment"># FileName = r"C:\python\to\temp.xlsx"</span></span><br><span class="line"></span><br><span class="line">wb = xw.Book(fn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 sheet 的三种方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 打开第一个 sheet</span></span><br><span class="line">sheet = wb.sheets[<span class="number">0</span>]</span><br><span class="line"><span class="comment">## 打开名字为 "youdaily" sheet</span></span><br><span class="line">sheet = wb.sheets[<span class="string">"youdaily"</span>]</span><br><span class="line"><span class="comment">## 打开当前活动的 sheet</span></span><br><span class="line">sheet = wb.sheets.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读写数据到 sheet </span></span><br><span class="line"><span class="comment">## 当前活动的 sheet 中读写一个单元格的数据</span></span><br><span class="line"></span><br><span class="line">sht = wb.sheets.active</span><br><span class="line">sht.range(<span class="string">'A1'</span>).value = <span class="string">"youdaily"</span></span><br><span class="line">print(sht.range(<span class="string">'A1'</span>).value)</span><br><span class="line"><span class="comment">## youdaily</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前活动的 sheet 中读写一行单元格的数据</span></span><br><span class="line"><span class="comment">## 将列表储存在A1：C1中</span></span><br><span class="line">sht.range(<span class="string">'A1'</span>).value=[<span class="string">"youdaily"</span>,<span class="string">"age"</span>,<span class="string">"gender"</span>]</span><br><span class="line">print(sht.range(<span class="string">'A1:C1'</span>).value)</span><br><span class="line"><span class="comment">## ['youdaily', 'age', 'gender']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># #当前活动的 sheet 中读写一列单元格的数据</span></span><br><span class="line"><span class="comment"># 将列表储存在A1:A3中</span></span><br><span class="line">sht.range(<span class="string">'A1'</span>).options(transpose=<span class="literal">True</span>).value=[<span class="string">"youdaily"</span>,<span class="number">18</span>,<span class="number">1</span>]</span><br><span class="line">print(sht.range(<span class="string">"A1:A3"</span>).value)</span><br><span class="line"><span class="comment">## ['youdaily', 18.0, 1.0]</span></span><br><span class="line"></span><br><span class="line">sht.range(<span class="string">'A1:A3'</span>).value = [<span class="string">"youdaily"</span>, <span class="number">20</span>, <span class="number">2</span>]</span><br><span class="line">print(sht.range(<span class="string">"A1:A3"</span>).value)</span><br><span class="line"><span class="comment">## ['youdaily', 18.0, 1.0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 当前活动的 sheet 中读写多行多列单元格的数据</span></span><br><span class="line"><span class="comment">## 将2x2表格，即二维数组，储存在A1:B2中，如第一行1，2，第二行3，4</span></span><br><span class="line">wb = xw.Book()</span><br><span class="line">sht = wb.sheets.active</span><br><span class="line">sht.range(<span class="string">'A1'</span>).options(expand=<span class="string">'table'</span>).value=[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">print(sht.range(<span class="string">"A1"</span>).expand().value)</span><br><span class="line"><span class="comment">## [[1.0, 2.0], [3.0, 4.0]]</span></span><br><span class="line"><span class="comment">## expand 的详细用法请参考文档</span></span><br><span class="line">sht.range(<span class="string">'A1:B2'</span>).value = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">print(sht.range(<span class="string">'A1:B2'</span>).value)</span><br><span class="line"><span class="comment">## [[1.0, 2.0], [3.0, 4.0]]</span></span><br></pre></td></tr></table></figure><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>有了上面的回顾后，我们再来一个实例来再学习一次。</p><p>需求：删除 Excel 文件中，满足条件的单元格所在的一整行.</p><p>我们的Excel 文件长这样。</p><p><img src="https://upload-images.jianshu.io/upload_images/1940331-a73d9fda25c0a8fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="excel"></p><blockquote><p>你当然可以在Excel 中使用Excel 自带的方法，来实现去重的功能，但是那不是手动了吗？<br>现在是数据少的时候，如果数据多了呢？手动操作，出错的概率会大大的增加。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2019-11-09 17:14:03</span></span><br><span class="line"><span class="comment"># @Author  : youdaily (youdaily)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"></span><br><span class="line">fn = <span class="string">"temp.xlsx"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeleteTools</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    删除满足某些条件的行</span></span><br><span class="line"><span class="string">    data.xlsx 中有很多重复的数据    </span></span><br><span class="line"><span class="string">    需要删除那些重复的</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        super(DeleteTools, self).__init__()</span><br><span class="line">        self.ExistSet = set()</span><br><span class="line">        self.ToDelList = list()</span><br><span class="line">        self.fn = fn</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rule</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 可以自定义规则来操作</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># visible 控制 Excel 打开是否显示界面</span></span><br><span class="line">        <span class="comment">## add_book 控制是否添加新的 workbook</span></span><br><span class="line">        app = xw.App(visible=<span class="literal">True</span>, add_book=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># app.display_alerts = False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开 temp.xlsx 文件到 wookbook 中</span></span><br><span class="line">        wb = app.books.open(fn)</span><br><span class="line">        <span class="comment"># 切换到当前活动的 sheet 中</span></span><br><span class="line">        sheet = wb.sheets.active</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择 A1 所在的一列</span></span><br><span class="line">        <span class="comment">## 当 Excel 格式复杂的时候,不建议使用 expand</span></span><br><span class="line">        <span class="comment">## 可以这样选择</span></span><br><span class="line">        ARange = sheet.range(<span class="string">"A1:A100"</span>)</span><br><span class="line">        <span class="comment"># ARange = sheet.range("A1").expand("download")</span></span><br><span class="line">        <span class="keyword">for</span> A <span class="keyword">in</span> ARange:</span><br><span class="line">            <span class="keyword">if</span> str(A.value).strip() <span class="keyword">not</span> <span class="keyword">in</span> self.ExistSet:</span><br><span class="line">                self.ExistSet.add(str(A.value).strip())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># address = A.address</span></span><br><span class="line">                <span class="comment">## 获取 A 所在的位置坐标</span></span><br><span class="line">                self.ToDelList.append(A.address)</span><br><span class="line">                <span class="comment">## print(A.value)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.ToDelList:</span><br><span class="line">            td = self.ToDelList.pop()</span><br><span class="line">            <span class="comment"># 删除 A 所在的一行</span></span><br><span class="line">            sheet.range(td).api.EntireRow.Delete()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 保存 wookbook</span></span><br><span class="line">        <span class="comment">## 相当于Excel 的 Ctrl+S 快捷键</span></span><br><span class="line">        sheet.autofit()</span><br><span class="line">        wb.save()</span><br><span class="line">        app.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    d = DeleteTools(fn)</span><br><span class="line">    d.Delete()</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>通过 <code>xlwings</code> 模块去自动操作 excel , 将日常需要手动操作的过程通过代码来自动操作，减少犯错的可能，一次次的不犯错，就是巨大的成功，在迎娶“白富美”的路上越走越远了。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;Python-高级-实用-操作-Excel&quot;&gt;&lt;a href=&quot;#Python-高级-实用-操作-Excel&quot; class=&quot;headerlink&quot; title=&quot;Python-高级-实用-操作 Excel&quot;&gt;&lt;/a&gt;Python-高级-实用-操作 Excel&lt;/h1&gt;&lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;Excel 是我们日常工作学习中都会使用到的很重要的工具。但是处理过程中难免会遇到重复的操作，同时面对大量数据时手工操作也可能因为误操作导致错误发生。我们刚好在学习 Python, 那有没有办法通过 code 来读取 Excel 文件。&lt;/p&gt;
&lt;p&gt;答案是肯定的，下面我们就使用 Python 来进行操作 Excel 文件。&lt;/p&gt;
&lt;h2 id=&quot;模块选择&quot;&gt;&lt;a href=&quot;#模块选择&quot; class=&quot;headerlink&quot; title=&quot;模块选择&quot;&gt;&lt;/a&gt;模块选择&lt;/h2&gt;&lt;p&gt;熟悉 Python 世界的读者，就会明白：在 Python 的世界里，做一件事情，官方建议只有一种方法。但是现实中，大佬太多，互相之间看不上别人做的东西，重复造轮子的现象比较严重。&lt;/p&gt;
&lt;p&gt;如果百度或google 一下：“Python Excel”, 下面的几个第三方模块库常常出现在推荐列表中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;openpyxl&lt;/li&gt;
&lt;li&gt;xlsxwriter&lt;/li&gt;
&lt;li&gt;xlutils&lt;/li&gt;
&lt;li&gt;xlwings&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过实际的验证(验证过程略), 我挑选 &lt;code&gt;xlwings&lt;/code&gt; 作为实际使用的模块。&lt;/p&gt;
&lt;h2 id=&quot;xlwings-简介&quot;&gt;&lt;a href=&quot;#xlwings-简介&quot; class=&quot;headerlink&quot; title=&quot;xlwings 简介&quot;&gt;&lt;/a&gt;&lt;code&gt;xlwings&lt;/code&gt; 简介&lt;/h2&gt;&lt;p&gt;众所周知，VBA 可以很高效的操作 Excel，提高办公效率。&lt;br&gt;在 Python 中，我们可以通过 pywin32 来调用 windows 系统的 API 来实现 VBA 的很多功能，但是写起来比较复杂。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xlwings&lt;/code&gt; 是基于 BSD-licensed 的一个 Python 第三方的模块，对 &lt;code&gt;pywin32&lt;/code&gt; 进行了封装，可以很方便的和 Excel 进行交互，它有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法接近 VBA&lt;/li&gt;
&lt;li&gt;可以用 Python 代码取代 VBA 编写宏&lt;/li&gt;
&lt;li&gt;在 windows 可以用 Python 编写 Excel 用户自定义函数&lt;/li&gt;
&lt;li&gt;全功能支持 Numpy Pandas matplotlib 等科学计算库&lt;/li&gt;
&lt;li&gt;支持 Windows 和 MacOS&lt;/li&gt;
&lt;li&gt;支持 Py3.3+&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python-高级-爬虫-Requests 库高级使用</title>
    <link href="http://yoursite.com/2019/10/13/2019-10-13-Programing-Python-Advanded-Requests-intro-2/"/>
    <id>http://yoursite.com/2019/10/13/2019-10-13-Programing-Python-Advanded-Requests-intro-2/</id>
    <published>2019-10-13T03:29:35.000Z</published>
    <updated>2019-11-25T03:37:39.060Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Headers（定制请求头）"><a href="#Headers（定制请求头）" class="headerlink" title="Headers（定制请求头）"></a>Headers（定制请求头）</h2><h3 id="什么是Headers请求头呢？"><a href="#什么是Headers请求头呢？" class="headerlink" title="什么是Headers请求头呢？"></a>什么是Headers请求头呢？</h3><p>请求头就是访问网页时的各种简单的证明信息，里面包含了很多内容。</p><p>比如你要获取信息的格式、访问的时间、是否用了代理（使用透明代理时浏览器依旧会发送你的真实IP，只有高匿代理才不会）、浏览器标识（User-Agent）等。</p><p>提示：给大家举一个非常直白的例子，浏览器就像是你的专属外卖配送员，各网站就像外卖商家，配送员到商家取餐时，需要提供订单号、我是谁的配送员、要取什么餐等等信息。</p><p>这里以chrome浏览器为例，首先 F12 打开调试模式，然后访问一个网站，将会在NetWork下看到对目标网页的请求信息，如下图：<br><img src="https://images.xiaozhuanlan.com/photo/2019/b2f2ccdcfc8c21bd8cf347564f09ec12.png" alt></p><p>通过设置header可以跳过一些简单的反爬或者防盗链措施。对付防盗链，服务器会识别 headers 中的 referer 是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在 headers 中加入 referer 。</p><blockquote><p>爬虫和反爬虫就像是双生兄弟一样，其中</p></blockquote><h3 id="一个响应内容的小例子"><a href="#一个响应内容的小例子" class="headerlink" title="一个响应内容的小例子"></a>一个响应内容的小例子</h3><p>这里以上海证券交易所为例，比如我要获取整个市场当日的基金成交信息，地址：<a href="http://www.sse.com.cn/market/funddata/overview/day/" target="_blank" rel="noopener">http://www.sse.com.cn/market/funddata/overview/day/</a><br><img src="https://images.xiaozhuanlan.com/photo/2019/4fa96803c51d0ccd800998dc044d5560.png" alt="当日的基金成交信息"></p><p>经过分析，其数据所在网址为<br><a href="http://query.sse.com.cn/marketdata/tradedata/queryNewTradingByProdTypeData.do?jsonCallBack=jsonpCallback10558&amp;searchDate=2019-10-08&amp;prodType=jj&amp;_=1570591517567" target="_blank" rel="noopener">http://query.sse.com.cn/marketdata/tradedata/queryNewTradingByProdTypeData.do?jsonCallBack=jsonpCallback10558&amp;searchDate=2019-10-08&amp;prodType=jj&amp;_=1570591517567</a></p><p>里面几个参数 <code>searchDate=2019-10-08</code> 和 <code>_=1570591517567</code> 很明显是时间戳，如果需要定时访问时，还是要构造一个url的。</p><p>使用time库的time方法即可。</p><a id="more"></a><p>时间戳的长度跟url中有差别，是因为精度问题，只需要乘以1000然后取整即可。</p><p>构造好url后，直接访问以下试试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">timestamp = int(time.time()*<span class="number">1000</span>)</span><br><span class="line">url = <span class="string">'http://query.sse.com.cn/marketdata/tradedata/queryTradingByProdTypeData.do?jsonCallBack=jsonpCallback21071&amp;searchDate=&amp;prodType=jj&amp;_=&#123;&#125;'</span>.format(timestamp)</span><br><span class="line">res = requests.get(url)</span><br><span class="line">html = res.content.decode()</span><br><span class="line">print(html)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到结果</span></span><br><span class="line">jsonpCallback21071(&#123;“jsonCallBack”:”jsonpCallback21071″,”success”:”false”,”error”:”系统繁忙…”,”errorType”:”ExceptionInterceptor”&#125;)</span><br></pre></td></tr></table></figure><br>虽然有一些信息，但明显是出错了。<br><img src="https://images.xiaozhuanlan.com/photo/2019/a52113b1b8f0f60145e15418c2c2a611.png" alt="出错了"></p><p>我们通过浏览器来查看这个链接的请求头到底是什么：</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/b8451173af49b6f9b5c59c093079b477.png" alt="请求头"></p><p>复制过来，构造一个dict类型的header字典，再次访问试试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">myheaders = &#123;</span><br><span class="line">        <span class="string">'Referer'</span>: <span class="string">'http://www.sse.com.cn/market/funddata/overview/day/'</span>, </span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span></span><br><span class="line">             &#125;</span><br><span class="line">timestamp = int(time.time()*<span class="number">1000</span>)</span><br><span class="line">url = <span class="string">'http://query.sse.com.cn/marketdata/tradedata/queryTradingByProdTypeData.do?jsonCallBack=jsonpCallback21071&amp;searchDate=&amp;prodType=jj&amp;_=&#123;&#125;'</span>.format(timestamp)</span><br><span class="line">res = requests.get(url, headers=myheaders)</span><br><span class="line">html = res.content.decode()</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><br>完全没毛病了：<br><img src="https://images.xiaozhuanlan.com/photo/2019/338ebf5fb19f485f6e5abe8b105c5867.png" alt="成功了"></p><h3 id="Headers各主要字段的解释"><a href="#Headers各主要字段的解释" class="headerlink" title="Headers各主要字段的解释"></a>Headers各主要字段的解释</h3><p>在Requests Headers中各主要字段的解释如下：</p><ul><li>User-Agent<br> 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求</li><li>Content-Type<br>  在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。</li><li>application/xml<br> 在 XML RPC，如 RESTful/SOAP 调用时使用</li><li>application/json<br> 在 JSON RPC 调用时使用</li><li>application/x-www-form-urlencoded<br>  浏览器提交 Web 表单时使用</li></ul><blockquote><p>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</p></blockquote><h3 id="其他响应方式"><a href="#其他响应方式" class="headerlink" title="其他响应方式"></a>其他响应方式</h3><p>二进制响应内容：res.content，解码前，是byte格式。</p><p>JSON 响应内容：Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据 <code>res.json()</code> 。如果 JSON 解码失败， r.json() 就会抛出一个异常。例如，响应内容是 401 (Unauthorized)，尝试访问 r.json() 将会抛出  <code>ValueError: No JSON object could be decoded</code>异常。</p><p>原始响应内容：在罕见的情况下，你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw。 如果你确实想这么干，那请你确保在初始请求中设置了 <code>stream=True</code>。</p><h2 id="构造Url"><a href="#构造Url" class="headerlink" title="构造Url"></a>构造Url</h2><p>前文中目标 url 有很多参数，一方面很不美观，也容易出错，我们完全可以把参数全部摘出来放到一个 dict 字典中，然后在请求网页数据时将这个字典数据传递给 <code>params</code> 参数，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">myheaders = &#123;</span><br><span class="line">    <span class="string">'Referer'</span>: <span class="string">'http://www.sse.com.cn/market/funddata/overview/day/'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timestamp = int(time.time()*<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">localtime = time.localtime()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里以当前日期为例，如果需要特定日期，直接为`searchDate` 赋值就可以了</span></span><br><span class="line"><span class="comment"># searchDate = "&#123;0&#125;-&#123;1&#125;-&#123;2&#125;".format("2019"， "10"， "08")</span></span><br><span class="line">searchDate = <span class="string">"&#123;&#125;-&#123;:0&gt;2d&#125;-&#123;:0&gt;2d&#125;"</span>.format(localtime.tm_year,localtime.tm_mon, localtime.tm_mday)</span><br><span class="line"></span><br><span class="line">pp = &#123;</span><br><span class="line">    <span class="string">'jsonCallBack'</span>: <span class="string">'jsonpCallback22341'</span>,</span><br><span class="line">    <span class="string">'searchDate'</span>: searchDate,</span><br><span class="line">    <span class="string">'prodType'</span>: <span class="string">'jj'</span>,</span><br><span class="line">    <span class="string">'_'</span>: timestamp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://query.sse.com.cn/marketdata/tradedata/queryTradingByProdTypeData.do'</span></span><br><span class="line">res = requests.get(url, headers=myheaders, params=pp)</span><br><span class="line">html = res.content.decode()</span><br><span class="line"></span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure></p><h2 id="Timeout-超时设置"><a href="#Timeout-超时设置" class="headerlink" title="Timeout(超时设置)"></a>Timeout(超时设置)</h2><p>连接超时指的是在你的客户端实现到远端机器端口的连接时（对应的是<code>connect()</code>_），Request 会等待的秒数。<br>一个很好的实践方法是把连接超时设为比 3 的倍数略大的一个数值，因为 TCP 数据包重传窗口 (<code>TCP packet retransmission window</code>) 的默认大小是 3。</p><p>有时候，我们访问的网页可能挂了、或者网络不稳定，或者网速太差等等原因导致整个程序卡在某个页面上了，这就非常耽误事，毕竟爬虫需要批量抓很多内容的，有些内容我们可以临时放弃并做标记，将所有都爬完后再考虑是否重新爬之前超时的页面。为防止服务器不能及时响应，大部分发至外部服务器的请求都应该带着 timeout 参数。</p><p>在默认情况下，除非显式指定了 timeout 值，requests 是不会自动进行超时处理的。</p><p>如果没有 timeout，你的代码可能会挂起若干分钟甚至更长时间。</p><p>你可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">requests.get(‘https://xiaozhuanlan.com/python_mastery’, timeout=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><blockquote><p>timeout 仅对连接过程有效，与响应体的下载无关。</p></blockquote><p>timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）<code>If no timeout is specified explicitly, requests do not time out.</code>。</p><p>如果远端服务器很慢，你可以让 Request 永远等待，传入一个 None 作为 timeout 值，然后就可以了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">'https://xiaozhuanlan.com/python_mastery'</span>, timeout=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;Headers（定制请求头）&quot;&gt;&lt;a href=&quot;#Headers（定制请求头）&quot; class=&quot;headerlink&quot; title=&quot;Headers（定制请求头）&quot;&gt;&lt;/a&gt;Headers（定制请求头）&lt;/h2&gt;&lt;h3 id=&quot;什么是Headers请求头呢？&quot;&gt;&lt;a href=&quot;#什么是Headers请求头呢？&quot; class=&quot;headerlink&quot; title=&quot;什么是Headers请求头呢？&quot;&gt;&lt;/a&gt;什么是Headers请求头呢？&lt;/h3&gt;&lt;p&gt;请求头就是访问网页时的各种简单的证明信息，里面包含了很多内容。&lt;/p&gt;
&lt;p&gt;比如你要获取信息的格式、访问的时间、是否用了代理（使用透明代理时浏览器依旧会发送你的真实IP，只有高匿代理才不会）、浏览器标识（User-Agent）等。&lt;/p&gt;
&lt;p&gt;提示：给大家举一个非常直白的例子，浏览器就像是你的专属外卖配送员，各网站就像外卖商家，配送员到商家取餐时，需要提供订单号、我是谁的配送员、要取什么餐等等信息。&lt;/p&gt;
&lt;p&gt;这里以chrome浏览器为例，首先 F12 打开调试模式，然后访问一个网站，将会在NetWork下看到对目标网页的请求信息，如下图：&lt;br&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2019/b2f2ccdcfc8c21bd8cf347564f09ec12.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;通过设置header可以跳过一些简单的反爬或者防盗链措施。对付防盗链，服务器会识别 headers 中的 referer 是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在 headers 中加入 referer 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;爬虫和反爬虫就像是双生兄弟一样，其中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一个响应内容的小例子&quot;&gt;&lt;a href=&quot;#一个响应内容的小例子&quot; class=&quot;headerlink&quot; title=&quot;一个响应内容的小例子&quot;&gt;&lt;/a&gt;一个响应内容的小例子&lt;/h3&gt;&lt;p&gt;这里以上海证券交易所为例，比如我要获取整个市场当日的基金成交信息，地址：&lt;a href=&quot;http://www.sse.com.cn/market/funddata/overview/day/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.sse.com.cn/market/funddata/overview/day/&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2019/4fa96803c51d0ccd800998dc044d5560.png&quot; alt=&quot;当日的基金成交信息&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过分析，其数据所在网址为&lt;br&gt;&lt;a href=&quot;http://query.sse.com.cn/marketdata/tradedata/queryNewTradingByProdTypeData.do?jsonCallBack=jsonpCallback10558&amp;amp;searchDate=2019-10-08&amp;amp;prodType=jj&amp;amp;_=1570591517567&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://query.sse.com.cn/marketdata/tradedata/queryNewTradingByProdTypeData.do?jsonCallBack=jsonpCallback10558&amp;amp;searchDate=2019-10-08&amp;amp;prodType=jj&amp;amp;_=1570591517567&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面几个参数 &lt;code&gt;searchDate=2019-10-08&lt;/code&gt; 和 &lt;code&gt;_=1570591517567&lt;/code&gt; 很明显是时间戳，如果需要定时访问时，还是要构造一个url的。&lt;/p&gt;
&lt;p&gt;使用time库的time方法即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python-高级-爬虫-Requests 库基础使用</title>
    <link href="http://yoursite.com/2019/10/10/2019-10-10-Programing-Python-Advanded-Requests-intro/"/>
    <id>http://yoursite.com/2019/10/10/2019-10-10-Programing-Python-Advanded-Requests-intro/</id>
    <published>2019-10-10T03:27:37.000Z</published>
    <updated>2019-11-25T03:37:51.095Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h2><p><code>Requests</code> 库就非常优雅，虽然不是原生python模块，但自己安装也非常简单，只需要使用以下命令即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p>作为 GitHub上关注数最多的 Python 项目之一，使用的是 urllib3，继承了urllib2的所有特性。requests实现了 HTTP协议中绝大部分功能，它提供的功能包括 Keep-Alive、连接池、Cookie持久化、内容自动解压、HTTP代理、SSL认证、连接超时、Session等很多特性，最重要的是它同时兼容 python2 和 python3。</p><p>同时，Requests对于HEAD, POST, PUT, PATCH, 和 DELETE方法的api同样简单。它可以处理多部分上传，同样支持自动转码，文档更好，还有更多的特性。</p><blockquote><p>值得注意的是，网络上有种言论是因为requests不支持异步，所以不推荐使用，但是随着 Python 语言本身的发展，现在已经可以很方便的将<code>requests</code>转为异步。</p></blockquote><h3 id="查看所安装-Requests-的版本"><a href="#查看所安装-Requests-的版本" class="headerlink" title="查看所安装 Requests 的版本"></a>查看所安装 Requests 的版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.__version__</span><br><span class="line"><span class="string">'2.21.0'</span></span><br></pre></td></tr></table></figure><h2 id="常用的-Requests-方法及说明"><a href="#常用的-Requests-方法及说明" class="headerlink" title="常用的 Requests 方法及说明"></a>常用的 Requests 方法及说明</h2><h3 id="请求URL：GET"><a href="#请求URL：GET" class="headerlink" title="请求URL：GET"></a>请求URL：GET</h3><p>当我们导入requests模块之后就可以使用get命令来获取网页了，我们以自己的小专栏为例，测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.get(<span class="string">'https://xiaozhuanlan.com/python_mastery'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>请求url之后，我们可以通过 <code>response.status_code</code> 或者 <code>response.ok</code> 命令来查看是否访问成功。</p><p>网页的具体内容则可以通过方法 <code>response.content.decode()</code> 来获取，其中 <code>decode()</code> 是用于解析内容编码的，如果网页编码格式是 <code>gb2312</code> 之类的，需要 <code>decode(&#39;gbk&#39;)</code> ，如果是 <code>utf8</code> ，则需要 <code>decode(&#39;utf-8&#39;)</code> 传入不同的参数。当参数为空时，默认为当前脚本的编码格式。<br><img src="https://images.xiaozhuanlan.com/photo/2019/e0ecacb5b5aab5cb0f1a9d34f7625038.png" alt="response.content.decode()"></p><p>其中对象response的属性 <code>status_code</code> 代表网页的htpp状态码，爬虫在抓取过程中经常遇到的的状态码有以下几种：</p><ul><li>200<br>  一切正常，网页资源正常获取到。</li><li>500<br>  如果在网页上会提示Bad Request，表示网页服务器返回给请求端的错误提示，提示请求端修复请求信息。</li><li>500<br>  Internal Server Error，网页服务器方面的问题，在爬虫抓取网站的过程中如果过快、被禁止等，会引发该类问题。表示服务器限制了客户端的访问。</li><li>404(“Not Found”) 和410(“Gone”)<br>  表示请求的网页资源不存在。</li><li>301<br>  重定向，请求的url呗重新定向到了另外一个url请求，通常需要请求端向另外一个url发送get请求才能得到所需要的网页资源。</li></ul><p>这里只是摘抄了部分返回值的情况，完整的内容请参见 https 状态码<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">HTTP 响应代码</a></p><h3 id="传递URL的参数"><a href="#传递URL的参数" class="headerlink" title="传递URL的参数"></a>传递URL的参数</h3><p>与后面要将到的 <code>post</code> 方式请求url相比，通过在url上添加参数也是网页服务器的设计之一，具体使用哪种方式是有网站程序来控制。</p><p>最经典、使用率最高的就是百度搜索了，百度搜索就是典型的通过 url 来传递搜索词和其他变量的，当然，也有一些 post 的内容在此处用不到暂时不展开讲。</p><p>用百度搜索一下，此处以关键词 “小专栏 Python 从入门到精通”为例，</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/649d4725ae4bde13071acda730a5c131.png" alt="百度搜索"></p><p>可以看到其中 <code>wd</code> 是关键词，<code>wd</code> 的具体值中空格变成了<code>+</code>，这是 url 转码导致的，在我们传递 url 参数时，有时候也需要这样的处理。</p><p>我们试着用requests来传递参数，目标地址：<code>https://www.baidu.com/s</code>，构造一个参数字典：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>params = &#123;<span class="string">'wd'</span>:<span class="string">'小专栏 Python 从入门到精通'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = requests.get(<span class="string">'https://www.baidu.com/s'</span>, params=params)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.url)</span><br><span class="line">https://www.baidu.com/s?wd=%E5%B0%8F%E4%B8%93%E6%A0%8F+Python+%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A</span><br></pre></td></tr></table></figure><br>可以看到，url 已经传递了参数过来。浏览器访问该链接时中文讲自动解析。</p><blockquote><p>如果我们直接请求该网址，可能网页内容无法或许到，因为我们访问的是 <code>https</code> ，需要 <code>ssl</code> 证书，此后的教程中我会讲到该部分内容。</p></blockquote><h2 id="请求URL：POST"><a href="#请求URL：POST" class="headerlink" title="请求URL：POST"></a>请求URL：POST</h2><p>前面讲到传递 url 参数时提到 <code>post</code> 方法，<code>post</code> 方法就是 url 保持不变而具体的请求变量内容以 <code>post</code> 的形式发送过去。可以直接理解为将 url 中的参数改到了 <code>post</code> 的data中，<code>post</code> 还有一个好处是当传递的内容很长时，通过 url 是无法发送的（有最大长度），<code>post</code> 就没问题。而且，除了用于登录，像图片上传、文件上传，发表文章、论坛发帖顶贴等也基本使用的是 <code>post</code> 方法。</p><p>这里假设登录 wordpress 的博客后台来举例，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造一个post的form Data</span></span><br><span class="line">postdata = &#123;</span><br><span class="line"><span class="string">'log'</span>: <span class="string">'XXXXXXXXXXXX'</span>,</span><br><span class="line"><span class="string">'pwd'</span>: <span class="string">'XXXXXXXXXXXX'</span>,</span><br><span class="line"><span class="string">'wp-submit'</span>: <span class="string">'登录'</span>,</span><br><span class="line"><span class="string">'redirect_to'</span>: <span class="string">'http://xxx.xxx.xxx/'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行post命令</span></span><br><span class="line">response = requests.post(url, data=postdata)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看取得的网页内容</span></span><br><span class="line">response.content.decode()</span><br></pre></td></tr></table></figure><p>以上就是requests库的基础用法。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;Requests&quot;&gt;&lt;a href=&quot;#Requests&quot; class=&quot;headerlink&quot; title=&quot;Requests&quot;&gt;&lt;/a&gt;Requests&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Requests&lt;/code&gt; 库就非常优雅，虽然不是原生python模块，但自己安装也非常简单，只需要使用以下命令即可：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install requests&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;作为 GitHub上关注数最多的 Python 项目之一，使用的是 urllib3，继承了urllib2的所有特性。requests实现了 HTTP协议中绝大部分功能，它提供的功能包括 Keep-Alive、连接池、Cookie持久化、内容自动解压、HTTP代理、SSL认证、连接超时、Session等很多特性，最重要的是它同时兼容 python2 和 python3。&lt;/p&gt;
&lt;p&gt;同时，Requests对于HEAD, POST, PUT, PATCH, 和 DELETE方法的api同样简单。它可以处理多部分上传，同样支持自动转码，文档更好，还有更多的特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;值得注意的是，网络上有种言论是因为requests不支持异步，所以不推荐使用，但是随着 Python 语言本身的发展，现在已经可以很方便的将&lt;code&gt;requests&lt;/code&gt;转为异步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;查看所安装-Requests-的版本&quot;&gt;&lt;a href=&quot;#查看所安装-Requests-的版本&quot; class=&quot;headerlink&quot; title=&quot;查看所安装 Requests 的版本&quot;&gt;&lt;/a&gt;查看所安装 Requests 的版本&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; requests&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;requests.__version__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;2.21.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;常用的-Requests-方法及说明&quot;&gt;&lt;a href=&quot;#常用的-Requests-方法及说明&quot; class=&quot;headerlink&quot; title=&quot;常用的 Requests 方法及说明&quot;&gt;&lt;/a&gt;常用的 Requests 方法及说明&lt;/h2&gt;&lt;h3 id=&quot;请求URL：GET&quot;&gt;&lt;a href=&quot;#请求URL：GET&quot; class=&quot;headerlink&quot; title=&quot;请求URL：GET&quot;&gt;&lt;/a&gt;请求URL：GET&lt;/h3&gt;&lt;p&gt;当我们导入requests模块之后就可以使用get命令来获取网页了，我们以自己的小专栏为例，测试一下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; requests&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;response = requests.get(&lt;span class=&quot;string&quot;&gt;&#39;https://xiaozhuanlan.com/python_mastery&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Python/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>你真的掌握变量和类型了吗（二）类型转换</title>
    <link href="http://yoursite.com/2019/09/08/2019-09-08-Programing-JavaScript-Type-conversion-Introduction-2/"/>
    <id>http://yoursite.com/2019/09/08/2019-09-08-Programing-JavaScript-Type-conversion-Introduction-2/</id>
    <published>2019-09-08T07:09:34.000Z</published>
    <updated>2019-11-25T07:31:33.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六、还有哪些引用类型"><a href="#六、还有哪些引用类型" class="headerlink" title="六、还有哪些引用类型"></a>六、还有哪些引用类型</h2><blockquote><p>在<code>ECMAScript</code>中，引用类型是一种数据结构，用于将数据和功能组织在一起。</p></blockquote><p>我们通常所说的对象，就是某个特定引用类型的实例。</p><p>在<code>ECMAScript</code>关于类型的定义中，只给出了<code>Object</code>类型，实际上，我们平时使用的很多引用类型的变量，并不是由<code>Object</code>构造的，但是它们原型链的终点都是<code>Object</code>，这些类型都属于引用类型。</p><ul><li><code>Array</code> 数组</li><li><code>Date</code> 日期</li><li><code>RegExp</code> 正则</li><li><code>Function</code> 函数</li></ul><h3 id="6-1-包装类型"><a href="#6-1-包装类型" class="headerlink" title="6.1 包装类型"></a>6.1 包装类型</h3><p>为了便于操作基本类型值，<code>ECMAScript</code>还提供了几个特殊的引用类型，他们是基本类型的包装类型：</p><ul><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code></li></ul><p>注意包装类型和原始类型的区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> === <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"><span class="number">123</span> === <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// false</span></span><br><span class="line"><span class="string">"ConardLi"</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"ConardLi"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"ConardLi"</span>)); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"ConardLi"</span>); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><blockquote><p>引用类型和包装类型的主要区别就是对象的生存期，使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"ConardLi"</span>;</span><br><span class="line">name.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.color); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="6-2-装箱和拆箱"><a href="#6-2-装箱和拆箱" class="headerlink" title="6.2 装箱和拆箱"></a>6.2 装箱和拆箱</h3><ul><li><p>装箱转换：把基本类型转换为对应的包装类型</p></li><li><p>拆箱操作：把引用类型转换为基本类型</p></li></ul><p>既然原始类型不能扩展属性和方法，那么我们是如何使用原始类型调用方法的呢？</p><p>每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而让我们能够调用一些方法和属性，例如下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"ConardLi"</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = name.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>实际上发生了以下几个过程：</p><ul><li>创建一个<code>String</code>的包装类型实例</li><li>在实例上调用<code>substring</code>方法</li><li>销毁实例</li></ul><p>也就是说，我们使用基本类型调用方法，就会自动进行装箱和拆箱操作，相同的，我们使用<code>Number</code>和<code>Boolean</code>类型时，也会发生这个过程。</p><p>从引用类型到基本类型的转换，也就是拆箱的过程中，会遵循<code>ECMAScript规范</code>规定的<code>toPrimitive</code>原则，一般会调用引用类型的<code>valueOf</code>和<code>toString</code>方法，你也可以直接重写<code>toPeimitive</code>方法。一般转换成不同类型的值遵循的原则不同，例如：</p><ul><li>引用类型转换为<code>Number</code>类型，先调用<code>valueOf</code>，再调用<code>toString</code></li><li>引用类型转换为<code>String</code>类型，先调用<code>toString</code>，再调用<code>valueOf</code></li></ul><p>若<code>valueOf</code>和<code>toString</code>都不存在，或者没有返回基本类型，则抛出<code>TypeError</code>异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"valueOf"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"toString"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ConardLi"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj - <span class="number">1</span>); <span class="comment">// valueOf   122</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj&#125;</span>ConardLi`</span>); <span class="comment">// toString  ConardLiConardLi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"toPrimitive"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj2 - <span class="number">1</span>); <span class="comment">// valueOf   122</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"valueOf"</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"toString"</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj3 - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// valueOf</span></span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>除了程序中的自动拆箱和自动装箱，我们还可以手动进行拆箱和装箱操作。我们可以直接调用包装类型的<code>valueOf</code>或<code>toString</code>，实现拆箱操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"123"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num.valueOf()); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num.toString()); <span class="comment">//string</span></span><br></pre></td></tr></table></figure><h2 id="七、类型转换"><a href="#七、类型转换" class="headerlink" title="七、类型转换"></a>七、类型转换</h2><p>因为<code>JavaScript</code>是弱类型的语言，所以类型转换发生非常频繁，上面我们说的装箱和拆箱其实就是一种类型转换。</p><p>类型转换分为两种，隐式转换即程序自动进行的类型转换，强制转换即我们手动进行的类型转换。</p><p>强制转换这里就不再多提及了，下面我们来看看让人头疼的可能发生隐式类型转换的几个场景，以及如何转换：</p><h3 id="7-1-类型转换规则"><a href="#7-1-类型转换规则" class="headerlink" title="7.1 类型转换规则"></a>7.1 类型转换规则</h3><p>如果发生了隐式转换，那么各种类型互转符合下面的规则：</p><p><img src="http://www.conardli.top/img/bl/bl_8_convert.png" alt></p><h3 id="7-2-if-语句和逻辑语句"><a href="#7-2-if-语句和逻辑语句" class="headerlink" title="7.2 if 语句和逻辑语句"></a>7.2 if 语句和逻辑语句</h3><p>在<code>if</code>语句和逻辑语句中，如果只有单个变量，会先将变量转换为<code>Boolean</code>值，只有下面几种情况会转换成<code>false</code>，其余被转换成<code>true</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>;</span><br><span class="line"><span class="literal">undefined</span>;</span><br><span class="line">(<span class="string">""</span>);</span><br><span class="line"><span class="literal">NaN</span>;</span><br><span class="line"><span class="number">0</span>;</span><br><span class="line"><span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="7-3-各种运数学算符"><a href="#7-3-各种运数学算符" class="headerlink" title="7.3 各种运数学算符"></a>7.3 各种运数学算符</h3><p>我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="literal">true</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span> - <span class="literal">null</span>; <span class="comment">//  1</span></span><br><span class="line"><span class="number">1</span> * <span class="literal">undefined</span>; <span class="comment">//  NaN</span></span><br><span class="line"><span class="number">2</span> * [<span class="string">"5"</span>]; <span class="comment">//  10</span></span><br></pre></td></tr></table></figure><p>注意<code>+</code>是个例外，执行<code>+</code>操作符时：</p><ul><li>1.当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li><li>2.当一侧为<code>Number</code>类型，另一侧为原始类型，则将原始类型转换为<code>Number</code>类型。</li><li>3.当一侧为<code>Number</code>类型，另一侧为引用类型，将引用类型和<code>Number</code>类型转换成字符串后拼接。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> + <span class="string">"123"</span>; <span class="comment">// 123123   （规则1）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">null</span>; <span class="comment">// 123    （规则2）</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">true</span>; <span class="comment">// 124    （规则2）</span></span><br><span class="line"><span class="number">123</span> + &#123;&#125;; <span class="comment">// 123[object Object]    （规则3）</span></span><br></pre></td></tr></table></figure><h3 id="7-4"><a href="#7-4" class="headerlink" title="7.4 =="></a>7.4 ==</h3><p>使用<code>==</code>时，若两侧类型相同，则比较结果和<code>===</code>相同，否则会发生隐式转换，使用<code>==</code>时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：</p><ul><li><strong>1.NaN</strong></li></ul><p><code>NaN</code>和其他任何类型比较永远返回<code>false</code>(包括和他自己)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><strong>2.Boolean</strong></li></ul><p><code>Boolean</code>和其他任何类型比较，<code>Boolean</code>首先被转换为<code>Number</code>类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">"2"</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">"1"</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == [<span class="string">"2"</span>]; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>这里注意一个可能会弄混的点：<code>undefined、null</code>和<code>Boolean</code>比较，虽然<code>undefined、null</code>和<code>false</code>都很容易被想象成假值，但是他们比较结果是<code>false</code>，原因是<code>false</code>首先被转换成<code>0</code>：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><strong>3.String 和 Number</strong></li></ul><p><code>String</code>和<code>Number</code>比较，先将<code>String</code>转换为<code>Number</code>类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> == <span class="string">"123"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == <span class="number">0</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>4.null 和 undefined</strong></li></ul><p><code>null == undefined</code>比较结果是<code>true</code>，除此之外，<code>null、undefined</code>和其他任何结果的比较值都为<code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="string">""</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="string">""</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><strong>5.原始类型和引用类型</strong></li></ul><p>当原始类型和引用类型做比较时，对象类型会依照<code>ToPrimitive</code>规则转换为原始类型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"[object Object]"</span> == &#123;&#125;; <span class="comment">// true</span></span><br><span class="line"><span class="string">"1,2,3"</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>来看看下面这个比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] == ![]; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>!</code>的优先级高于<code>==</code>，<code>![]</code>首先会被转换为<code>false</code>，然后根据上面第三点，<code>false</code>转换成<code>Number</code>类型<code>0</code>，左侧<code>[]</code>转换为<code>0</code>，两侧比较相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([<span class="literal">null</span>] ==</span><br><span class="line">  <span class="literal">false</span>[<span class="literal">undefined</span>]) == <span class="comment">// true</span></span><br><span class="line">  <span class="literal">false</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>根据数组的<code>ToPrimitive</code>规则，数组元素为<code>null</code>或<code>undefined</code>时，该元素被当做空字符串处理，所以<code>[null]、[undefined]</code>都会被转换为<code>0</code>。</p><p>所以，说了这么多，推荐使用<code>===</code>来判断两个值是否相等…</p><h3 id="7-5-一道有意思的面试题"><a href="#7-5-一道有意思的面试题" class="headerlink" title="7.5 一道有意思的面试题"></a>7.5 一道有意思的面试题</h3><p>一道经典的面试题，如何让：<code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code>。</p><p>根据上面的拆箱转换，以及<code>==</code>的隐式转换，我们可以轻松写出答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  value: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="八、判断-JavaScript-数据类型的方式"><a href="#八、判断-JavaScript-数据类型的方式" class="headerlink" title="八、判断 JavaScript 数据类型的方式"></a>八、判断 JavaScript 数据类型的方式</h2><h3 id="8-1-typeof"><a href="#8-1-typeof" class="headerlink" title="8.1 typeof"></a>8.1 typeof</h3><p><strong>适用场景</strong></p><p><code>typeof</code>操作符可以准确判断一个变量是否为下面几个原始类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">"ConardLi"</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>你还可以用它来判断函数类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// function</span></span><br></pre></td></tr></table></figure><p><strong>不适用场景</strong></p><p>当你用<code>typeof</code>来判断引用类型时似乎显得有些乏力了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> /^\d*$/; <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>除函数外所有的引用类型都会被判定为<code>object</code>。</p><p>另外<code>typeof null === &#39;object&#39;</code>也会让人感到头痛，这是在<code>JavaScript</code>初版就流传下来的<code>bug</code>，后面由于修改会造成大量的兼容问题就一直没有被修复…</p><h3 id="8-2-instanceof"><a href="#8-2-instanceof" class="headerlink" title="8.2 instanceof"></a>8.2 instanceof</h3><p><code>instanceof</code>操作符可以帮助我们判断引用类型具体是什么类型的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>() <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们先来回顾下原型链的几条规则：</p><ul><li>1.所有引用类型都具有对象特性，即可以自由扩展属性</li><li>2.所有引用类型都具有一个<code>__proto__</code>（隐式原型）属性，是一个普通对象</li><li>3.所有的函数都具有<code>prototype</code>（显式原型）属性，也是一个普通对象</li><li>4.所有引用类型<code>__proto__</code>值指向它构造函数的<code>prototype</code></li><li>5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的<code>__proto__</code>中去找</li></ul><p><code>[] instanceof Array</code>实际上是判断<code>Array.prototype</code>是否在<code>[]</code>的原型链上。</p><p>所以，使用<code>instanceof</code>来检测数据类型，不会很准确，这不是它设计的初衷：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>另外，使用<code>instanceof</code>也不能检测基本数据类型，所以<code>instanceof</code>并不是一个很好的选择。</p><h3 id="8-3-toString"><a href="#8-3-toString" class="headerlink" title="8.3 toString"></a>8.3 toString</h3><p>上面我们在拆箱操作中提到了<code>toString</code>函数，我们可以调用它实现从引用类型的转换。</p><blockquote><p>每一个引用类型都有<code>toString</code>方法，默认情况下，<code>toString()</code>方法被每个<code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，<code>toString()</code> 返回 <code>&quot;[object type]&quot;</code>，其中<code>type</code>是对象的类型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.toString(); <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure><p>注意，上面提到了<code>如果此方法在自定义对象中未被覆盖</code>，<code>toString</code>才会达到预想的效果，事实上，大部分引用类型比如<code>Array、Date、RegExp</code>等都重写了<code>toString</code>方法。</p><p>我们可以直接调用<code>Object</code>原型上未被覆盖的<code>toString()</code>方法，使用<code>call</code>来改变<code>this</code>指向来达到我们想要的效果。</p><p><img src="http://www.conardli.top/img/bl/bl_9_jc.png" alt></p><h3 id="8-4-jquery"><a href="#8-4-jquery" class="headerlink" title="8.4 jquery"></a>8.4 jquery</h3><p>我们来看看<code>jquery</code>源码中如何进行类型判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> class2type = &#123;&#125;;</span><br><span class="line">jQuery.each( <span class="string">"Boolean Number String Function Array Date RegExp Object Error Symbol"</span>.split( <span class="string">" "</span> ),</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"> i, name </span>) </span>&#123;</span><br><span class="line">class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase();</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">type: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( obj == <span class="literal">null</span> ) &#123;</span><br><span class="line"><span class="keyword">return</span> obj + <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"object"</span> || <span class="keyword">typeof</span> obj === <span class="string">"function"</span> ?</span><br><span class="line">class2type[<span class="built_in">Object</span>.prototype.toString.call(obj) ] || <span class="string">"object"</span> :</span><br><span class="line"><span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isFunction: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> jQuery.type(obj) === <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始类型直接使用<code>typeof</code>，引用类型使用<code>Object.prototype.toString.call</code>取得类型，借助一个<code>class2type</code>对象将字符串多余的代码过滤掉，例如<code>[object function]</code>将得到<code>array</code>，然后在后面的类型判断，如<code>isFunction</code>直接可以使用<code>jQuery.type(obj) === &quot;function&quot;</code>这样的判断。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ecma-international.org/ecma-262/9.0/index.html" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/9.0/index.html</a></li><li><a href="https://while.dev/articles/explaining-truthy-falsy-null-0-and-undefined-in-typescript/" target="_blank" rel="noopener">https://while.dev/articles/explaining-truthy-falsy-null-0-and-undefined-in-typescript/</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/28</a></li><li><a href="https://juejin.im/post/5bc5c752f265da0a9a399a62" target="_blank" rel="noopener">https://juejin.im/post/5bc5c752f265da0a9a399a62</a></li><li><a href="https://juejin.im/post/5bbda2b36fb9a05cfd27f55e" target="_blank" rel="noopener">https://juejin.im/post/5bbda2b36fb9a05cfd27f55e</a></li><li>《JS 高级程序设计》</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p><ul><li>了解<code>JavaScript</code>中的变量在内存中的具体存储形式，可对应实际场景</li><li>搞懂小数计算不精确的底层原因</li><li>了解可能发生隐式类型转换的场景以及转换原则</li><li>掌握判断<code>JavaScript</code>数据类型的方式和底层原理</li></ul><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;六、还有哪些引用类型&quot;&gt;&lt;a href=&quot;#六、还有哪些引用类型&quot; class=&quot;headerlink&quot; title=&quot;六、还有哪些引用类型&quot;&gt;&lt;/a&gt;六、还有哪些引用类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在&lt;code&gt;ECMAScript&lt;/code&gt;中
      
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>你真的掌握变量和类型了吗（一）数据类型</title>
    <link href="http://yoursite.com/2019/09/03/2019-09-03-Programing-JavaScript-Type-conversion-Introduction-1/"/>
    <id>http://yoursite.com/2019/09/03/2019-09-03-Programing-JavaScript-Type-conversion-Introduction-1/</id>
    <published>2019-09-03T07:06:26.000Z</published>
    <updated>2019-11-25T07:09:14.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>变量和类型是学习<code>JavaScript</code>最先接触到的东西，但是往往看起来最简单的东西往往还隐藏着很多你不了解、或者容易犯错的知识，比如下面几个问题：</p><ul><li><code>JavaScript</code>中的变量在内存中的具体存储形式是什么？</li><li><code>0.1+0.2</code>为什么不等于<code>0.3</code>?发生小数计算错误的具体原因是什么？</li><li><code>Symbol</code>的特点，以及实际应用场景是什么？</li><li><code>[] == ![]</code>、<code>[undefined] == false</code>为什么等于<code>true</code>?代码中何时会发生隐式类型转换？转换的规则是什么？</li><li>如何精确的判断变量的类型？</li></ul><p>如果你还不能很好的解答上面的问题，那说明你还没有完全掌握这部分的知识，那么请好好阅读下面的文章吧。</p><p>本文从底层原理到实际应用详细介绍了<code>JavaScript</code>中的变量和类型相关知识。</p><h2 id="一、JavaScript数据类型"><a href="#一、JavaScript数据类型" class="headerlink" title="一、JavaScript数据类型"></a>一、JavaScript数据类型</h2><p><a href="http://www.ecma-international.org/ecma-262/9.0/index.html" target="_blank" rel="noopener">ECMAScript标准</a>规定了<code>7</code>种数据类型，其把这<code>7</code>种数据类型又分为两种：原始类型和对象类型。</p><p><strong>原始类型</strong></p><ul><li><code>Null</code>：只包含一个值：<code>null</code></li><li><code>Undefined</code>：只包含一个值：<code>undefined</code></li><li><code>Boolean</code>：包含两个值：<code>true</code>和<code>false</code></li><li><code>Number</code>：整数或浮点数，还有一些特殊值（<code>-Infinity</code>、<code>+Infinity</code>、<code>NaN</code>）</li><li><code>String</code>：一串表示文本值的字符序列</li><li><code>Symbol</code>：一种实例是唯一且不可改变的数据类型</li></ul><p>(在<code>es10</code>中加入了第七种原始类型<code>BigInt</code>，现已被最新<code>Chrome</code>支持)</p><p><strong>对象类型</strong></p><ul><li><code>Object</code>：自己分一类丝毫不过分，除了常用的<code>Object</code>，<code>Array</code>、<code>Function</code>等都属于特殊的对象</li></ul><h2 id="二、为什么区分原始类型和对象类型"><a href="#二、为什么区分原始类型和对象类型" class="headerlink" title="二、为什么区分原始类型和对象类型"></a>二、为什么区分原始类型和对象类型</h2><h3 id="2-1-不可变性"><a href="#2-1-不可变性" class="headerlink" title="2.1 不可变性"></a>2.1 不可变性</h3><p>上面所提到的原始类型，在<code>ECMAScript</code>标准中，它们被定义为<code>primitive values</code>，即原始值，代表值本身是不可被改变的。</p><p>以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'ConardLi'</span>;</span><br><span class="line">str.slice(<span class="number">1</span>);</span><br><span class="line">str.substr(<span class="number">1</span>);</span><br><span class="line">str.trim(<span class="number">1</span>);</span><br><span class="line">str.toLowerCase(<span class="number">1</span>);</span><br><span class="line">str[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// ConardLi</span></span><br></pre></td></tr></table></figure><p>在上面的代码中我们对<code>str</code>调用了几个方法，无一例外，这些方法都在原字符串的基础上产生了一个新字符串，而非直接去改变<code>str</code>，这就印证了字符串的不可变性。</p><p>那么，当我们继续调用下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str += <span class="string">'6'</span></span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// ConardLi6</span></span><br></pre></td></tr></table></figure><p>你会发现，<code>str</code>的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解：</p><p>在<code>JavaScript</code>中，每一个变量在内存中都需要一个空间来存储。</p><p>内存空间又被分为两种，栈内存与堆内存。</p><a id="more"></a><p>栈内存：</p><ul><li>存储的值大小固定</li><li>空间较小</li><li>可以直接操作其保存的变量，运行效率高</li><li>由系统自动分配存储空间</li></ul><p><code>JavaScript</code>中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。</p><p><img src="http://www.conardli.top/img/bl/bl_1_stack.png" alt></p><p>由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的。</p><p>在上面的代码中，我们执行了<code>str += &#39;6&#39;</code>的操作，实际上是在栈中又开辟了一块内存空间用于存储<code>&#39;ConardLi6&#39;</code>，然后将变量<code>str</code>指向这块空间，所以这并不违背<code>不可变性的</code>特点。</p><p><img src="http://www.conardli.top/img/bl/bl_2_stack.png" alt></p><h3 id="2-2-引用类型"><a href="#2-2-引用类型" class="headerlink" title="2.2 引用类型"></a>2.2 引用类型</h3><p>堆内存：</p><ul><li>存储的值大小不定，可动态调整</li><li>空间较大，运行效率低</li><li>无法直接操作其内部存储，使用引用地址读取</li><li>通过代码进行分配空间</li></ul><p>相对于上面具有不可变性的原始类型，我习惯把对象称为引用类型，引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"ConardLi"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> obj4 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><img src="http://www.conardli.top/img/bl/bl_3_heap.png" alt></p><blockquote><p>由于内存是有限的，这些变量不可能一直在内存中占用资源，这里推荐下这篇文章<a href="https://juejin.im/post/5cb33660e51d456e811d2687" target="_blank" rel="noopener">JavaScript中的垃圾回收和内存泄漏</a>，这里告诉你<code>JavaScript</code>是如何进行垃圾回收以及可能会发生内存泄漏的一些场景。</p></blockquote><p>当然，引用类型就不再具有<code>不可变性</code>了，我们可以轻易的改变它们： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj1.name = <span class="string">"ConardLi6"</span>;</span><br><span class="line">obj2.age = <span class="number">19</span>;</span><br><span class="line">obj4.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name:"ConardLi6"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age:19&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>以数组为例，它的很多方法都可以改变它自身。</p><ul><li><code>pop()</code> 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素</li><li><code>push()</code>向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>shift()</code>把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值</li><li><code>unshift()</code>向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>reverse()</code>颠倒数组中元素的顺序，改变原数组，返回该数组</li><li><code>sort()</code>对数组元素进行排序，改变原数组，返回该数组</li><li><code>splice()</code>从数组中添加/删除项目，改变原数组，返回被删除的元素</li></ul><p>下面我们通过几个操作来对比一下原始类型和引用类型的区别：</p><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><p>当我们把一个变量的值复制到另一个变量上时，原始类型和引用类型的表现是不一样的，先来看看原始类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = name;</span><br><span class="line">name2 = <span class="string">'code秘密花园'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// ConardLi;</span></span><br></pre></td></tr></table></figure><p><img src="http://www.conardli.top/img/bl/bl_4_copy.png" alt></p><p>内存中有一个变量<code>name</code>，值为<code>ConardLi</code>。我们从变量<code>name</code>复制出一个变量<code>name2</code>，此时在内存中创建了一个块新的空间用于存储<code>ConardLi</code>，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。</p><p>复制一个引用类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj;</span><br><span class="line">obj2.name = <span class="string">'code秘密花园'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// code秘密花园</span></span><br></pre></td></tr></table></figure><p><img src="http://www.conardli.top/img/bl/bl_5_copy.png" alt></p><p>当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的<code>obj2</code>实际上和<code>obj</code>指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。</p><h3 id="2-4-比较"><a href="#2-4-比较" class="headerlink" title="2.4 比较"></a>2.4 比较</h3><p>当我们在对两个变量进行比较时，不同类型的变量的表现是不同的：</p><p><img src="http://www.conardli.top/img/bl/bl_6_compare.png" alt></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name === name2); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj === obj2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>对于原始类型，比较时会直接比较它们的值，如果值相等，即返回<code>true</code>。</p><p>对于引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为<code>false</code>。</p><h3 id="2-5-值传递和引用传递"><a href="#2-5-值传递和引用传递" class="headerlink" title="2.5 值传递和引用传递"></a>2.5 值传递和引用传递</h3><p>借助下面的例子，我们先来看一看什么是值传递，什么是引用传递：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'ConardLi'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  name = <span class="string">'code秘密花园'</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(name);</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><p>执行上面的代码，如果最终打印出来的<code>name</code>是<code>&#39;ConardLi&#39;</code>，没有改变，说明函数参数传递的是变量的值，即值传递。如果最终打印的是<code>&#39;code秘密花园&#39;</code>，函数内部的操作可以改变传入的变量，那么说明函数参数传递的是引用，即引用传递。</p><p>很明显，上面的执行结果是<code>&#39;ConardLi&#39;</code>，即函数参数仅仅是被传入变量复制给了的一个局部变量，改变这个局部变量不会对外部变量产生影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">'code秘密花园'</span>;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// code秘密花园</span></span><br></pre></td></tr></table></figure><p>上面的代码可能让你产生疑惑，是不是参数是引用类型就是引用传递呢？</p><p>首先明确一点，<code>ECMAScript</code>中所有的函数的参数都是按值传递的。</p><p>同样的，当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递，下面我们再按一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">'ConardLi'</span>;</span><br><span class="line">  obj = &#123;<span class="attr">name</span>:<span class="string">'code秘密花园'</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">changeValue(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// ConardLi</span></span><br></pre></td></tr></table></figure><p>可见，函数参数传递的并不是变量的<code>引用</code>，而是变量拷贝的副本，当变量是原始类型时，这个副本就是值本身，当变量是引用类型时，这个副本是指向堆内存的地址。所以，再次记住：</p><blockquote><p><code>ECMAScript</code>中所有的函数的参数都是按值传递的。</p></blockquote><h2 id="三、分不清的null和undefined"><a href="#三、分不清的null和undefined" class="headerlink" title="三、分不清的null和undefined"></a>三、分不清的null和undefined</h2><p><img src="http://www.conardli.top/img/bl/bl_7_null.png" alt></p><p>在原始类型中，有两个类型<code>Null</code>和<code>Undefined</code>，他们都有且仅有一个值，<code>null</code>和<code>undefined</code>，并且他们都代表无和空，我一般这样区分它们：</p><p><strong>null</strong></p><p>表示被赋值过的对象，刻意把一个对象赋值为<code>null</code>，故意表示其为空，不应有值。</p><p>所以对象的某个属性值为<code>null</code>是正常的，<code>null</code>转换为数值时值为<code>0</code>。</p><p><strong>undefined</strong> </p><p>表示“缺少值”，即此处应有一个值，但还没有定义，</p><p>如果一个对象的某个属性值为<code>undefined</code>，这是不正常的，如<code>obj.name=undefined</code>，我们不应该这样写，应该直接<code>delete obj.name</code>。</p><p><code>undefined</code>转为数值时为<code>NaN</code>(非数字值的特殊值)</p><p><code>JavaScript</code>是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是<code>undefined</code>的意义所在。对于<code>JAVA</code>这种强类型语言，如果有<code>&quot;undefined&quot;</code>这种情况，就会直接编译失败，所以在它不需要一个这样的类型。</p><h2 id="四、不太熟的Symbol类型"><a href="#四、不太熟的Symbol类型" class="headerlink" title="四、不太熟的Symbol类型"></a>四、不太熟的Symbol类型</h2><p><code>Symbol</code>类型是<code>ES6</code>中新加入的一种原始类型。</p><blockquote><p>每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。</p></blockquote><p>下面来看看<code>Symbol</code>类型具有哪些特性。</p><h3 id="4-1-Symbol的特性"><a href="#4-1-Symbol的特性" class="headerlink" title="4.1 Symbol的特性"></a>4.1 Symbol的特性</h3><p><strong>1.独一无二</strong></p><p>直接使用<code>Symbol()</code>创建新的<code>symbol</code>变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的<code>toString()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>();  <span class="comment">// Symbol() </span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym4 = <span class="built_in">Symbol</span>(&#123;<span class="attr">name</span>:<span class="string">'ConardLi'</span>&#125;); <span class="comment">// Symbol([object Object])</span></span><br><span class="line"><span class="built_in">console</span>.log(sym2 === sym3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>我们用两个相同的字符串创建两个<code>Symbol</code>变量，它们是不相等的，可见每个<code>Symbol</code>变量都是独一无二的。</p><p>如果我们想创造两个相等的<code>Symbol</code>变量，可以使用<code>Symbol.for(key)</code>。</p><blockquote><p>使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>.for(<span class="string">'ConardLi'</span>);</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">'ConardLi'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym1 === sym2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>2.原始类型</strong></p><p>注意是使用<code>Symbol()</code>函数创建<code>symbol</code>变量，并非使用构造函数，使用<code>new</code>操作符会直接报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// Uncaught TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><p>我们可以使用<code>typeof</code>运算符判断一个<code>Symbol</code>类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'ConardLi'</span>) === <span class="string">'symbol'</span></span><br></pre></td></tr></table></figure><p><strong>3.不可枚举</strong></p><p>当使用<code>Symbol</code>作为对象属性时，可以保证对象不会出现重名属性，调用<code>for...in</code>不能将其枚举出来，另外调用<code>Object.getOwnPropertyNames、Object.keys()</code>也不能获取<code>Symbol</code>属性。</p><blockquote><p>可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name:<span class="string">'ConardLi'</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'name2'</span>)]:<span class="string">'code秘密花园'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj); <span class="comment">// ["name"]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">// ["name"]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [Symbol(name)]</span></span><br></pre></td></tr></table></figure><h3 id="4-2-Symbol的应用场景"><a href="#4-2-Symbol的应用场景" class="headerlink" title="4.2 Symbol的应用场景"></a>4.2 Symbol的应用场景</h3><p>下面是几个<code>Symbol</code>在程序中的应用场景。</p><p><strong>应用一：防止XSS</strong></p><p>在<code>React</code>的<code>ReactElement</code>对象中，有一个<code>$$typeof</code>属性，它是一个<code>Symbol</code>类型的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> REACT_ELEMENT_TYPE =</span><br><span class="line">  (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">'function'</span> &amp;&amp; <span class="built_in">Symbol</span>.for &amp;&amp; <span class="built_in">Symbol</span>.for(<span class="string">'react.element'</span>)) ||</span><br><span class="line">  <span class="number">0xeac7</span>;</span><br></pre></td></tr></table></figure><p><code>ReactElement.isValidElement</code>函数用来判断一个React组件是否是有效的，下面是它的具体实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object === <span class="string">'object'</span> &amp;&amp; object !== <span class="literal">null</span> &amp;&amp; object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可见<code>React</code>渲染时会把没有<code>$$typeof</code>标识，以及规则校验不通过的组件过滤掉。</p><p>如果你的服务器有一个漏洞，允许用户存储任意<code>JSON</code>对象， 而客户端代码需要一个字符串，这可能会成为一个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON</span></span><br><span class="line"><span class="keyword">let</span> expectedTextButGotJSON = &#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    dangerouslySetInnerHTML: &#123;</span><br><span class="line">      __html: <span class="string">'/* put your exploit here */'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> message = &#123; <span class="attr">text</span>: expectedTextButGotJSON &#125;;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  &#123;message.text&#125;</span><br><span class="line">&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure><p>而<code>JSON</code>中不能存储<code>Symbol</code>类型的变量，这就是防止<code>XSS</code>的一种手段。</p><p><strong>应用二：私有属性</strong></p><p>借助<code>Symbol</code>类型的不可枚举，我们可以在类中模拟私有属性，控制变量读写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateField = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>[privateField] = <span class="string">'ConardLi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  getField()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[privateField];</span><br><span class="line">  &#125;</span><br><span class="line">  setField(val)&#123;</span><br><span class="line">    <span class="keyword">this</span>[privateField] = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用三：防止属性污染</strong></p><p>在某些情况下，我们可能要为对象添加一个属性，此时就有可能造成属性覆盖，用<code>Symbol</code>作为对象属性可以保证永远不会出现同名属性。</p><p>例如下面的场景，我们模拟实现一个<code>call</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> result = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在某个对象上临时调用一个方法，又不能造成属性污染，<code>Symbol</code>是一个很好的选择。</p><h2 id="五、不老实的Number类型"><a href="#五、不老实的Number类型" class="headerlink" title="五、不老实的Number类型"></a>五、不老实的Number类型</h2><p>为什么说<code>Number</code>类型不老实呢，相信大家都多多少少的在开发中遇到过小数计算不精确的问题，比如<code>0.1+0.2!==0.3</code>，下面我们来追本溯源，看看为什么会出现这种现象，以及该如何避免。</p><p>下面是我实现的一个简单的函数，用于判断两个小数进行加法运算是否精确：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeFloat</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> binaryN = n.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> binaryM = m.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>的二进制是    <span class="subst">$&#123;binaryN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;m&#125;</span>的二进制是    <span class="subst">$&#123;binaryM&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> MN = m + n;</span><br><span class="line">  <span class="keyword">const</span> accuracyMN = (m * <span class="number">100</span> + n * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> binaryMN = MN.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> accuracyBinaryMN = accuracyMN.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制是<span class="subst">$&#123;binaryMN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是    <span class="subst">$&#123;accuracyBinaryMN&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制再转成十进制是<span class="subst">$&#123;to10(binaryMN)&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是再转成十进制是<span class="subst">$&#123;to10(accuracyBinaryMN)&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>在js中计算是<span class="subst">$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? <span class="string">''</span> : <span class="string">'不'</span>&#125;</span>准确的`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">to10</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pre = (n.split(<span class="string">'.'</span>)[<span class="number">0</span>] - <span class="number">0</span>).toString(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> arr = n.split(<span class="string">'.'</span>)[<span class="number">1</span>].split(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr.length) &#123;</span><br><span class="line">    result += arr[i] * <span class="built_in">Math</span>.pow(<span class="number">2</span>, -(i + <span class="number">1</span>));</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">judgeFloat(<span class="number">0.1</span>, <span class="number">0.2</span>);</span><br><span class="line">judgeFloat(<span class="number">0.6</span>, <span class="number">0.7</span>);</span><br></pre></td></tr></table></figure><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制3.png" alt="image"></p><h3 id="5-1-精度丢失"><a href="#5-1-精度丢失" class="headerlink" title="5.1 精度丢失"></a>5.1 精度丢失</h3><p>计算机中所有的数据都是以<code>二进制</code>存储的，所以在计算时计算机要把数据先转换成<code>二进制</code>进行计算，然后在把计算结果转换成<code>十进制</code>。</p><p>由上面的代码不难看出，在计算<code>0.1+0.2</code>时，<code>二进制</code>计算发生了精度丢失，导致再转换成<code>十进制</code>后和预计的结果不符。</p><h3 id="5-2-对结果的分析—更多的问题"><a href="#5-2-对结果的分析—更多的问题" class="headerlink" title="5.2 对结果的分析—更多的问题"></a>5.2 对结果的分析—更多的问题</h3><p><code>0.1</code>和<code>0.2</code>的二进制都是以1100无限循环的小数，下面逐个来看JS帮我们计算所得的结果：</p><p><strong>0.1的二进制</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure><p><strong>0.2的二进制</strong>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure></p><p><strong>理论上讲，由上面的结果相加应该：</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001100111</span></span><br></pre></td></tr></table></figure><p><strong>实际JS计算得到的0.1+0.2的二进制</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure><p>看到这里你可能会产生更多的问题：</p><blockquote><p>为什么 js计算出的 0.1的二进制 是这么多位而不是更多位？？？</p><p>为什么 js计算的（0.1+0.2）的二进制和我们自己计算的（0.1+0.2）的二进制结果不一样呢？？？</p><p>为什么 0.1的二进制 + 0.2的二进制 != 0.3的二进制？？？</p></blockquote><h3 id="5-3-js对二进制小数的存储方式"><a href="#5-3-js对二进制小数的存储方式" class="headerlink" title="5.3 js对二进制小数的存储方式"></a>5.3 js对二进制小数的存储方式</h3><p>小数的<code>二进制</code>大多数都是无限循环的，<code>JavaScript</code>是怎么来存储他们的呢？</p><p>在<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.19" target="_blank" rel="noopener">ECMAScript®语言规范</a>中可以看到，<code>ECMAScript</code>中的<code>Number</code>类型遵循<code>IEEE 754</code>标准。使用64位固定长度来表示。</p><p>事实上有很多语言的数字类型都遵循这个标准，例如<code>JAVA</code>,所以很多语言同样有着上面同样的问题。</p><p>所以下次遇到这种问题不要上来就喷<code>JavaScript</code>…</p><p>有兴趣可以看看下这个网站<a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">http://0.30000000000000004.com/</a>，是的，你没看错，就是<a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">http://0.30000000000000004.com/</a>！！！</p><h3 id="5-4-IEEE-754"><a href="#5-4-IEEE-754" class="headerlink" title="5.4 IEEE 754"></a>5.4 IEEE 754</h3><p><code>IEEE754</code>标准包含一组实数的二进制表示法。它有三部分组成：</p><ul><li><p>符号位</p></li><li><p>指数位</p></li><li><p>尾数位</p></li></ul><p>三种精度的浮点数各个部分位数如下：</p><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制1.png" alt="image"></p><p><code>JavaScript</code>使用的是64位双精度浮点数编码，所以它的<code>符号位</code>占<code>1</code>位，指数位占<code>11</code>位，尾数位占<code>52</code>位。</p><p>下面我们在理解下什么是<code>符号位</code>、<code>指数位</code>、<code>尾数位</code>，以<code>0.1</code>为例：</p><p>它的二进制为：<code>0.0001100110011001100...</code></p><p>为了节省存储空间，在计算机中它是以科学计数法表示的，也就是</p><p><code>1.100110011001100...</code> X 2<sup>-4</sup></p><p>如果这里不好理解可以想一下十进制的数：</p><p><code>1100</code>的科学计数法为<code>11</code> X 10<sup>2</sup></p><p>所以：</p><p><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/二进制2.png" alt="image"></p><p><code>符号位</code>就是标识正负的，<code>1</code>表示<code>负</code>，<code>0</code>表示<code>正</code>；</p><p><code>指数位</code>存储科学计数法的指数；</p><p><code>尾数位</code>存储科学计数法后的有效数字；</p><p>所以我们通常看到的二进制，其实是计算机实际存储的尾数位。</p><h3 id="5-5-js中的toString-2"><a href="#5-5-js中的toString-2" class="headerlink" title="5.5 js中的toString(2)"></a>5.5 js中的toString(2)</h3><p>由于尾数位只能存储<code>52</code>个数字，这就能解释<code>toString(2)</code>的执行结果了：</p><p>如果计算机没有存储空间的限制，那么<code>0.1</code>的<code>二进制</code>应该是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span>...</span><br></pre></td></tr></table></figure><br>科学计数法尾数位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>...</span><br></pre></td></tr></table></figure><p>但是由于限制，有效数字第<code>53</code>位及以后的数字是不能存储的，它遵循，如果是<code>1</code>就向前一位进<code>1</code>，如果是<code>0</code>就舍弃的原则。</p><p>0.1的二进制科学计数法第53位是1，所以就有了下面的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure><p><code>0.2</code>有着同样的问题，其实正是由于这样的存储，在这里有了精度丢失，导致了<code>0.1+0.2!=0.3</code>。</p><p>事实上有着同样精度问题的计算还有很多，我们无法把他们都记下来，所以当程序中有数字计算时，我们最好用工具库来帮助我们解决，下面是两个推荐使用的开源库：</p><ul><li><a href="https://github.com/nefe/number-precision" target="_blank" rel="noopener">number-precision</a></li><li><a href="https://github.com/josdejong/mathjs/" target="_blank" rel="noopener">mathjs/</a></li></ul><h3 id="5-6-JavaScript能表示的最大数字"><a href="#5-6-JavaScript能表示的最大数字" class="headerlink" title="5.6 JavaScript能表示的最大数字"></a>5.6 JavaScript能表示的最大数字</h3><p>由与<code>IEEE 754</code>双精度64位规范的限制：</p><p><code>指数位</code>能表示的最大数字：<code>1023</code>(十进制)</p><p><code>尾数位</code>能表达的最大数字即尾数位都位<code>1</code>的情况</p><p>所以JavaScript能表示的最大数字即位</p><p><code>1.111...</code>X 2<sup>1023</sup> 这个结果转换成十进制是<code>1.7976931348623157e+308</code>,这个结果即为<code>Number.MAX_VALUE</code>。</p><h3 id="5-7-最大安全数字"><a href="#5-7-最大安全数字" class="headerlink" title="5.7 最大安全数字"></a>5.7 最大安全数字</h3><p>JavaScript中<code>Number.MAX_SAFE_INTEGER</code>表示最大安全数字,计算结果是<code>9007199254740991</code>，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是<code>1.111...</code>X 2<sup>52</sup>。</p><p>我们同样可以用一些开源库来处理大整数：</p><ul><li><a href="https://github.com/justmoon/node-bignum" target="_blank" rel="noopener">node-bignum</a></li><li><a href="https://github.com/substack/node-bigint" target="_blank" rel="noopener">node-bigint</a></li></ul><p>其实官方也考虑到了这个问题，<code>bigInt</code>类型在<code>es10</code>中被提出，现在<code>Chrome</code>中已经可以使用，使用<code>bigInt</code>可以操作超过最大安全数字的数字。</p><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;变量和类型是学习&lt;code&gt;JavaScript&lt;/code&gt;最先接触到的东西，但是往往看起来最简单的东西往往还隐藏着很多你不了解、或者容易犯错的知识，比如下面几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JavaScript&lt;/code&gt;中的变量在内存中的具体存储形式是什么？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0.1+0.2&lt;/code&gt;为什么不等于&lt;code&gt;0.3&lt;/code&gt;?发生小数计算错误的具体原因是什么？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Symbol&lt;/code&gt;的特点，以及实际应用场景是什么？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[] == ![]&lt;/code&gt;、&lt;code&gt;[undefined] == false&lt;/code&gt;为什么等于&lt;code&gt;true&lt;/code&gt;?代码中何时会发生隐式类型转换？转换的规则是什么？&lt;/li&gt;
&lt;li&gt;如何精确的判断变量的类型？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你还不能很好的解答上面的问题，那说明你还没有完全掌握这部分的知识，那么请好好阅读下面的文章吧。&lt;/p&gt;
&lt;p&gt;本文从底层原理到实际应用详细介绍了&lt;code&gt;JavaScript&lt;/code&gt;中的变量和类型相关知识。&lt;/p&gt;
&lt;h2 id=&quot;一、JavaScript数据类型&quot;&gt;&lt;a href=&quot;#一、JavaScript数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript数据类型&quot;&gt;&lt;/a&gt;一、JavaScript数据类型&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/9.0/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECMAScript标准&lt;/a&gt;规定了&lt;code&gt;7&lt;/code&gt;种数据类型，其把这&lt;code&gt;7&lt;/code&gt;种数据类型又分为两种：原始类型和对象类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原始类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Null&lt;/code&gt;：只包含一个值：&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Undefined&lt;/code&gt;：只包含一个值：&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Boolean&lt;/code&gt;：包含两个值：&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number&lt;/code&gt;：整数或浮点数，还有一些特殊值（&lt;code&gt;-Infinity&lt;/code&gt;、&lt;code&gt;+Infinity&lt;/code&gt;、&lt;code&gt;NaN&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt;：一串表示文本值的字符序列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Symbol&lt;/code&gt;：一种实例是唯一且不可改变的数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(在&lt;code&gt;es10&lt;/code&gt;中加入了第七种原始类型&lt;code&gt;BigInt&lt;/code&gt;，现已被最新&lt;code&gt;Chrome&lt;/code&gt;支持)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object&lt;/code&gt;：自己分一类丝毫不过分，除了常用的&lt;code&gt;Object&lt;/code&gt;，&lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Function&lt;/code&gt;等都属于特殊的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二、为什么区分原始类型和对象类型&quot;&gt;&lt;a href=&quot;#二、为什么区分原始类型和对象类型&quot; class=&quot;headerlink&quot; title=&quot;二、为什么区分原始类型和对象类型&quot;&gt;&lt;/a&gt;二、为什么区分原始类型和对象类型&lt;/h2&gt;&lt;h3 id=&quot;2-1-不可变性&quot;&gt;&lt;a href=&quot;#2-1-不可变性&quot; class=&quot;headerlink&quot; title=&quot;2.1 不可变性&quot;&gt;&lt;/a&gt;2.1 不可变性&lt;/h3&gt;&lt;p&gt;上面所提到的原始类型，在&lt;code&gt;ECMAScript&lt;/code&gt;标准中，它们被定义为&lt;code&gt;primitive values&lt;/code&gt;，即原始值，代表值本身是不可被改变的。&lt;/p&gt;
&lt;p&gt;以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&#39;ConardLi&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str.substr(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str.trim(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str.toLowerCase(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(str);  &lt;span class=&quot;comment&quot;&gt;// ConardLi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面的代码中我们对&lt;code&gt;str&lt;/code&gt;调用了几个方法，无一例外，这些方法都在原字符串的基础上产生了一个新字符串，而非直接去改变&lt;code&gt;str&lt;/code&gt;，这就印证了字符串的不可变性。&lt;/p&gt;
&lt;p&gt;那么，当我们继续调用下面的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;str += &lt;span class=&quot;string&quot;&gt;&#39;6&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(str);  &lt;span class=&quot;comment&quot;&gt;// ConardLi6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你会发现，&lt;code&gt;str&lt;/code&gt;的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;JavaScript&lt;/code&gt;中，每一个变量在内存中都需要一个空间来存储。&lt;/p&gt;
&lt;p&gt;内存空间又被分为两种，栈内存与堆内存。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>如何写出一个惊艳面试官的深拷贝</title>
    <link href="http://yoursite.com/2019/09/01/2019-09-01-Programing-JavaScript-How-to-Write-a-stunning-deep-copy-of-the-interviewer/"/>
    <id>http://yoursite.com/2019/09/01/2019-09-01-Programing-JavaScript-How-to-Write-a-stunning-deep-copy-of-the-interviewer/</id>
    <published>2019-09-01T06:59:01.000Z</published>
    <updated>2019-11-25T07:05:03.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>最近经常看到很多<code>JavaScript</code>手写代码的文章总结，里面提供了很多<code>JavaScript Api</code>的手写实现。</p><p>里面的题目实现大多类似，而且说实话很多代码在我看来是非常简陋的，如果我作为面试官，看到这样的代码，在我心里是不会合格的，本篇文章我拿最简单的深拷贝来讲一讲。</p><p>看本文之前先问自己三个问题：</p><ul><li><p>你真的理解什么是深拷贝吗？</p></li><li><p>在面试官眼里，什么样的深拷贝才算合格？</p></li><li><p>什么样的深拷贝能让面试官感到惊艳？</p></li></ul><p>本文由浅入深，带你一步一步实现一个惊艳面试官的深拷贝。</p><h2 id="深拷贝和浅拷贝的定义"><a href="#深拷贝和浅拷贝的定义" class="headerlink" title="深拷贝和浅拷贝的定义"></a>深拷贝和浅拷贝的定义</h2><p>深拷贝已经是一个老生常谈的话题了，也是现在前端面试的高频题目，但是令我吃惊的是有很多同学还没有搞懂深拷贝和浅拷贝的区别和定义。例如前几天给我提<code>issue</code>的同学：</p><p><img src="https://i.loli.net/2019/08/30/8U5e2I6lmzBHcW9.jpg" alt></p><p>很明显这位同学把拷贝和赋值搞混了，如果你还对赋值、对象在内存中的存储、变量和类型等等有什么疑问，可以看看我这篇文章：<br><a href="https://juejin.im/post/5cec1bcff265da1b8f1aa08f" target="_blank" rel="noopener">https://juejin.im/post/5cec1bcff265da1b8f1aa08f</a> 。</p><p>你只要少搞明白<code>拷贝</code>和<code>赋值</code>的区别。</p><p>我们来明确一下深拷贝和浅拷贝的定义：</p><p>浅拷贝：</p><p><img src="https://i.loli.net/2019/08/30/N3CB7obYhn5Lvxz.jpg" alt></p><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><a id="more"></a><p>深拷贝：</p><p><img src="https://i.loli.net/2019/08/30/OFIGRqZeWkBn9cr.jpg" alt></p><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><p>话不多说，浅拷贝就不再多说，下面我们直入正题：</p><h2 id="乞丐版"><a href="#乞丐版" class="headerlink" title="乞丐版"></a>乞丐版</h2><p>在不使用第三方库的情况下，我们想要深拷贝一个对象，用的最多的就是下面这个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify());</span><br></pre></td></tr></table></figure><p>这种写法非常简单，而且可以应对大部分的应用场景，但是它还是有很大缺陷的，比如拷贝其他引用类型、拷贝函数、循环引用等情况。</p><p>显然，面试时你只说出这样的方法是一定不会合格的。</p><p>接下来，我们一起来手动实现一个深拷贝方法。</p><h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><p>如果是浅拷贝的话，我们可以很容易写出下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        cloneTarget[key] = target[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性依次添加到新对象上，返回。</p><p>如果是深拷贝的话，考虑到我们要拷贝的对象是不知道有多少层深度的，我们可以用递归来解决问题，稍微改写上面的代码：</p><ul><li>如果是原始类型，无需继续拷贝，直接返回</li><li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行 <strong>深拷贝后</strong> 依次添加到新对象上。</li></ul><p>很容易理解，如果有更深层次的对象可以继续递归直到属性为原始类型，这样我们就完成了一个最简单的深拷贝：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看下面的测试用例进行测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: <span class="string">'ConardLi'</span>,</span><br><span class="line">    field4: &#123;</span><br><span class="line">        child: <span class="string">'child'</span>,</span><br><span class="line">        child2: &#123;</span><br><span class="line">            child2: <span class="string">'child2'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2019/08/31/Nxr21XJnVgqOTs5.png" alt></p><p>这是一个最基础版本的深拷贝，这段代码可以让你向面试官展示你可以用递归解决问题，但是显然，他还有非常多的缺陷，比如，还没有考虑数组。</p><h2 id="考虑数组"><a href="#考虑数组" class="headerlink" title="考虑数组"></a>考虑数组</h2><p>在上面的版本中，我们的初始化结果只考虑了普通的<code>object</code>，下面我们只需要把初始化代码稍微一变，就可以兼容数组了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行下面的测试用例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2019/08/31/2LokZ1hMcGbBYU7.jpg" alt></p><p>OK，没有问题，你的代码又向合格迈进了一小步。</p><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>我们执行下面这样一个测试用例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br><span class="line">target.target = target;</span><br></pre></td></tr></table></figure><p>可以看到下面的结果：</p><p><img src="https://i.loli.net/2019/08/31/JMiLz6qt2BYdvjm.png" alt></p><p>很明显，因为递归进入死循环导致栈内存溢出了。</p><p>原因就是上面的对象存在循环引用的情况，即对象的属性间接或直接的引用了自身的情况：</p><p><img src="https://i.loli.net/2019/09/01/uYyaqztP23xh5Vf.jpg" alt></p><p>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。</p><p>这个存储空间，需要可以存储<code>key-value</code>形式的数据，且<code>key</code>可以是一个引用类型，我们可以选择<code>Map</code>这种数据结构：</p><ul><li>检查<code>map</code>中有无克隆过的对象</li><li>有 - 直接返回</li><li>没有 - 将当前对象作为<code>key</code>，克隆对象作为<code>value</code>进行存储</li><li>继续克隆</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new Map(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(target, cloneTarget);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key], map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来执行上面的测试用例：</p><p><img src="https://i.loli.net/2019/08/31/z1OWfmFcAJ9SR8I.jpg" alt></p><p>可以看到，执行没有报错，且<code>target</code>属性，变为了一个<code>Circular</code>类型，即循环应用的意思。</p><p>接下来，我们可以使用，<code>WeakMap</code>提代<code>Map</code>来使代码达到画龙点睛的作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/09/01/AWrneLyJavhTfOG.jpg" alt></p><p>为什么要这样做呢？，先来看看<code>WeakMap</code>的作用：</p><blockquote><p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p></blockquote><p>什么是弱引用呢？</p><blockquote><p>在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。</p></blockquote><p>我们默认创建一个对象：<code>const obj = {}</code>，就默认创建了一个强引用的对象，我们只有手动将<code>obj = null</code>，它才会被垃圾回收机制进行回收，如果是弱引用对象，垃圾回收机制会自动帮我们回收。</p><p>举个例子：</p><p>如果我们使用<code>Map</code>的话，那么对象间是存在强引用关系的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span> : <span class="string">'ConardLi'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">target.set(obj,<span class="string">'code秘密花园'</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>虽然我们手动将<code>obj</code>，进行释放，然是<code>target</code>依然对<code>obj</code>存在强引用关系，所以这部分内存依然无法被释放。</p><p>再来看<code>WeakMap</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span> : <span class="string">'ConardLi'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">target.set(obj,<span class="string">'code秘密花园'</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>如果是<code>WeakMap</code>的话，<code>target</code>和<code>obj</code>存在的就是弱引用关系，当下一次垃圾回收机制执行时，这块内存就会被释放掉。</p><p>设想一下，如果我们要拷贝的对象非常庞大时，使用<code>Map</code>会对内存造成非常大的额外消耗，而且我们需要手动清除<code>Map</code>的属性才能释放这块内存，而<code>WeakMap</code>会帮我们巧妙化解这个问题。</p><p>我也经常在某些代码中看到有人使用<code>WeakMap</code>来解决循环引用问题，但是解释都是模棱两可的，当你不太了解<code>WeakMap</code>的真正作用时。我建议你也不要在面试中写这样的代码，结果只能是给自己挖坑，即使是准备面试，你写的每一行代码也都是需要经过深思熟虑并且非常明白的。</p><p>能考虑到循环引用的问题，你已经向面试官展示了你考虑问题的全面性，如果还能用<code>WeakMap</code>解决问题，并很明确的向面试官解释这样做的目的，那么你的代码在面试官眼里应该算是合格了。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>在上面的代码中，我们遍历数组和对象都使用了<code>for in</code>这种方式，实际上<code>for in</code>在遍历时效率是非常低的，我们来对比下常见的三种循环<code>for、while、for in</code>的执行效率：</p><p><img src="https://i.loli.net/2019/08/29/1ydBJ63LntlvZWO.jpg" alt></p><p>可以看到，<code>while</code>的效率是最好的，所以，我们可以想办法把<code>for in</code>遍历改变为<code>while</code>遍历。</p><p>我们先使用<code>while</code>来实现一个通用的<code>forEach</code>遍历，<code>iteratee</code>是遍历的回掉函数，他可以接收每次遍历的<code>value</code>和<code>index</code>两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">        iteratee(array[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对我们的<code>cloen</code>函数进行改写：当遍历数组时，直接使用<code>forEach</code>进行遍历，当遍历对象时，使用<code>Object.keys</code>取出所有的<code>key</code>进行遍历，然后在遍历时把<code>forEach</code>会调函数的<code>value</code>当作<code>key</code>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray(target);</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = isArray ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> keys = isArray ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line">        forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">                key = value;</span><br><span class="line">            &#125;</span><br><span class="line">            cloneTarget[key] = clone2(target[key], map);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们执行测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    f: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">f</span>: &#123;&#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">target.target = target;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> result = clone1(target);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time();</span><br><span class="line"><span class="keyword">const</span> result2 = clone2(target);</span><br><span class="line"><span class="built_in">console</span>.timeEnd();</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2019/08/31/ZhMxNjFE9KYqH7l.jpg" alt></p><p>很明显，我们的性能优化是有效的。</p><p>到这里，你已经向面试官展示了，在写代码的时候你会考虑程序的运行效率，并且你具有通用函数的抽象能力。</p><h2 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h2><p>在上面的代码中，我们其实只考虑了普通的<code>object</code>和<code>array</code>两种数据类型，实际上所有的引用类型远远不止这两个，还有很多，下面我们先尝试获取对象准确的类型。</p><h3 id="合理的判断引用类型"><a href="#合理的判断引用类型" class="headerlink" title="合理的判断引用类型"></a>合理的判断引用类型</h3><p>首先，判断是否为引用类型，我们还需要考虑<code>function</code>和<code>null</code>两种特殊的数据类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> target;</span><br><span class="line">    <span class="keyword">return</span> target !== <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="获取数据类型"><a href="#获取数据类型" class="headerlink" title="获取数据类型"></a>获取数据类型</h3><p>我们可以使用<code>toString</code>来获取准确的引用类型：</p><blockquote><p>每一个引用类型都有<code>toString</code>方法，默认情况下，<code>toString()</code>方法被每个<code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，t<code>oString()</code> 返回 <code>&quot;[object type]&quot;</code>，其中type是对象的类型。</p></blockquote><p>注意，上面提到了如果此方法在自定义对象中未被覆盖，<code>toString</code>才会达到预想的效果，事实上，大部分引用类型比如<code>Array、Date、RegExp</code>等都重写了<code>toString</code>方法。</p><p>我们可以直接调用<code>Object</code>原型上未被覆盖的<code>toString()</code>方法，使用<code>call</code>来改变<code>this</code>指向来达到我们想要的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/09/01/wvJgxWe17RdaEHY.jpg" alt></p><p>下面我们抽离出一些常用的数据类型以便后面使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapTag = <span class="string">'[object Map]'</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">'[object Set]'</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">'[object Array]'</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">'[object Object]'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">'[object Boolean]'</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">'[object Date]'</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">'[object Error]'</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">'[object Number]'</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">'[object RegExp]'</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">'[object String]'</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">'[object Symbol]'</span>;</span><br></pre></td></tr></table></figure><p>在上面的集中类型中，我们简单将他们分为两类：</p><ul><li>可以继续遍历的类型</li><li>不可以继续遍历的类型</li></ul><p>我们分别为它们做不同的拷贝。</p><h3 id="可继续遍历的类型"><a href="#可继续遍历的类型" class="headerlink" title="可继续遍历的类型"></a>可继续遍历的类型</h3><p>上面我们已经考虑的<code>object</code>、<code>array</code>都属于可以继续遍历的类型，因为它们内存都还可以存储其他数据类型的数据，另外还有<code>Map</code>，<code>Set</code>等都是可以继续遍历的类型，这里我们只考虑这四种，如果你有兴趣可以继续探索其他类型。</p><p>有序这几种类型还需要继续进行递归，我们首先需要获取它们的初始化数据，例如上面的<code>[]</code>和<code>{}</code>，我们可以通过拿到<code>constructor</code>的方式来通用的获取。</p><p>例如：<code>const target = {}</code>就是<code>const target = new Object()</code>的语法糖。另外这种方法还有一个好处：因为我们还使用了原对象的构造方法，所以它可以保留对象原型上的数据，如果直接使用普通的<code>{}</code>，那么原型必然是丢失了的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInit</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ctor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们改写<code>clone</code>函数，对可继续遍历的数据类型进行处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆原始类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">const</span> type = getType(target);</span><br><span class="line">    <span class="keyword">let</span> cloneTarget;</span><br><span class="line">    <span class="keyword">if</span> (deepTag.includes(type)) &#123;</span><br><span class="line">        cloneTarget = getInit(target, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(target);</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆set</span></span><br><span class="line">    <span class="keyword">if</span> (type === setTag) &#123;</span><br><span class="line">        target.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.add(clone(value,map));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆map</span></span><br><span class="line">    <span class="keyword">if</span> (type === mapTag) &#123;</span><br><span class="line">        target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.set(key, clone(value,map));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆对象和数组</span></span><br><span class="line">    <span class="keyword">const</span> keys = type === arrayTag ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line">    forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">            key = value;</span><br><span class="line">        &#125;</span><br><span class="line">        cloneTarget[key] = clone(target[key], map);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    empty: <span class="literal">null</span>,</span><br><span class="line">    map,</span><br><span class="line">    <span class="keyword">set</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2019/09/01/dQ7hGjYirkRlN3s.jpg" alt></p><p>没有问题，里大功告成又进一步，下面我们继续处理其他类型：</p><h3 id="不可继续遍历的类型"><a href="#不可继续遍历的类型" class="headerlink" title="不可继续遍历的类型"></a>不可继续遍历的类型</h3><p>其他剩余的类型我们把它们统一归类成不可处理的数据类型，我们依次进行处理：</p><p><code>Bool</code>、<code>Number</code>、<code>String</code>、<code>String</code>、<code>Date</code>、<code>Error</code>这几种类型我们都可以直接用构造函数和原始数据创建一个新对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneOtherType</span>(<span class="params">targe, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = targe.constructor;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> boolTag:</span><br><span class="line">        <span class="keyword">case</span> numberTag:</span><br><span class="line">        <span class="keyword">case</span> stringTag:</span><br><span class="line">        <span class="keyword">case</span> errorTag:</span><br><span class="line">        <span class="keyword">case</span> dateTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ctor(targe);</span><br><span class="line">        <span class="keyword">case</span> regexpTag:</span><br><span class="line">            <span class="keyword">return</span> cloneReg(targe);</span><br><span class="line">        <span class="keyword">case</span> symbolTag:</span><br><span class="line">            <span class="keyword">return</span> cloneSymbol(targe);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>克隆<code>Symbol</code>类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">targe</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(targe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">克隆正则：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneReg</span>(<span class="params">targe</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class="line">    result.lastIndex = targe.lastIndex;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上还有很多数据类型我这里没有写到，有兴趣的话可以继续探索实现一下。</p><p>能写到这里，面试官已经看到了你考虑问题的严谨性，你对变量和类型的理解，对<code>JS API</code>的熟练程度，相信面试官已经开始对你刮目相看了。</p><h3 id="克隆函数"><a href="#克隆函数" class="headerlink" title="克隆函数"></a>克隆函数</h3><p>最后，我把克隆函数单独拎出来了，实际上克隆函数是没有实际应用场景的，两个对象使用一个在内存中处于同一个地址的函数也是没有任何问题的，我特意看了下<code>lodash</code>对函数的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value == <span class="string">'function'</span></span><br><span class="line"><span class="keyword">if</span> (isFunc || !cloneableTags[tag]) &#123;</span><br><span class="line">       <span class="keyword">return</span> object ? value : &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见这里如果发现是函数的话就会直接返回了，没有做特殊的处理，但是我发现不少面试官还是热衷于问这个问题的，而且据我了解能写出来的少之又少。。。</p><p>实际上这个方法并没有什么难度，主要就是考察你对基础的掌握扎实不扎实。</p><p>首先，我们可以通过<code>prototype</code>来区分下箭头函数和普通函数，箭头函数是没有<code>prototype</code>的。</p><p>我们可以直接使用<code>eval</code>和函数字符串来重新生成一个箭头函数，注意这种方法是不适用于普通函数的。</p><p>我们可以使用正则来处理普通函数：</p><p>分别使用正则取出函数体和函数参数，然后使用<code>new Function ([arg1[, arg2[, ...argN]],] functionBody)</code>构造函数重新构造一个新的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneFunction</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">    <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">    <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">    <span class="keyword">if</span> (func.prototype) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'普通函数'</span>);</span><br><span class="line">        <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">        <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">        <span class="keyword">if</span> (body) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'匹配到函数体：'</span>, body[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (param) &#123;</span><br><span class="line">                <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">','</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'匹配到参数：'</span>, paramArr);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(funcString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们再来执行测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line">map.set(<span class="string">'ConardLi'</span>, <span class="string">'code秘密花园'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add('ConardLi');</span><br><span class="line"><span class="keyword">set</span>.add('code秘密花园');</span><br><span class="line"></span><br><span class="line">const target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    empty: <span class="literal">null</span>,</span><br><span class="line">    map,</span><br><span class="line">    <span class="keyword">set</span>,</span><br><span class="line">    bool: new Boolean(true),</span><br><span class="line">    num: new Number(2),</span><br><span class="line">    str: new String(2),</span><br><span class="line">    symbol: Object(Symbol(1)),</span><br><span class="line">    date: new Date(),</span><br><span class="line">    reg: /\d+/,</span><br><span class="line">    error: new Error(),</span><br><span class="line">    func1: () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'code秘密花园'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2019/09/01/3tsUZR561FYOuQc.jpg" alt></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>为了更好的阅读，我们用一张图来展示上面所有的代码：</p><p><img src="https://i.loli.net/2019/08/30/9lfDPCXBagE8rQY.jpg" alt></p><p>可见，一个小小的深拷贝还是隐藏了很多的知识点的。</p><p>千万不要以最低的要求来要求自己，如果你只是为了应付面试中的一个题目，那么你可能只会去准备上面最简陋的深拷贝的方法。</p><p>但是面试官考察你的目的是全方位的考察你的思维能力，如果你写出上面的代码，可以体现你多方位的能力：</p><ul><li>基本实现<ul><li>递归能力</li></ul></li><li>循环引用<ul><li>考虑问题的全面性</li><li>理解weakmap的真正意义</li></ul></li><li>多种类型<ul><li>考虑问题的严谨性</li><li>创建各种引用类型的方法，JS API的熟练程度</li><li>准确的判断数据类型，对数据类型的理解程度</li></ul></li><li>通用遍历：<ul><li>写代码可以考虑性能优化</li><li>了解集中遍历的效率</li><li>代码抽象能力</li></ul></li><li>拷贝函数：<ul><li>箭头函数和普通函数的区别</li><li>正则表达式熟练程度</li></ul></li></ul><p>看吧，一个小小的深拷贝能考察你这么多的能力，如果面试官看到这样的代码，怎么能够不惊艳呢？</p><p>其实面试官出的所有题目你都可以用这样的思路去考虑。不要为了应付面试而去背一些代码，这样在有经验的面试官面前会都会暴露出来。你写的每一段代码都要经过深思熟虑，为什么要这样用，还能怎么优化…这样才能给面试官展现一个最好的你。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank" rel="noopener">WeakMap</a></li><li><a href="https://lodash.com/" target="_blank" rel="noopener">lodash</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望看完本篇文章能对你有如下帮助：</p><ul><li>理解深浅拷贝的真正意义</li><li>能整我深拷贝的各个要点，对问题进行深入分析</li><li>可以手写一个比较完整的深拷贝</li></ul><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;最近经常看到很多&lt;code&gt;JavaScript&lt;/code&gt;手写代码的文章总结，里面提供了很多&lt;code&gt;JavaScript Api&lt;/code&gt;的手写实现。&lt;/p&gt;
&lt;p&gt;里面的题目实现大多类似，而且说实话很多代码在我看来是非常简陋的，如果我作为面试官，看到这样的代码，在我心里是不会合格的，本篇文章我拿最简单的深拷贝来讲一讲。&lt;/p&gt;
&lt;p&gt;看本文之前先问自己三个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;你真的理解什么是深拷贝吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在面试官眼里，什么样的深拷贝才算合格？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么样的深拷贝能让面试官感到惊艳？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文由浅入深，带你一步一步实现一个惊艳面试官的深拷贝。&lt;/p&gt;
&lt;h2 id=&quot;深拷贝和浅拷贝的定义&quot;&gt;&lt;a href=&quot;#深拷贝和浅拷贝的定义&quot; class=&quot;headerlink&quot; title=&quot;深拷贝和浅拷贝的定义&quot;&gt;&lt;/a&gt;深拷贝和浅拷贝的定义&lt;/h2&gt;&lt;p&gt;深拷贝已经是一个老生常谈的话题了，也是现在前端面试的高频题目，但是令我吃惊的是有很多同学还没有搞懂深拷贝和浅拷贝的区别和定义。例如前几天给我提&lt;code&gt;issue&lt;/code&gt;的同学：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/30/8U5e2I6lmzBHcW9.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;很明显这位同学把拷贝和赋值搞混了，如果你还对赋值、对象在内存中的存储、变量和类型等等有什么疑问，可以看看我这篇文章：&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/5cec1bcff265da1b8f1aa08f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5cec1bcff265da1b8f1aa08f&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;你只要少搞明白&lt;code&gt;拷贝&lt;/code&gt;和&lt;code&gt;赋值&lt;/code&gt;的区别。&lt;/p&gt;
&lt;p&gt;我们来明确一下深拷贝和浅拷贝的定义：&lt;/p&gt;
&lt;p&gt;浅拷贝：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/30/N3CB7obYhn5Lvxz.jpg&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配总结（二）应用篇</title>
    <link href="http://yoursite.com/2019/05/27/2019-05-27-Programing-JavaScript-moblie-develop-2/"/>
    <id>http://yoursite.com/2019/05/27/2019-05-27-Programing-JavaScript-moblie-develop-2/</id>
    <published>2019-05-27T07:28:41.000Z</published>
    <updated>2019-11-25T07:30:06.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="五、1px问题"><a href="#五、1px问题" class="headerlink" title="五、1px问题"></a>五、1px问题</h2><p>为了适配各种屏幕，我们写代码时一般使用设备独立像素来对页面进行布局。</p><p>而在设备像素比大于<code>1</code>的屏幕上，我们写的<code>1px</code>实际上是被多个物理像素渲染，这就会出现<code>1px</code>在有些屏幕上看起来很粗的现象。</p><h3 id="5-1-border-image"><a href="#5-1-border-image" class="headerlink" title="5.1 border-image"></a>5.1 border-image</h3><p>基于<code>media</code>查询判断不同的设备像素比给定不同的<code>border-image</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">         <span class="attribute">border-bottom</span>: none;</span><br><span class="line">         <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span>;</span><br><span class="line">         <span class="attribute">border-image</span>: <span class="built_in">url</span>(../img/1pxline.png) <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> stretch;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-background-image"><a href="#5-2-background-image" class="headerlink" title="5.2 background-image"></a>5.2 background-image</h3><p>和<code>border-image</code>类似，准备一张符合条件的边框背景图，模拟在背景上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span>&#123;</span><br><span class="line">         <span class="attribute">background</span>: <span class="built_in">url</span>(../img/1pxline.png) repeat-x left bottom;</span><br><span class="line">         <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">1px</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面两种都需要单独准备图片，而且圆角不是很好处理，但是可以应对大部分场景。</p><a id="more"></a><h3 id="5-3-伪类-transform"><a href="#5-3-伪类-transform" class="headerlink" title="5.3 伪类 + transform"></a>5.3 伪类 + transform</h3><p>基于<code>media</code>查询判断不同的设备像素比对线条进行缩放：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_1px</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">   <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">   <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0%</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">         <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(0.5);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">3</span>)&#123;</span><br><span class="line">     <span class="selector-class">.border_1px</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">         <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(0.33);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种方式可以满足各种场景，如果需要满足圆角，只需要给伪类也加上<code>border-radius</code>即可。</p><h3 id="5-4-svg"><a href="#5-4-svg" class="headerlink" title="5.4 svg"></a>5.4 svg</h3><p>上面我们<code>border-image</code>和<code>background-image</code>都可以模拟<code>1px</code>边框，但是使用的都是位图，还需要外部引入。</p><p>借助<code>PostCSS</code>的<code>postcss-write-svg</code>我们能直接使用<code>border-image</code>和<code>background-image</code>创建<code>svg</code>的<code>1px</code>边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">svg</span> border_1px &#123; </span><br><span class="line">  <span class="selector-tag">height</span>: 2<span class="selector-tag">px</span>; </span><br><span class="line">  @<span class="keyword">rect</span> &#123; </span><br><span class="line">    <span class="selector-tag">fill</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--color</span>, <span class="selector-tag">black</span>); </span><br><span class="line">    <span class="selector-tag">width</span>: 100%; </span><br><span class="line">    <span class="selector-tag">height</span>: 50%; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"><span class="selector-class">.example</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid transparent; <span class="attribute">border-image</span>: <span class="built_in">svg</span>(border_1px param(--color #00b1ff)) <span class="number">2</span> <span class="number">2</span> stretch; &#125;</span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid transparent; <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' height='2px'%3E%3Crect fill='%2300b1ff' width='100%25' height='50%25'/%3E%3C/svg%3E"</span>) <span class="number">2</span> <span class="number">2</span> stretch; &#125;</span><br></pre></td></tr></table></figure><p>上面的方案是大漠在他的文章中推荐使用的，基本可以满足所有场景，而且不需要外部引入，这是我个人比较喜欢的一种方案。</p><h3 id="5-5-设置viewport"><a href="#5-5-设置viewport" class="headerlink" title="5.5 设置viewport"></a>5.5 设置viewport</h3><p>通过设置缩放，让<code>CSS</code>像素等于真正的物理像素。</p><p>例如：当设备像素比为<code>3</code>时，我们将页面缩放<code>1/3</code>倍，这时<code>1px</code>等于一个真正的屏幕像素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="keyword">const</span> viewport = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>);</span><br><span class="line"><span class="keyword">if</span> (!viewport) &#123;</span><br><span class="line">    viewport = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>);</span><br><span class="line">    viewport.setAttribute(<span class="string">'name'</span>, <span class="string">'viewport'</span>);</span><br><span class="line">    <span class="built_in">window</span>.document.head.appendChild(viewport);</span><br><span class="line">&#125;</span><br><span class="line">viewport.setAttribute(<span class="string">'content'</span>, <span class="string">'width=device-width,user-scalable=no,initial-scale='</span> + scale + <span class="string">',maximum-scale='</span> + scale + <span class="string">',minimum-scale='</span> + scale);</span><br></pre></td></tr></table></figure><p>实际上，上面这种方案是早先<code>flexible</code>采用的方案。</p><p>当然，这样做是要付出代价的，这意味着你页面上所有的布局都要按照物理像素来写。这显然是不现实的，这时，我们可以借助<code>flexible</code>或<code>vw、vh</code>来帮助我们进行适配。</p><h2 id="六、移动端适配方案"><a href="#六、移动端适配方案" class="headerlink" title="六、移动端适配方案"></a>六、移动端适配方案</h2><p>尽管我们可以使用设备独立像素来保证各个设备在不同手机上显示的效果类似，但这并不能保证它们显示完全一致，我们需要一种方案来让设计稿得到更完美的适配。</p><h3 id="6-1-flexible方案"><a href="#6-1-flexible方案" class="headerlink" title="6.1 flexible方案"></a>6.1 flexible方案</h3><p><code>flexible</code>方案是阿里早期开源的一个移动端适配解决方案，引用<code>flexible</code>后，我们在页面上统一使用<code>rem</code>来布局。</p><p>它的核心代码非常简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set 1rem = viewWidth / 10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRemUnit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rem = docEl.clientWidth / <span class="number">10</span></span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">'px'</span></span><br><span class="line">&#125;</span><br><span class="line">setRemUnit();</span><br></pre></td></tr></table></figure><p><code>rem</code> 是相对于<code>html</code>节点的<code>font-size</code>来做计算的。</p><p>我们通过设置<code>document.documentElement.style.fontSize</code>就可以统一整个页面的布局标准。</p><p>上面的代码中，将<code>html</code>节点的<code>font-size</code>设置为页面<code>clientWidth</code>(布局视口)的<code>1/10</code>，即<code>1rem</code>就等于页面布局视口的<code>1/10</code>，这就意味着我们后面使用的<code>rem</code>都是按照页面比例来计算的。</p><p>这时，我们只需要将<code>UI</code>出的图转换为<code>rem</code>即可。</p><p>以<code>iPhone6</code>为例：布局视口为<code>375px</code>，则<code>1rem = 37.5px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 37.5 = 2rem</code>。</p><p>当然，每个布局都要计算非常繁琐，我们可以借助<code>PostCSS</code>的<code>px2rem</code>插件来帮助我们完成这个过程。</p><p>下面的代码可以保证在页面大小变化时，布局可以自适应，当触发了<code>window</code>的<code>resize</code>和<code>pageShow</code>事件之后自动调整<code>html</code>的<code>fontSize</code>大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// reset rem unit on page resize</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, setRemUnit)<span class="built_in">window</span>.addEventListener(<span class="string">'pageshow'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">      setRemUnit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于<code>viewport</code>单位得到众多浏览器的兼容，上面这种方案现在已经被官方弃用：</p><blockquote><p>lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。</p></blockquote><p>下面我们来看看现在最流行的<code>vh、vw</code>方案。</p><h3 id="6-2-vh、vw方案"><a href="#6-2-vh、vw方案" class="headerlink" title="6.2 vh、vw方案"></a>6.2 vh、vw方案</h3><p><code>vh、vw</code>方案即将视觉视口宽度 <code>window.innerWidth</code>和视觉视口高度 <code>window.innerHeight</code> 等分为 100 份。</p><p>上面的<code>flexible</code>方案就是模仿这种方案，因为早些时候<code>vw</code>还没有得到很好的兼容。</p><ul><li><code>vw(Viewport&#39;s width)</code>：<code>1vw</code>等于视觉视口的<code>1%</code></li><li><code>vh(Viewport&#39;s height)</code> :<code>1vh</code> 为视觉视口高度的<code>1%</code></li><li><code>vmin</code> :  <code>vw</code> 和 <code>vh</code> 中的较小值</li><li><code>vmax</code> : 选取 <code>vw</code> 和 <code>vh</code> 中的较大值</li></ul><p><img src="https://i.loli.net/2019/05/17/5cddf1f0e18bb53584.png" alt></p><p>如果视觉视口为<code>375px</code>，那么<code>1vw = 3.75px</code>，这时<code>UI</code>给定一个元素的宽为<code>75px</code>（设备独立像素），我们只需要将它设置为<code>75 / 3.75 = 20vw</code>。</p><p>这里的比例关系我们也不用自己换算，我们可以使用<code>PostCSS</code>的 <code>postcss-px-to-viewport</code> 插件帮我们完成这个过程。写代码时，我们只需要根据<code>UI</code>给的设计图写<code>px</code>单位即可。</p><p>当然，没有一种方案是十全十美的，<code>vw</code>同样有一定的缺陷：</p><ul><li><code>px</code>转换成<code>vw</code>不一定能完全整除，因此有一定的像素差。</li><li>比如当容器使用<code>vw</code>，<code>margin</code>采用<code>px</code>时，很容易造成整体宽度超过<code>100vw</code>，从而影响布局效果。当然我们也是可以避免的，例如使用<code>padding</code>代替<code>margin</code>，结合<code>calc()</code>函数使用等等…</li></ul><h2 id="七、适配iPhoneX"><a href="#七、适配iPhoneX" class="headerlink" title="七、适配iPhoneX"></a>七、适配iPhoneX</h2><p><code>iPhoneX</code>的出现将手机的颜值带上了一个新的高度，它取消了物理按键，改成了底部的小黑条，但是这样的改动给开发者适配移动端又增加了难度。</p><h3 id="7-1-安全区域"><a href="#7-1-安全区域" class="headerlink" title="7.1 安全区域"></a>7.1 安全区域</h3><p>在<code>iPhoneX</code>发布后，许多厂商相继推出了具有边缘屏幕的手机。</p><p><img src="https://i.loli.net/2019/05/17/5cddf1e78a7c870328.png" alt></p><p>这些手机和普通手机在外观上无外乎做了三个改动：圆角（<code>corners</code>）、刘海（<code>sensor housing</code>）和小黑条（<code>Home Indicator</code>）。为了适配这些手机，安全区域这个概念变诞生了：安全区域就是一个不受上面三个效果的可视窗口范围。</p><p>为了保证页面的显示效果，我们必须把页面限制在安全范围内，但是不影响整体效果。</p><h3 id="7-2-viewport-fit"><a href="#7-2-viewport-fit" class="headerlink" title="7.2 viewport-fit"></a>7.2 viewport-fit</h3><p><code>viewport-fit</code>是专门为了适配<code>iPhoneX</code>而诞生的一个属性，它用于限制网页如何在安全区域内进行展示。</p><p><img src="https://i.loli.net/2019/05/17/5cddf1a74a74578018.png" alt></p><p><code>contain</code>: 可视窗口完全包含网页内容</p><p><code>cover</code>：网页内容完全覆盖可视窗口</p><p>默认情况下或者设置为<code>auto</code>和<code>contain</code>效果相同。</p><h3 id="7-3-env、constant"><a href="#7-3-env、constant" class="headerlink" title="7.3 env、constant"></a>7.3 env、constant</h3><p><img src="https://i.loli.net/2019/05/17/5cddf1b63010c69640.png" alt></p><p>我们需要将顶部和底部合理的摆放在安全区域内，<code>iOS11</code>新增了两个<code>CSS</code>函数<code>env、constant</code>，用于设定安全区域与边界的距离。</p><p>函数内部可以是四个常量：</p><ul><li><code>safe-area-inset-left</code>：安全区域距离左边边界距离</li><li><code>safe-area-inset-right</code>：安全区域距离右边边界距离</li><li><code>safe-area-inset-top</code>：安全区域距离顶部边界距离</li><li><code>safe-area-inset-bottom</code>：安全区域距离底部边界距离</li></ul><p>注意：我们必须指定<code>viweport-fit</code>后才能使用这两个函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"viewport-fit=cover"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>constant</code>在<code>iOS &lt; 11.2</code>的版本中生效，<code>env</code>在<code>iOS &gt;= 11.2</code>的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用底部固定导航栏时，我们要为他们设置<code>padding</code>值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、横屏适配"><a href="#八、横屏适配" class="headerlink" title="八、横屏适配"></a>八、横屏适配</h2><p><img src="https://i.loli.net/2019/05/17/5cddf20178d8c32612.png" alt></p><p>很多视口我们要对横屏和竖屏显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式：</p><h3 id="8-1-JavaScript检测横屏"><a href="#8-1-JavaScript检测横屏" class="headerlink" title="8.1 JavaScript检测横屏"></a>8.1 JavaScript检测横屏</h3><p><code>window.orientation</code>:获取屏幕旋转方向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.orientation === <span class="number">180</span> || <span class="built_in">window</span>.orientation === <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// 正常方向或屏幕旋转180度</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'竖屏'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.orientation === <span class="number">90</span> || <span class="built_in">window</span>.orientation === <span class="number">-90</span> )&#123; </span><br><span class="line">       <span class="comment">// 屏幕顺时钟旋转90度或屏幕逆时针旋转90度</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'横屏'</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8-2-CSS检测横屏"><a href="#8-2-CSS检测横屏" class="headerlink" title="8.2 CSS检测横屏"></a>8.2 CSS检测横屏</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (orientation: portrait) &#123;</span><br><span class="line">  <span class="comment">/*竖屏...*/</span></span><br><span class="line">&#125; </span><br><span class="line">@media screen and (orientation: landscape) &#123;</span><br><span class="line">  <span class="comment">/*横屏...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、图片模糊问题"><a href="#九、图片模糊问题" class="headerlink" title="九、图片模糊问题"></a>九、图片模糊问题</h2><h3 id="9-1-产生原因"><a href="#9-1-产生原因" class="headerlink" title="9.1 产生原因"></a>9.1 产生原因</h3><p>我们平时使用的图片大多数都属于位图（<code>png、jpg...</code>），位图由一个个像素点构成的，每个像素都具有特定的位置和颜色值：</p><p><img src="https://i.loli.net/2019/05/17/5cddf1ea88e2190952.png" alt></p><p>理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果。</p><p>而在<code>dpr &gt; 1</code>的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确的分配上对应位图像素的颜色，只能取近似值，所以相同的图片在<code>dpr &gt; 1</code>的屏幕上就会模糊:</p><p><img src="https://i.loli.net/2019/05/17/5cddf1ebd33ce27972.jpg" alt></p><h3 id="9-2-解决方案"><a href="#9-2-解决方案" class="headerlink" title="9.2 解决方案"></a>9.2 解决方案</h3><p>为了保证图片质量，我们应该尽可能让一个屏幕像素来渲染一个图片像素，所以，针对不同<code>DPR</code>的屏幕，我们需要展示不同分辨率的图片。</p><p>如：在<code>dpr=2</code>的屏幕上展示两倍图<code>(@2x)</code>，在<code>dpr=3</code>的屏幕上展示三倍图<code>(@3x)</code>。</p><p><img src="https://i.loli.net/2019/05/17/5cddf1ee82d2b57483.png" alt></p><h3 id="9-3-media查询"><a href="#9-3-media查询" class="headerlink" title="9.3 media查询"></a>9.3 media查询</h3><p>使用<code>media</code>查询判断不同的设备像素比来显示不同精度的图片：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span>&#123;</span><br><span class="line">     <span class="attribute">background-image</span>: <span class="built_in">url</span>(conardLi_1x.png);</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="selector-class">.avatar</span>&#123;</span><br><span class="line">         <span class="attribute">background-image</span>: <span class="built_in">url</span>(conardLi_2x.png);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> @<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio:<span class="number">3</span>)&#123;</span><br><span class="line">     <span class="selector-class">.avatar</span>&#123;</span><br><span class="line">         <span class="attribute">background-image</span>: <span class="built_in">url</span>(conardLi_3x.png);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>只适用于背景图</p></blockquote><h3 id="9-4-image-set"><a href="#9-4-image-set" class="headerlink" title="9.4 image-set"></a>9.4 image-set</h3><p>使用<code>image-set</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.avatar</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">-webkit-image-set</span>( <span class="string">"conardLi_1x.png"</span> 1x, <span class="string">"conardLi_2x.png"</span> 2x );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只适用于背景图</p></blockquote><h3 id="9-5-srcset"><a href="#9-5-srcset" class="headerlink" title="9.5 srcset"></a>9.5 srcset</h3><p>使用<code>img</code>标签的<code>srcset</code>属性，浏览器会自动根据像素密度匹配最佳显示图片：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"conardLi_1x.png"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">srcset</span>=<span class="string">" conardLi_2x.png 2x, conardLi_3x.png 3x"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-6-JavaScript拼接图片url"><a href="#9-6-JavaScript拼接图片url" class="headerlink" title="9.6 JavaScript拼接图片url"></a>9.6 JavaScript拼接图片url</h3><p>使用<code>window.devicePixelRatio</code>获取设备像素比，遍历所有图片，替换图片地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="keyword">const</span> images =  <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>);</span><br><span class="line">images.forEach(<span class="function">(<span class="params">img</span>)=&gt;</span>&#123;</span><br><span class="line">  img.src.replace(<span class="string">"."</span>, <span class="string">`@<span class="subst">$&#123;dpr&#125;</span>x.`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="9-7-使用svg"><a href="#9-7-使用svg" class="headerlink" title="9.7 使用svg"></a>9.7 使用svg</h3><p><code>SVG</code>的全称是可缩放矢量图（<code>Scalable Vector Graphics</code>）。不同于位图的基于像素，<code>SVG</code> 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。</p><p><img src="https://i.loli.net/2019/05/17/5cddf1f59b24a71558.png" alt></p><p>除了我们手动在代码中绘制<code>svg</code>，我们还可以像使用位图一样使用<code>svg</code>图片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"conardLi.svg"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">"data:image/svg+xml;base64,[data]"</span>&gt;</span><br><span class="line"></span><br><span class="line">.avatar &#123;</span><br><span class="line">  background: url(conardLi.svg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.w3cplus.com/css/vw-for-layout.html" target="_blank" rel="noopener">https://www.w3cplus.com/css/vw-for-layout.html</a></li><li><a href="https://aotu.io/notes/2017/11/27/iphonex/index.html" target="_blank" rel="noopener">https://aotu.io/notes/2017/11/27/iphonex/index.html</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p><ul><li>理清移动端适配常用概念</li><li>理解移动端适配问题产生的原理，至少掌握一种解决方案</li></ul><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;五、1px问题&quot;&gt;&lt;a href=&quot;#五、1px问题&quot; class=&quot;headerlink&quot; title=&quot;五、1px问题&quot;&gt;&lt;/a&gt;五、1px问题&lt;/h2&gt;&lt;p&gt;为了适配各种屏幕，我们写代码时一般使用设备独立像素来对页面进行布局。&lt;/p&gt;
&lt;p&gt;而在设备像素比大于&lt;code&gt;1&lt;/code&gt;的屏幕上，我们写的&lt;code&gt;1px&lt;/code&gt;实际上是被多个物理像素渲染，这就会出现&lt;code&gt;1px&lt;/code&gt;在有些屏幕上看起来很粗的现象。&lt;/p&gt;
&lt;h3 id=&quot;5-1-border-image&quot;&gt;&lt;a href=&quot;#5-1-border-image&quot; class=&quot;headerlink&quot; title=&quot;5.1 border-image&quot;&gt;&lt;/a&gt;5.1 border-image&lt;/h3&gt;&lt;p&gt;基于&lt;code&gt;media&lt;/code&gt;查询判断不同的设备像素比给定不同的&lt;code&gt;border-image&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.border_1px&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attribute&quot;&gt;border-bottom&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1px&lt;/span&gt; solid &lt;span class=&quot;number&quot;&gt;#000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; @&lt;span class=&quot;keyword&quot;&gt;media&lt;/span&gt; only screen and (-webkit-min-device-pixel-ratio:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;selector-class&quot;&gt;.border_1px&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attribute&quot;&gt;border-bottom&lt;/span&gt;: none;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attribute&quot;&gt;border-width&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attribute&quot;&gt;border-image&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;url&lt;/span&gt;(../img/1pxline.png) &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; stretch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;5-2-background-image&quot;&gt;&lt;a href=&quot;#5-2-background-image&quot; class=&quot;headerlink&quot; title=&quot;5.2 background-image&quot;&gt;&lt;/a&gt;5.2 background-image&lt;/h3&gt;&lt;p&gt;和&lt;code&gt;border-image&lt;/code&gt;类似，准备一张符合条件的边框背景图，模拟在背景上。&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.border_1px&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attribute&quot;&gt;border-bottom&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1px&lt;/span&gt; solid &lt;span class=&quot;number&quot;&gt;#000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; @&lt;span class=&quot;keyword&quot;&gt;media&lt;/span&gt; only screen and (-webkit-min-device-pixel-ratio:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;selector-class&quot;&gt;.border_1px&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;url&lt;/span&gt;(../img/1pxline.png) repeat-x left bottom;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attribute&quot;&gt;background-size&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;100%&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面两种都需要单独准备图片，而且圆角不是很好处理，但是可以应对大部分场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配总结（一）原理篇</title>
    <link href="http://yoursite.com/2019/05/22/2019-05-22-Programing-JavaScript-moblie-develop-1/"/>
    <id>http://yoursite.com/2019/05/22/2019-05-22-Programing-JavaScript-moblie-develop-1/</id>
    <published>2019-05-22T07:26:14.000Z</published>
    <updated>2019-11-25T07:28:32.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>移动端适配，是我们在开发中经常会遇到的，这里面可能会遇到非常多的问题：</p><ul><li><code>1px</code>问题</li><li><code>UI</code>图完美适配方案</li><li><code>iPhoneX</code>适配方案</li><li>横屏适配</li><li>高清屏图片模糊问题</li><li>…</li></ul><p>上面这些问题可能我们在开发中已经知道如何解决，但是问题产生的原理，以及解决方案的原理可能会模糊不清。在解决这些问题的过程中，我们往往会遇到非常多的概念：像素、分辨率、<code>PPI</code>、<code>DPI</code>、<code>DP</code>、<code>DIP</code>、<code>DPR</code>、视口等等，你真的能分清这些概念的意义吗？</p><p>本文将从移动端适配的基础概念出发，探究移动端适配各种问题的解决方案和实现原理。</p><h2 id="一、英寸"><a href="#一、英寸" class="headerlink" title="一、英寸"></a>一、英寸</h2><p>一般用英寸描述屏幕的物理大小，如电脑显示器的<code>17</code>、<code>22</code>，手机显示器的<code>4.8</code>、<code>5.7</code>等使用的单位都是英寸。</p><p>需要注意，上面的尺寸都是屏幕对角线的长度：</p><p><img src="https://i.loli.net/2019/05/17/5cddefa632f3247082.png" alt></p><p>英寸(<code>inch</code>,缩写为<code>in</code>)在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。</p><p>英寸和厘米的换算：<code>1英寸 = 2.54 厘米</code></p><h2 id="二、分辨率"><a href="#二、分辨率" class="headerlink" title="二、分辨率"></a>二、分辨率</h2><h3 id="2-1-像素"><a href="#2-1-像素" class="headerlink" title="2.1 像素"></a>2.1 像素</h3><p>像素即一个小方块，它具有特定的位置和颜色。</p><p>图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。</p><p>像素可以作为图片或电子屏幕的最小组成单位。</p><p>下面我们使用<code>sketch</code>打开一张图片：</p><p><img src="https://i.loli.net/2019/05/17/5cddefd18987943848.png" alt></p><p>将这些图片放大即可看到这些像素点：</p><p><img src="https://i.loli.net/2019/05/17/5cddefb8d84ab76156.png" alt></p><a id="more"></a><p>通常我们所说的分辨率有两种，屏幕分辨率和图像分辨率。</p><h3 id="2-2-屏幕分辨率"><a href="#2-2-屏幕分辨率" class="headerlink" title="2.2 屏幕分辨率"></a>2.2 屏幕分辨率</h3><p>屏幕分辨率指一个屏幕具体由多少个像素点组成。</p><p>下面是<code>apple</code>的官网上对手机分辨率的描述：</p><p><img src="https://i.loli.net/2019/05/17/5cddefb520e2929179.png" alt></p><p><code>iPhone XS Max</code> 和 <code>iPhone SE</code>的分辨率分别为<code>2688 x 1242</code>和<code>1136 x 640</code>。这表示手机分别在垂直和水平上所具有的像素点数。</p><p>当然分辨率高不代表屏幕就清晰，屏幕的清晰程度还与尺寸有关。</p><h3 id="2-3-图像分辨率"><a href="#2-3-图像分辨率" class="headerlink" title="2.3 图像分辨率"></a>2.3 图像分辨率</h3><p>我们通常说的<code>图片分辨率</code>其实是指图片含有的<code>像素数</code>，比如一张图片的分辨率为<code>800 x 400</code>。这表示图片分别在垂直和水平上所具有的像素点数为<code>800</code>和<code>400</code>。</p><p>同一尺寸的图片，分辨率越高，图片越清晰。</p><p><img src="https://i.loli.net/2019/05/17/5cddefb19aeaa99756.png" alt></p><h3 id="2-4-PPI"><a href="#2-4-PPI" class="headerlink" title="2.4 PPI"></a>2.4 PPI</h3><p><code>PPI(Pixel Per Inch)</code>：每英寸包括的像素数。</p><p><code>PPI</code>可以用于描述屏幕的清晰度以及一张图片的质量。</p><p>使用<code>PPI</code>描述图片时，<code>PPI</code>越高，图片质量越高，使用<code>PPI</code>描述屏幕时，<code>PPI</code>越高，屏幕越清晰。</p><p>在上面描述手机分辨率的图片中，我们可以看到：<code>iPhone XS Max</code> 和 <code>iPhone SE</code>的<code>PPI</code>分别为<code>458</code>和<code>326</code>，这足以证明前者的屏幕更清晰。</p><p>由于手机尺寸为手机对角线的长度，我们通常使用如下的方法计算<code>PPI</code>:</p><script type="math/tex; mode=display">\frac{\sqrt{水平像素点数^2+垂直像素点数^2}}{尺寸}</script><p><code>iPhone 6</code>的<code>PPI</code>为 $ \frac{\sqrt{1334^2+750^2}}{4.7}=325.6$，那它每英寸约含有<code>326</code>个物理像素点。</p><h3 id="2-5-DPI"><a href="#2-5-DPI" class="headerlink" title="2.5 DPI"></a>2.5 DPI</h3><p><code>DPI(Dot Per Inch)</code>：即每英寸包括的点数。</p><p>这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点也可以是打印机的墨点。</p><p>平时你可能会看到使用<code>DPI</code>来描述图片和屏幕，这时的<code>DPI</code>应该和<code>PPI</code>是等价的，<code>DPI</code>最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。</p><p>一张图片在屏幕上显示时，它的像素点数是规则排列的，每个像素点都有特定的位置和颜色。</p><p>当使用打印机进行打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是<code>DPI</code>所描述的：打印点的密度。</p><p><img src="https://i.loli.net/2019/05/17/5cddf09abd86b34406.png" alt></p><p>在上面的图像中我们可以清晰的看到，打印机是如何使用墨点来打印一张图像。</p><p>所以，打印机的<code>DPI</code>越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。</p><h2 id="三、设备独立像素"><a href="#三、设备独立像素" class="headerlink" title="三、设备独立像素"></a>三、设备独立像素</h2><p>实际上，上面我们描述的像素都是<code>物理像素</code>，即设备上真实的物理单元。</p><p>下面我们来看看<code>设备独立像素</code>究竟是如何产生的：</p><p>智能手机发展非常之快，在几年之前，我们还用着分辨率非常低的手机，比如下面左侧的白色手机，它的分辨率是<code>320x480</code>，我们可以在上面浏览正常的文字、图片等等。</p><p>但是，随着科技的发展，低分辨率的手机已经不能满足我们的需求了。很快，更高分辨率的屏幕诞生了，比如下面的黑色手机，它的分辨率是<code>640x940</code>，正好是白色手机的两倍。</p><p>理论上来讲，在白色手机上相同大小的图片和文字，在黑色手机上会被缩放一倍，因为它的分辨率提高了一倍。这样，岂不是后面出现更高分辨率的手机，页面元素会变得越来越小吗？</p><p><img src="https://i.loli.net/2019/05/17/5cddf09f48f0a33102.png" alt></p><p>然而，事实并不是这样的，我们现在使用的智能手机，不管分辨率多高，他们所展示的界面比例都是基本类似的。乔布斯在<code>iPhone4</code>的发布会上首次提出了<code>Retina Display</code>(视网膜屏幕)的概念，它正是解决了上面的问题，这也使它成为一款跨时代的手机。</p><p><img src="https://i.loli.net/2019/05/17/5cddf0897062b36552.png" alt></p><p>在<code>iPhone4</code>使用的视网膜屏幕中，把<code>2x2</code>个像素当<code>1</code>个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变。</p><p><img src="https://i.loli.net/2019/05/17/5cddf09af318944420.png" alt></p><p>如果黑色手机使用了视网膜屏幕的技术，那么显示结果应该是下面的情况，比如列表的宽度为<code>300</code>个像素，那么在一条水平线上，白色手机会用<code>300</code>个物理像素去渲染它，而黑色手机实际上会用<code>600</code>个物理像素去渲染它。</p><p>我们必须用一种单位来同时告诉不同分辨率的手机，它们在界面上显示元素的大小是多少，这个单位就是设备独立像素(<code>Device Independent Pixels</code>)简称<code>DIP</code>或<code>DP</code>。上面我们说，列表的宽度为<code>300</code>个像素，实际上我们可以说：列表的宽度为<code>300</code>个设备独立像素。</p><p><img src="https://i.loli.net/2019/05/17/5cddf08cd614e72602.png" alt></p><p>打开<code>chrome</code>的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如<code>iPhone X</code>显示的尺寸是<code>375x812</code>，实际<code>iPhone X</code>的分辨率会比这高很多，这里显示的就是设备独立像素。</p><p><img src="https://i.loli.net/2019/05/17/5cddf0955ea4541111.png" alt></p><h3 id="3-1-设备像素比"><a href="#3-1-设备像素比" class="headerlink" title="3.1 设备像素比"></a>3.1 设备像素比</h3><p>设备像素比<code>device pixel ratio</code>简称<code>dpr</code>，即物理像素和设备独立像素的比值。</p><p>在<code>web</code>中，浏览器为我们提供了<code>window.devicePixelRatio</code>来帮助我们获取<code>dpr</code>。</p><p>在<code>css</code>中，可以使用媒体查询<code>min-device-pixel-ratio</code>，区分<code>dpr</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> (-webkit-min-device-pixel-ratio: <span class="number">2</span>), (min-device-pixel-ratio: <span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>React Native</code>中，我们也可以使用<code>PixelRatio.get()</code>来获取<code>DPR</code>。</p><p>当然，上面的规则也有例外，<code>iPhone 6、7、8 Plus</code>的实际物理像素是<code>1080 x 1920</code>，在开发者工具中我们可以看到：它的设备独立像素是<code>414 x 736</code>，设备像素比为<code>3</code>，设备独立像素和设备像素比的乘积并不等于<code>1080 x 1920</code>，而是等于<code>1242 x 2208</code>。</p><p>实际上，手机会自动把<code>1242 x 2208</code>个像素点塞进<code>1080 * 1920</code>个物理像素点来渲染，我们不用关心这个过程，而<code>1242 x 2208</code>被称为屏幕的<code>设计像素</code>。我们开发过程中也是以这个<code>设计像素</code>为准。</p><p>实际上，从苹果提出视网膜屏幕开始，才出现设备像素比这个概念，因为在这之前，移动设备都是直接使用物理像素来进行展示。</p><p>紧接着，<code>Android</code>同样使用了其他的技术方案来实现<code>DPR</code>大于<code>1</code>的屏幕，不过原理是类似的。由于<code>Android</code>屏幕尺寸非常多、分辨率高低跨度非常大，不像苹果只有它自己的几款固定设备、尺寸。所以，为了保证各种设备的显示效果，<code>Android</code>按照设备的像素密度将设备分成了几个区间：</p><p><img src="https://i.loli.net/2019/05/17/5cddf152a707694983.png" alt></p><p>当然，所有的<code>Android</code>设备不一定严格按照上面的分辨率，每个类型可能对应几种不同分辨率，所以，每个<code>Android</code>手机都能根据给定的区间范围，确定自己的<code>DPR</code>，从而拥有类似的显示。当然，仅仅是类似，由于各个设备的尺寸、分辨率上的差异，设备独立像素也不会完全相等，所以各种<code>Android</code>设备仍然不能做到在展示上完全相等。</p><h3 id="3-2-移动端开发"><a href="#3-2-移动端开发" class="headerlink" title="3.2 移动端开发"></a>3.2 移动端开发</h3><p>在<code>iOS</code>、<code>Android</code>和<code>React Native</code>开发中样式单位其实都使用的是设备独立像素。</p><p><code>iOS</code>的尺寸单位为<code>pt</code>，<code>Android</code>的尺寸单位为<code>dp</code>，<code>React Native</code>中没有指定明确的单位，它们其实都是设备独立像素<code>dp</code>。</p><p>在使用<code>React Native</code>开发<code>App</code>时，<code>UI</code>给我们的原型图一般是基于<code>iphone6</code>的像素给定的。</p><p>为了适配所有机型，我们在写样式时需要把物理像素转换为设备独立像素：例如：如果给定一个元素的高度为<code>200px</code>(这里的<code>px</code>指物理像素，非<code>CSS</code>像素)，<code>iphone6</code>的设备像素比为<code>2</code>，我们给定的<code>height</code>应为<code>200px/2=100dp</code>。</p><p>当然，最好的是，你可以和设计沟通好，所有的<code>UI</code>图都按照设备独立像素来出。</p><p>我们还可以在代码(<code>React Native</code>)中进行<code>px</code>和<code>dp</code>的转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PixelRatio &#125; <span class="keyword">from</span> <span class="string">"react-native"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dpr = PixelRatio.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * px转换为dp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pxConvertTodp</span>(<span class="params">px</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> px / dpr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp转换为px</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dpConvertTopx</span>(<span class="params">dp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PixelRatio.getPixelSizeForLayoutSize(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-WEB-端开发"><a href="#3-3-WEB-端开发" class="headerlink" title="3.3 WEB 端开发"></a>3.3 WEB 端开发</h3><p>在写<code>CSS</code>时，我们用到最多的单位是<code>px</code>，即<code>CSS像素</code>，当页面缩放比例为<code>100%</code>时，一个<code>CSS像素</code>等于一个设备独立像素。</p><p>但是<code>CSS像素</code>是很容易被改变的，当用户对浏览器进行了放大，<code>CSS像素</code>会被放大，这时一个<code>CSS像素</code>会跨越更多的物理像素。</p><p><code>页面的缩放系数 = CSS像素 / 设备独立像素</code>。</p><h3 id="3-4-关于屏幕"><a href="#3-4-关于屏幕" class="headerlink" title="3.4 关于屏幕"></a>3.4 关于屏幕</h3><p>这里多说两句<code>Retina</code>屏幕，因为我在很多文章中看到对<code>Retina</code>屏幕的误解。</p><p><code>Retina</code>屏幕只是苹果提出的一个营销术语：</p><blockquote><p>在普通的使用距离下，人的肉眼无法分辨单个的像素点。</p></blockquote><p>为什么强调<code>普通的使用距离下</code>呢？我们来看一下它的计算公式：</p><script type="math/tex; mode=display">a=2arctan(h/2d)</script><p><code>a</code>代表人眼视角，<code>h</code>代表像素间距，<code>d</code>代表肉眼与屏幕的距离，符合以上条件的屏幕可以使肉眼看不见单个物理像素点。</p><p>它不能单纯的表达分辨率和<code>PPI</code>，只能一种表达视觉效果。</p><p>让多个物理像素渲染一个独立像素只是<code>Retina</code>屏幕为了达到效果而使用的一种技术。而不是所有<code>DPR &gt; 1</code>的屏幕就是<code>Retina</code>屏幕。</p><p>比如：给你一块超大尺寸的屏幕，即使它的<code>PPI</code>很高，<code>DPR</code>也很高，在近距离你也能看清它的像素点，这就不算<code>Retina</code>屏幕。</p><p><img src="https://i.loli.net/2019/05/17/5cddf1510035720584.jpg" alt></p><p>我们经常见到用<code>K</code>和<code>P</code>这个单位来形容屏幕：</p><p><code>P</code>代表的就是屏幕纵向的像素个数，<code>1080P</code>即纵向有<code>1080</code>个像素，分辨率为<code>1920X1080</code>的屏幕就属于<code>1080P</code>屏幕。</p><p>我们平时所说的高清屏其实就是屏幕的物理分辨率达到或超过<code>1920X1080</code>的屏幕。</p><p><code>K</code>代表屏幕横向有几个<code>1024</code>个像素，一般来讲横向像素超过<code>2048</code>就属于<code>2K</code>屏，横向像素超过<code>4096</code>就属于<code>4K</code>屏。</p><h2 id="四、视口"><a href="#四、视口" class="headerlink" title="四、视口"></a>四、视口</h2><p>视口(<code>viewport</code>)代表当前可见的计算机图形区域。在<code>Web</code>浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的<code>UI</code>， 菜单栏等——即指你正在浏览的文档的那一部分。</p><p>一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。</p><h3 id="4-1-布局视口"><a href="#4-1-布局视口" class="headerlink" title="4.1 布局视口"></a>4.1 布局视口</h3><p><img src="https://i.loli.net/2019/05/17/5cddf1581489419627.png" alt></p><p>布局视口(<code>layout viewport</code>)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。</p><p>所以，布局视口是网页布局的基准窗口，在<code>PC</code>浏览器上，布局视口就等于当前浏览器的窗口大小（不包括<code>borders</code> 、<code>margins</code>、滚动条）。</p><p>在移动端，布局视口被赋予一个默认值，大部分为<code>980px</code>，这保证<code>PC</code>的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。</p><p>我们可以通过调用<code>document.documentElement.clientWidth / clientHeight</code>来获取布局视口大小。</p><h3 id="4-2-视觉视口"><a href="#4-2-视觉视口" class="headerlink" title="4.2 视觉视口"></a>4.2 视觉视口</h3><p><img src="https://i.loli.net/2019/05/17/5cddf1554295a45164.png" alt></p><p>视觉视口(<code>visual viewport</code>)：用户通过屏幕真实看到的区域。</p><p>视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。</p><p>当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小。</p><p>例如：用户将浏览器窗口放大了<code>200%</code>，这时浏览器窗口中的<code>CSS像素</code>会随着视觉视口的放大而放大，这时一个<code>CSS</code>像素会跨越更多的物理像素。</p><p>所以，布局视口会限制你的<code>CSS</code>布局而视觉视口决定用户具体能看到什么。</p><p>我们可以通过调用<code>window.innerWidth / innerHeight</code>来获取视觉视口大小。</p><h3 id="4-3-理想视口"><a href="#4-3-理想视口" class="headerlink" title="4.3 理想视口"></a>4.3 理想视口</h3><p><img src="https://i.loli.net/2019/05/17/5cddf0955ea4541111.png" alt></p><p>布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(<code>ideal viewport</code>)就诞生了：网站页面在移动端展示的理想大小。</p><p>如上图，我们在描述设备独立像素时曾使用过这张图，在浏览器调试移动端时页面上给定的像素大小就是理想视口大小，它的单位正是设备独立像素。</p><p>上面在介绍<code>CSS像素时</code>曾经提到<code>页面的缩放系数 = CSS像素 / 设备独立像素</code>，实际上说<code>页面的缩放系数 = 理想视口宽度 / 视觉视口宽度</code>更为准确。</p><p>所以，当页面缩放比例为<code>100%</code>时，<code>CSS像素 = 设备独立像素</code>，<code>理想视口 = 视觉视口</code>。</p><p>我们可以通过调用<code>screen.width / height</code>来获取理想视口大小。</p><h3 id="4-4-Meta-viewport"><a href="#4-4-Meta-viewport" class="headerlink" title="4.4 Meta viewport"></a>4.4 Meta viewport</h3><p><code>&lt;meta&gt;</code> 元素表示那些不能由其它<code>HTML</code>元相关元素之一表示的任何元数据信息，它可以告诉浏览器如何解析页面。</p><p>我们可以借助<code>&lt;meta&gt;</code>元素的<code>viewport</code>来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>上面是<code>viewport</code>的一个配置，我们来看看它们的具体含义：</p><div class="table-container"><table><thead><tr><th><code>Value</code></th><th>可能值</th><th>描述</th></tr></thead><tbody><tr><td><code>width</code></td><td>正整数或<code>device-width</code></td><td>以<code>pixels</code>（像素）为单位， 定义布局视口的宽度。</td></tr><tr><td><code>height</code></td><td>正整数或<code>device-height</code></td><td>以<code>pixels</code>（像素）为单位， 定义布局视口的高度。</td></tr><tr><td><code>initial-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义页面初始缩放比率。</td></tr><tr><td><code>minimum-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义缩放的最小值；必须小于或等于<code>maximum-scale</code>的值。</td></tr><tr><td><code>maximum-scale</code></td><td><code>0.0 - 10.0</code></td><td>定义缩放的最大值；必须大于或等于<code>minimum-scale</code>的值。</td></tr><tr><td><code>user-scalable</code></td><td>一个布尔值（<code>yes</code>或者<code>no</code>）</td><td>如果设置为 <code>no</code>，用户将不能放大或缩小网页。默认值为 yes。</td></tr></tbody></table></div><h3 id="4-5-移动端适配"><a href="#4-5-移动端适配" class="headerlink" title="4.5 移动端适配"></a>4.5 移动端适配</h3><p>为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。</p><p><code>device-width</code>就等于理想视口的宽度，所以设置<code>width=device-width</code>就相当于让布局视口等于理想视口。</p><p>由于<code>initial-scale = 理想视口宽度 / 视觉视口宽度</code>，所以我们设置<code>initial-scale=1;</code>就相当于让视觉视口等于理想视口。</p><p>这时，1 个<code>CSS</code>像素就等于 1 个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。</p><h3 id="4-6-缩放"><a href="#4-6-缩放" class="headerlink" title="4.6 缩放"></a>4.6 缩放</h3><p>上面提到<code>width</code>可以决定布局视口的宽度，实际上它并不是布局视口的唯一决定性因素，设置<code>initial-scale</code>也有肯能影响到布局视口，因为布局视口宽度取的是<code>width</code>和视觉视口宽度的最大值。</p><p>例如：若手机的理想视口宽度为<code>400px</code>，设置<code>width=device-width</code>，<code>initial-scale=2</code>，此时<code>视觉视口宽度 = 理想视口宽度 / initial-scale</code>即<code>200px</code>，布局视口取两者最大值即<code>device-width</code> <code>400px</code>。</p><p>若设置<code>width=device-width</code>，<code>initial-scale=0.5</code>，此时<code>视觉视口宽度 = 理想视口宽度 / initial-scale</code>即<code>800px</code>，布局视口取两者最大值即<code>800px</code>。</p><h3 id="4-7-获取浏览器大小"><a href="#4-7-获取浏览器大小" class="headerlink" title="4.7 获取浏览器大小"></a>4.7 获取浏览器大小</h3><p>浏览器为我们提供的获取窗口大小的<code>API</code>有很多，下面我们再来对比一下：</p><p><img src="https://i.loli.net/2019/05/17/5cddf1b5bc92295065.png" alt></p><ul><li><code>window.innerHeight</code>：获取浏览器视觉视口高度（包括垂直滚动条）。</li><li><code>window.outerHeight</code>：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。</li><li><code>window.screen.Height</code>：获取获屏幕取理想视口高度，这个数值是固定的，<code>设备的分辨率/设备像素比</code></li><li><code>window.screen.availHeight</code>：浏览器窗口可用的高度。</li><li><code>document.documentElement.clientHeight</code>：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。</li><li><code>document.documentElement.offsetHeight</code>：包括内边距、滚动条、边框和外边距。</li><li><code>document.documentElement.scrollHeight</code>：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与<code>clientHeight</code>相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;移动端适配，是我们在开发中经常会遇到的，这里面可能会遇到非常多的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1px&lt;/code&gt;问题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UI&lt;/code&gt;图完美适配方案&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iPhoneX&lt;/code&gt;适配方案&lt;/li&gt;
&lt;li&gt;横屏适配&lt;/li&gt;
&lt;li&gt;高清屏图片模糊问题&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面这些问题可能我们在开发中已经知道如何解决，但是问题产生的原理，以及解决方案的原理可能会模糊不清。在解决这些问题的过程中，我们往往会遇到非常多的概念：像素、分辨率、&lt;code&gt;PPI&lt;/code&gt;、&lt;code&gt;DPI&lt;/code&gt;、&lt;code&gt;DP&lt;/code&gt;、&lt;code&gt;DIP&lt;/code&gt;、&lt;code&gt;DPR&lt;/code&gt;、视口等等，你真的能分清这些概念的意义吗？&lt;/p&gt;
&lt;p&gt;本文将从移动端适配的基础概念出发，探究移动端适配各种问题的解决方案和实现原理。&lt;/p&gt;
&lt;h2 id=&quot;一、英寸&quot;&gt;&lt;a href=&quot;#一、英寸&quot; class=&quot;headerlink&quot; title=&quot;一、英寸&quot;&gt;&lt;/a&gt;一、英寸&lt;/h2&gt;&lt;p&gt;一般用英寸描述屏幕的物理大小，如电脑显示器的&lt;code&gt;17&lt;/code&gt;、&lt;code&gt;22&lt;/code&gt;，手机显示器的&lt;code&gt;4.8&lt;/code&gt;、&lt;code&gt;5.7&lt;/code&gt;等使用的单位都是英寸。&lt;/p&gt;
&lt;p&gt;需要注意，上面的尺寸都是屏幕对角线的长度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/17/5cddefa632f3247082.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;英寸(&lt;code&gt;inch&lt;/code&gt;,缩写为&lt;code&gt;in&lt;/code&gt;)在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。&lt;/p&gt;
&lt;p&gt;英寸和厘米的换算：&lt;code&gt;1英寸 = 2.54 厘米&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、分辨率&quot;&gt;&lt;a href=&quot;#二、分辨率&quot; class=&quot;headerlink&quot; title=&quot;二、分辨率&quot;&gt;&lt;/a&gt;二、分辨率&lt;/h2&gt;&lt;h3 id=&quot;2-1-像素&quot;&gt;&lt;a href=&quot;#2-1-像素&quot; class=&quot;headerlink&quot; title=&quot;2.1 像素&quot;&gt;&lt;/a&gt;2.1 像素&lt;/h3&gt;&lt;p&gt;像素即一个小方块，它具有特定的位置和颜色。&lt;/p&gt;
&lt;p&gt;图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。&lt;/p&gt;
&lt;p&gt;像素可以作为图片或电子屏幕的最小组成单位。&lt;/p&gt;
&lt;p&gt;下面我们使用&lt;code&gt;sketch&lt;/code&gt;打开一张图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/17/5cddefd18987943848.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;将这些图片放大即可看到这些像素点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/17/5cddefb8d84ab76156.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用JS开发桌面应用（五）终篇</title>
    <link href="http://yoursite.com/2019/05/17/2019-05-17-Programing-JavaScript-use-js-develop-desk-app-5/"/>
    <id>http://yoursite.com/2019/05/17/2019-05-17-Programing-JavaScript-use-js-develop-desk-app-5/</id>
    <published>2019-05-17T07:23:28.000Z</published>
    <updated>2019-11-25T07:25:14.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="十一、扩展能力"><a href="#十一、扩展能力" class="headerlink" title="十一、扩展能力"></a>十一、扩展能力</h2><p><img src="http://www.conardli.top/img/electron/el_4_iot.jpg" alt></p><p>在很多情况下，你的应用程序要和外部设备进行交互，一般情况下厂商会为你提供硬件设备的开发包，这些开发包基本上都是通过<code>C++</code> 编写，在使用<code>electron</code>开发的情况下，我们并不具备直接调用<code>C++</code>代码的能力，我们可以利用<code>node-ffi</code>来实现这一功能。</p><p><code>node-ffi</code>提供了一组强大的工具，用于在<code>Node.js</code>环境中使用纯<code>JavaScript</code>调用动态链接库接口。它可以用来为库构建接口绑定，而不需要使用任何<code>C++</code>代码。</p><blockquote><p>注意<code>node-ffi</code>并不能直接调用<code>C++</code>代码，你需要将<code>C++</code>代码编译为动态链接库：在 <code>Windows</code>下是 <code>Dll</code> ，在 <code>Mac OS</code>下是 <code>dylib</code> <code>，Linux</code> 是 <code>so</code> 。</p><p><code>node-ffi</code> 加载 <code>Library</code>是有限制的，只能处理 <code>C</code>风格的 <code>Library</code>。 </p></blockquote><p>下面是一个简单的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ffi = <span class="built_in">require</span>(<span class="string">'ffi'</span>);</span><br><span class="line"><span class="keyword">const</span> ref = <span class="built_in">require</span>(<span class="string">'ref'</span>);</span><br><span class="line"><span class="keyword">const</span> SHORT_CODE = ref.refType(<span class="string">'short'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DLL = <span class="keyword">new</span> ffi.Library(<span class="string">'test.dll'</span>, &#123;</span><br><span class="line">    Test_CPP_Method: [<span class="string">'int'</span>, [<span class="string">'string'</span>,SHORT_CODE]], </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">testCppMethod(str: <span class="built_in">String</span>, <span class="attr">num</span>: number): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result: any = DLL.Test_CPP_Method(str, num);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'调用失败～'</span>,error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.testCppMethod(<span class="string">'ConardLi'</span>,<span class="number">123</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面的代码中，我们用<code>ffi</code>包装<code>C++</code>接口生成的动态链接库<code>test.dll</code>，并使用<code>ref</code>进行一些类型映射。</p><p>使用<code>JavaScript</code>调用这些映射方法时，推荐使用<code>TypeScript</code>来约定参数类型，因为弱类型的<code>JavaScript</code>在调用强类型语言的接口时可能会带来意想不到的风险。</p><p>借助这一能力，前端开发工程师也可以在<code>IOT</code>领域一展身手了😎～</p><h2 id="十二、环境选择"><a href="#十二、环境选择" class="headerlink" title="十二、环境选择"></a>十二、环境选择</h2><p>一般情况下，我们的应用程序可能运行在多套环境下（<code>production</code>、<code>beta</code>、<code>uat</code>、<code>moke</code>、<code>development</code>…），不同的开发环境可能对应不同的后端接口或者其他配置，我们可以在客户端程序中内置一个简单的环境选择功能来帮助我们更高效的开发。</p><p><img src="http://www.conardli.top/img/electron/el_14_env.png" alt></p><p>具体策略如下：</p><p><img src="http://www.conardli.top/img/electron/el_15_env.png" alt></p><ul><li>在开发环境中，我们直接进入环境选择页面，读取到选择的环境后进行响应的重定向操作</li><li>在菜单保留环境选择入口，以便在开发过程中切换</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> envList = [<span class="string">"moke"</span>, <span class="string">"beta"</span>, <span class="string">"development"</span>, <span class="string">"production"</span>];</span><br><span class="line">exports.envList = envList;</span><br><span class="line"><span class="keyword">const</span> urlBeta = <span class="string">'https://wwww.xxx-beta.com'</span>;</span><br><span class="line"><span class="keyword">const</span> urlDev = <span class="string">'https://wwww.xxx-dev.com'</span>;</span><br><span class="line"><span class="keyword">const</span> urlProp = <span class="string">'https://wwww.xxx-prop.com'</span>;</span><br><span class="line"><span class="keyword">const</span> urlMoke = <span class="string">'https://wwww.xxx-moke.com'</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(path.resolve(global.__dirname, <span class="string">'package.json'</span>));</span><br><span class="line"><span class="keyword">const</span> build = pkg[<span class="string">'build-config'</span>];</span><br><span class="line">exports.handleEnv = &#123;</span><br><span class="line">  build,</span><br><span class="line">  currentEnv: <span class="string">'moke'</span>,</span><br><span class="line">  setEnv: <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentEnv = env</span><br><span class="line">  &#125;,</span><br><span class="line">  getUrl: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'env:'</span>, build.env);</span><br><span class="line">    <span class="keyword">if</span> (build.env === <span class="string">'production'</span> || <span class="keyword">this</span>.currentEnv === <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlProp;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.currentEnv === <span class="string">'moke'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlMoke;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.currentEnv === <span class="string">'development'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlDev;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.currentEnv === <span class="string">"beta"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> urlBeta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isDebugger: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build.env === <span class="string">'development'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十三、打包"><a href="#十三、打包" class="headerlink" title="十三、打包"></a>十三、打包</h2><p>最后也是最重要的一步，将写好的代码打包成可运行的<code>.app</code>或<code>.exe</code>可执行文件。</p><p>这里我把打包氛围两部分来做，渲染进程打包和主进程打包。</p><h3 id="13-1-渲染进程打包和升级"><a href="#13-1-渲染进程打包和升级" class="headerlink" title="13.1 渲染进程打包和升级"></a>13.1 渲染进程打包和升级</h3><p>一般情况下，我们的大部分业务逻辑代码是在渲染进程完成的，在大部分情况下我们仅仅需要对渲染进程进行更新和升级而不需要改动主进程代码，我们渲染进程的打包实际上和一般的<code>web</code>项目打包没有太大差别，使用<code>webpack</code>打包即可。</p><p>这里我说说渲染进程单独打包的好处：</p><p>打包完成的<code>html</code>和<code>js</code>文件，我们一般要上传到我们的前端静态资源服务器下，然后告知服务端我们的渲染进程有代码更新，这里可以说成渲染进程单独的升级。</p><p>注意，和壳的升级不同，渲染进程的升级仅仅是静态资源服务器上<code>html</code>和<code>js</code>文件的更新，而不需要重新下载更新客户端，这样我们每次启动程序的时候检测到离线包有更新，即可直接刷新读取最新版本的静态资源文件，即使在程序运行过程中要强制更新，我们的程序只需要强制刷新页面读取最新的静态资源即可，这样的升级对用户是非常友好的。</p><p>这里注意，一旦我们这样配置，就意味着渲染进程和主进程打包升级的完全分离，我们在启动主窗口时读取的文件就不应该再是本地文件，而是打包完成后放在静态资源服务器的文件。</p><p>为了方便开发，这里我们可以区分本地和线上加载不同的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVersion</span> (<span class="params">mac,current</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 根据设备mac和当前版本获取最新版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (build.env === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> version = getVersion (mac,current);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'https://www.xxxserver.html/electron-react/index_'</span>+version+<span class="string">'.html'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url.format(&#123;</span><br><span class="line">    protocol: <span class="string">'file:'</span>,</span><br><span class="line">    pathname: path.join(__dirname, <span class="string">'env/environment.html'</span>),</span><br><span class="line">    slashes: <span class="literal">true</span>,</span><br><span class="line">    query: &#123; <span class="attr">debugger</span>: build.env === <span class="string">"development"</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的<code>webpack</code>配置这里就不再贴出。</p><p>这里需要注意，在开发环境下我们可以结合<code>webpack</code>的<code>devServer</code>和<code>electron</code>命令来启动<code>app</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: <span class="string">'./assets/'</span>,</span><br><span class="line">  historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  port: PORT,</span><br><span class="line">  noInfo: <span class="literal">false</span>,</span><br><span class="line">  stats: &#123;</span><br><span class="line">    colors: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    spawn(</span><br><span class="line">      <span class="string">'electron'</span>,</span><br><span class="line">      [<span class="string">'.'</span>],</span><br><span class="line">      &#123;</span><br><span class="line">        shell: <span class="literal">true</span>,</span><br><span class="line">        stdio: <span class="string">'inherit'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      .on(<span class="string">'close'</span>, () =&gt; process.exit(<span class="number">0</span>))</span><br><span class="line">      .on(<span class="string">'error'</span>, e =&gt; <span class="built_in">console</span>.error(e));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,<span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="13-2-主进程打包"><a href="#13-2-主进程打包" class="headerlink" title="13.2 主进程打包"></a>13.2 主进程打包</h3><p> 主进程，即将整个程序打包成可运行的客户端程序，常用的打包方案一般有两种，<code>electron-packager</code>和<code>electron-builder</code>。</p><p> <code>electron-packager</code>在打包配置上我觉得有些繁琐，而且它只能将应用直接打包为可执行程序。</p><p> 这里我推荐使用<code>electron-builder</code>，它不仅拥有方便的配置 <code>protocol</code> 的功能、内置的 <code>Auto Update</code>、简单的配置 <code>package.json</code> 便能完成整个打包工作，用户体验非常不错。而且<code>electron-builder</code>不仅能直接将应用打包成<code>exe app</code>等可执行程序，还能打包成<code>msi dmg</code>等安装包格式。</p><p> 你可以在<code>package.json</code>方便的进行各种配置：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build"</span>: &#123;</span><br><span class="line">  <span class="string">"productName"</span>: <span class="string">"electron-react"</span>, <span class="comment">// app中文名称</span></span><br><span class="line">  <span class="string">"appId"</span>: <span class="string">"electron-react"</span>,<span class="comment">// app标识</span></span><br><span class="line">  <span class="string">"directories"</span>: &#123; <span class="comment">// 打包后输出的文件夹</span></span><br><span class="line">    <span class="string">"buildResources"</span>: <span class="string">"resources"</span>,</span><br><span class="line">    <span class="string">"output"</span>: <span class="string">"dist/"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"files"</span>: [ <span class="comment">// 打包后依然保留的源文件</span></span><br><span class="line">    <span class="string">"main_process/"</span>,</span><br><span class="line">    <span class="string">"render_process/"</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"mac"</span>: &#123; <span class="comment">// mac打包配置</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"dmg"</span>,</span><br><span class="line">    <span class="string">"icon"</span>: <span class="string">"icon.ico"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"win"</span>: &#123; <span class="comment">// windows打包配置</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"nsis"</span>,</span><br><span class="line">    <span class="string">"icon"</span>: <span class="string">"icon.ico"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"dmg"</span>: &#123; <span class="comment">// dmg文件打包配置</span></span><br><span class="line">    <span class="string">"artifactName"</span>: <span class="string">"electron_react.dmg"</span>,</span><br><span class="line">    <span class="string">"contents"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="string">"path"</span>: <span class="string">"/Applications"</span>,</span><br><span class="line">        <span class="string">"x"</span>: <span class="number">410</span>,</span><br><span class="line">        <span class="string">"y"</span>: <span class="number">150</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"file"</span>,</span><br><span class="line">        <span class="string">"x"</span>: <span class="number">130</span>,</span><br><span class="line">        <span class="string">"y"</span>: <span class="number">150</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"nsis"</span>: &#123; <span class="comment">// nsis文件打包配置</span></span><br><span class="line">    <span class="string">"oneClick"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"allowToChangeInstallationDirectory"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"shortcutName"</span>: <span class="string">"electron-react"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 执行<code>electron-builder</code>打包命令时，可指定参数进行打包。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--mac, -m, -o, --macos   macOS打包</span><br><span class="line">--linux, -l              Linux打包</span><br><span class="line">--win, -w, --windows     Windows打包</span><br><span class="line">--mwl                    同时为macOS，Windows和Linux打包</span><br><span class="line">--x64                    x64 (<span class="number">64</span>位安装包)</span><br><span class="line">--ia32                   ia32(<span class="number">32</span>位安装包)</span><br></pre></td></tr></table></figure><p> 关于主进程的更新你可以使用<code>electron-builder</code>自带的<code>Auto Update</code>模块，在<code>electron-react</code>也实现了手动更新的模块。</p><h3 id="13-3-打包优化"><a href="#13-3-打包优化" class="headerlink" title="13.3 打包优化"></a>13.3 打包优化</h3><p><code>electron-builder</code>打包出来的<code>App</code>要比相同功能的原生客户端应用体积大很多，即使是空的应用，体积也要在<code>100mb</code>以上。原因有很多：</p><p>第一点；为了达到跨平台的效果，每个<code>Electron</code>应用都包含了整个<code>V8</code>引擎和<code>Chromium</code>内核。</p><p>第二点：打包时会将整个<code>node_modules</code>打包进去，大家都知道一个应用的<code>node_module</code>体积是非常庞大的，这也是使得<code>Electron</code>应用打包后的体积较大的原因。</p><p>第一点我们无法改变，我们可以从第二点对应用体积进行优化：<code>Electron</code>在打包时只会将<code>denpendencies</code>的依赖打包进去，而不会将 <code>devDependencies</code> 中的依赖进行打包。所以我们应尽可能的减少<code>denpendencies</code>中的依赖。在上面的进程中，我们使用<code>webpack</code>对渲染进程进行打包，所以渲染进程的依赖全部都可以移入<code>devDependencies</code>。</p><p>另外，我们还可以使用双<code>packajson.json</code>的方式来进行优化，把只在开发环境中使用到的依赖放在整个项目的根目录的<code>package.json</code>下，将与平台相关的或者运行时需要的依赖装在<code>app</code>目录下。具体详见<a href="https://www.electron.build/tutorials/two-package-structure" target="_blank" rel="noopener">two-package-structure</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://electronjs.org/docs" target="_blank" rel="noopener">https://electronjs.org/docs</a></li><li><a href="http://jlord.us/essential-electron/" target="_blank" rel="noopener">http://jlord.us/essential-electron/</a></li><li><a href="https://imweb.io/topic/5b9f500cc2ec8e6772f34d79" target="_blank" rel="noopener">https://imweb.io/topic/5b9f500cc2ec8e6772f34d79</a></li><li><a href="https://www.jianshu.com/p/1ece6fd7a80c" target="_blank" rel="noopener">https://www.jianshu.com/p/1ece6fd7a80c</a></li><li><a href="https://zhuanlan.zhihu.com/p/52991793" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52991793</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p><ul><li>了解<code>Electron</code>的基本运行原理</li><li>掌握<code>Electron</code>开发的核心基础知识</li><li>了解<code>Electron</code>关于弹框、打印、保护、打包等功能的基本使用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;十一、扩展能力&quot;&gt;&lt;a href=&quot;#十一、扩展能力&quot; class=&quot;headerlink&quot; title=&quot;十一、扩展能力&quot;&gt;&lt;/a&gt;十一、扩展能力&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.conardli.top/img/electron/el_4_iot.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;在很多情况下，你的应用程序要和外部设备进行交互，一般情况下厂商会为你提供硬件设备的开发包，这些开发包基本上都是通过&lt;code&gt;C++&lt;/code&gt; 编写，在使用&lt;code&gt;electron&lt;/code&gt;开发的情况下，我们并不具备直接调用&lt;code&gt;C++&lt;/code&gt;代码的能力，我们可以利用&lt;code&gt;node-ffi&lt;/code&gt;来实现这一功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node-ffi&lt;/code&gt;提供了一组强大的工具，用于在&lt;code&gt;Node.js&lt;/code&gt;环境中使用纯&lt;code&gt;JavaScript&lt;/code&gt;调用动态链接库接口。它可以用来为库构建接口绑定，而不需要使用任何&lt;code&gt;C++&lt;/code&gt;代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意&lt;code&gt;node-ffi&lt;/code&gt;并不能直接调用&lt;code&gt;C++&lt;/code&gt;代码，你需要将&lt;code&gt;C++&lt;/code&gt;代码编译为动态链接库：在 &lt;code&gt;Windows&lt;/code&gt;下是 &lt;code&gt;Dll&lt;/code&gt; ，在 &lt;code&gt;Mac OS&lt;/code&gt;下是 &lt;code&gt;dylib&lt;/code&gt; &lt;code&gt;，Linux&lt;/code&gt; 是 &lt;code&gt;so&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node-ffi&lt;/code&gt; 加载 &lt;code&gt;Library&lt;/code&gt;是有限制的，只能处理 &lt;code&gt;C&lt;/code&gt;风格的 &lt;code&gt;Library&lt;/code&gt;。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是一个简单的实例：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; ffi = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ffi&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; ref = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ref&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SHORT_CODE = ref.refType(&lt;span class=&quot;string&quot;&gt;&#39;short&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; DLL = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ffi.Library(&lt;span class=&quot;string&quot;&gt;&#39;test.dll&#39;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Test_CPP_Method: [&lt;span class=&quot;string&quot;&gt;&#39;int&#39;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&#39;string&#39;&lt;/span&gt;,SHORT_CODE]], &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;testCppMethod(str: &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;num&lt;/span&gt;: number): &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; result: any = DLL.Test_CPP_Method(str, num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;调用失败～&#39;&lt;/span&gt;,error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.testCppMethod(&lt;span class=&quot;string&quot;&gt;&#39;ConardLi&#39;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用JS开发桌面应用（四）程序保护</title>
    <link href="http://yoursite.com/2019/05/13/2019-05-13-Programing-JavaScript-use-js-develop-desk-app-4/"/>
    <id>http://yoursite.com/2019/05/13/2019-05-13-Programing-JavaScript-use-js-develop-desk-app-4/</id>
    <published>2019-05-13T07:21:03.000Z</published>
    <updated>2019-11-25T07:25:04.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="十、程序保护"><a href="#十、程序保护" class="headerlink" title="十、程序保护"></a>十、程序保护</h2><p><a href="https://segmentfault.com/a/1190000007503495" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007503495</a></p><p><img src="http://www.conardli.top/img/electron/el_22_protect.gif" alt></p><h3 id="10-1-崩溃"><a href="#10-1-崩溃" class="headerlink" title="10.1 崩溃"></a>10.1 崩溃</h3><p>崩溃监控是每个客户端程序必备的保护功能，当程序崩溃时我们一般期望做到两件事：</p><ul><li>1.上传崩溃日志，及时报警</li><li>2.监控程序崩溃，提示用户重启程序</li></ul><p><code>electron</code>为我们提供给了<code>crashReporter</code>来帮助我们记录崩溃日志，我们可以通过<code>crashReporter.start</code>来创建一个崩溃报告器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; crashReporter &#125; = <span class="built_in">require</span>(<span class="string">"electron"</span>);</span><br><span class="line">crashReporter.start(&#123;</span><br><span class="line">  productName: <span class="string">"YourName"</span>,</span><br><span class="line">  companyName: <span class="string">"YourCompany"</span>,</span><br><span class="line">  submitURL: <span class="string">"https://your-domain.com/url-to-submit"</span>,</span><br><span class="line">  uploadToServer: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当程序发生崩溃时，崩溃报日志将被储存在临时文件夹中名为<code>YourName Crashes</code>的文件文件夹中。<code>submitURL</code>用于指定你的崩溃日志上传服务器。 在启动崩溃报告器之前，您可以通过调用<code>app.setPath(&#39;temp&#39;, &#39;my/custom/temp&#39;)</code>API 来自定义这些临时文件的保存路径。你还可以通过<code>crashReporter.getLastCrashReport()</code>来获取上次崩溃报告的日期和<code>ID</code>。</p><p>我们可以通过<code>webContents</code>的<code>crashed</code>来监听渲染进程的崩溃，另外经测试有些主进程的崩溃也会触发该事件。所以我们可以根据主<code>window</code>是否被销毁来判断进行不同的重启逻辑，下面使整个崩溃监控的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserWindow, crashReporter, dialog &#125; <span class="keyword">from</span> <span class="string">"electron"</span>;</span><br><span class="line"><span class="comment">// 开启进程崩溃记录</span></span><br><span class="line">crashReporter.start(&#123;</span><br><span class="line">  productName: <span class="string">"electron-react"</span>,</span><br><span class="line">  companyName: <span class="string">"ConardLi"</span>,</span><br><span class="line">  submitURL: <span class="string">"http://xxx.com"</span>, <span class="comment">// 上传崩溃日志的接口</span></span><br><span class="line">  uploadToServer: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reloadWindow</span>(<span class="params">mainWin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mainWin.isDestroyed()) &#123;</span><br><span class="line">    app.relaunch();</span><br><span class="line">    app.exit(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 销毁其他窗口</span></span><br><span class="line">    BrowserWindow.getAllWindows().forEach(<span class="function"><span class="params">w</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (w.id !== mainWin.id) w.destroy();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">      type: <span class="string">"info"</span>,</span><br><span class="line">      title: <span class="string">"渲染器进程崩溃"</span>,</span><br><span class="line">      message: <span class="string">"这个进程已经崩溃."</span>,</span><br><span class="line">      buttons: [<span class="string">"重载"</span>, <span class="string">"关闭"</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">    dialog.showMessageBox(options, index =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) mainWin.reload();</span><br><span class="line">      <span class="keyword">else</span> mainWin.close();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mainWindow = BrowserWindow.fromId(global.mainId);</span><br><span class="line">  mainWindow.webContents.on(<span class="string">"crashed"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> errorMessage = crashReporter.getLastCrashReport();</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"程序崩溃了！"</span>, errorMessage); <span class="comment">// 可单独上传日志</span></span><br><span class="line">    reloadWindow(mainWindow);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="10-2-最小化到托盘"><a href="#10-2-最小化到托盘" class="headerlink" title="10.2 最小化到托盘"></a>10.2 最小化到托盘</h3><p>有的时候我们并不想让用户通过点关闭按钮的时候就关闭程序，而是把程序最小化到托盘，在托盘上做真正的退出操作。</p><p>首先要监听窗口的关闭事件，阻止用户关闭操作的默认行为，将窗口隐藏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkQuit</span>(<span class="params">mainWindow, event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    type: <span class="string">"info"</span>,</span><br><span class="line">    title: <span class="string">"关闭确认"</span>,</span><br><span class="line">    message: <span class="string">"确认要最小化程序到托盘吗？"</span>,</span><br><span class="line">    buttons: [<span class="string">"确认"</span>, <span class="string">"关闭程序"</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  dialog.showMessageBox(options, index =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">      mainWindow.hide();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mainWindow = <span class="literal">null</span>;</span><br><span class="line">      app.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleQuit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mainWindow = BrowserWindow.fromId(global.mainId);</span><br><span class="line">  mainWindow.on(<span class="string">"close"</span>, event =&gt; &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    checkQuit(mainWindow, event);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时程序就再也找不到了，任务托盘中也没有我们的程序，所以我们要先创建好任务托盘，并做好事件监听。</p><blockquote><p>windows 平台使用<code>ico</code>文件可以达到更好的效果</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createTray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mainWindow = BrowserWindow.fromId(global.mainId);</span><br><span class="line">  <span class="keyword">const</span> iconName = process.platform === <span class="string">"win32"</span> ? <span class="string">"icon.ico"</span> : <span class="string">"icon.png"</span>;</span><br><span class="line">  tray = <span class="keyword">new</span> Tray(path.join(global.__dirname, iconName));</span><br><span class="line">  <span class="keyword">const</span> contextMenu = Menu.buildFromTemplate([</span><br><span class="line">    &#123;</span><br><span class="line">      label: <span class="string">"显示主界面"</span>,</span><br><span class="line">      click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        mainWindow.show();</span><br><span class="line">        mainWindow.setSkipTaskbar(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      label: <span class="string">"退出"</span>,</span><br><span class="line">      click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        mainWindow.destroy();</span><br><span class="line">        app.quit();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  tray.setToolTip(<span class="string">"electron-react"</span>);</span><br><span class="line">  tray.setContextMenu(contextMenu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;十、程序保护&quot;&gt;&lt;a href=&quot;#十、程序保护&quot; class=&quot;headerlink&quot; title=&quot;十、程序保护&quot;&gt;&lt;/a&gt;十、程序保护&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007503495&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000007503495&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.conardli.top/img/electron/el_22_protect.gif&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;10-1-崩溃&quot;&gt;&lt;a href=&quot;#10-1-崩溃&quot; class=&quot;headerlink&quot; title=&quot;10.1 崩溃&quot;&gt;&lt;/a&gt;10.1 崩溃&lt;/h3&gt;&lt;p&gt;崩溃监控是每个客户端程序必备的保护功能，当程序崩溃时我们一般期望做到两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.上传崩溃日志，及时报警&lt;/li&gt;
&lt;li&gt;2.监控程序崩溃，提示用户重启程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;electron&lt;/code&gt;为我们提供给了&lt;code&gt;crashReporter&lt;/code&gt;来帮助我们记录崩溃日志，我们可以通过&lt;code&gt;crashReporter.start&lt;/code&gt;来创建一个崩溃报告器：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; crashReporter &amp;#125; = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;electron&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;crashReporter.start(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  productName: &lt;span class=&quot;string&quot;&gt;&quot;YourName&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  companyName: &lt;span class=&quot;string&quot;&gt;&quot;YourCompany&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  submitURL: &lt;span class=&quot;string&quot;&gt;&quot;https://your-domain.com/url-to-submit&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  uploadToServer: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当程序发生崩溃时，崩溃报日志将被储存在临时文件夹中名为&lt;code&gt;YourName Crashes&lt;/code&gt;的文件文件夹中。&lt;code&gt;submitURL&lt;/code&gt;用于指定你的崩溃日志上传服务器。 在启动崩溃报告器之前，您可以通过调用&lt;code&gt;app.setPath(&amp;#39;temp&amp;#39;, &amp;#39;my/custom/temp&amp;#39;)&lt;/code&gt;API 来自定义这些临时文件的保存路径。你还可以通过&lt;code&gt;crashReporter.getLastCrashReport()&lt;/code&gt;来获取上次崩溃报告的日期和&lt;code&gt;ID&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;code&gt;webContents&lt;/code&gt;的&lt;code&gt;crashed&lt;/code&gt;来监听渲染进程的崩溃，另外经测试有些主进程的崩溃也会触发该事件。所以我们可以根据主&lt;code&gt;window&lt;/code&gt;是否被销毁来判断进行不同的重启逻辑，下面使整个崩溃监控的逻辑：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; BrowserWindow, crashReporter, dialog &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;electron&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 开启进程崩溃记录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;crashReporter.start(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  productName: &lt;span class=&quot;string&quot;&gt;&quot;electron-react&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  companyName: &lt;span class=&quot;string&quot;&gt;&quot;ConardLi&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  submitURL: &lt;span class=&quot;string&quot;&gt;&quot;http://xxx.com&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 上传崩溃日志的接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  uploadToServer: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reloadWindow&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;mainWin&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mainWin.isDestroyed()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    app.relaunch();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    app.exit(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 销毁其他窗口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BrowserWindow.getAllWindows().forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;w&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (w.id !== mainWin.id) w.destroy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; options = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      type: &lt;span class=&quot;string&quot;&gt;&quot;info&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      title: &lt;span class=&quot;string&quot;&gt;&quot;渲染器进程崩溃&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      message: &lt;span class=&quot;string&quot;&gt;&quot;这个进程已经崩溃.&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      buttons: [&lt;span class=&quot;string&quot;&gt;&quot;重载&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;关闭&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dialog.showMessageBox(options, index =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (index === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) mainWin.reload();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; mainWin.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; mainWindow = BrowserWindow.fromId(global.mainId);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  mainWindow.webContents.on(&lt;span class=&quot;string&quot;&gt;&quot;crashed&quot;&lt;/span&gt;, () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; errorMessage = crashReporter.getLastCrashReport();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.error(&lt;span class=&quot;string&quot;&gt;&quot;程序崩溃了！&quot;&lt;/span&gt;, errorMessage); &lt;span class=&quot;comment&quot;&gt;// 可单独上传日志&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reloadWindow(mainWindow);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用JS开发桌面应用（三）打印篇</title>
    <link href="http://yoursite.com/2019/05/09/2019-05-09-Programing-JavaScript-use-js-develop-desk-app-3/"/>
    <id>http://yoursite.com/2019/05/09/2019-05-09-Programing-JavaScript-use-js-develop-desk-app-3/</id>
    <published>2019-05-09T07:18:14.000Z</published>
    <updated>2019-11-25T07:22:11.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="九、打印"><a href="#九、打印" class="headerlink" title="九、打印"></a>九、打印</h2><p>很多情况下程序中使用的打印都是用户无感知的。并且想要灵活的控制打印内容，往往需要借助打印机给我们提供的<code>api</code>再进行开发，这种开发方式非常繁琐，并且开发难度较大。第一次在业务中用到<code>Electron</code>其实就是用到它的打印功能，这里就多介绍一些。</p><p><code>Electron</code>提供的打印api可以非常灵活的控制打印设置的显示，并且可以通过html来书写打印内容。<code>Electron</code>提供了两种方式进行打印，一种是直接调用打印机打印，一种是打印到<code>pdf</code>。</p><p>并且有两种对象可以调用打印：</p><ul><li>通过<code>window</code>的<code>webcontent</code>对象，使用此种方式需要单独开出一个打印的窗口，可以将该窗口隐藏，但是通信调用相对复杂。</li><li>使用页面的<code>webview</code>元素调用打印，可以将<code>webview</code>隐藏在调用的页面中，通信方式比较简单。</li></ul><p>上面两种方式同时拥有<code>print</code>和<code>printToPdf</code>方法。</p><p><img src="http://www.conardli.top/img/electron/el_23_print.gif" alt></p><h3 id="9-1-调用系统打印"><a href="#9-1-调用系统打印" class="headerlink" title="9.1 调用系统打印"></a>9.1 调用系统打印</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contents.print([options], [callback])；</span><br></pre></td></tr></table></figure><p>打印配置(options)中只有简单的三个配置：</p><ul><li><code>silent</code>：打印时是否不展示打印配置（是否静默打印）</li><li><code>printBackground</code>：是否打印背景</li><li><code>deviceName</code>：打印机设备名称</li></ul><p>首先要将我们使用的打印机名称配置好，并且要在调用打印前首先要判断打印机是否可用。</p><p>使用<code>webContents</code>的<code>getPrinters</code>方法可获取当前设备已经配置的打印机列表，注意配置过不是可用，只是在此设备上安装过驱动。</p><p>通过<code>getPrinters</code>获取到的打印机对象：<a href="https://electronjs.org/docs/api/structures/printer-info" target="_blank" rel="noopener">https://electronjs.org/docs/api/structures/printer-info</a></p><p>我们这里只管关心两个，<code>name</code>和<code>status</code>，<code>status</code>为<code>0</code>时表示打印机可用。</p><p><code>print</code>的第二个参数<code>callback</code>是用于判断打印任务是否发出的回调，而不是打印任务完成后的回调。所以一般打印任务发出，回调函数即会调用并返回参数<code>true</code>。这个回调并不能判断打印是否真的成功了。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.state.curretnPrinter) &#123;</span><br><span class="line">  mainWindow.webContents.print(&#123;</span><br><span class="line">    silent: silent, <span class="attr">printBackground</span>: <span class="literal">true</span>, <span class="attr">deviceName</span>: <span class="keyword">this</span>.state.curretnPrinter</span><br><span class="line">  &#125;, () =&gt; &#123; &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  remote.dialog.showErrorBox(<span class="string">'错误'</span>, <span class="string">'请先选择一个打印机！'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-打印到PDF"><a href="#9-2-打印到PDF" class="headerlink" title="9.2 打印到PDF"></a>9.2 打印到PDF</h3><p><code>printToPdf</code>的用法基本和<code>print</code>相同，但是<code>print</code>的配置项非常少，而<code>printToPdf</code>则扩展了很多属性。这里翻了一下源码发现还有很多没有被贴进api的，大概有三十几个包括可以对打印的margin，打印页眉页脚等进行配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contents.printToPDF(options, callback)</span><br></pre></td></tr></table></figure><p><code>callback</code>函数在打印失败或打印成功后调用，可获取打印失败信息或包含<code>PDF</code>数据的缓冲区。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pdfPath = path.join(os.tmpdir(), <span class="string">'webviewPrint.pdf'</span>);</span><br><span class="line"><span class="keyword">const</span> webview = <span class="built_in">document</span>.getElementById(<span class="string">'printWebview'</span>);</span><br><span class="line"><span class="keyword">const</span> renderHtml = <span class="string">'我是被临时插入webview的内容...'</span>;</span><br><span class="line">webview.executeJavaScript(<span class="string">'document.documentElement.innerHTML =`'</span> + renderHtml + <span class="string">'`;'</span>);</span><br><span class="line">webview.printToPDF(&#123;&#125;, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err, data);</span><br><span class="line">  fs.writeFile(pdfPath, data, (error) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">    shell.openExternal(<span class="string">`file://<span class="subst">$&#123;pdfPath&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">webviewPdfPath</span>: pdfPath &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>这个例子中的打印是使用<code>webview</code>完成的，通过调用<code>executeJavaScript</code>方法可动态向<code>webview</code>插入打印内容。</p></blockquote><h3 id="9-3-两种打印方案的选择"><a href="#9-3-两种打印方案的选择" class="headerlink" title="9.3 两种打印方案的选择"></a>9.3 两种打印方案的选择</h3><p>上面提到，使用<code>webview</code>和<code>webcontent</code>都可以调用打印功能，使用<code>webcontent</code>打印，首先要有一个打印窗口，这个窗口不能随时打印随时创建，比较耗费性能。可以将它在程序运行时启动好，并做好事件监听。</p><p>此过程需和调用打印的进行做好通信，大致过程如下：</p><p><img src="http://www.conardli.top/img/electron/el_24_print.png" alt></p><p>可见通信非常繁琐，使用<code>webview</code>进行打印可实现同样的效果但是通信方式会变得简单，因为渲染进程和<code>webview</code>通信不需要经过主进程，通过如下方式即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webview = <span class="built_in">document</span>.querySelector(<span class="string">'webview'</span>)</span><br><span class="line">webview.addEventListener(<span class="string">'ipc-message'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.channel)</span><br><span class="line">&#125;)</span><br><span class="line">webview.send(<span class="string">'ping'</span>)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line">ipcRenderer.on(<span class="string">'ping'</span>, () =&gt; &#123;</span><br><span class="line">  ipcRenderer.sendToHost(<span class="string">'pong'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="9-4-打印功能封装"><a href="#9-4-打印功能封装" class="headerlink" title="9.4 打印功能封装"></a>9.4 打印功能封装</h3><p>下面是几个针对常用打印功能的工具函数封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取系统打印机列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getPrinters</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> printers = [];</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> contents = remote.getCurrentWindow().webContents;</span><br><span class="line">    printers = contents.getPrinters();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'getPrintersError'</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> printers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取系统默认打印机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getDefaultPrinter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getPrinters().find(<span class="function"><span class="params">element</span> =&gt;</span> element.isDefault);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测是否安装了某个打印驱动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">checkDriver</span>(<span class="params">driverMame</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getPrinters().find(<span class="function"><span class="params">element</span> =&gt;</span> (element.options[<span class="string">"printer-make-and-model"</span>] || <span class="string">''</span>).includes(driverMame));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据打印机名称获取打印机对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getPrinterByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getPrinters().find(<span class="function"><span class="params">element</span> =&gt;</span> element.name === name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>希望你阅读本篇文章后可以达到以下几点：</p><ul><li>了解<code>Electron</code>的基本运行原理</li><li>掌握<code>Electron</code>开发的核心基础知识</li><li>了解<code>Electron</code>关于弹框、打印、保护、打包等功能的基本使用</li></ul><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;九、打印&quot;&gt;&lt;a href=&quot;#九、打印&quot; class=&quot;headerlink&quot; title=&quot;九、打印&quot;&gt;&lt;/a&gt;九、打印&lt;/h2&gt;&lt;p&gt;很多情况下程序中使用的打印都是用户无感知的。并且想要灵活的控制打印内容，往往需要借助打印机给我们提供的&lt;code&gt;api&lt;/code&gt;再进行开发，这种开发方式非常繁琐，并且开发难度较大。第一次在业务中用到&lt;code&gt;Electron&lt;/code&gt;其实就是用到它的打印功能，这里就多介绍一些。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Electron&lt;/code&gt;提供的打印api可以非常灵活的控制打印设置的显示，并且可以通过html来书写打印内容。&lt;code&gt;Electron&lt;/code&gt;提供了两种方式进行打印，一种是直接调用打印机打印，一种是打印到&lt;code&gt;pdf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;并且有两种对象可以调用打印：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;window&lt;/code&gt;的&lt;code&gt;webcontent&lt;/code&gt;对象，使用此种方式需要单独开出一个打印的窗口，可以将该窗口隐藏，但是通信调用相对复杂。&lt;/li&gt;
&lt;li&gt;使用页面的&lt;code&gt;webview&lt;/code&gt;元素调用打印，可以将&lt;code&gt;webview&lt;/code&gt;隐藏在调用的页面中，通信方式比较简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面两种方式同时拥有&lt;code&gt;print&lt;/code&gt;和&lt;code&gt;printToPdf&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.conardli.top/img/electron/el_23_print.gif&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;9-1-调用系统打印&quot;&gt;&lt;a href=&quot;#9-1-调用系统打印&quot; class=&quot;headerlink&quot; title=&quot;9.1 调用系统打印&quot;&gt;&lt;/a&gt;9.1 调用系统打印&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;contents.print([options], [callback])；&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;打印配置(options)中只有简单的三个配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;silent&lt;/code&gt;：打印时是否不展示打印配置（是否静默打印）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printBackground&lt;/code&gt;：是否打印背景&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deviceName&lt;/code&gt;：打印机设备名称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先要将我们使用的打印机名称配置好，并且要在调用打印前首先要判断打印机是否可用。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;webContents&lt;/code&gt;的&lt;code&gt;getPrinters&lt;/code&gt;方法可获取当前设备已经配置的打印机列表，注意配置过不是可用，只是在此设备上安装过驱动。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;getPrinters&lt;/code&gt;获取到的打印机对象：&lt;a href=&quot;https://electronjs.org/docs/api/structures/printer-info&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://electronjs.org/docs/api/structures/printer-info&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们这里只管关心两个，&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;status&lt;/code&gt;，&lt;code&gt;status&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;时表示打印机可用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print&lt;/code&gt;的第二个参数&lt;code&gt;callback&lt;/code&gt;是用于判断打印任务是否发出的回调，而不是打印任务完成后的回调。所以一般打印任务发出，回调函数即会调用并返回参数&lt;code&gt;true&lt;/code&gt;。这个回调并不能判断打印是否真的成功了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用JS开发桌面应用（二）- 应用篇</title>
    <link href="http://yoursite.com/2019/05/06/2019-05-06-Programing-JavaScript-use-js-develop-desk-app-2/"/>
    <id>http://yoursite.com/2019/05/06/2019-05-06-Programing-JavaScript-use-js-develop-desk-app-2/</id>
    <published>2019-05-06T07:15:42.000Z</published>
    <updated>2019-11-25T07:22:06.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="五、窗口"><a href="#五、窗口" class="headerlink" title="五、窗口"></a>五、窗口</h2><h3 id="5-1-BrowserWindow"><a href="#5-1-BrowserWindow" class="headerlink" title="5.1 BrowserWindow"></a>5.1 BrowserWindow</h3><p>主进程模块<code>BrowserWindow</code>用于创建和控制浏览器窗口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  width: <span class="number">1000</span>,</span><br><span class="line">  height: <span class="number">800</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line">mainWindow.loadURL(<span class="string">"http://www.conardli.top/"</span>);</span><br></pre></td></tr></table></figure><p>你可以在<a href="https://electronjs.org/docs/api/browser-window#new-browserwindowoptions" target="_blank" rel="noopener">这里</a>查看它所有的构造参数。</p><p><img src="http://www.conardli.top/img/electron/el_13_window.gif" alt></p><h3 id="5-2-无框窗口"><a href="#5-2-无框窗口" class="headerlink" title="5.2 无框窗口"></a>5.2 无框窗口</h3><blockquote><p>无框窗口是没有镶边的窗口，窗口的部分（如工具栏）不属于网页的一部分。</p></blockquote><p>在<code>BrowserWindow</code>的构造参数中，将<code>frame</code>设置为<code>false</code>可以指定窗口为无边框窗口，将工具栏隐藏后，就会产生两个问题：</p><ul><li>1.窗口控制按钮（最小化、全屏、关闭按钮）会被隐藏</li><li>2.无法拖拽移动窗口</li></ul><p>可以通过指定<code>titleBarStyle</code>选项来再将工具栏按钮显示出来，将其设置为<code>hidden</code>表示返回一个隐藏标题栏的全尺寸内容窗口，在左上角仍然有标准的窗口控制按钮。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  width: <span class="number">200</span>,</span><br><span class="line">  height: <span class="number">200</span>,</span><br><span class="line">  titleBarStyle: <span class="string">"hidden"</span>,</span><br><span class="line">  frame: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="5-3-窗口拖拽"><a href="#5-3-窗口拖拽" class="headerlink" title="5.3 窗口拖拽"></a>5.3 窗口拖拽</h3><p>默认情况下, 无边框窗口是不可拖拽的。我们可以在界面中通过<code>CSS</code>属性<code>-webkit-app-region: drag</code>手动制定拖拽区域。</p><p>在无框窗口中, 拖动行为可能与选择文本冲突，可以通过设定<code>-webkit-user-select: none;</code>禁用文本选择：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-webkit-app-region</span>: drag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相反的，在可拖拽区域内部设置 <code>-webkit-app-region: no-drag</code>则可以指定特定不可拖拽区域。</p></blockquote><h3 id="5-4-透明窗口"><a href="#5-4-透明窗口" class="headerlink" title="5.4 透明窗口"></a>5.4 透明窗口</h3><p>通过将<code>transparent</code>选项设置为<code>true</code>, 还可以使无框窗口透明:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  transparent: <span class="literal">true</span>,</span><br><span class="line">  frame: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-5-Webview"><a href="#5-5-Webview" class="headerlink" title="5.5 Webview"></a>5.5 Webview</h3><p>使用 <code>webview</code> 标签在<code>Electron</code> 应用中嵌入 “外来” 内容。外来内容包含在 <code>webview</code> 容器中。 应用中的嵌入页面可以控制外来内容的布局和重绘。</p><p>与 <code>iframe</code> 不同, <code>webview</code> 在与应用程序不同的进程中运行。它与您的网页没有相同的权限, 应用程序和嵌入内容之间的所有交互都将是异步的。</p><h2 id="六、对话框"><a href="#六、对话框" class="headerlink" title="六、对话框"></a>六、对话框</h2><p><code>dialog</code> 模块提供了<code>api</code>来展示原生的系统对话框，例如打开文件框，<code>alert</code>框，所以<code>web</code>应用可以给用户带来跟系统应用相同的体验。</p><blockquote><p>注意：dialog 是主进程模块，想要在渲染进程调用可以使用 remote</p></blockquote><p><img src="http://www.conardli.top/img/electron/el_16_dialog.gif" alt></p><h3 id="6-1-错误提示"><a href="#6-1-错误提示" class="headerlink" title="6.1 错误提示"></a>6.1 错误提示</h3><p><code>dialog.showErrorBox</code>用于显示一个显示错误消息的模态对话框。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote.dialog.showErrorBox(<span class="string">"错误"</span>, <span class="string">"这是一个错误弹框！"</span>);</span><br></pre></td></tr></table></figure><h3 id="6-2-对话框"><a href="#6-2-对话框" class="headerlink" title="6.2 对话框"></a>6.2 对话框</h3><p><code>dialog.showErrorBox</code>用于调用系统对话框，可以为指定几种不同的类型： “<code>none</code>“, “<code>info</code>“, “<code>error</code>“, “<code>question</code>“ 或者 “<code>warning</code>“。</p><blockquote><p>在 Windows 上, “question” 与”info”显示相同的图标, 除非你使用了 “icon” 选项设置图标。 在 macOS 上, “warning” 和 “error” 显示相同的警告图标</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">remote.dialog.showMessageBox(</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">"info"</span>,</span><br><span class="line">    title: <span class="string">"提示信息"</span>,</span><br><span class="line">    message: <span class="string">"这是一个对话弹框！"</span>,</span><br><span class="line">    buttons: [<span class="string">"确定"</span>, <span class="string">"取消"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  index =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      dialogMessage: <span class="string">`【你点击了<span class="subst">$&#123;index ? <span class="string">"取消"</span> : <span class="string">"确定"</span>&#125;</span>！！】`</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="6-3-文件框"><a href="#6-3-文件框" class="headerlink" title="6.3 文件框"></a>6.3 文件框</h3><p><code>dialog.showOpenDialog</code>用于打开或选择系统目录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">remote.dialog.showOpenDialog(</span><br><span class="line">  &#123;</span><br><span class="line">    properties: [<span class="string">"openDirectory"</span>, <span class="string">"openFile"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  data =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">filePath</span>: <span class="string">`【选择路径：<span class="subst">$&#123;data[<span class="number">0</span>]&#125;</span>】 `</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="6-4-信息框"><a href="#6-4-信息框" class="headerlink" title="6.4 信息框"></a>6.4 信息框</h3><p>这里推荐直接使用<code>HTML5 API</code>，它只能在渲染器进程中使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">"信息框标题"</span>,</span><br><span class="line">  body: <span class="string">"我是一条信息～～～"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> myNotification = <span class="keyword">new</span> <span class="built_in">window</span>.Notification(options.title, options);</span><br><span class="line">myNotification.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">message</span>: <span class="string">"【你点击了信息框！！】"</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="七、系统"><a href="#七、系统" class="headerlink" title="七、系统"></a>七、系统</h2><h3 id="7-1-获取系统信息"><a href="#7-1-获取系统信息" class="headerlink" title="7.1 获取系统信息"></a>7.1 获取系统信息</h3><p><img src="http://www.conardli.top/img/electron/el_17_sys.png" alt></p><p>通过<code>remote</code>获取到主进程的<code>process</code>对象，可以获取到当前应用的各个版本信息：</p><ul><li><code>process.versions.electron</code>：<code>electron</code>版本信息</li><li><code>process.versions.chrome</code>：<code>chrome</code>版本信息</li><li><code>process.versions.node</code>：<code>node</code>版本信息</li><li><code>process.versions.v8</code>：<code>v8</code>版本信息</li></ul><p>获取当前应用根目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote.app.getAppPath();</span><br></pre></td></tr></table></figure><p>使用<code>node</code>的<code>os</code>模块获取当前系统根目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.homedir();</span><br></pre></td></tr></table></figure><h3 id="7-2-复制粘贴"><a href="#7-2-复制粘贴" class="headerlink" title="7.2 复制粘贴"></a>7.2 复制粘贴</h3><p><img src="http://www.conardli.top/img/electron/el_18_clipboard.gif" alt></p><p><code>Electron</code>提供的<code>clipboard</code>在渲染进程和主进程都可使用，用于在系统剪贴板上执行复制和粘贴操作。</p><p>以纯文本的形式写入剪贴板：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clipboard.writeText(text[, type])</span><br></pre></td></tr></table></figure><p>以纯文本的形式获取剪贴板的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clipboard.readText([type]);</span><br></pre></td></tr></table></figure><h3 id="7-3-截图"><a href="#7-3-截图" class="headerlink" title="7.3 截图"></a>7.3 截图</h3><p><code>desktopCapturer</code>用于从桌面捕获音频和视频的媒体源的信息。它只能在渲染进程中被调用。</p><p><img src="http://www.conardli.top/img/electron/el_19_cap.gif" alt></p><p>下面的代码是一个获取屏幕截图并保存的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">getImg = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">imgMsg</span>: <span class="string">"正在截取屏幕..."</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> thumbSize = <span class="keyword">this</span>.determineScreenShotSize();</span><br><span class="line">  <span class="keyword">let</span> options = &#123; <span class="attr">types</span>: [<span class="string">"screen"</span>], <span class="attr">thumbnailSize</span>: thumbSize &#125;;</span><br><span class="line">  desktopCapturer.getSources(options, (error, sources) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="built_in">console</span>.log(error);</span><br><span class="line">    sources.forEach(<span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (source.name === <span class="string">"Entire screen"</span> || source.name === <span class="string">"Screen 1"</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> screenshotPath = path.join(os.tmpdir(), <span class="string">"screenshot.png"</span>);</span><br><span class="line">        fs.writeFile(screenshotPath, source.thumbnail.toPNG(), error =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="built_in">console</span>.log(error);</span><br><span class="line">          shell.openExternal(<span class="string">`file://<span class="subst">$&#123;screenshotPath&#125;</span>`</span>);</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123; <span class="attr">imgMsg</span>: <span class="string">`截图保存到: <span class="subst">$&#123;screenshotPath&#125;</span>`</span> &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">determineScreenShotSize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> screenSize = screen.getPrimaryDisplay().workAreaSize;</span><br><span class="line">  <span class="keyword">const</span> maxDimension = <span class="built_in">Math</span>.max(screenSize.width, screenSize.height);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    width: maxDimension * <span class="built_in">window</span>.devicePixelRatio,</span><br><span class="line">    height: maxDimension * <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="八、菜单"><a href="#八、菜单" class="headerlink" title="八、菜单"></a>八、菜单</h2><p>应用程序的菜单可以帮助我们快捷的到达某一功能，而不借助客户端的界面资源，一般菜单分为两种：</p><ul><li>应用程序菜单：位于应用程序顶部，在全局范围内都能使用</li><li>上下文菜单：可自定义任意页面显示，自定义调用，如右键菜单</li></ul><p><code>Electron</code>为我们提供了<code>Menu</code>模块用于创建本机应用程序菜单和上下文菜单，它是一个主进程模块。</p><p>你可以通过<code>Menu</code>的静态方法<code>buildFromTemplate(template)</code>，使用自定义菜单模版来构造一个菜单对象。</p><p><code>template</code>是一个<code>MenuItem</code>的数组，我们来看看<code>MenuItem</code>的几个重要参数：</p><ul><li><code>label</code>：菜单显示的文字</li><li><code>click</code>：点击菜单后的事件处理函数</li><li><code>role</code>：系统预定义的菜单，例如<code>copy</code>(复制)、<code>paste</code>(粘贴)、<code>minimize</code>(最小化)…</li><li><code>enabled</code>：指示是否启用该项目，此属性可以动态更改</li><li><code>submenu</code>：子菜单，也是一个<code>MenuItem</code>的数组</li></ul><blockquote><p>推荐：最好指定 role 与标准角色相匹配的任何菜单项，而不是尝试手动实现 click 函数中的行为。内置 role 行为将提供最佳的本地体验。</p></blockquote><p>下面的实例是一个简单的额菜单<code>template</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> template = [</span><br><span class="line">  &#123;</span><br><span class="line">    label: <span class="string">"文件"</span>,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123;</span><br><span class="line">        label: <span class="string">"新建文件"</span>,</span><br><span class="line">        click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          dialog.showMessageBox(&#123;</span><br><span class="line">            type: <span class="string">"info"</span>,</span><br><span class="line">            message: <span class="string">"嘿!"</span>,</span><br><span class="line">            detail: <span class="string">"你点击了新建文件！"</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    label: <span class="string">"编辑"</span>,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123;</span><br><span class="line">        label: <span class="string">"剪切"</span>,</span><br><span class="line">        role: <span class="string">"cut"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        label: <span class="string">"复制"</span>,</span><br><span class="line">        role: <span class="string">"copy"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        label: <span class="string">"粘贴"</span>,</span><br><span class="line">        role: <span class="string">"paste"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    label: <span class="string">"最小化"</span>,</span><br><span class="line">    role: <span class="string">"minimize"</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="8-1-应用程序菜单"><a href="#8-1-应用程序菜单" class="headerlink" title="8.1 应用程序菜单"></a>8.1 应用程序菜单</h3><p>使用<code>Menu</code>的静态方法<code>setApplicationMenu</code>，可创建一个应用程序菜单，在 <code>Windows</code> 和 <code>Linux</code> 上，<code>menu</code>将被设置为每个窗口的顶层菜单。</p><blockquote><p>注意：必须在模块 ready 事件后调用此 API app。</p></blockquote><p>我们可以根据应用程序不同的的生命周期，不同的系统对菜单做不同的处理。</p><p><img src="http://www.conardli.top/img/electron/el_20_menu.png" alt></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">"ready"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> menu = Menu.buildFromTemplate(template);</span><br><span class="line">  Menu.setApplicationMenu(menu);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">"browser-window-created"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reopenMenuItem = findReopenMenuItem();</span><br><span class="line">  <span class="keyword">if</span> (reopenMenuItem) reopenMenuItem.enabled = <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">"window-all-closed"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reopenMenuItem = findReopenMenuItem();</span><br><span class="line">  <span class="keyword">if</span> (reopenMenuItem) reopenMenuItem.enabled = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.platform === <span class="string">"win32"</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> helpMenu = template[template.length - <span class="number">1</span>].submenu;</span><br><span class="line">  addUpdateMenuItems(helpMenu, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-上下文菜单"><a href="#8-2-上下文菜单" class="headerlink" title="8.2 上下文菜单"></a>8.2 上下文菜单</h3><p>使用<code>Menu</code>的实例方法<code>menu.popup</code>可自定义弹出上下文菜单。</p><p><img src="http://www.conardli.top/img/electron/el_21_memu.gif" alt></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = Menu.buildFromTemplate(template);</span><br><span class="line"><span class="built_in">document</span></span><br><span class="line">  .getElementById(<span class="string">"menuDemoContainer"</span>)</span><br><span class="line">  .addEventListener(<span class="string">"contextmenu"</span>, e =&gt; &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    m.popup(&#123; <span class="attr">window</span>: remote.getCurrentWindow() &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="8-3-快捷键"><a href="#8-3-快捷键" class="headerlink" title="8.3 快捷键"></a>8.3 快捷键</h3><p>在菜单选项中，我们可以指定一个<code>accelerator</code>属性来指定操作的快捷键：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  label: <span class="string">'最小化'</span>,</span><br><span class="line">  accelerator: <span class="string">'CmdOrCtrl+M'</span>,</span><br><span class="line">  role: <span class="string">'minimize'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们还可以使用<code>globalShortcut</code>来注册全局快捷键。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">globalShortcut.register(<span class="string">"CommandOrControl+N"</span>, () =&gt; &#123;</span><br><span class="line">  dialog.showMessageBox(&#123;</span><br><span class="line">    type: <span class="string">"info"</span>,</span><br><span class="line">    message: <span class="string">"嘿!"</span>,</span><br><span class="line">    detail: <span class="string">"你触发了手动注册的快捷键."</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>CommandOrControl 代表在 macOS 上为 Command 键，以及在 Linux 和 Windows 上为 Control 键。</p></blockquote><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;五、窗口&quot;&gt;&lt;a href=&quot;#五、窗口&quot; class=&quot;headerlink&quot; title=&quot;五、窗口&quot;&gt;&lt;/a&gt;五、窗口&lt;/h2&gt;&lt;h3 id=&quot;5-1-BrowserWindow&quot;&gt;&lt;a href=&quot;#5-1-BrowserWindow&quot; class=&quot;headerlink&quot; title=&quot;5.1 BrowserWindow&quot;&gt;&lt;/a&gt;5.1 BrowserWindow&lt;/h3&gt;&lt;p&gt;主进程模块&lt;code&gt;BrowserWindow&lt;/code&gt;用于创建和控制浏览器窗口。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mainWindow = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BrowserWindow(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  width: &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  height: &lt;span class=&quot;number&quot;&gt;800&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mainWindow.loadURL(&lt;span class=&quot;string&quot;&gt;&quot;http://www.conardli.top/&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以在&lt;a href=&quot;https://electronjs.org/docs/api/browser-window#new-browserwindowoptions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;查看它所有的构造参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.conardli.top/img/electron/el_13_window.gif&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-2-无框窗口&quot;&gt;&lt;a href=&quot;#5-2-无框窗口&quot; class=&quot;headerlink&quot; title=&quot;5.2 无框窗口&quot;&gt;&lt;/a&gt;5.2 无框窗口&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;无框窗口是没有镶边的窗口，窗口的部分（如工具栏）不属于网页的一部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;BrowserWindow&lt;/code&gt;的构造参数中，将&lt;code&gt;frame&lt;/code&gt;设置为&lt;code&gt;false&lt;/code&gt;可以指定窗口为无边框窗口，将工具栏隐藏后，就会产生两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.窗口控制按钮（最小化、全屏、关闭按钮）会被隐藏&lt;/li&gt;
&lt;li&gt;2.无法拖拽移动窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过指定&lt;code&gt;titleBarStyle&lt;/code&gt;选项来再将工具栏按钮显示出来，将其设置为&lt;code&gt;hidden&lt;/code&gt;表示返回一个隐藏标题栏的全尺寸内容窗口，在左上角仍然有标准的窗口控制按钮。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BrowserWindow(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  width: &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  height: &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  titleBarStyle: &lt;span class=&quot;string&quot;&gt;&quot;hidden&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  frame: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用JS开发桌面应用（一）原理篇</title>
    <link href="http://yoursite.com/2019/05/04/2019-05-04-Programing-JavaScript-use-js-develop-desk-app-1/"/>
    <id>http://yoursite.com/2019/05/04/2019-05-04-Programing-JavaScript-use-js-develop-desk-app-1/</id>
    <published>2019-05-04T07:13:30.000Z</published>
    <updated>2019-11-25T07:21:59.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>使用<code>Electron</code>开发客户端程序已经有一段时间了，整体感觉还是非常不错的，其中也遇到了一些坑点，本文旨在从【运行原理】到【实际应用】对<code>Electron</code>进行一次系统性的总结。【多图，长文预警～】</p><p>另外<code>electron-react</code>还可作为使用<code>Electron + React + Mobx + Webpack</code>技术栈的脚手架工程。</p><h2 id="一、桌面应用程序"><a href="#一、桌面应用程序" class="headerlink" title="一、桌面应用程序"></a>一、桌面应用程序</h2><p><img src="http://www.conardli.top/img/electron/el_1_app.jpg" alt></p><blockquote><p>桌面应用程序，又称为 GUI 程序（Graphical User Interface），但是和 GUI 程序也有一些区别。桌面应用程序 将 GUI 程序从 GUI 具体为“桌面”，使冷冰冰的像块木头一样的电脑概念更具有 人性化，更生动和富有活力。</p></blockquote><p>我们电脑上使用的各种客户端程序都属于桌面应用程序，近年来<code>WEB</code>和移动端的兴起让桌面程序渐渐暗淡，但是在某些日常功能或者行业应用中桌面应用程序仍然是必不可少的。</p><p>传统的桌面应用开发方式，一般是下面两种：</p><h3 id="1-1-原生开发"><a href="#1-1-原生开发" class="headerlink" title="1.1 原生开发"></a>1.1 原生开发</h3><p>直接将语言编译成可执行文件，直接调用系统<code>API</code>，完成 UI 绘制等。这类开发技术，有着较高的运行效率，但一般来说，开发速度较慢，技术要求较高，例如：</p><ul><li>使用<code>C++ / MFC</code>开发<code>Windows</code>应用</li><li>使用<code>Objective-C</code>开发<code>MAC</code>应用</li></ul><h3 id="1-2-托管平台"><a href="#1-2-托管平台" class="headerlink" title="1.2 托管平台"></a>1.2 托管平台</h3><p>一开始就有本地开发和 UI 开发。一次编译后，得到中间文件，通过平台或虚机完成二次加载编译或解释运行。运行效率低于原生编译，但平台优化后，其效率也是比较可观的。就开发速度方面，比原生编译技术要快一些。例如：</p><ul><li>使用<code>C# / .NET Framework</code>(只能开发<code>Windows应用</code>)</li><li><code>Java / Swing</code></li></ul><p>不过，上面两种对前端开发人员太不友好了，基本是前端人员不会设计的领域，但是在这个【大前端 😅】的时代，前端开发者正在想方设法涉足各个领域，使用<code>WEB</code>技术开发客户端的方式横空出世。</p><h3 id="1-3-WEB-开发"><a href="#1-3-WEB-开发" class="headerlink" title="1.3 WEB 开发"></a>1.3 WEB 开发</h3><p>使用<code>WEB</code>技术进行开发，利用浏览器引擎完成<code>UI</code>渲染，利用<code>Node.js</code>实现服务器端<code>JS</code>编程并可以调用系统<code>API</code>，可以把它想像成一个套了一个客户端外壳的<code>WEB</code>应用。</p><p>在界面上，<code>WEB</code>的强大生态为<code>UI</code>带来了无限可能，并且开发、维护成本相对较低，有<code>WEB</code>开发经验的前端开发者很容易上手进行开发。</p><p>本文就来着重介绍使用<code>WEB</code>技术开发客户端程序的技术之一【<code>electron</code>】</p><h2 id="二、Electron"><a href="#二、Electron" class="headerlink" title="二、Electron"></a>二、Electron</h2><p><img src="http://www.conardli.top/img/electron/el_2_electron.jpg" alt></p><p><code>Electron</code>是由<code>Github</code>开发，用<code>HTML，CSS</code>和<code>JavaScript</code>来构建跨平台桌面应用程序的一个开源库。 <code>Electron</code>通过将<code>Chromium</code>和<code>Node.js</code>合并到同一个运行时环境中，并将其打包为<code>Mac，Windows</code>和<code>Linux</code>系统下的应用来实现这一目的。</p><p><a href="https://electronjs.org/docs" target="_blank" rel="noopener">https://electronjs.org/docs</a></p><p><a href="https://juejin.im/post/5c67619351882562276c3162#heading-5" target="_blank" rel="noopener">https://juejin.im/post/5c67619351882562276c3162#heading-5</a></p><h3 id="2-1-使用-Electron-开发的理由："><a href="#2-1-使用-Electron-开发的理由：" class="headerlink" title="2.1 使用 Electron 开发的理由："></a>2.1 使用 Electron 开发的理由：</h3><ul><li>1.使用具有强大生态的<code>Web</code>技术进行开发，开发成本低，可扩展性强，更炫酷的<code>UI</code></li><li>2.跨平台，一套代码可打包为<code>Windows、Linux、Mac</code>三套软件，且编译快速</li><li>3.可直接在现有<code>Web</code>应用上进行扩展，提供浏览器不具备的能力</li><li>4.你是一个前端 👨‍</li></ul><p>当然，我们也要认清它的缺点：性能比原生桌面应用要低，最终打包后的安装包和其他文件都比较大。</p><a id="more"></a><h3 id="2-2-开发体验"><a href="#2-2-开发体验" class="headerlink" title="2.2 开发体验"></a>2.2 开发体验</h3><p><strong>兼容性</strong></p><p>虽然你还在用<code>WEB</code>技术进行开发，但是你不用再考虑兼容性问题了，你只需要关心你当前使用<code>Electron</code>的版本对应<code>Chrome</code>的版本，一般情况下它已经足够新来让你使用最新的<code>API</code>和语法了，你还可以手动升级<code>Chrome</code>版本。同样的，你也不用考虑不同浏览器带了的样式和代码兼容问题。</p><p><strong>Node 环境</strong></p><p>这可能是很多前端开发者曾经梦想过的功能，在<code>WEB</code>界面中使用<code>Node.js</code>提供的强大<code>API</code>，这意味着你在<code>WEB</code>页面直接可以操作文件，调用系统<code>API</code>，甚至操作数据库。当然，除了完整的<code>Node API</code>，你还可以使用额外的几十万个<code>npm</code>模块。</p><p><strong>跨域</strong></p><p>你可以直接使用<code>Node</code>提供的<code>request</code>模块进行网络请求，这意味着你无需再被跨域所困扰。</p><p><strong>强大的扩展性</strong></p><p>借助<code>node-ffi</code>，为应用程序提供强大的扩展性（后面的章节会详细介绍）。</p><h3 id="2-3-谁在用-Electron"><a href="#2-3-谁在用-Electron" class="headerlink" title="2.3 谁在用 Electron"></a>2.3 谁在用 Electron</h3><p><img src="http://www.conardli.top/img/electron/el_6_apps.png" alt></p><p>现在市面上已经有非常多的应用在使用<code>electron</code>进行开发了，包括我们熟悉的<code>VS Code</code>客户端、<code>GitHub</code>客户端、<code>Atom</code>客户端等等。印象很深的，去年迅雷在发布迅雷 X<code>10.1</code>时的文案：</p><blockquote><p>从迅雷 X 10.1 版本开始，我们采用 Electron 软件框架完全重写了迅雷主界面。使用新框架的迅雷 X 可以完美支持 2K、4K 等高清显示屏，界面中的文字渲染也更加清晰锐利。从技术层面来说，新框架的界面绘制、事件处理等方面比老框架更加灵活高效，因此界面的流畅度也显著优于老框架的迅雷。至于具体提升有多大？您一试便知。</p></blockquote><p>你可以打开<code>VS Code</code>，点击【帮助】【切换开发人员工具】来<code>VS Code</code>客户端的界面。</p><p><img src="http://www.conardli.top/img/electron/el_5_vscode.png" alt></p><h2 id="三、Electron-运行原理"><a href="#三、Electron-运行原理" class="headerlink" title="三、Electron 运行原理"></a>三、Electron 运行原理</h2><p><img src="http://www.conardli.top/img/electron/el_3_composition.png" alt></p><p><code>Electron</code> 结合了 <code>Chromium</code>、<code>Node.js</code> 和用于调用操作系统本地功能的<code>API</code>。</p><h3 id="3-1-Chromium"><a href="#3-1-Chromium" class="headerlink" title="3.1 Chromium"></a>3.1 Chromium</h3><p><code>Chromium</code>是<code>Google</code>为发展<code>Chrome</code>浏览器而启动的开源项目，<code>Chromium</code>相当于<code>Chrome</code>的工程版或称实验版，新功能会率先在<code>Chromium</code>上实现，待验证后才会应用在<code>Chrome</code>上，故<code>Chrome</code>的功能会相对落后但较稳定。</p><p><code>Chromium</code>为<code>Electron</code>提供强大的<code>UI</code>能力，可以在不考虑兼容性的情况下开发界面。</p><h3 id="3-2-Node-js"><a href="#3-2-Node-js" class="headerlink" title="3.2 Node.js"></a>3.2 Node.js</h3><p><code>Node.js</code>是一个让<code>JavaScript</code>运行在服务端的开发平台，<code>Node</code>使用事件驱动，非阻塞<code>I/O</code>模型而得以轻量和高效。</p><p>单单靠<code>Chromium</code>是不能具备直接操作原生<code>GUI</code>能力的，<code>Electron</code>内集成了<code>Nodejs</code>，这让其在开发界面的同时也有了操作系统底层<code>API</code>的能力，<code>Nodejs</code> 中常用的 <code>Path、fs、Crypto</code> 等模块在 <code>Electron</code> 可以直接使用。</p><h3 id="3-3-系统-API"><a href="#3-3-系统-API" class="headerlink" title="3.3 系统 API"></a>3.3 系统 API</h3><p>为了提供原生系统的<code>GUI</code>支持，<code>Electron</code>内置了原生应用程序接口，对调用一些系统功能，如调用系统通知、打开系统文件夹提供支持。</p><p>在开发模式上，<code>Electron</code>在调用系统<code>API</code>和绘制界面上是分离开发的，下面我们来看看<code>Electron</code>关于进程如何划分。</p><h3 id="3-4-主进程"><a href="#3-4-主进程" class="headerlink" title="3.4 主进程"></a>3.4 主进程</h3><p><code>Electron</code>区分了两种进程：主进程和渲染进程，两者各自负责自己的职能。</p><p><img src="http://www.conardli.top/img/electron/el_7_process.png" alt></p><p><code>Electron</code> 运行<code>package.json</code>的 <code>main</code> 脚本的进程被称为主进程。一个 <code>Electron</code> 应用总是有且只有一个主进程。</p><p><strong>职责:</strong></p><ul><li>创建渲染进程（可多个）</li><li>控制了应用生命周期（启动、退出<code>APP</code>以及对<code>APP</code>做一些事件监听）</li><li>调用系统底层功能、调用原生资源</li></ul><p><strong>可调用的 API:</strong></p><ul><li><code>Node.js API</code></li><li><code>Electron</code>提供的主进程<code>API</code>（包括一些系统功能和<code>Electron</code>附加功能）</li></ul><h3 id="3-5-渲染进程"><a href="#3-5-渲染进程" class="headerlink" title="3.5 渲染进程"></a>3.5 渲染进程</h3><p>由于 <code>Electron</code> 使用了 <code>Chromium</code> 来展示 <code>web</code> 页面，所以 <code>Chromium</code> 的多进程架构也被使用到。 每个<code>Electron</code> 中的 <code>web</code>页面运行在它自己的渲染进程中。</p><blockquote><p>主进程使用 BrowserWindow 实例创建页面。 每个 BrowserWindow 实例都在自己的渲染进程里运行页面。 当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被终止。</p></blockquote><p>你可以把渲染进程想像成一个浏览器窗口，它能存在多个并且相互独立，不过和浏览器不同的是，它能调用<code>Node API</code>。</p><p><strong>职责:</strong></p><ul><li>用<code>HTML</code>和<code>CSS</code>渲染界面</li><li>用<code>JavaScript</code>做一些界面交互</li></ul><p><strong>可调用的 API:</strong></p><ul><li><code>DOM API</code></li><li><code>Node.js API</code></li><li><code>Electron</code>提供的渲染进程<code>API</code></li></ul><h2 id="四、Electron-基础"><a href="#四、Electron-基础" class="headerlink" title="四、Electron 基础"></a>四、Electron 基础</h2><h3 id="4-1-Electron-API"><a href="#4-1-Electron-API" class="headerlink" title="4.1 Electron API"></a>4.1 Electron API</h3><p>在上面的章节我们提到，渲染进和主进程分别可调用的<code>Electron API</code>。所有<code>Electron</code>的<code>API</code>都被指派给一种进程类型。 许多<code>API</code>只能被用于主进程中，有些<code>API</code>又只能被用于渲染进程，又有一些主进程和渲染进程中都可以使用。</p><p>你可以通过如下方式获取<code>Electron API</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BrowserWindow, ... &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br></pre></td></tr></table></figure><p>下面是一些常用的<code>Electron API</code>：</p><p><img src="http://www.conardli.top/img/electron/el_8_api.png" alt></p><p>在后面的章节我们会选择其中常用的模块进行详细介绍。</p><h3 id="4-2-使用-Node-js-的-API"><a href="#4-2-使用-Node-js-的-API" class="headerlink" title="4.2 使用 Node.js 的 API"></a>4.2 使用 Node.js 的 API</h3><p><img src="http://www.conardli.top/img/electron/el_9_node.png" alt></p><p>你可以同时在<code>Electron</code>的主进程和渲染进程使用<code>Node.js API</code>，)所有在<code>Node.js</code>可以使用的<code>API</code>，在<code>Electron</code>中同样可以使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shell &#125; <span class="keyword">from</span> <span class="string">"electron"</span>;</span><br><span class="line"><span class="keyword">import</span> os <span class="keyword">from</span> <span class="string">"os"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  shell.showItemInFolder(os.homedir());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>有一个非常重要的提示: 原生 Node.js 模块 (即指，需要编译源码过后才能被使用的模块) 需要在编译后才能和 Electron 一起使用。</p></blockquote><h3 id="4-3-进程通信"><a href="#4-3-进程通信" class="headerlink" title="4.3 进程通信"></a>4.3 进程通信</h3><p>主进程和渲染进程虽然拥有不同的职责，然是他们也需要相互协作，互相通讯。</p><blockquote><p>例如：在<code>web</code>页面管理原生<code>GUI</code>资源是很危险的，会很容易泄露资源。所以在<code>web</code>页面，不允许直接调用原生<code>GUI</code>相关的<code>API</code>。渲染进程如果想要进行原生的<code>GUI</code>操作，就必须和主进程通讯，请求主进程来完成这些操作。</p></blockquote><p><img src="http://www.conardli.top/img/electron/el_10_ipc.gif" alt></p><h3 id="4-4-渲染进程向主进程通信"><a href="#4-4-渲染进程向主进程通信" class="headerlink" title="4.4 渲染进程向主进程通信"></a>4.4 渲染进程向主进程通信</h3><p><code>ipcRenderer</code> 是一个 <code>EventEmitter</code> 的实例。 你可以使用它提供的一些方法从渲染进程发送同步或异步的消息到主进程。 也可以接收主进程回复的消息。</p><p>在渲染进程引入<code>ipcRenderer</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ipcRenderer &#125; <span class="keyword">from</span> <span class="string">"electron"</span>;</span><br></pre></td></tr></table></figure><p>异步发送：</p><p>通过 <code>channel</code> 发送同步消息到主进程，可以携带任意参数。</p><blockquote><p>在内部，参数会被序列化为 <code>JSON</code>，因此参数对象上的函数和原型链不会被发送。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcRenderer.send(<span class="string">"sync-render"</span>, <span class="string">"我是来自渲染进程的异步消息"</span>);</span><br></pre></td></tr></table></figure><p>同步发送：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = ipcRenderer.sendSync(<span class="string">"async-render"</span>, <span class="string">"我是来自渲染进程的同步消息"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意: 发送同步消息将会阻塞整个渲染进程，直到收到主进程的响应。</p></blockquote><p>主进程监听消息：</p><p><code>ipcMain</code>模块是<code>EventEmitter</code>类的一个实例。 当在主进程中使用时，它处理从渲染器进程（网页）发送出来的异步和同步信息。 从渲染器进程发送的消息将被发送到该模块。</p><p><code>ipcMain.on</code>：监听 <code>channel</code>，当接收到新的消息时 <code>listener</code> 会以 <code>listener(event, args...)</code> 的形式被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipcMain.on(<span class="string">"sync-render"</span>, (event, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-5-主进程向渲染进程通信"><a href="#4-5-主进程向渲染进程通信" class="headerlink" title="4.5 主进程向渲染进程通信"></a>4.5 主进程向渲染进程通信</h3><p><a href="https://imweb.io/topic/5b13a663d4c96b9b1b4c4e9c" target="_blank" rel="noopener">https://imweb.io/topic/5b13a663d4c96b9b1b4c4e9c</a></p><p>在主进程中可以通过<code>BrowserWindow</code>的<code>webContents</code>向渲染进程发送消息，所以，在发送消息前你必须先找到对应渲染进程的<code>BrowserWindow</code>对象。：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mainWindow = BrowserWindow.fromId(global.mainId);</span><br><span class="line">mainWindow.webContents.send(<span class="string">"main-msg"</span>, <span class="string">`ConardLi]`</span>);</span><br></pre></td></tr></table></figure><p>根据消息来源发送：</p><p>在<code>ipcMain</code>接受消息的回调函数中，通过第一个参数<code>event</code>的属性<code>sender</code>可以拿到消息来源渲染进程的<code>webContents</code>对象，我们可以直接用此对象回应消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ipcMain.on(<span class="string">"sync-render"</span>, (event, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  event.sender.send(<span class="string">"main-msg"</span>, <span class="string">"主进程收到了渲染进程的【异步】消息！"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>渲染进程监听：</p><p><code>ipcRenderer.on</code>:监听 <code>channel</code>, 当新消息到达，将通过<code>listener(event, args...)</code>调用 <code>listener</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipcRenderer.on(<span class="string">"main-msg"</span>, (event, msg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-6-通信原理"><a href="#4-6-通信原理" class="headerlink" title="4.6 通信原理"></a>4.6 通信原理</h3><p><code>ipcMain</code> 和 <code>ipcRenderer</code> 都是 <code>EventEmitter</code> 类的一个实例。<code>EventEmitter</code> 类是 <code>NodeJS</code> 事件的基础，它由 <code>NodeJS</code> 中的 <code>events</code> 模块导出。</p><p><code>EventEmitter</code> 的核心就是事件触发与事件监听器功能的封装。它实现了事件模型需要的接口， 包括 <code>addListener，removeListener</code>, <code>emit</code> 及其它工具方法. 同原生 <code>JavaScript</code> 事件类似， 采用了发布/订阅(观察者)的方式， 使用内部 <code>_events</code> 列表来记录注册的事件处理器。</p><p>我们通过 <code>ipcMain</code>和<code>ipcRenderer</code> 的 <code>on、send</code> 进行监听和发送消息都是 <code>EventEmitter</code> 定义的相关接口。</p><h3 id="4-7-remote"><a href="#4-7-remote" class="headerlink" title="4.7 remote"></a>4.7 remote</h3><p><code>remote</code> 模块为渲染进程（web 页面）和主进程通信（<code>IPC</code>）提供了一种简单方法。 使用 <code>remote</code> 模块, 你可以调用 <code>main</code> 进程对象的方法, 而不必显式发送进程间消息, 类似于 <code>Java</code> 的 <code>RMI</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; remote &#125; <span class="keyword">from</span> <span class="string">"electron"</span>;</span><br><span class="line"></span><br><span class="line">remote.dialog.showErrorBox(<span class="string">"主进程才有的dialog模块"</span>, <span class="string">"我是使用remote调用的"</span>);</span><br></pre></td></tr></table></figure><p><img src="http://www.conardli.top/img/electron/el_11_remote.gif" alt></p><p>但实际上，我们在调用远程对象的方法、函数或者通过远程构造函数创建一个新的对象，实际上都是在发送一个同步的进程间消息。</p><p>在上面通过 <code>remote</code> 模块调用 <code>dialog</code> 的例子里。我们在渲染进程中创建的 <code>dialog</code> 对象其实并不在我们的渲染进程中，它只是让主进程创建了一个 <code>dialog</code> 对象，并返回了这个相对应的远程对象给了渲染进程。</p><h3 id="4-8-渲染进程间通信"><a href="#4-8-渲染进程间通信" class="headerlink" title="4.8 渲染进程间通信"></a>4.8 渲染进程间通信</h3><p><code>Electron</code>并没有提供渲染进程之间相互通信的方式，我们可以在主进程中建立一个消息中转站。</p><p>渲染进程之间通信首先发送消息到主进程，主进程的中转站接受到消息后根据条件进行分发。</p><h3 id="4-9-渲染进程数据共享"><a href="#4-9-渲染进程数据共享" class="headerlink" title="4.9 渲染进程数据共享"></a>4.9 渲染进程数据共享</h3><p>在两个渲染进程间共享数据最简单的方法是使用浏览器中已经实现的<code>HTML5 API</code>。 其中比较好的方案是用<code>Storage API</code>， <code>localStorage，sessionStorage</code> 或者 <code>IndexedDB。</code></p><p>就像在浏览器中使用一样，这种存储相当于在应用程序中永久存储了一部分数据。有时你并不需要这样的存储，只需要在当前应用程序的生命周期内进行一些数据的共享。这时你可以用 <code>Electron</code> 内的 <code>IPC</code> 机制实现。</p><p>将数据存在主进程的某个全局变量中，然后在多个渲染进程中使用 <code>remote</code> 模块来访问它。</p><p><img src="http://www.conardli.top/img/electron/el_12_global.gif" alt></p><p>在主进程中初始化全局变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">global.mainId = ...;</span><br><span class="line">global.device = &#123;...&#125;;</span><br><span class="line">global.__dirname = __dirname;</span><br><span class="line">global.myField = &#123; <span class="attr">name</span>: <span class="string">'ConardLi'</span> &#125;;</span><br></pre></td></tr></table></figure><p>在渲染进程中读取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ipcRenderer, remote &#125; <span class="keyword">from</span> <span class="string">"electron"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; getGlobal &#125; = remote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mainId = getGlobal(<span class="string">"mainId"</span>);</span><br><span class="line"><span class="keyword">const</span> dirname = getGlobal(<span class="string">"__dirname"</span>);</span><br><span class="line"><span class="keyword">const</span> deviecMac = getGlobal(<span class="string">"device"</span>).mac;</span><br></pre></td></tr></table></figure><p>在渲染进程中改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getGlobal(<span class="string">"myField"</span>).name = <span class="string">"code秘密花园"</span>;</span><br></pre></td></tr></table></figure><p>多个渲染进程共享同一个主进程的全局变量，这样即可达到渲染进程数据共享和传递的效果。</p><p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;Electron&lt;/code&gt;开发客户端程序已经有一段时间了，整体感觉还是非常不错的，其中也遇到了一些坑点，本文旨在从【运行原理】到【实际应用】对&lt;code&gt;Electron&lt;/code&gt;进行一次系统性的总结。【多图，长文预警～】&lt;/p&gt;
&lt;p&gt;另外&lt;code&gt;electron-react&lt;/code&gt;还可作为使用&lt;code&gt;Electron + React + Mobx + Webpack&lt;/code&gt;技术栈的脚手架工程。&lt;/p&gt;
&lt;h2 id=&quot;一、桌面应用程序&quot;&gt;&lt;a href=&quot;#一、桌面应用程序&quot; class=&quot;headerlink&quot; title=&quot;一、桌面应用程序&quot;&gt;&lt;/a&gt;一、桌面应用程序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.conardli.top/img/electron/el_1_app.jpg&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;桌面应用程序，又称为 GUI 程序（Graphical User Interface），但是和 GUI 程序也有一些区别。桌面应用程序 将 GUI 程序从 GUI 具体为“桌面”，使冷冰冰的像块木头一样的电脑概念更具有 人性化，更生动和富有活力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们电脑上使用的各种客户端程序都属于桌面应用程序，近年来&lt;code&gt;WEB&lt;/code&gt;和移动端的兴起让桌面程序渐渐暗淡，但是在某些日常功能或者行业应用中桌面应用程序仍然是必不可少的。&lt;/p&gt;
&lt;p&gt;传统的桌面应用开发方式，一般是下面两种：&lt;/p&gt;
&lt;h3 id=&quot;1-1-原生开发&quot;&gt;&lt;a href=&quot;#1-1-原生开发&quot; class=&quot;headerlink&quot; title=&quot;1.1 原生开发&quot;&gt;&lt;/a&gt;1.1 原生开发&lt;/h3&gt;&lt;p&gt;直接将语言编译成可执行文件，直接调用系统&lt;code&gt;API&lt;/code&gt;，完成 UI 绘制等。这类开发技术，有着较高的运行效率，但一般来说，开发速度较慢，技术要求较高，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;C++ / MFC&lt;/code&gt;开发&lt;code&gt;Windows&lt;/code&gt;应用&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;Objective-C&lt;/code&gt;开发&lt;code&gt;MAC&lt;/code&gt;应用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-托管平台&quot;&gt;&lt;a href=&quot;#1-2-托管平台&quot; class=&quot;headerlink&quot; title=&quot;1.2 托管平台&quot;&gt;&lt;/a&gt;1.2 托管平台&lt;/h3&gt;&lt;p&gt;一开始就有本地开发和 UI 开发。一次编译后，得到中间文件，通过平台或虚机完成二次加载编译或解释运行。运行效率低于原生编译，但平台优化后，其效率也是比较可观的。就开发速度方面，比原生编译技术要快一些。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;C# / .NET Framework&lt;/code&gt;(只能开发&lt;code&gt;Windows应用&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Java / Swing&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过，上面两种对前端开发人员太不友好了，基本是前端人员不会设计的领域，但是在这个【大前端 😅】的时代，前端开发者正在想方设法涉足各个领域，使用&lt;code&gt;WEB&lt;/code&gt;技术开发客户端的方式横空出世。&lt;/p&gt;
&lt;h3 id=&quot;1-3-WEB-开发&quot;&gt;&lt;a href=&quot;#1-3-WEB-开发&quot; class=&quot;headerlink&quot; title=&quot;1.3 WEB 开发&quot;&gt;&lt;/a&gt;1.3 WEB 开发&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;WEB&lt;/code&gt;技术进行开发，利用浏览器引擎完成&lt;code&gt;UI&lt;/code&gt;渲染，利用&lt;code&gt;Node.js&lt;/code&gt;实现服务器端&lt;code&gt;JS&lt;/code&gt;编程并可以调用系统&lt;code&gt;API&lt;/code&gt;，可以把它想像成一个套了一个客户端外壳的&lt;code&gt;WEB&lt;/code&gt;应用。&lt;/p&gt;
&lt;p&gt;在界面上，&lt;code&gt;WEB&lt;/code&gt;的强大生态为&lt;code&gt;UI&lt;/code&gt;带来了无限可能，并且开发、维护成本相对较低，有&lt;code&gt;WEB&lt;/code&gt;开发经验的前端开发者很容易上手进行开发。&lt;/p&gt;
&lt;p&gt;本文就来着重介绍使用&lt;code&gt;WEB&lt;/code&gt;技术开发客户端程序的技术之一【&lt;code&gt;electron&lt;/code&gt;】&lt;/p&gt;
&lt;h2 id=&quot;二、Electron&quot;&gt;&lt;a href=&quot;#二、Electron&quot; class=&quot;headerlink&quot; title=&quot;二、Electron&quot;&gt;&lt;/a&gt;二、Electron&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.conardli.top/img/electron/el_2_electron.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Electron&lt;/code&gt;是由&lt;code&gt;Github&lt;/code&gt;开发，用&lt;code&gt;HTML，CSS&lt;/code&gt;和&lt;code&gt;JavaScript&lt;/code&gt;来构建跨平台桌面应用程序的一个开源库。 &lt;code&gt;Electron&lt;/code&gt;通过将&lt;code&gt;Chromium&lt;/code&gt;和&lt;code&gt;Node.js&lt;/code&gt;合并到同一个运行时环境中，并将其打包为&lt;code&gt;Mac，Windows&lt;/code&gt;和&lt;code&gt;Linux&lt;/code&gt;系统下的应用来实现这一目的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://electronjs.org/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://electronjs.org/docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c67619351882562276c3162#heading-5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5c67619351882562276c3162#heading-5&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-使用-Electron-开发的理由：&quot;&gt;&lt;a href=&quot;#2-1-使用-Electron-开发的理由：&quot; class=&quot;headerlink&quot; title=&quot;2.1 使用 Electron 开发的理由：&quot;&gt;&lt;/a&gt;2.1 使用 Electron 开发的理由：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1.使用具有强大生态的&lt;code&gt;Web&lt;/code&gt;技术进行开发，开发成本低，可扩展性强，更炫酷的&lt;code&gt;UI&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2.跨平台，一套代码可打包为&lt;code&gt;Windows、Linux、Mac&lt;/code&gt;三套软件，且编译快速&lt;/li&gt;
&lt;li&gt;3.可直接在现有&lt;code&gt;Web&lt;/code&gt;应用上进行扩展，提供浏览器不具备的能力&lt;/li&gt;
&lt;li&gt;4.你是一个前端 👨‍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，我们也要认清它的缺点：性能比原生桌面应用要低，最终打包后的安装包和其他文件都比较大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="编程技术" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="高级技术" scheme="http://yoursite.com/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《张扬的日生活》 写在专题开始前</title>
    <link href="http://yoursite.com/2019/02/23/2019-02-23-Life-JianShu-ZY-intro-1/"/>
    <id>http://yoursite.com/2019/02/23/2019-02-23-Life-JianShu-ZY-intro-1/</id>
    <published>2019-02-23T07:44:04.000Z</published>
    <updated>2019-11-25T08:02:32.383Z</updated>
    
    <content type="html"><![CDATA[<p>有感于生活，最近准备新开一个专题，主要描述来源于生活并高于生活的日常生活。</p><p>既然是来源于日常生活，那就免不了柴米油盐，免不了柴米油盐，免不了蒜皮小事，免不了流水账。</p><p>篇幅不会太长，每篇 600 字左右吧。不会有太多的写作技法，只是最基本的白描，不带任何感情色彩的白描。</p><p>先简单对几个重要人物做个脸谱化的设定，后续提到新人物的时候再进行补充说明。</p><p>张扬：85 后，已婚。在一家小公司做程序员，公交车上下班，偶尔加班。</p><p>李强：张扬现工作中的小组长。</p><p>马琦：张扬前公司的同事。</p><p>万玉：张扬的妻子。90 年，在一家小公司做程序员，离家较远，公交车上下班。</p><p>张一中：张扬爸，60 后，之前是农民，现在帮忙带小孩。</p><p>刘英：张扬妈，60 后，之前是农民，现在在家带弟弟张明家的小孩。</p><p>张明：张扬的弟弟，90 后，已婚。外出打工，一个小孩留在老家由刘英照顾。</p><p>张冲：<code>张扬</code>和<code>妻子万玉</code>的孩子。19 个月男宝宝。</p><p>这个系列预计更新 100 篇左右，希望自己能坚持下去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有感于生活，最近准备新开一个专题，主要描述来源于生活并高于生活的日常生活。&lt;/p&gt;
&lt;p&gt;既然是来源于日常生活，那就免不了柴米油盐，免不了柴米油盐，免不了蒜皮小事，免不了流水账。&lt;/p&gt;
&lt;p&gt;篇幅不会太长，每篇 600 字左右吧。不会有太多的写作技法，只是最基本的白描，不
      
    
    </summary>
    
    
      <category term="日常生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="简书" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E7%AE%80%E4%B9%A6/"/>
    
      <category term="张扬的日生活" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E7%AE%80%E4%B9%A6/%E5%BC%A0%E6%89%AC%E7%9A%84%E6%97%A5%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日常生活" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
      <category term="简书" scheme="http://yoursite.com/tags/%E7%AE%80%E4%B9%A6/"/>
    
  </entry>
  
</feed>
